{"version":3,"file":"5f34e1cb125a54fc09ab.chunk.js","mappings":"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","sources":["webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/roundDecimal.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/geo.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/luminanceFromRGB.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/MapBox.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/node_modules/kdbush/index.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/node_modules/supercluster/index.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/transformProps.js"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport default function roundDecimal(number, precision) {\n  let roundedNumber;\n  let p = precision;\n  if (precision) {\n    roundedNumber = Math.round(number * (p = 10 ** p)) / p;\n  } else {\n    roundedNumber = Math.round(number);\n  }\n\n  return roundedNumber;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport roundDecimal from './roundDecimal';\n\nexport const EARTH_CIRCUMFERENCE_KM = 40075.16;\nexport const MILES_PER_KM = 1.60934;\n\nexport function kmToPixels(kilometers, latitude, zoomLevel) {\n  // Algorithm from: http://wiki.openstreetmap.org/wiki/Zoom_levels\n  const latitudeRad = latitude * (Math.PI / 180);\n  // Seems like the zoomLevel is off by one\n  const kmPerPixel =\n    (EARTH_CIRCUMFERENCE_KM * Math.cos(latitudeRad)) / 2 ** (zoomLevel + 9);\n\n  return roundDecimal(kilometers / kmPerPixel, 2);\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport { PureComponent } from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const LUMINANCE_RED_WEIGHT = 0.2126;\nexport const LUMINANCE_GREEN_WEIGHT = 0.7152;\nexport const LUMINANCE_BLUE_WEIGHT = 0.0722;\n\nexport default function luminanceFromRGB(r, g, b) {\n  // Formula: https://en.wikipedia.org/wiki/Relative_luminance\n  return (\n    LUMINANCE_RED_WEIGHT * r +\n    LUMINANCE_GREEN_WEIGHT * g +\n    LUMINANCE_BLUE_WEIGHT * b\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n","\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\n\nexport default class KDBush {\n\n    /**\n     * Creates an index from raw `ArrayBuffer` data.\n     * @param {ArrayBuffer} data\n     */\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xdb) {\n            throw new Error('Data does not appear to be in a KDBush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new KDBush(numItems, nodeSize, ArrayType, data);\n    }\n\n    /**\n     * Creates an index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBuffer} [data] (For internal use only)\n     */\n    constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n        if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) { // reconstruct an index from a buffer\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else { // initialize a new index\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            // set header\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    /**\n     * Add a point to the index.\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} An incremental index associated with the added item (starting from `0`).\n     */\n    add(x, y) {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    /**\n     * Perform indexing of the added points.\n     */\n    finish() {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        // kd-sort both arrays for efficient search\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n\n        this._finished = true;\n        return this;\n    }\n\n    /**\n     * Search the index for items within a given bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    range(minX, minY, maxX, maxY) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n\n        // recursively search for items in range in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    const x = coords[2 * i];\n                    const y = coords[2 * i + 1];\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? minX <= x : minY <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? maxX >= x : maxY >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Search the index for items within a given radius.\n     * @param {number} qx\n     * @param {number} qy\n     * @param {number} r Query radius.\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    within(qx, qy, r) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n        const r2 = r * r;\n\n        // recursively search for items within radius in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? qx - r <= x : qy - r <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? qx + r >= x : qy + r >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1; // middle index\n\n    // sort ids and coords around the middle index so that the halves lie\n    // either left/right or top/bottom correspondingly (taking turns)\n    select(ids, coords, m, left, right, axis);\n\n    // recursively kd-sort first half and second half on the opposite axis\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport Supercluster from 'supercluster';\nimport { DEFAULT_POINT_RADIUS, DEFAULT_MAX_ZOOM } from './MapBox';\n\nconst NOOP = () => {};\n\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, queriesData } = chartProps;\n  const { onError = NOOP, setControlValue = NOOP } = hooks;\n  const { bounds, geoJSON, hasCustomMetric, mapboxApiKey } =\n    queriesData[0].data;\n  const {\n    clusteringRadius,\n    globalOpacity,\n    mapboxColor,\n    mapboxStyle,\n    pandasAggfunc,\n    pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n  } = formData;\n\n  // Validate mapbox color\n  const rgb = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/.exec(mapboxColor);\n  if (rgb === null) {\n    onError(\"Color field must be of form 'rgb(%d, %d, %d)'\");\n\n    return {};\n  }\n\n  const opts = {\n    maxZoom: DEFAULT_MAX_ZOOM,\n    radius: clusteringRadius,\n  };\n  if (hasCustomMetric) {\n    opts.initial = () => ({\n      sum: 0,\n      squaredSum: 0,\n      min: Infinity,\n      max: -Infinity,\n    });\n    opts.map = prop => ({\n      sum: prop.metric,\n      squaredSum: prop.metric ** 2,\n      min: prop.metric,\n      max: prop.metric,\n    });\n    opts.reduce = (accu, prop) => {\n      // Temporarily disable param-reassignment linting to work with supercluster's api\n      /* eslint-disable no-param-reassign */\n      accu.sum += prop.sum;\n      accu.squaredSum += prop.squaredSum;\n      accu.min = Math.min(accu.min, prop.min);\n      accu.max = Math.max(accu.max, prop.max);\n      /* eslint-enable no-param-reassign */\n    };\n  }\n  const clusterer = new Supercluster(opts);\n  clusterer.load(geoJSON.features);\n\n  return {\n    width,\n    height,\n    aggregatorName: pandasAggfunc,\n    bounds,\n    clusterer,\n    globalOpacity,\n    hasCustomMetric,\n    mapboxApiKey,\n    mapStyle: mapboxStyle,\n    onViewportChange({ latitude, longitude, zoom }) {\n      setControlValue('viewport_longitude', longitude);\n      setControlValue('viewport_latitude', latitude);\n      setControlValue('viewport_zoom', zoom);\n    },\n    pointRadius: pointRadius === 'Auto' ? DEFAULT_POINT_RADIUS : pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n    rgb,\n  };\n}\n"],"names":["roundDecimal","number","precision","roundedNumber","p","Math","round","kmToPixels","kilometers","latitude","zoomLevel","latitudeRad","PI","cos","propTypes","aggregation","PropTypes","compositeOperation","dotRadius","lngLatAccessor","locations","isRequired","pointRadiusUnit","renderWhileDragging","rgb","zoom","ScatterPlotGlowOverlay","PureComponent","constructor","props","super","this","redraw","bind","drawText","ctx","pixel","options","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","height","isDragging","project","clusterLabelMap","forEach","location","i","properties","cluster","computeClusterLabel","count","point_count","sum","mean","squaredSum","variance","sqrt","maxLabel","max","filter","v","Number","isNaN","clearRect","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointLabel","pointRadius","pointLatitude","undefined","render","_jsx","CanvasOverlay","defaultProps","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","aggregatorName","clusterer","globalOpacity","hasCustomMetric","mapStyle","mapboxApiKey","onViewportChange","bounds","NOOP","MapBox","Component","mercator","ViewportMercator","fitBounds","longitude","state","viewport","handleViewportChange","setState","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","MapGL","mapboxApiAccessToken","preserveDrawingBuffer","children","coordinates","geometry","ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","KDBush","from","data","ArrayBuffer","Error","magic","versionAndType","version","ArrayType","nodeSize","numItems","min","IndexArrayType","arrayTypeIndex","indexOf","coordsByteSize","BYTES_PER_ELEMENT","idsByteSize","padCoords","ids","coords","_pos","_finished","set","add","index","finish","numAdded","sort","range","minX","minY","maxX","maxY","stack","length","result","axis","pop","right","left","push","m","within","qx","qy","r","r2","sqDist","select","k","n","z","log","s","exp","sd","floor","t","j","swapItem","swap","arr","tmp","ax","ay","bx","by","dx","dy","defaultOptions","minZoom","maxZoom","minPoints","extent","generateId","reduce","map","fround","OFFSET_ID","OFFSET_NUM","OFFSET_PROP","Supercluster","Object","assign","create","trees","Array","stride","clusterProps","load","points","console","time","timerId","lng","lat","lngX","latY","Infinity","tree","_createTree","timeEnd","now","Date","_cluster","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","_limitZoom","id","getClusterJSON","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","pow","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","cluster_id","skipped","child","isCluster","tags","px","py","getClusterProperties","f","type","nextData","neighborIds","numPointsOrigin","numPoints","neighborId","clusterProperties","wx","wy","clusterPropIndex","numPoints2","_map","clone","original","yLat","abbrev","propIndex","point_count_abbreviated","sin","y2","atan","transformProps","chartProps","formData","hooks","queriesData","onError","setControlValue","geoJSON","clusteringRadius","mapboxColor","mapboxStyle","pandasAggfunc","exec","opts","initial","prop","accu"],"sourceRoot":""}