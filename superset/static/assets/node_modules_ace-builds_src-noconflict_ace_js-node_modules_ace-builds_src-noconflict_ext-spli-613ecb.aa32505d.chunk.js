/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["node_modules_ace-builds_src-noconflict_ace_js-node_modules_ace-builds_src-noconflict_ext-spli-613ecb"],{

/***/ "./node_modules/ace-builds/src-noconflict/ace.js":
/*!*******************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/ace.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/* ***** BEGIN LICENSE BLOCK *****\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/**\n * Define a module along with a payload\n * @param module a name for the payload\n * @param payload a function to call with (require, exports, module) params\n */\n\n(function() {\n\nvar ACE_NAMESPACE = \"ace\";\n\nvar global = (function() { return this; })();\nif (!global && typeof window != \"undefined\") global = window; // strict mode\n\n\nif (!ACE_NAMESPACE && typeof requirejs !== \"undefined\")\n    return;\n\n\nvar define = function(module, deps, payload) {\n    if (typeof module !== \"string\") {\n        if (define.original)\n            define.original.apply(this, arguments);\n        else {\n            console.error(\"dropping module because define wasn\\'t a string.\");\n            console.trace();\n        }\n        return;\n    }\n    if (arguments.length == 2)\n        payload = deps;\n    if (!define.modules[module]) {\n        define.payloads[module] = payload;\n        define.modules[module] = null;\n    }\n};\n\ndefine.modules = {};\ndefine.payloads = {};\n\n/**\n * Get at functionality define()ed using the function above\n */\nvar _require = function(parentId, module, callback) {\n    if (typeof module === \"string\") {\n        var payload = lookup(parentId, module);\n        if (payload != undefined) {\n            callback && callback();\n            return payload;\n        }\n    } else if (Object.prototype.toString.call(module) === \"[object Array]\") {\n        var params = [];\n        for (var i = 0, l = module.length; i < l; ++i) {\n            var dep = lookup(parentId, module[i]);\n            if (dep == undefined && require.original)\n                return;\n            params.push(dep);\n        }\n        return callback && callback.apply(null, params) || true;\n    }\n};\n\nvar require = function(module, callback) {\n    var packagedModule = _require(\"\", module, callback);\n    if (packagedModule == undefined && require.original)\n        return require.original.apply(this, arguments);\n    return packagedModule;\n};\n\nvar normalizeModule = function(parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n        var chunks = moduleName.split(\"!\");\n        return normalizeModule(parentId, chunks[0]) + \"!\" + normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n        moduleName = base + \"/\" + moduleName;\n\n        while(moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n            var previous = moduleName;\n            moduleName = moduleName.replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n        }\n    }\n    return moduleName;\n};\n\n/**\n * Internal function to lookup moduleNames and resolve them by calling the\n * definition function if needed.\n */\nvar lookup = function(parentId, moduleName) {\n    moduleName = normalizeModule(parentId, moduleName);\n\n    var module = define.modules[moduleName];\n    if (!module) {\n        module = define.payloads[moduleName];\n        if (typeof module === 'function') {\n            var exports = {};\n            var mod = {\n                id: moduleName,\n                uri: '',\n                exports: exports,\n                packaged: true\n            };\n\n            var req = function(module, callback) {\n                return _require(moduleName, module, callback);\n            };\n\n            var returnValue = module(req, exports, mod);\n            exports = returnValue || mod.exports;\n            define.modules[moduleName] = exports;\n            delete define.payloads[moduleName];\n        }\n        module = define.modules[moduleName] = exports || module;\n    }\n    return module;\n};\n\nfunction exportAce(ns) {\n    var root = global;\n    if (ns) {\n        if (!global[ns])\n            global[ns] = {};\n        root = global[ns];\n    }\n\n    if (!root.define || !root.define.packaged) {\n        define.original = root.define;\n        root.define = define;\n        root.define.packaged = true;\n    }\n\n    if (!root.require || !root.require.packaged) {\n        require.original = root.require;\n        root.require = require;\n        root.require.packaged = true;\n    }\n}\n\nexportAce(ACE_NAMESPACE);\n\n})();\n\nace.define(\"ace/lib/es6-shim\",[\"require\",\"exports\",\"module\"], function(require, exports, module){function defineProp(obj, name, val) {\n    Object.defineProperty(obj, name, {\n        value: val,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n}\nif (!String.prototype.startsWith) {\n    defineProp(String.prototype, \"startsWith\", function (searchString, position) {\n        position = position || 0;\n        return this.lastIndexOf(searchString, position) === position;\n    });\n}\nif (!String.prototype.endsWith) {\n    defineProp(String.prototype, \"endsWith\", function (searchString, position) {\n        var subjectString = this;\n        if (position === undefined || position > subjectString.length) {\n            position = subjectString.length;\n        }\n        position -= searchString.length;\n        var lastIndex = subjectString.indexOf(searchString, position);\n        return lastIndex !== -1 && lastIndex === position;\n    });\n}\nif (!String.prototype.repeat) {\n    defineProp(String.prototype, \"repeat\", function (count) {\n        var result = \"\";\n        var string = this;\n        while (count > 0) {\n            if (count & 1)\n                result += string;\n            if ((count >>= 1))\n                string += string;\n        }\n        return result;\n    });\n}\nif (!String.prototype.includes) {\n    defineProp(String.prototype, \"includes\", function (str, position) {\n        return this.indexOf(str, position) != -1;\n    });\n}\nif (!Object.assign) {\n    Object.assign = function (target) {\n        if (target === undefined || target === null) {\n            throw new TypeError(\"Cannot convert undefined or null to object\");\n        }\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                Object.keys(source).forEach(function (key) {\n                    output[key] = source[key];\n                });\n            }\n        }\n        return output;\n    };\n}\nif (!Object.values) {\n    Object.values = function (o) {\n        return Object.keys(o).map(function (k) {\n            return o[k];\n        });\n    };\n}\nif (!Array.prototype.find) {\n    defineProp(Array.prototype, \"find\", function (predicate) {\n        var len = this.length;\n        var thisArg = arguments[1];\n        for (var k = 0; k < len; k++) {\n            var kValue = this[k];\n            if (predicate.call(thisArg, kValue, k, this)) {\n                return kValue;\n            }\n        }\n    });\n}\nif (!Array.prototype.findIndex) {\n    defineProp(Array.prototype, \"findIndex\", function (predicate) {\n        var len = this.length;\n        var thisArg = arguments[1];\n        for (var k = 0; k < len; k++) {\n            var kValue = this[k];\n            if (predicate.call(thisArg, kValue, k, this)) {\n                return k;\n            }\n        }\n    });\n}\nif (!Array.prototype.includes) {\n    defineProp(Array.prototype, \"includes\", function (item, position) {\n        return this.indexOf(item, position) != -1;\n    });\n}\nif (!Array.prototype.fill) {\n    defineProp(Array.prototype, \"fill\", function (value) {\n        var O = this;\n        var len = O.length >>> 0;\n        var start = arguments[1];\n        var relativeStart = start >> 0;\n        var k = relativeStart < 0\n            ? Math.max(len + relativeStart, 0)\n            : Math.min(relativeStart, len);\n        var end = arguments[2];\n        var relativeEnd = end === undefined ? len : end >> 0;\n        var final = relativeEnd < 0\n            ? Math.max(len + relativeEnd, 0)\n            : Math.min(relativeEnd, len);\n        while (k < final) {\n            O[k] = value;\n            k++;\n        }\n        return O;\n    });\n}\nif (!Array.of) {\n    defineProp(Array, \"of\", function () {\n        return Array.prototype.slice.call(arguments);\n    });\n}\n\n});\n\nace.define(\"ace/lib/fixoldbrowsers\",[\"require\",\"exports\",\"module\",\"ace/lib/es6-shim\"], function(require, exports, module){// vim:set ts=4 sts=4 sw=4 st:\n\"use strict\";\nrequire(\"./es6-shim\");\n\n});\n\nace.define(\"ace/lib/deep_copy\",[\"require\",\"exports\",\"module\"], function(require, exports, module){exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj)\n        return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = [];\n        for (var key = 0; key < obj.length; key++) {\n            copy[key] = deepCopy(obj[key]);\n        }\n        return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\")\n        return obj;\n    copy = {};\n    for (var key in obj)\n        copy[key] = deepCopy(obj[key]);\n    return copy;\n};\n\n});\n\nace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\",\"ace/lib/deep_copy\"], function(require, exports, module){\"use strict\";\nexports.last = function (a) {\n    return a[a.length - 1];\n};\nexports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n};\nexports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n        if (count & 1)\n            result += string;\n        if (count >>= 1)\n            string += string;\n    }\n    return result;\n};\nvar trimBeginRegexp = /^\\s\\s*/;\nvar trimEndRegexp = /\\s\\s*$/;\nexports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n};\nexports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n};\nexports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n        copy[key] = obj[key];\n    }\n    return copy;\n};\nexports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] && typeof array[i] == \"object\")\n            copy[i] = this.copyObject(array[i]);\n        else\n            copy[i] = array[i];\n    }\n    return copy;\n};\nexports.deepCopy = require(\"./deep_copy\").deepCopy;\nexports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n        map[arr[i]] = 1;\n    }\n    return map;\n};\nexports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n        map[i] = props[i];\n    }\n    return map;\n};\nexports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n        if (value === array[i]) {\n            array.splice(i, 1);\n        }\n    }\n};\nexports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\nexports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n};\nexports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n        matches.push({\n            offset: arguments[arguments.length - 2],\n            length: str.length\n        });\n    });\n    return matches;\n};\nexports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function () {\n        timer = null;\n        fcn();\n    };\n    var deferred = function (timeout) {\n        deferred.cancel();\n        timer = setTimeout(callback, timeout || 0);\n        return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n        this.cancel();\n        fcn();\n        return deferred;\n    };\n    deferred.cancel = function () {\n        clearTimeout(timer);\n        timer = null;\n        return deferred;\n    };\n    deferred.isPending = function () {\n        return timer;\n    };\n    return deferred;\n};\nexports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function () {\n        timer = null;\n        fcn();\n    };\n    var _self = function (timeout) {\n        if (timer == null)\n            timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n        timer && clearTimeout(timer);\n        timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n        this.cancel();\n        fcn();\n    };\n    _self.cancel = function () {\n        timer && clearTimeout(timer);\n        timer = null;\n    };\n    _self.isPending = function () {\n        return timer;\n    };\n    return _self;\n};\nexports.supportsLookbehind = function () {\n    try {\n        new RegExp('(?<=.)');\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\nexports.skipEmptyMatch = function (line, last, supportsUnicodeFlag) {\n    return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;\n};\n\n});\n\nace.define(\"ace/lib/useragent\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nexports.OS = {\n    LINUX: \"LINUX\",\n    MAC: \"MAC\",\n    WINDOWS: \"WINDOWS\"\n};\nexports.getOS = function () {\n    if (exports.isMac) {\n        return exports.OS.MAC;\n    }\n    else if (exports.isLinux) {\n        return exports.OS.LINUX;\n    }\n    else {\n        return exports.OS.WINDOWS;\n    }\n};\nvar _navigator = typeof navigator == \"object\" ? navigator : {};\nvar os = (/mac|win|linux/i.exec(_navigator.platform) || [\"other\"])[0].toLowerCase();\nvar ua = _navigator.userAgent || \"\";\nvar appName = _navigator.appName || \"\";\nexports.isWin = (os == \"win\");\nexports.isMac = (os == \"mac\");\nexports.isLinux = (os == \"linux\");\nexports.isIE =\n    (appName == \"Microsoft Internet Explorer\" || appName.indexOf(\"MSAppHost\") >= 0)\n        ? parseFloat((ua.match(/(?:MSIE |Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/) || [])[1])\n        : parseFloat((ua.match(/(?:Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/) || [])[1]); // for ie\nexports.isOldIE = exports.isIE && exports.isIE < 9;\nexports.isGecko = exports.isMozilla = ua.match(/ Gecko\\/\\d+/);\nexports.isOpera = typeof opera == \"object\" && Object.prototype.toString.call(window[\"opera\"]) == \"[object Opera]\";\nexports.isWebKit = parseFloat(ua.split(\"WebKit/\")[1]) || undefined;\nexports.isChrome = parseFloat(ua.split(\" Chrome/\")[1]) || undefined;\nexports.isSafari = parseFloat(ua.split(\" Safari/\")[1]) && !exports.isChrome || undefined;\nexports.isEdge = parseFloat(ua.split(\" Edge/\")[1]) || undefined;\nexports.isAIR = ua.indexOf(\"AdobeAIR\") >= 0;\nexports.isAndroid = ua.indexOf(\"Android\") >= 0;\nexports.isChromeOS = ua.indexOf(\" CrOS \") >= 0;\nexports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window[\"MSStream\"];\nif (exports.isIOS)\n    exports.isMac = true;\nexports.isMobile = exports.isIOS || exports.isAndroid;\n\n});\n\nace.define(\"ace/lib/dom\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar useragent = require(\"./useragent\");\nvar XHTML_NS = \"http://www.w3.org/1999/xhtml\";\nexports.buildDom = function buildDom(arr, parent, refs) {\n    if (typeof arr == \"string\" && arr) {\n        var txt = document.createTextNode(arr);\n        if (parent)\n            parent.appendChild(txt);\n        return txt;\n    }\n    if (!Array.isArray(arr)) {\n        if (arr && arr.appendChild && parent)\n            parent.appendChild(arr);\n        return arr;\n    }\n    if (typeof arr[0] != \"string\" || !arr[0]) {\n        var els = [];\n        for (var i = 0; i < arr.length; i++) {\n            var ch = buildDom(arr[i], parent, refs);\n            ch && els.push(ch);\n        }\n        return els;\n    }\n    var el = document.createElement(arr[0]);\n    var options = arr[1];\n    var childIndex = 1;\n    if (options && typeof options == \"object\" && !Array.isArray(options))\n        childIndex = 2;\n    for (var i = childIndex; i < arr.length; i++)\n        buildDom(arr[i], el, refs);\n    if (childIndex == 2) {\n        Object.keys(options).forEach(function (n) {\n            var val = options[n];\n            if (n === \"class\") {\n                el.className = Array.isArray(val) ? val.join(\" \") : val;\n            }\n            else if (typeof val == \"function\" || n == \"value\" || n[0] == \"$\") {\n                el[n] = val;\n            }\n            else if (n === \"ref\") {\n                if (refs)\n                    refs[val] = el;\n            }\n            else if (n === \"style\") {\n                if (typeof val == \"string\")\n                    el.style.cssText = val;\n            }\n            else if (val != null) {\n                el.setAttribute(n, val);\n            }\n        });\n    }\n    if (parent)\n        parent.appendChild(el);\n    return el;\n};\nexports.getDocumentHead = function (doc) {\n    if (!doc)\n        doc = document;\n    return doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement;\n};\nexports.createElement = function (tag, ns) {\n    return document.createElementNS ?\n        document.createElementNS(ns || XHTML_NS, tag) :\n        document.createElement(tag);\n};\nexports.removeChildren = function (element) {\n    element.innerHTML = \"\";\n};\nexports.createTextNode = function (textContent, element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createTextNode(textContent);\n};\nexports.createFragment = function (element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createDocumentFragment();\n};\nexports.hasCssClass = function (el, name) {\n    var classes = (el.className + \"\").split(/\\s+/g);\n    return classes.indexOf(name) !== -1;\n};\nexports.addCssClass = function (el, name) {\n    if (!exports.hasCssClass(el, name)) {\n        el.className += \" \" + name;\n    }\n};\nexports.removeCssClass = function (el, name) {\n    var classes = el.className.split(/\\s+/g);\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        classes.splice(index, 1);\n    }\n    el.className = classes.join(\" \");\n};\nexports.toggleCssClass = function (el, name) {\n    var classes = el.className.split(/\\s+/g), add = true;\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        add = false;\n        classes.splice(index, 1);\n    }\n    if (add)\n        classes.push(name);\n    el.className = classes.join(\" \");\n    return add;\n};\nexports.setCssClass = function (node, className, include) {\n    if (include) {\n        exports.addCssClass(node, className);\n    }\n    else {\n        exports.removeCssClass(node, className);\n    }\n};\nexports.hasCssString = function (id, doc) {\n    var index = 0, sheets;\n    doc = doc || document;\n    if ((sheets = doc.querySelectorAll(\"style\"))) {\n        while (index < sheets.length) {\n            if (sheets[index++].id === id) {\n                return true;\n            }\n        }\n    }\n};\nexports.removeElementById = function (id, doc) {\n    doc = doc || document;\n    if (doc.getElementById(id)) {\n        doc.getElementById(id).remove();\n    }\n};\nvar strictCSP;\nvar cssCache = [];\nexports.useStrictCSP = function (value) {\n    strictCSP = value;\n    if (value == false)\n        insertPendingStyles();\n    else if (!cssCache)\n        cssCache = [];\n};\nfunction insertPendingStyles() {\n    var cache = cssCache;\n    cssCache = null;\n    cache && cache.forEach(function (item) {\n        importCssString(item[0], item[1]);\n    });\n}\nfunction importCssString(cssText, id, target) {\n    if (typeof document == \"undefined\")\n        return;\n    if (cssCache) {\n        if (target) {\n            insertPendingStyles();\n        }\n        else if (target === false) {\n            return cssCache.push([cssText, id]);\n        }\n    }\n    if (strictCSP)\n        return;\n    var container = target;\n    if (!target || !target.getRootNode) {\n        container = document;\n    }\n    else {\n        container = target.getRootNode();\n        if (!container || container == target)\n            container = document;\n    }\n    var doc = container.ownerDocument || container;\n    if (id && exports.hasCssString(id, container))\n        return null;\n    if (id)\n        cssText += \"\\n/*# sourceURL=ace/css/\" + id + \" */\";\n    var style = exports.createElement(\"style\");\n    style.appendChild(doc.createTextNode(cssText));\n    if (id)\n        style.id = id;\n    if (container == doc)\n        container = exports.getDocumentHead(doc);\n    container.insertBefore(style, container.firstChild);\n}\nexports.importCssString = importCssString;\nexports.importCssStylsheet = function (uri, doc) {\n    exports.buildDom([\"link\", { rel: \"stylesheet\", href: uri }], exports.getDocumentHead(doc));\n};\nexports.scrollbarWidth = function (doc) {\n    var inner = exports.createElement(\"ace_inner\");\n    inner.style.width = \"100%\";\n    inner.style.minWidth = \"0px\";\n    inner.style.height = \"200px\";\n    inner.style.display = \"block\";\n    var outer = exports.createElement(\"ace_outer\");\n    var style = outer.style;\n    style.position = \"absolute\";\n    style.left = \"-10000px\";\n    style.overflow = \"hidden\";\n    style.width = \"200px\";\n    style.minWidth = \"0px\";\n    style.height = \"150px\";\n    style.display = \"block\";\n    outer.appendChild(inner);\n    var body = (doc && doc.documentElement) || (document && document.documentElement);\n    if (!body)\n        return 0;\n    body.appendChild(outer);\n    var noScrollbar = inner.offsetWidth;\n    style.overflow = \"scroll\";\n    var withScrollbar = inner.offsetWidth;\n    if (noScrollbar === withScrollbar) {\n        withScrollbar = outer.clientWidth;\n    }\n    body.removeChild(outer);\n    return noScrollbar - withScrollbar;\n};\nexports.computedStyle = function (element, style) {\n    return window.getComputedStyle(element, \"\") || {};\n};\nexports.setStyle = function (styles, property, value) {\n    if (styles[property] !== value) {\n        styles[property] = value;\n    }\n};\nexports.HAS_CSS_ANIMATION = false;\nexports.HAS_CSS_TRANSFORMS = false;\nexports.HI_DPI = useragent.isWin\n    ? typeof window !== \"undefined\" && window.devicePixelRatio >= 1.5\n    : true;\nif (useragent.isChromeOS)\n    exports.HI_DPI = false;\nif (typeof document !== \"undefined\") {\n    var div = document.createElement(\"div\");\n    if (exports.HI_DPI && div.style.transform !== undefined)\n        exports.HAS_CSS_TRANSFORMS = true;\n    if (!useragent.isEdge && typeof div.style.animationName !== \"undefined\")\n        exports.HAS_CSS_ANIMATION = true;\n    div = null;\n}\nif (exports.HAS_CSS_TRANSFORMS) {\n    exports.translate = function (element, tx, ty) {\n        element.style.transform = \"translate(\" + Math.round(tx) + \"px, \" + Math.round(ty) + \"px)\";\n    };\n}\nelse {\n    exports.translate = function (element, tx, ty) {\n        element.style.top = Math.round(ty) + \"px\";\n        element.style.left = Math.round(tx) + \"px\";\n    };\n}\n\n});\n\nace.define(\"ace/lib/net\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){/*\n * based on code from:\n *\n * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\"use strict\";\nvar dom = require(\"./dom\");\nexports.get = function (url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            callback(xhr.responseText);\n        }\n    };\n    xhr.send(null);\n};\nexports.loadScript = function (path, callback) {\n    var head = dom.getDocumentHead();\n    var s = document.createElement('script');\n    s.src = path;\n    head.appendChild(s);\n    s.onload = s.onreadystatechange = function (_, isAbort) {\n        if (isAbort || !s.readyState || s.readyState == \"loaded\" || s.readyState == \"complete\") {\n            s = s.onload = s.onreadystatechange = null;\n            if (!isAbort)\n                callback();\n        }\n    };\n};\nexports.qualifyURL = function (url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.href;\n};\n\n});\n\nace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nexports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\nexports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\nexports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n\n});\n\nace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar EventEmitter = {};\nvar stopPropagation = function () { this.propagationStopped = true; };\nvar preventDefault = function () { this.defaultPrevented = true; };\nEventEmitter._emit =\n    EventEmitter._dispatchEvent = function (eventName, e) {\n        this._eventRegistry || (this._eventRegistry = {});\n        this._defaultHandlers || (this._defaultHandlers = {});\n        var listeners = this._eventRegistry[eventName] || [];\n        var defaultHandler = this._defaultHandlers[eventName];\n        if (!listeners.length && !defaultHandler)\n            return;\n        if (typeof e != \"object\" || !e)\n            e = {};\n        if (!e.type)\n            e.type = eventName;\n        if (!e.stopPropagation)\n            e.stopPropagation = stopPropagation;\n        if (!e.preventDefault)\n            e.preventDefault = preventDefault;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++) {\n            listeners[i](e, this);\n            if (e.propagationStopped)\n                break;\n        }\n        if (defaultHandler && !e.defaultPrevented)\n            return defaultHandler(e, this);\n    };\nEventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++)\n        listeners[i](e, this);\n};\nEventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n        _self.off(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        return new Promise(function (resolve) {\n            callback = resolve;\n        });\n    }\n};\nEventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = { _disabled_: {} };\n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    }\n    else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\nEventEmitter.on =\n    EventEmitter.addEventListener = function (eventName, callback, capturing) {\n        this._eventRegistry = this._eventRegistry || {};\n        var listeners = this._eventRegistry[eventName];\n        if (!listeners)\n            listeners = this._eventRegistry[eventName] = [];\n        if (listeners.indexOf(callback) == -1)\n            listeners[capturing ? \"unshift\" : \"push\"](callback);\n        return callback;\n    };\nEventEmitter.off =\n    EventEmitter.removeListener =\n        EventEmitter.removeEventListener = function (eventName, callback) {\n            this._eventRegistry = this._eventRegistry || {};\n            var listeners = this._eventRegistry[eventName];\n            if (!listeners)\n                return;\n            var index = listeners.indexOf(callback);\n            if (index !== -1)\n                listeners.splice(index, 1);\n        };\nEventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName)\n        this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry)\n        this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers)\n        this._defaultHandlers[eventName] = undefined;\n};\nexports.EventEmitter = EventEmitter;\n\n});\n\nace.define(\"ace/lib/report_error\",[\"require\",\"exports\",\"module\"], function(require, exports, module){exports.reportError = function reportError(msg, data) {\n    var e = new Error(msg);\n    e[\"data\"] = data;\n    if (typeof console == \"object\" && console.error)\n        console.error(e);\n    setTimeout(function () { throw e; });\n};\n\n});\n\nace.define(\"ace/lib/default_english_messages\",[\"require\",\"exports\",\"module\"], function(require, exports, module){var defaultEnglishMessages = {\n    \"autocomplete.popup.aria-roledescription\": \"Autocomplete suggestions\",\n    \"autocomplete.popup.aria-label\": \"Autocomplete suggestions\",\n    \"autocomplete.popup.item.aria-roledescription\": \"item\",\n    \"autocomplete.loading\": \"Loading...\",\n    \"editor.scroller.aria-roledescription\": \"editor\",\n    \"editor.scroller.aria-label\": \"Editor content, press Enter to start editing, press Escape to exit\",\n    \"editor.gutter.aria-roledescription\": \"editor\",\n    \"editor.gutter.aria-label\": \"Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit\",\n    \"error-marker.good-state\": \"Looks good!\",\n    \"prompt.recently-used\": \"Recently used\",\n    \"prompt.other-commands\": \"Other commands\",\n    \"prompt.no-matching-commands\": \"No matching commands\",\n    \"search-box.find.placeholder\": \"Search for\",\n    \"search-box.find-all.text\": \"All\",\n    \"search-box.replace.placeholder\": \"Replace with\",\n    \"search-box.replace-next.text\": \"Replace\",\n    \"search-box.replace-all.text\": \"All\",\n    \"search-box.toggle-replace.title\": \"Toggle Replace mode\",\n    \"search-box.toggle-regexp.title\": \"RegExp Search\",\n    \"search-box.toggle-case.title\": \"CaseSensitive Search\",\n    \"search-box.toggle-whole-word.title\": \"Whole Word Search\",\n    \"search-box.toggle-in-selection.title\": \"Search In Selection\",\n    \"search-box.search-counter\": \"$0 of $1\",\n    \"text-input.aria-roledescription\": \"editor\",\n    \"text-input.aria-label\": \"Cursor at row $0\",\n    \"gutter.code-folding.range.aria-label\": \"Toggle code folding, rows $0 through $1\",\n    \"gutter.code-folding.closed.aria-label\": \"Toggle code folding, rows $0 through $1\",\n    \"gutter.code-folding.open.aria-label\": \"Toggle code folding, row $0\",\n    \"gutter.code-folding.closed.title\": \"Unfold code\",\n    \"gutter.code-folding.open.title\": \"Fold code\",\n    \"gutter.annotation.aria-label.error\": \"Error, read annotations row $0\",\n    \"gutter.annotation.aria-label.warning\": \"Warning, read annotations row $0\",\n    \"gutter.annotation.aria-label.info\": \"Info, read annotations row $0\",\n    \"inline-fold.closed.title\": \"Unfold code\",\n    \"gutter-tooltip.aria-label.error.singular\": \"error\",\n    \"gutter-tooltip.aria-label.error.plural\": \"errors\",\n    \"gutter-tooltip.aria-label.warning.singular\": \"warning\",\n    \"gutter-tooltip.aria-label.warning.plural\": \"warnings\",\n    \"gutter-tooltip.aria-label.info.singular\": \"information message\",\n    \"gutter-tooltip.aria-label.info.plural\": \"information messages\"\n};\nexports.defaultEnglishMessages = defaultEnglishMessages;\n\n});\n\nace.define(\"ace/lib/app_config\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/lib/report_error\",\"ace/lib/default_english_messages\"], function(require, exports, module){\"no use strict\";\nvar oop = require(\"./oop\");\nvar EventEmitter = require(\"./event_emitter\").EventEmitter;\nvar reportError = require(\"./report_error\").reportError;\nvar defaultEnglishMessages = require(\"./default_english_messages\").defaultEnglishMessages;\nvar optionsProvider = {\n    setOptions: function (optList) {\n        Object.keys(optList).forEach(function (key) {\n            this.setOption(key, optList[key]);\n        }, this);\n    },\n    getOptions: function (optionNames) {\n        var result = {};\n        if (!optionNames) {\n            var options = this.$options;\n            optionNames = Object.keys(options).filter(function (key) {\n                return !options[key].hidden;\n            });\n        }\n        else if (!Array.isArray(optionNames)) {\n            result = optionNames;\n            optionNames = Object.keys(result);\n        }\n        optionNames.forEach(function (key) {\n            result[key] = this.getOption(key);\n        }, this);\n        return result;\n    },\n    setOption: function (name, value) {\n        if (this[\"$\" + name] === value)\n            return;\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);\n        if (!opt.handlesSet)\n            this[\"$\" + name] = value;\n        if (opt && opt.set)\n            opt.set.call(this, value);\n    },\n    getOption: function (name) {\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);\n        return opt && opt.get ? opt.get.call(this) : this[\"$\" + name];\n    }\n};\nfunction warn(message) {\n    if (typeof console != \"undefined\" && console.warn)\n        console.warn.apply(console, arguments);\n}\nvar messages;\nvar nlsPlaceholders;\nvar AppConfig = /** @class */ (function () {\n    function AppConfig() {\n        this.$defaultOptions = {};\n        messages = defaultEnglishMessages;\n        nlsPlaceholders = \"dollarSigns\";\n    }\n    AppConfig.prototype.defineOptions = function (obj, path, options) {\n        if (!obj.$options)\n            this.$defaultOptions[path] = obj.$options = {};\n        Object.keys(options).forEach(function (key) {\n            var opt = options[key];\n            if (typeof opt == \"string\")\n                opt = { forwardTo: opt };\n            opt.name || (opt.name = key);\n            obj.$options[opt.name] = opt;\n            if (\"initialValue\" in opt)\n                obj[\"$\" + opt.name] = opt.initialValue;\n        });\n        oop.implement(obj, optionsProvider);\n        return this;\n    };\n    AppConfig.prototype.resetOptions = function (obj) {\n        Object.keys(obj.$options).forEach(function (key) {\n            var opt = obj.$options[key];\n            if (\"value\" in opt)\n                obj.setOption(key, opt.value);\n        });\n    };\n    AppConfig.prototype.setDefaultValue = function (path, name, value) {\n        if (!path) {\n            for (path in this.$defaultOptions)\n                if (this.$defaultOptions[path][name])\n                    break;\n            if (!this.$defaultOptions[path][name])\n                return false;\n        }\n        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});\n        if (opts[name]) {\n            if (opts.forwardTo)\n                this.setDefaultValue(opts.forwardTo, name, value);\n            else\n                opts[name].value = value;\n        }\n    };\n    AppConfig.prototype.setDefaultValues = function (path, optionHash) {\n        Object.keys(optionHash).forEach(function (key) {\n            this.setDefaultValue(path, key, optionHash[key]);\n        }, this);\n    };\n    AppConfig.prototype.setMessages = function (value, options) {\n        messages = value;\n        if (options && options.placeholders) {\n            nlsPlaceholders = options.placeholders;\n        }\n    };\n    AppConfig.prototype.nls = function (key, defaultString, params) {\n        if (!messages[key]) {\n            warn(\"No message found for the key '\" + key + \"' in the provided messages, trying to find a translation for the default string '\" + defaultString + \"'.\");\n            if (!messages[defaultString]) {\n                warn(\"No message found for the default string '\" + defaultString + \"' in the provided messages. Falling back to the default English message.\");\n            }\n        }\n        var translated = messages[key] || messages[defaultString] || defaultString;\n        if (params) {\n            if (nlsPlaceholders === \"dollarSigns\") {\n                translated = translated.replace(/\\$(\\$|[\\d]+)/g, function (_, dollarMatch) {\n                    if (dollarMatch == \"$\")\n                        return \"$\";\n                    return params[dollarMatch];\n                });\n            }\n            if (nlsPlaceholders === \"curlyBrackets\") {\n                translated = translated.replace(/\\{([^\\}]+)\\}/g, function (_, curlyBracketMatch) {\n                    return params[curlyBracketMatch];\n                });\n            }\n        }\n        return translated;\n    };\n    return AppConfig;\n}());\nAppConfig.prototype.warn = warn;\nAppConfig.prototype.reportError = reportError;\noop.implement(AppConfig.prototype, EventEmitter);\nexports.AppConfig = AppConfig;\n\n});\n\nace.define(\"ace/theme/textmate-css\",[\"require\",\"exports\",\"module\"], function(require, exports, module){module.exports = \".ace-tm .ace_gutter {\\n  background: #f0f0f0;\\n  color: #333;\\n}\\n\\n.ace-tm .ace_print-margin {\\n  width: 1px;\\n  background: #e8e8e8;\\n}\\n\\n.ace-tm .ace_fold {\\n    background-color: #6B72E6;\\n}\\n\\n.ace-tm {\\n  background-color: #FFFFFF;\\n  color: black;\\n}\\n\\n.ace-tm .ace_cursor {\\n  color: black;\\n}\\n        \\n.ace-tm .ace_invisible {\\n  color: rgb(191, 191, 191);\\n}\\n\\n.ace-tm .ace_storage,\\n.ace-tm .ace_keyword {\\n  color: blue;\\n}\\n\\n.ace-tm .ace_constant {\\n  color: rgb(197, 6, 11);\\n}\\n\\n.ace-tm .ace_constant.ace_buildin {\\n  color: rgb(88, 72, 246);\\n}\\n\\n.ace-tm .ace_constant.ace_language {\\n  color: rgb(88, 92, 246);\\n}\\n\\n.ace-tm .ace_constant.ace_library {\\n  color: rgb(6, 150, 14);\\n}\\n\\n.ace-tm .ace_invalid {\\n  background-color: rgba(255, 0, 0, 0.1);\\n  color: red;\\n}\\n\\n.ace-tm .ace_support.ace_function {\\n  color: rgb(60, 76, 114);\\n}\\n\\n.ace-tm .ace_support.ace_constant {\\n  color: rgb(6, 150, 14);\\n}\\n\\n.ace-tm .ace_support.ace_type,\\n.ace-tm .ace_support.ace_class {\\n  color: rgb(109, 121, 222);\\n}\\n\\n.ace-tm .ace_keyword.ace_operator {\\n  color: rgb(104, 118, 135);\\n}\\n\\n.ace-tm .ace_string {\\n  color: rgb(3, 106, 7);\\n}\\n\\n.ace-tm .ace_comment {\\n  color: rgb(76, 136, 107);\\n}\\n\\n.ace-tm .ace_comment.ace_doc {\\n  color: rgb(0, 102, 255);\\n}\\n\\n.ace-tm .ace_comment.ace_doc.ace_tag {\\n  color: rgb(128, 159, 191);\\n}\\n\\n.ace-tm .ace_constant.ace_numeric {\\n  color: rgb(0, 0, 205);\\n}\\n\\n.ace-tm .ace_variable {\\n  color: rgb(49, 132, 149);\\n}\\n\\n.ace-tm .ace_xml-pe {\\n  color: rgb(104, 104, 91);\\n}\\n\\n.ace-tm .ace_entity.ace_name.ace_function {\\n  color: #0000A2;\\n}\\n\\n\\n.ace-tm .ace_heading {\\n  color: rgb(12, 7, 255);\\n}\\n\\n.ace-tm .ace_list {\\n  color:rgb(185, 6, 144);\\n}\\n\\n.ace-tm .ace_meta.ace_tag {\\n  color:rgb(0, 22, 142);\\n}\\n\\n.ace-tm .ace_string.ace_regex {\\n  color: rgb(255, 0, 0)\\n}\\n\\n.ace-tm .ace_marker-layer .ace_selection {\\n  background: rgb(181, 213, 255);\\n}\\n.ace-tm.ace_multiselect .ace_selection.ace_start {\\n  box-shadow: 0 0 3px 0px white;\\n}\\n.ace-tm .ace_marker-layer .ace_step {\\n  background: rgb(252, 255, 0);\\n}\\n\\n.ace-tm .ace_marker-layer .ace_stack {\\n  background: rgb(164, 229, 101);\\n}\\n\\n.ace-tm .ace_marker-layer .ace_bracket {\\n  margin: -1px 0 0 -1px;\\n  border: 1px solid rgb(192, 192, 192);\\n}\\n\\n.ace-tm .ace_marker-layer .ace_active-line {\\n  background: rgba(0, 0, 0, 0.07);\\n}\\n\\n.ace-tm .ace_gutter-active-line {\\n    background-color : #dcdcdc;\\n}\\n\\n.ace-tm .ace_marker-layer .ace_selected-word {\\n  background: rgb(250, 250, 255);\\n  border: 1px solid rgb(200, 200, 250);\\n}\\n\\n.ace-tm .ace_indent-guide {\\n  background: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y;\\n}\\n\\n.ace-tm .ace_indent-guide-active {\\n  background: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC\\\") right repeat-y;\\n}\\n\";\n\n});\n\nace.define(\"ace/theme/textmate\",[\"require\",\"exports\",\"module\",\"ace/theme/textmate-css\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nexports.isDark = false;\nexports.cssClass = \"ace-tm\";\nexports.cssText = require(\"./textmate-css\");\nexports.$id = \"ace/theme/textmate\";\nvar dom = require(\"../lib/dom\");\ndom.importCssString(exports.cssText, exports.cssClass, false);\n\n});\n\nace.define(\"ace/config\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/net\",\"ace/lib/dom\",\"ace/lib/app_config\",\"ace/theme/textmate\"], function(require, exports, module){\"no use strict\";\nvar lang = require(\"./lib/lang\");\nvar net = require(\"./lib/net\");\nvar dom = require(\"./lib/dom\");\nvar AppConfig = require(\"./lib/app_config\").AppConfig;\nmodule.exports = exports = new AppConfig();\nvar options = {\n    packaged: false,\n    workerPath: null,\n    modePath: null,\n    themePath: null,\n    basePath: \"\",\n    suffix: \".js\",\n    $moduleUrls: {},\n    loadWorkerFromBlob: true,\n    sharedPopups: false,\n    useStrictCSP: null\n};\nexports.get = function (key) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n    return options[key];\n};\nexports.set = function (key, value) {\n    if (options.hasOwnProperty(key))\n        options[key] = value;\n    else if (this.setDefaultValue(\"\", key, value) == false)\n        throw new Error(\"Unknown config key: \" + key);\n    if (key == \"useStrictCSP\")\n        dom.useStrictCSP(value);\n};\nexports.all = function () {\n    return lang.copyObject(options);\n};\nexports.$modes = {};\nexports.moduleUrl = function (name, component) {\n    if (options.$moduleUrls[name])\n        return options.$moduleUrls[name];\n    var parts = name.split(\"/\");\n    component = component || parts[parts.length - 2] || \"\";\n    var sep = component == \"snippets\" ? \"/\" : \"-\";\n    var base = parts[parts.length - 1];\n    if (component == \"worker\" && sep == \"-\") {\n        var re = new RegExp(\"^\" + component + \"[\\\\-_]|[\\\\-_]\" + component + \"$\", \"g\");\n        base = base.replace(re, \"\");\n    }\n    if ((!base || base == component) && parts.length > 1)\n        base = parts[parts.length - 2];\n    var path = options[component + \"Path\"];\n    if (path == null) {\n        path = options.basePath;\n    }\n    else if (sep == \"/\") {\n        component = sep = \"\";\n    }\n    if (path && path.slice(-1) != \"/\")\n        path += \"/\";\n    return path + component + sep + base + this.get(\"suffix\");\n};\nexports.setModuleUrl = function (name, subst) {\n    return options.$moduleUrls[name] = subst;\n};\nvar loader = function (moduleName, cb) {\n    if (moduleName === \"ace/theme/textmate\" || moduleName === \"./theme/textmate\")\n        return cb(null, require(\"./theme/textmate\"));\n    if (customLoader)\n        return customLoader(moduleName, cb);\n    console.error(\"loader is not configured\");\n};\nvar customLoader;\nexports.setLoader = function (cb) {\n    customLoader = cb;\n};\nexports.dynamicModules = Object.create(null);\nexports.$loading = {};\nexports.$loaded = {};\nexports.loadModule = function (moduleId, onLoad) {\n    var loadedModule;\n    if (Array.isArray(moduleId)) {\n        var moduleType = moduleId[0];\n        var moduleName = moduleId[1];\n    }\n    else if (typeof moduleId == \"string\") {\n        var moduleName = moduleId;\n    }\n    var load = function (module) {\n        if (module && !exports.$loading[moduleName])\n            return onLoad && onLoad(module);\n        if (!exports.$loading[moduleName])\n            exports.$loading[moduleName] = [];\n        exports.$loading[moduleName].push(onLoad);\n        if (exports.$loading[moduleName].length > 1)\n            return;\n        var afterLoad = function () {\n            loader(moduleName, function (err, module) {\n                if (module)\n                    exports.$loaded[moduleName] = module;\n                exports._emit(\"load.module\", { name: moduleName, module: module });\n                var listeners = exports.$loading[moduleName];\n                exports.$loading[moduleName] = null;\n                listeners.forEach(function (onLoad) {\n                    onLoad && onLoad(module);\n                });\n            });\n        };\n        if (!exports.get(\"packaged\"))\n            return afterLoad();\n        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);\n        reportErrorIfPathIsNotConfigured();\n    };\n    if (exports.dynamicModules[moduleName]) {\n        exports.dynamicModules[moduleName]().then(function (module) {\n            if (module.default) {\n                load(module.default);\n            }\n            else {\n                load(module);\n            }\n        });\n    }\n    else {\n        try {\n            loadedModule = this.$require(moduleName);\n        }\n        catch (e) { }\n        load(loadedModule || exports.$loaded[moduleName]);\n    }\n};\nexports.$require = function (moduleName) {\n    if (typeof module[\"require\"] == \"function\") {\n        var req = \"require\";\n        return module[req](moduleName);\n    }\n};\nexports.setModuleLoader = function (moduleName, onLoad) {\n    exports.dynamicModules[moduleName] = onLoad;\n};\nvar reportErrorIfPathIsNotConfigured = function () {\n    if (!options.basePath && !options.workerPath\n        && !options.modePath && !options.themePath\n        && !Object.keys(options.$moduleUrls).length) {\n        console.error(\"Unable to infer path to ace from script src,\", \"use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes\", \"or with webpack use ace/webpack-resolver\");\n        reportErrorIfPathIsNotConfigured = function () { };\n    }\n};\nexports.version = \"1.35.4\";\n\n});\n\nace.define(\"ace/loader_build\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\nvar config = require(\"./config\");\nconfig.setLoader(function(moduleName, cb) {\n    require([moduleName], function(module) {\n        cb(null, module);\n    });\n});\n\nvar global = (function() {\n    return this || typeof window != \"undefined\" && window;\n})();\n\nmodule.exports = function(ace) {\n    config.init = init;\n    config.$require = require;\n    ace.require = require;\n\n    if (true)\n        ace.define = __webpack_require__.amdD;\n};\ninit(true);function init(packaged) {\n\n    if (!global || !global.document)\n        return;\n    \n    config.set(\"packaged\", packaged || require.packaged || module.packaged || (global.define && __webpack_require__.amdD.packaged));\n\n    var scriptOptions = {};\n    var scriptUrl = \"\";\n    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill\n    var currentDocument = currentScript && currentScript.ownerDocument || document;\n    \n    if (currentScript && currentScript.src) {\n        scriptUrl = currentScript.src.split(/[?#]/)[0].split(\"/\").slice(0, -1).join(\"/\") || \"\";\n    }\n    \n    var scripts = currentDocument.getElementsByTagName(\"script\");\n    for (var i=0; i<scripts.length; i++) {\n        var script = scripts[i];\n\n        var src = script.src || script.getAttribute(\"src\");\n        if (!src)\n            continue;\n\n        var attributes = script.attributes;\n        for (var j=0, l=attributes.length; j < l; j++) {\n            var attr = attributes[j];\n            if (attr.name.indexOf(\"data-ace-\") === 0) {\n                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, \"\"))] = attr.value;\n            }\n        }\n\n        var m = src.match(/^(.*)\\/ace([\\-.]\\w+)?\\.js(\\?|$)/);\n        if (m)\n            scriptUrl = m[1];\n    }\n\n    if (scriptUrl) {\n        scriptOptions.base = scriptOptions.base || scriptUrl;\n        scriptOptions.packaged = true;\n    }\n\n    scriptOptions.basePath = scriptOptions.base;\n    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;\n    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;\n    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;\n    delete scriptOptions.base;\n\n    for (var key in scriptOptions)\n        if (typeof scriptOptions[key] !== \"undefined\")\n            config.set(key, scriptOptions[key]);\n}\n\nfunction deHyphenate(str) {\n    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });\n}\n});\n\nace.define(\"ace/range\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar Range = /** @class */ (function () {\n    function Range(startRow, startColumn, endRow, endColumn) {\n        this.start = {\n            row: startRow,\n            column: startColumn\n        };\n        this.end = {\n            row: endRow,\n            column: endColumn\n        };\n    }\n    Range.prototype.isEqual = function (range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n    Range.prototype.toString = function () {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n    Range.prototype.contains = function (row, column) {\n        return this.compare(row, column) == 0;\n    };\n    Range.prototype.compareRange = function (range) {\n        var cmp, end = range.end, start = range.start;\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            }\n            else if (cmp == 0) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (cmp == -1) {\n            return -2;\n        }\n        else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            }\n            else if (cmp == 1) {\n                return 42;\n            }\n            else {\n                return 0;\n            }\n        }\n    };\n    Range.prototype.comparePoint = function (p) {\n        return this.compare(p.row, p.column);\n    };\n    Range.prototype.containsRange = function (range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    Range.prototype.intersects = function (range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n    Range.prototype.isEnd = function (row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n    Range.prototype.isStart = function (row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n    Range.prototype.setStart = function (row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        }\n        else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n    Range.prototype.setEnd = function (row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        }\n        else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n    Range.prototype.inside = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Range.prototype.insideStart = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Range.prototype.insideEnd = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Range.prototype.compare = function (row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n        if (row < this.start.row)\n            return -1;\n        if (row > this.end.row)\n            return 1;\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n        return 0;\n    };\n    Range.prototype.compareStart = function (row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    Range.prototype.compareEnd = function (row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    Range.prototype.compareInside = function (row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        }\n        else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    Range.prototype.clipRows = function (firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = { row: lastRow + 1, column: 0 };\n        else if (this.end.row < firstRow)\n            var end = { row: firstRow, column: 0 };\n        if (this.start.row > lastRow)\n            var start = { row: lastRow + 1, column: 0 };\n        else if (this.start.row < firstRow)\n            var start = { row: firstRow, column: 0 };\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    Range.prototype.extend = function (row, column) {\n        var cmp = this.compare(row, column);\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = { row: row, column: column };\n        else\n            var end = { row: row, column: column };\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    Range.prototype.isEmpty = function () {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n    Range.prototype.isMultiLine = function () {\n        return (this.start.row !== this.end.row);\n    };\n    Range.prototype.clone = function () {\n        return Range.fromPoints(this.start, this.end);\n    };\n    Range.prototype.collapseRows = function () {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    Range.prototype.toScreenRange = function (session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    Range.prototype.moveBy = function (row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n    return Range;\n}());\nRange.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nexports.Range = Range;\n\n});\n\nace.define(\"ace/lib/keys\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./oop\");\nvar Keys = {\n    MODIFIER_KEYS: {\n        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',\n        91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'\n    },\n    KEY_MODS: {\n        \"ctrl\": 1, \"alt\": 2, \"option\": 2, \"shift\": 4,\n        \"super\": 8, \"meta\": 8, \"command\": 8, \"cmd\": 8,\n        \"control\": 1\n    },\n    FUNCTION_KEYS: {\n        8: \"Backspace\",\n        9: \"Tab\",\n        13: \"Return\",\n        19: \"Pause\",\n        27: \"Esc\",\n        32: \"Space\",\n        33: \"PageUp\",\n        34: \"PageDown\",\n        35: \"End\",\n        36: \"Home\",\n        37: \"Left\",\n        38: \"Up\",\n        39: \"Right\",\n        40: \"Down\",\n        44: \"Print\",\n        45: \"Insert\",\n        46: \"Delete\",\n        '-13': \"NumpadEnter\",\n        144: \"Numlock\",\n        145: \"Scrolllock\"\n    },\n    PRINTABLE_KEYS: {\n        32: ' ', 59: ';', 61: '=', 107: '+', 109: '-', 110: '.',\n        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',\n        219: '[', 220: '\\\\', 221: ']', 222: \"'\", 111: '/', 106: '*'\n    }\n};\nvar codeToKeyCode = {\n    Command: 224,\n    Backspace: 8,\n    Tab: 9,\n    Return: 13,\n    Enter: 13,\n    Pause: 19,\n    Escape: 27,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Insert: 45,\n    Delete: 46,\n    ArrowLeft: 37,\n    ArrowUp: 38,\n    ArrowRight: 39,\n    ArrowDown: 40,\n    Backquote: 192,\n    Minus: 189,\n    Equal: 187,\n    BracketLeft: 219,\n    Backslash: 220,\n    BracketRight: 221,\n    Semicolon: 186,\n    Quote: 222,\n    Comma: 188,\n    Period: 190,\n    Slash: 191,\n    Space: 32,\n    NumpadAdd: 107,\n    NumpadDecimal: 110,\n    NumpadSubtract: 109,\n    NumpadDivide: 111,\n    NumpadMultiply: 106\n};\nfor (var i = 0; i < 10; i++) {\n    codeToKeyCode[\"Digit\" + i] = 48 + i;\n    codeToKeyCode[\"Numpad\" + i] = 96 + i;\n    Keys.PRINTABLE_KEYS[48 + i] = \"\" + i;\n    Keys.FUNCTION_KEYS[96 + i] = \"Numpad\" + i;\n}\nfor (var i = 65; i < 91; i++) {\n    var chr = String.fromCharCode(i + 32);\n    codeToKeyCode[\"Key\" + chr.toUpperCase()] = i;\n    Keys.PRINTABLE_KEYS[i] = chr;\n}\nfor (var i = 1; i < 13; i++) {\n    codeToKeyCode[\"F\" + i] = 111 + i;\n    Keys.FUNCTION_KEYS[111 + i] = \"F\" + i;\n}\nvar modifiers = {\n    Shift: 16,\n    Control: 17,\n    Alt: 18,\n    Meta: 224\n};\nfor (var mod in modifiers) {\n    codeToKeyCode[mod] = codeToKeyCode[mod + \"Left\"]\n        = codeToKeyCode[mod + \"Right\"] = modifiers[mod];\n}\nexports.$codeToKeyCode = codeToKeyCode;\nKeys.PRINTABLE_KEYS[173] = '-';\nfor (var j in Keys.FUNCTION_KEYS) {\n    var name = Keys.FUNCTION_KEYS[j].toLowerCase();\n    Keys[name] = parseInt(j, 10);\n}\nfor (var j in Keys.PRINTABLE_KEYS) {\n    var name = Keys.PRINTABLE_KEYS[j].toLowerCase();\n    Keys[name] = parseInt(j, 10);\n}\noop.mixin(Keys, Keys.MODIFIER_KEYS);\noop.mixin(Keys, Keys.PRINTABLE_KEYS);\noop.mixin(Keys, Keys.FUNCTION_KEYS);\nKeys.enter = Keys[\"return\"];\nKeys.escape = Keys.esc;\nKeys.del = Keys[\"delete\"];\n(function () {\n    var mods = [\"cmd\", \"ctrl\", \"alt\", \"shift\"];\n    for (var i = Math.pow(2, mods.length); i--;) {\n        Keys.KEY_MODS[i] = mods.filter(function (x) {\n            return i & Keys.KEY_MODS[x];\n        }).join(\"-\") + \"-\";\n    }\n})();\nKeys.KEY_MODS[0] = \"\";\nKeys.KEY_MODS[-1] = \"input-\";\noop.mixin(exports, Keys);\nexports.default = exports;\nexports.keyCodeToString = function (keyCode) {\n    var keyString = Keys[keyCode];\n    if (typeof keyString != \"string\")\n        keyString = String.fromCharCode(keyCode);\n    return keyString.toLowerCase();\n};\n\n});\n\nace.define(\"ace/lib/event\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\"; var keys = require(\"./keys\");\nvar useragent = require(\"./useragent\");\nvar pressedKeys = null;\nvar ts = 0;\nvar activeListenerOptions;\nfunction detectListenerOptionsSupport() {\n    activeListenerOptions = false;\n    try {\n        document.createComment(\"\").addEventListener(\"test\", function () { }, {\n            get passive() {\n                activeListenerOptions = { passive: false };\n                return true;\n            }\n        });\n    }\n    catch (e) { }\n}\nfunction getListenerOptions() {\n    if (activeListenerOptions == undefined)\n        detectListenerOptionsSupport();\n    return activeListenerOptions;\n}\nfunction EventListener(elem, type, callback) {\n    this.elem = elem;\n    this.type = type;\n    this.callback = callback;\n}\nEventListener.prototype.destroy = function () {\n    removeListener(this.elem, this.type, this.callback);\n    this.elem = this.type = this.callback = undefined;\n};\nvar addListener = exports.addListener = function (elem, type, callback, /**@type{any?}*/ destroyer) {\n    elem.addEventListener(type, callback, getListenerOptions());\n    if (destroyer)\n        destroyer.$toDestroy.push(new EventListener(elem, type, callback));\n};\nvar removeListener = exports.removeListener = function (elem, type, callback) {\n    elem.removeEventListener(type, callback, getListenerOptions());\n};\nexports.stopEvent = function (e) {\n    exports.stopPropagation(e);\n    exports.preventDefault(e);\n    return false;\n};\nexports.stopPropagation = function (e) {\n    if (e.stopPropagation)\n        e.stopPropagation();\n};\nexports.preventDefault = function (e) {\n    if (e.preventDefault)\n        e.preventDefault();\n};\nexports.getButton = function (e) {\n    if (e.type == \"dblclick\")\n        return 0;\n    if (e.type == \"contextmenu\" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))\n        return 2;\n    return e.button;\n};\nexports.capture = function (el, eventHandler, releaseCaptureHandler) {\n    var ownerDocument = el && el.ownerDocument || document;\n    function onMouseUp(e) {\n        eventHandler && eventHandler(e);\n        releaseCaptureHandler && releaseCaptureHandler(e);\n        removeListener(ownerDocument, \"mousemove\", eventHandler);\n        removeListener(ownerDocument, \"mouseup\", onMouseUp);\n        removeListener(ownerDocument, \"dragstart\", onMouseUp);\n    }\n    addListener(ownerDocument, \"mousemove\", eventHandler);\n    addListener(ownerDocument, \"mouseup\", onMouseUp);\n    addListener(ownerDocument, \"dragstart\", onMouseUp);\n    return onMouseUp;\n};\nexports.addMouseWheelListener = function (el, callback, destroyer) {\n    addListener(el, \"wheel\", function (e) {\n        var factor = 0.15;\n        var deltaX = e.deltaX || 0;\n        var deltaY = e.deltaY || 0;\n        switch (e.deltaMode) {\n            case e.DOM_DELTA_PIXEL:\n                e.wheelX = deltaX * factor;\n                e.wheelY = deltaY * factor;\n                break;\n            case e.DOM_DELTA_LINE:\n                var linePixels = 15;\n                e.wheelX = deltaX * linePixels;\n                e.wheelY = deltaY * linePixels;\n                break;\n            case e.DOM_DELTA_PAGE:\n                var pagePixels = 150;\n                e.wheelX = deltaX * pagePixels;\n                e.wheelY = deltaY * pagePixels;\n                break;\n        }\n        callback(e);\n    }, destroyer);\n};\nexports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName, destroyer) {\n    var clicks = 0;\n    var startX, startY, timer;\n    var eventNames = {\n        2: \"dblclick\",\n        3: \"tripleclick\",\n        4: \"quadclick\"\n    };\n    function onMousedown(e) {\n        if (exports.getButton(e) !== 0) {\n            clicks = 0;\n        }\n        else if (e.detail > 1) {\n            clicks++;\n            if (clicks > 4)\n                clicks = 1;\n        }\n        else {\n            clicks = 1;\n        }\n        if (useragent.isIE) {\n            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;\n            if (!timer || isNewClick)\n                clicks = 1;\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);\n            if (clicks == 1) {\n                startX = e.clientX;\n                startY = e.clientY;\n            }\n        }\n        e._clicks = clicks;\n        eventHandler[callbackName](\"mousedown\", e);\n        if (clicks > 4)\n            clicks = 0;\n        else if (clicks > 1)\n            return eventHandler[callbackName](eventNames[clicks], e);\n    }\n    if (!Array.isArray(elements))\n        elements = [elements];\n    elements.forEach(function (el) {\n        addListener(el, \"mousedown\", onMousedown, destroyer);\n    });\n};\nfunction getModifierHash(e) {\n    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n}\nexports.getModifierString = function (e) {\n    return keys.KEY_MODS[getModifierHash(e)];\n};\nfunction normalizeCommandKeys(callback, e, keyCode) {\n    var hashId = getModifierHash(e);\n    if (!keyCode && e.code) {\n        keyCode = keys.$codeToKeyCode[e.code] || keyCode;\n    }\n    if (!useragent.isMac && pressedKeys) {\n        if (e.getModifierState && (e.getModifierState(\"OS\") || e.getModifierState(\"Win\")))\n            hashId |= 8;\n        if (pressedKeys.altGr) {\n            if ((3 & hashId) != 3)\n                pressedKeys.altGr = 0;\n            else\n                return;\n        }\n        if (keyCode === 18 || keyCode === 17) {\n            var location = e.location;\n            if (keyCode === 17 && location === 1) {\n                if (pressedKeys[keyCode] == 1)\n                    ts = e.timeStamp;\n            }\n            else if (keyCode === 18 && hashId === 3 && location === 2) {\n                var dt = e.timeStamp - ts;\n                if (dt < 50)\n                    pressedKeys.altGr = true;\n            }\n        }\n    }\n    if (keyCode in keys.MODIFIER_KEYS) {\n        keyCode = -1;\n    }\n    if (!hashId && keyCode === 13) {\n        if (e.location === 3) {\n            callback(e, hashId, -keyCode);\n            if (e.defaultPrevented)\n                return;\n        }\n    }\n    if (useragent.isChromeOS && hashId & 8) {\n        callback(e, hashId, keyCode);\n        if (e.defaultPrevented)\n            return;\n        else\n            hashId &= ~8;\n    }\n    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {\n        return false;\n    }\n    return callback(e, hashId, keyCode);\n}\nexports.addCommandKeyListener = function (el, callback, destroyer) {\n    var lastDefaultPrevented = null;\n    addListener(el, \"keydown\", function (e) {\n        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;\n        var result = normalizeCommandKeys(callback, e, e.keyCode);\n        lastDefaultPrevented = e.defaultPrevented;\n        return result;\n    }, destroyer);\n    addListener(el, \"keypress\", function (e) {\n        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {\n            exports.stopEvent(e);\n            lastDefaultPrevented = null;\n        }\n    }, destroyer);\n    addListener(el, \"keyup\", function (e) {\n        pressedKeys[e.keyCode] = null;\n    }, destroyer);\n    if (!pressedKeys) {\n        resetPressedKeys();\n        addListener(window, \"focus\", resetPressedKeys);\n    }\n};\nfunction resetPressedKeys() {\n    pressedKeys = Object.create(null);\n}\nif (typeof window == \"object\" && window.postMessage && !useragent.isOldIE) {\n    var postMessageId = 1;\n    exports.nextTick = function (callback, win) {\n        win = win || window;\n        var messageName = \"zero-timeout-message-\" + (postMessageId++);\n        var listener = function (e) {\n            if (e.data == messageName) {\n                exports.stopPropagation(e);\n                removeListener(win, \"message\", listener);\n                callback();\n            }\n        };\n        addListener(win, \"message\", listener);\n        win.postMessage(messageName, \"*\");\n    };\n}\nexports.$idleBlocked = false;\nexports.onIdle = function (cb, timeout) {\n    return setTimeout(function handler() {\n        if (!exports.$idleBlocked) {\n            cb();\n        }\n        else {\n            setTimeout(handler, 100);\n        }\n    }, timeout);\n};\nexports.$idleBlockId = null;\nexports.blockIdle = function (delay) {\n    if (exports.$idleBlockId)\n        clearTimeout(exports.$idleBlockId);\n    exports.$idleBlocked = true;\n    exports.$idleBlockId = setTimeout(function () {\n        exports.$idleBlocked = false;\n    }, delay || 100);\n};\nexports.nextFrame = typeof window == \"object\" && (window.requestAnimationFrame\n    || window[\"mozRequestAnimationFrame\"]\n    || window[\"webkitRequestAnimationFrame\"]\n    || window[\"msRequestAnimationFrame\"]\n    || window[\"oRequestAnimationFrame\"]);\nif (exports.nextFrame)\n    exports.nextFrame = exports.nextFrame.bind(window);\nelse\n    exports.nextFrame = function (callback) {\n        setTimeout(callback, 17);\n    };\n\n});\n\nace.define(\"ace/clipboard\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar $cancelT;\nmodule.exports = {\n    lineMode: false,\n    pasteCancelled: function () {\n        if ($cancelT && $cancelT > Date.now() - 50)\n            return true;\n        return $cancelT = false;\n    },\n    cancel: function () {\n        $cancelT = Date.now();\n    }\n};\n\n});\n\nace.define(\"ace/keyboard/textinput\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/config\",\"ace/lib/useragent\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/clipboard\",\"ace/lib/keys\"], function(require, exports, module){\"use strict\";\nvar event = require(\"../lib/event\");\nvar nls = require(\"../config\").nls;\nvar useragent = require(\"../lib/useragent\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar clipboard = require(\"../clipboard\");\nvar BROKEN_SETDATA = useragent.isChrome < 18;\nvar USE_IE_MIME_TYPE = useragent.isIE;\nvar HAS_FOCUS_ARGS = useragent.isChrome > 63;\nvar MAX_LINE_LENGTH = 400;\nvar KEYS = require(\"../lib/keys\");\nvar MODS = KEYS.KEY_MODS;\nvar isIOS = useragent.isIOS;\nvar valueResetRegex = isIOS ? /\\s/ : /\\n/;\nvar isMobile = useragent.isMobile;\nvar TextInput;\nTextInput = function (parentNode, host) {\n    var text = dom.createElement(\"textarea\");\n    text.className = \"ace_text-input\";\n    text.setAttribute(\"wrap\", \"off\");\n    text.setAttribute(\"autocorrect\", \"off\");\n    text.setAttribute(\"autocapitalize\", \"off\");\n    text.setAttribute(\"spellcheck\", \"false\");\n    text.style.opacity = \"0\";\n    parentNode.insertBefore(text, parentNode.firstChild);\n    var copied = false;\n    var pasted = false;\n    var inComposition = false;\n    var sendingText = false;\n    var tempStyle = '';\n    if (!isMobile)\n        text.style.fontSize = \"1px\";\n    var commandMode = false;\n    var ignoreFocusEvents = false;\n    var lastValue = \"\";\n    var lastSelectionStart = 0;\n    var lastSelectionEnd = 0;\n    var lastRestoreEnd = 0;\n    var rowStart = Number.MAX_SAFE_INTEGER;\n    var rowEnd = Number.MIN_SAFE_INTEGER;\n    var numberOfExtraLines = 0;\n    try {\n        var isFocused = document.activeElement === text;\n    }\n    catch (e) { }\n    this.setNumberOfExtraLines = function (number) {\n        rowStart = Number.MAX_SAFE_INTEGER;\n        rowEnd = Number.MIN_SAFE_INTEGER;\n        if (number < 0) {\n            numberOfExtraLines = 0;\n            return;\n        }\n        numberOfExtraLines = number;\n    };\n    this.setAriaOptions = function (options) {\n        if (options.activeDescendant) {\n            text.setAttribute(\"aria-haspopup\", \"true\");\n            text.setAttribute(\"aria-autocomplete\", options.inline ? \"both\" : \"list\");\n            text.setAttribute(\"aria-activedescendant\", options.activeDescendant);\n        }\n        else {\n            text.setAttribute(\"aria-haspopup\", \"false\");\n            text.setAttribute(\"aria-autocomplete\", \"both\");\n            text.removeAttribute(\"aria-activedescendant\");\n        }\n        if (options.role) {\n            text.setAttribute(\"role\", options.role);\n        }\n        if (options.setLabel) {\n            text.setAttribute(\"aria-roledescription\", nls(\"text-input.aria-roledescription\", \"editor\"));\n            var arialLabel = \"\";\n            if (host.$textInputAriaLabel) {\n                arialLabel += \"\".concat(host.$textInputAriaLabel, \", \");\n            }\n            if (host.session) {\n                var row = host.session.selection.cursor.row;\n                arialLabel += nls(\"text-input.aria-label\", \"Cursor at row $0\", [row + 1]);\n            }\n            text.setAttribute(\"aria-label\", arialLabel);\n        }\n    };\n    this.setAriaOptions({ role: \"textbox\" });\n    event.addListener(text, \"blur\", function (e) {\n        if (ignoreFocusEvents)\n            return;\n        host.onBlur(e);\n        isFocused = false;\n    }, host);\n    event.addListener(text, \"focus\", function (e) {\n        if (ignoreFocusEvents)\n            return;\n        isFocused = true;\n        if (useragent.isEdge) {\n            try {\n                if (!document.hasFocus())\n                    return;\n            }\n            catch (e) { }\n        }\n        host.onFocus(e);\n        if (useragent.isEdge)\n            setTimeout(resetSelection);\n        else\n            resetSelection();\n    }, host);\n    this.$focusScroll = false;\n    this.focus = function () {\n        this.setAriaOptions({\n            setLabel: host.renderer.enableKeyboardAccessibility\n        });\n        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == \"browser\")\n            return text.focus({ preventScroll: true });\n        var top = text.style.top;\n        text.style.position = \"fixed\";\n        text.style.top = \"0px\";\n        try {\n            var isTransformed = text.getBoundingClientRect().top != 0;\n        }\n        catch (e) {\n            return;\n        }\n        var ancestors = [];\n        if (isTransformed) {\n            var t = text.parentElement;\n            while (t && t.nodeType == 1) {\n                ancestors.push(t);\n                t.setAttribute(\"ace_nocontext\", \"true\");\n                if (!t.parentElement && t.getRootNode)\n                    t = t.getRootNode()[\"host\"];\n                else\n                    t = t.parentElement;\n            }\n        }\n        text.focus({ preventScroll: true });\n        if (isTransformed) {\n            ancestors.forEach(function (p) {\n                p.removeAttribute(\"ace_nocontext\");\n            });\n        }\n        setTimeout(function () {\n            text.style.position = \"\";\n            if (text.style.top == \"0px\")\n                text.style.top = top;\n        }, 0);\n    };\n    this.blur = function () {\n        text.blur();\n    };\n    this.isFocused = function () {\n        return isFocused;\n    };\n    host.on(\"beforeEndOperation\", function () {\n        var curOp = host.curOp;\n        var commandName = curOp && curOp.command && curOp.command.name;\n        if (commandName == \"insertstring\")\n            return;\n        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);\n        if (inComposition && isUserAction) {\n            lastValue = text.value = \"\";\n            onCompositionEnd();\n        }\n        resetSelection();\n    });\n    var positionToSelection = function (row, column) {\n        var selection = column;\n        for (var i = 1; i <= row - rowStart && i < 2 * numberOfExtraLines + 1; i++) {\n            selection += host.session.getLine(row - i).length + 1;\n        }\n        return selection;\n    };\n    var resetSelection = isIOS\n        ? function (value) {\n            if (!isFocused || (copied && !value) || sendingText)\n                return;\n            if (!value)\n                value = \"\";\n            var newValue = \"\\n ab\" + value + \"cde fg\\n\";\n            if (newValue != text.value)\n                text.value = lastValue = newValue;\n            var selectionStart = 4;\n            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));\n            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {\n                text.setSelectionRange(selectionStart, selectionEnd);\n            }\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n        }\n        : function () {\n            if (inComposition || sendingText)\n                return;\n            if (!isFocused && !afterContextMenu)\n                return;\n            inComposition = true;\n            var selectionStart = 0;\n            var selectionEnd = 0;\n            var line = \"\";\n            if (host.session) {\n                var selection = host.selection;\n                var range = selection.getRange();\n                var row = selection.cursor.row;\n                if (row === rowEnd + 1) {\n                    rowStart = rowEnd + 1;\n                    rowEnd = rowStart + 2 * numberOfExtraLines;\n                }\n                else if (row === rowStart - 1) {\n                    rowEnd = rowStart - 1;\n                    rowStart = rowEnd - 2 * numberOfExtraLines;\n                }\n                else if (row < rowStart - 1 || row > rowEnd + 1) {\n                    rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;\n                    rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2 * numberOfExtraLines;\n                }\n                var lines = [];\n                for (var i = rowStart; i <= rowEnd; i++) {\n                    lines.push(host.session.getLine(i));\n                }\n                line = lines.join('\\n');\n                selectionStart = positionToSelection(range.start.row, range.start.column);\n                selectionEnd = positionToSelection(range.end.row, range.end.column);\n                if (range.start.row < rowStart) {\n                    var prevLine = host.session.getLine(rowStart - 1);\n                    selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;\n                    selectionEnd += prevLine.length + 1;\n                    line = prevLine + \"\\n\" + line;\n                }\n                else if (range.end.row > rowEnd) {\n                    var nextLine = host.session.getLine(rowEnd + 1);\n                    selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;\n                    selectionEnd += line.length + 1;\n                    line = line + \"\\n\" + nextLine;\n                }\n                else if (isMobile && row > 0) {\n                    line = \"\\n\" + line;\n                    selectionEnd += 1;\n                    selectionStart += 1;\n                }\n                if (line.length > MAX_LINE_LENGTH) {\n                    if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {\n                        line = line.slice(0, MAX_LINE_LENGTH);\n                    }\n                    else {\n                        line = \"\\n\";\n                        if (selectionStart == selectionEnd) {\n                            selectionStart = selectionEnd = 0;\n                        }\n                        else {\n                            selectionStart = 0;\n                            selectionEnd = 1;\n                        }\n                    }\n                }\n                var newValue = line + \"\\n\\n\";\n                if (newValue != lastValue) {\n                    text.value = lastValue = newValue;\n                    lastSelectionStart = lastSelectionEnd = newValue.length;\n                }\n            }\n            if (afterContextMenu) {\n                lastSelectionStart = text.selectionStart;\n                lastSelectionEnd = text.selectionEnd;\n            }\n            if (lastSelectionEnd != selectionEnd\n                || lastSelectionStart != selectionStart\n                || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization\n            ) {\n                try {\n                    text.setSelectionRange(selectionStart, selectionEnd);\n                    lastSelectionStart = selectionStart;\n                    lastSelectionEnd = selectionEnd;\n                }\n                catch (e) { }\n            }\n            inComposition = false;\n        };\n    this.resetSelection = resetSelection;\n    if (isFocused)\n        host.onFocus();\n    var isAllSelected = function (text) {\n        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length\n            && text.value === lastValue && lastValue\n            && text.selectionEnd !== lastSelectionEnd;\n    };\n    var onSelect = function (e) {\n        if (inComposition)\n            return;\n        if (copied) {\n            copied = false;\n        }\n        else if (isAllSelected(text)) {\n            host.selectAll();\n            resetSelection();\n        }\n        else if (isMobile && text.selectionStart != lastSelectionStart) {\n            resetSelection();\n        }\n    };\n    var inputHandler = null;\n    this.setInputHandler = function (cb) { inputHandler = cb; };\n    this.getInputHandler = function () { return inputHandler; };\n    var afterContextMenu = false;\n    var sendText = function (value, fromInput) {\n        if (afterContextMenu)\n            afterContextMenu = false;\n        if (pasted) {\n            resetSelection();\n            if (value)\n                host.onPaste(value);\n            pasted = false;\n            return \"\";\n        }\n        else {\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            var extendLeft = lastSelectionStart;\n            var extendRight = lastValue.length - lastSelectionEnd;\n            var inserted = value;\n            var restoreStart = value.length - selectionStart;\n            var restoreEnd = value.length - selectionEnd;\n            var i = 0;\n            while (extendLeft > 0 && lastValue[i] == value[i]) {\n                i++;\n                extendLeft--;\n            }\n            inserted = inserted.slice(i);\n            i = 1;\n            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {\n                i++;\n                extendRight--;\n            }\n            restoreStart -= i - 1;\n            restoreEnd -= i - 1;\n            var endIndex = inserted.length - i + 1;\n            if (endIndex < 0) {\n                extendLeft = -endIndex;\n                endIndex = 0;\n            }\n            inserted = inserted.slice(0, endIndex);\n            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)\n                return \"\";\n            sendingText = true;\n            var shouldReset = false;\n            if (useragent.isAndroid && inserted == \". \") {\n                inserted = \"  \";\n                shouldReset = true;\n            }\n            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {\n                host.onTextInput(inserted);\n            }\n            else {\n                host.onTextInput(inserted, {\n                    extendLeft: extendLeft,\n                    extendRight: extendRight,\n                    restoreStart: restoreStart,\n                    restoreEnd: restoreEnd\n                });\n            }\n            sendingText = false;\n            lastValue = value;\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n            lastRestoreEnd = restoreEnd;\n            return shouldReset ? \"\\n\" : inserted;\n        }\n    };\n    var onInput = function (e) {\n        if (inComposition)\n            return onCompositionUpdate();\n        if (e && e.inputType) {\n            if (e.inputType == \"historyUndo\")\n                return host.execCommand(\"undo\");\n            if (e.inputType == \"historyRedo\")\n                return host.execCommand(\"redo\");\n        }\n        var data = text.value;\n        var inserted = sendText(data, true);\n        if (data.length > MAX_LINE_LENGTH + 100\n            || valueResetRegex.test(inserted)\n            || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {\n            resetSelection();\n        }\n    };\n    var handleClipboardData = function (e, data, forceIEMime) {\n        var clipboardData = e.clipboardData || window[\"clipboardData\"];\n        if (!clipboardData || BROKEN_SETDATA)\n            return;\n        var mime = USE_IE_MIME_TYPE || forceIEMime ? \"Text\" : \"text/plain\";\n        try {\n            if (data) {\n                return clipboardData.setData(mime, data) !== false;\n            }\n            else {\n                return clipboardData.getData(mime);\n            }\n        }\n        catch (e) {\n            if (!forceIEMime)\n                return handleClipboardData(e, data, true);\n        }\n    };\n    var doCopy = function (e, isCut) {\n        var data = host.getCopyText();\n        if (!data)\n            return event.preventDefault(e);\n        if (handleClipboardData(e, data)) {\n            if (isIOS) {\n                resetSelection(data);\n                copied = data;\n                setTimeout(function () {\n                    copied = false;\n                }, 10);\n            }\n            isCut ? host.onCut() : host.onCopy();\n            event.preventDefault(e);\n        }\n        else {\n            copied = true;\n            text.value = data;\n            text.select();\n            setTimeout(function () {\n                copied = false;\n                resetSelection();\n                isCut ? host.onCut() : host.onCopy();\n            });\n        }\n    };\n    var onCut = function (e) {\n        doCopy(e, true);\n    };\n    var onCopy = function (e) {\n        doCopy(e, false);\n    };\n    var onPaste = function (e) {\n        var data = handleClipboardData(e);\n        if (clipboard.pasteCancelled())\n            return;\n        if (typeof data == \"string\") {\n            if (data)\n                host.onPaste(data, e);\n            if (useragent.isIE)\n                setTimeout(resetSelection);\n            event.preventDefault(e);\n        }\n        else {\n            text.value = \"\";\n            pasted = true;\n        }\n    };\n    event.addCommandKeyListener(text, function (e, hashId, keyCode) {\n        if (inComposition)\n            return;\n        return host.onCommandKey(e, hashId, keyCode);\n    }, host);\n    event.addListener(text, \"select\", onSelect, host);\n    event.addListener(text, \"input\", onInput, host);\n    event.addListener(text, \"cut\", onCut, host);\n    event.addListener(text, \"copy\", onCopy, host);\n    event.addListener(text, \"paste\", onPaste, host);\n    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {\n        event.addListener(parentNode, \"keydown\", function (e) {\n            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)\n                return;\n            switch (e.keyCode) {\n                case 67:\n                    onCopy(e);\n                    break;\n                case 86:\n                    onPaste(e);\n                    break;\n                case 88:\n                    onCut(e);\n                    break;\n            }\n        }, host);\n    }\n    var onCompositionStart = function (e) {\n        if (inComposition || !host.onCompositionStart || host.$readOnly)\n            return;\n        inComposition = {};\n        if (commandMode)\n            return;\n        if (e.data)\n            inComposition.useTextareaForIME = false;\n        setTimeout(onCompositionUpdate, 0);\n        host._signal(\"compositionStart\");\n        host.on(\"mousedown\", cancelComposition);\n        var range = host.getSelectionRange();\n        range.end.row = range.start.row;\n        range.end.column = range.start.column;\n        inComposition.markerRange = range;\n        inComposition.selectionStart = lastSelectionStart;\n        host.onCompositionStart(inComposition);\n        if (inComposition.useTextareaForIME) {\n            lastValue = text.value = \"\";\n            lastSelectionStart = 0;\n            lastSelectionEnd = 0;\n        }\n        else {\n            if (text.msGetInputContext)\n                inComposition.context = text.msGetInputContext();\n            if (text.getInputContext)\n                inComposition.context = text.getInputContext();\n        }\n    };\n    var onCompositionUpdate = function () {\n        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)\n            return;\n        if (commandMode)\n            return cancelComposition();\n        if (inComposition.useTextareaForIME) {\n            host.onCompositionUpdate(text.value);\n        }\n        else {\n            var data = text.value;\n            sendText(data);\n            if (inComposition.markerRange) {\n                if (inComposition.context) {\n                    inComposition.markerRange.start.column = inComposition.selectionStart\n                        = inComposition.context.compositionStartOffset;\n                }\n                inComposition.markerRange.end.column = inComposition.markerRange.start.column\n                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;\n            }\n        }\n    };\n    var onCompositionEnd = function (e) {\n        if (!host.onCompositionEnd || host.$readOnly)\n            return;\n        inComposition = false;\n        host.onCompositionEnd();\n        host.off(\"mousedown\", cancelComposition);\n        if (e)\n            onInput();\n    };\n    function cancelComposition() {\n        ignoreFocusEvents = true;\n        text.blur();\n        text.focus();\n        ignoreFocusEvents = false;\n    }\n    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);\n    function onKeyup(e) {\n        if (e.keyCode == 27 && text.value.length < text.selectionStart) {\n            if (!inComposition)\n                lastValue = text.value;\n            lastSelectionStart = lastSelectionEnd = -1;\n            resetSelection();\n        }\n        syncComposition();\n    }\n    event.addListener(text, \"compositionstart\", onCompositionStart, host);\n    event.addListener(text, \"compositionupdate\", onCompositionUpdate, host);\n    event.addListener(text, \"keyup\", onKeyup, host);\n    event.addListener(text, \"keydown\", syncComposition, host);\n    event.addListener(text, \"compositionend\", onCompositionEnd, host);\n    this.getElement = function () {\n        return text;\n    };\n    this.setCommandMode = function (value) {\n        commandMode = value;\n        text.readOnly = false;\n    };\n    this.setReadOnly = function (readOnly) {\n        if (!commandMode)\n            text.readOnly = readOnly;\n    };\n    this.setCopyWithEmptySelection = function (value) {\n    };\n    this.onContextMenu = function (e) {\n        afterContextMenu = true;\n        resetSelection();\n        host._emit(\"nativecontextmenu\", { target: host, domEvent: e });\n        this.moveToMouse(e, true);\n    };\n    this.moveToMouse = function (e, bringToFront) {\n        if (!tempStyle)\n            tempStyle = text.style.cssText;\n        text.style.cssText = (bringToFront ? \"z-index:100000;\" : \"\")\n            + (useragent.isIE ? \"opacity:0.1;\" : \"\")\n            + \"text-indent: -\" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + \"px;\";\n        var rect = host.container.getBoundingClientRect();\n        var style = dom.computedStyle(host.container);\n        var top = rect.top + (parseInt(style.borderTopWidth) || 0);\n        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);\n        var maxTop = rect.bottom - top - text.clientHeight - 2;\n        var move = function (e) {\n            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));\n        };\n        move(e);\n        if (e.type != \"mousedown\")\n            return;\n        host.renderer.$isMousePressed = true;\n        clearTimeout(closeTimeout);\n        if (useragent.isWin)\n            event.capture(host.container, move, onContextMenuClose);\n    };\n    this.onContextMenuClose = onContextMenuClose;\n    var closeTimeout;\n    function onContextMenuClose() {\n        clearTimeout(closeTimeout);\n        closeTimeout = setTimeout(function () {\n            if (tempStyle) {\n                text.style.cssText = tempStyle;\n                tempStyle = '';\n            }\n            host.renderer.$isMousePressed = false;\n            if (host.renderer.$keepTextAreaAtCursor)\n                host.renderer.$moveTextAreaToCursor();\n        }, 0);\n    }\n    var onContextMenu = function (e) {\n        host.textInput.onContextMenu(e);\n        onContextMenuClose();\n    };\n    event.addListener(text, \"mouseup\", onContextMenu, host);\n    event.addListener(text, \"mousedown\", function (e) {\n        e.preventDefault();\n        onContextMenuClose();\n    }, host);\n    event.addListener(host.renderer.scroller, \"contextmenu\", onContextMenu, host);\n    event.addListener(text, \"contextmenu\", onContextMenu, host);\n    if (isIOS)\n        addIosSelectionHandler(parentNode, host, text);\n    function addIosSelectionHandler(parentNode, host, text) {\n        var typingResetTimeout = null;\n        var typing = false;\n        text.addEventListener(\"keydown\", function (e) {\n            if (typingResetTimeout)\n                clearTimeout(typingResetTimeout);\n            typing = true;\n        }, true);\n        text.addEventListener(\"keyup\", function (e) {\n            typingResetTimeout = setTimeout(function () {\n                typing = false;\n            }, 100);\n        }, true);\n        var detectArrowKeys = function (e) {\n            if (document.activeElement !== text)\n                return;\n            if (typing || inComposition || host.$mouseHandler.isMousePressed)\n                return;\n            if (copied) {\n                return;\n            }\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            var key = null;\n            var modifier = 0;\n            if (selectionStart == 0) {\n                key = KEYS.up;\n            }\n            else if (selectionStart == 1) {\n                key = KEYS.home;\n            }\n            else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == \"\\n\") {\n                key = KEYS.end;\n            }\n            else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == \" \") {\n                key = KEYS.left;\n                modifier = MODS.option;\n            }\n            else if (selectionStart < lastSelectionStart\n                || (selectionStart == lastSelectionStart\n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd)) {\n                key = KEYS.left;\n            }\n            else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split(\"\\n\").length > 2) {\n                key = KEYS.down;\n            }\n            else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == \" \") {\n                key = KEYS.right;\n                modifier = MODS.option;\n            }\n            else if (selectionEnd > lastSelectionEnd\n                || (selectionEnd == lastSelectionEnd\n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd)) {\n                key = KEYS.right;\n            }\n            if (selectionStart !== selectionEnd)\n                modifier |= MODS.shift;\n            if (key) {\n                var result = host.onCommandKey({}, modifier, key);\n                if (!result && host.commands) {\n                    key = KEYS.keyCodeToString(key);\n                    var command = host.commands.findKeyCommand(modifier, key);\n                    if (command)\n                        host.execCommand(command);\n                }\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n                resetSelection(\"\");\n            }\n        };\n        document.addEventListener(\"selectionchange\", detectArrowKeys);\n        host.on(\"destroy\", function () {\n            document.removeEventListener(\"selectionchange\", detectArrowKeys);\n        });\n    }\n    this.destroy = function () {\n        if (text.parentElement)\n            text.parentElement.removeChild(text);\n    };\n};\nexports.TextInput = TextInput;\nexports.$setUserAgentForTests = function (_isMobile, _isIOS) {\n    isMobile = _isMobile;\n    isIOS = _isIOS;\n};\n\n});\n\nace.define(\"ace/mouse/default_handlers\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar useragent = require(\"../lib/useragent\");\nvar DRAG_OFFSET = 0; // pixels\nvar SCROLL_COOLDOWN_T = 550; // milliseconds\nvar DefaultHandlers = /** @class */ (function () {\n    function DefaultHandlers(mouseHandler) {\n        mouseHandler.$clickSelection = null;\n        var editor = mouseHandler.editor;\n        editor.setDefaultHandler(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n        editor.setDefaultHandler(\"dblclick\", this.onDoubleClick.bind(mouseHandler));\n        editor.setDefaultHandler(\"tripleclick\", this.onTripleClick.bind(mouseHandler));\n        editor.setDefaultHandler(\"quadclick\", this.onQuadClick.bind(mouseHandler));\n        editor.setDefaultHandler(\"mousewheel\", this.onMouseWheel.bind(mouseHandler));\n        var exports = [\"select\", \"startSelect\", \"selectEnd\", \"selectAllEnd\", \"selectByWordsEnd\",\n            \"selectByLinesEnd\", \"dragWait\", \"dragWaitEnd\", \"focusWait\"];\n        exports.forEach(function (x) {\n            mouseHandler[x] = this[x];\n        }, this);\n        mouseHandler[\"selectByLines\"] = this.extendSelectionBy.bind(mouseHandler, \"getLineRange\");\n        mouseHandler[\"selectByWords\"] = this.extendSelectionBy.bind(mouseHandler, \"getWordRange\");\n    }\n    DefaultHandlers.prototype.onMouseDown = function (ev) {\n        var inSelection = ev.inSelection();\n        var pos = ev.getDocumentPosition();\n        this.mousedownEvent = ev;\n        var editor = this.editor;\n        var button = ev.getButton();\n        if (button !== 0) {\n            var selectionRange = editor.getSelectionRange();\n            var selectionEmpty = selectionRange.isEmpty();\n            if (selectionEmpty || button == 1)\n                editor.selection.moveToPosition(pos);\n            if (button == 2) {\n                editor.textInput.onContextMenu(ev.domEvent);\n                if (!useragent.isMozilla)\n                    ev.preventDefault();\n            }\n            return;\n        }\n        this.mousedownEvent.time = Date.now();\n        if (inSelection && !editor.isFocused()) {\n            editor.focus();\n            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {\n                this.setState(\"focusWait\");\n                this.captureMouse(ev);\n                return;\n            }\n        }\n        this.captureMouse(ev);\n        this.startSelect(pos, ev.domEvent._clicks > 1);\n        return ev.preventDefault();\n    };\n    DefaultHandlers.prototype.startSelect = function (pos, waitForClickSelection) {\n        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var editor = this.editor;\n        if (!this.mousedownEvent)\n            return;\n        if (this.mousedownEvent.getShiftKey())\n            editor.selection.selectToPosition(pos);\n        else if (!waitForClickSelection)\n            editor.selection.moveToPosition(pos);\n        if (!waitForClickSelection)\n            this.select();\n        editor.setStyle(\"ace_selecting\");\n        this.setState(\"select\");\n    };\n    DefaultHandlers.prototype.select = function () {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        if (this.$clickSelection) {\n            var cmp = this.$clickSelection.comparePoint(cursor);\n            if (cmp == -1) {\n                anchor = this.$clickSelection.end;\n            }\n            else if (cmp == 1) {\n                anchor = this.$clickSelection.start;\n            }\n            else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n    DefaultHandlers.prototype.extendSelectionBy = function (unitName) {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var range = editor.selection[unitName](cursor.row, cursor.column);\n        if (this.$clickSelection) {\n            var cmpStart = this.$clickSelection.comparePoint(range.start);\n            var cmpEnd = this.$clickSelection.comparePoint(range.end);\n            if (cmpStart == -1 && cmpEnd <= 0) {\n                anchor = this.$clickSelection.end;\n                if (range.end.row != cursor.row || range.end.column != cursor.column)\n                    cursor = range.start;\n            }\n            else if (cmpEnd == 1 && cmpStart >= 0) {\n                anchor = this.$clickSelection.start;\n                if (range.start.row != cursor.row || range.start.column != cursor.column)\n                    cursor = range.end;\n            }\n            else if (cmpStart == -1 && cmpEnd == 1) {\n                cursor = range.end;\n                anchor = range.start;\n            }\n            else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n    DefaultHandlers.prototype.selectByLinesEnd = function () {\n        this.$clickSelection = null;\n        this.editor.unsetStyle(\"ace_selecting\");\n    };\n    DefaultHandlers.prototype.focusWait = function () {\n        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n        var time = Date.now();\n        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)\n            this.startSelect(this.mousedownEvent.getDocumentPosition());\n    };\n    DefaultHandlers.prototype.onDoubleClick = function (ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        var session = editor.session;\n        var range = session.getBracketRange(pos);\n        if (range) {\n            if (range.isEmpty()) {\n                range.start.column--;\n                range.end.column++;\n            }\n            this.setState(\"select\");\n        }\n        else {\n            range = editor.selection.getWordRange(pos.row, pos.column);\n            this.setState(\"selectByWords\");\n        }\n        this.$clickSelection = range;\n        this.select();\n    };\n    DefaultHandlers.prototype.onTripleClick = function (ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        this.setState(\"selectByLines\");\n        var range = editor.getSelectionRange();\n        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {\n            this.$clickSelection = editor.selection.getLineRange(range.start.row);\n            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;\n        }\n        else {\n            this.$clickSelection = editor.selection.getLineRange(pos.row);\n        }\n        this.select();\n    };\n    DefaultHandlers.prototype.onQuadClick = function (ev) {\n        var editor = this.editor;\n        editor.selectAll();\n        this.$clickSelection = editor.getSelectionRange();\n        this.setState(\"selectAll\");\n    };\n    DefaultHandlers.prototype.onMouseWheel = function (ev) {\n        if (ev.getAccelKey())\n            return;\n        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n            ev.wheelX = ev.wheelY;\n            ev.wheelY = 0;\n        }\n        var editor = this.editor;\n        if (!this.$lastScroll)\n            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };\n        var prevScroll = this.$lastScroll;\n        var t = ev.domEvent.timeStamp;\n        var dt = t - prevScroll.t;\n        var vx = dt ? ev.wheelX / dt : prevScroll.vx;\n        var vy = dt ? ev.wheelY / dt : prevScroll.vy;\n        if (dt < SCROLL_COOLDOWN_T) {\n            vx = (vx + prevScroll.vx) / 2;\n            vy = (vy + prevScroll.vy) / 2;\n        }\n        var direction = Math.abs(vx / vy);\n        var canScroll = false;\n        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))\n            canScroll = true;\n        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))\n            canScroll = true;\n        if (canScroll) {\n            prevScroll.allowed = t;\n        }\n        else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {\n            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)\n                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);\n            if (isSlower) {\n                canScroll = true;\n                prevScroll.allowed = t;\n            }\n            else {\n                prevScroll.allowed = 0;\n            }\n        }\n        prevScroll.t = t;\n        prevScroll.vx = vx;\n        prevScroll.vy = vy;\n        if (canScroll) {\n            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n            return ev.stop();\n        }\n    };\n    return DefaultHandlers;\n}());\nDefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;\nDefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;\nDefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;\nexports.DefaultHandlers = DefaultHandlers;\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\nfunction calcRangeOrientation(range, cursor) {\n    if (range.start.row == range.end.row)\n        var cmp = 2 * cursor.column - range.start.column - range.end.column;\n    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)\n        var cmp = cursor.column - 4;\n    else\n        var cmp = 2 * cursor.row - range.start.row - range.end.row;\n    if (cmp < 0)\n        return { cursor: range.start, anchor: range.end };\n    else\n        return { cursor: range.end, anchor: range.start };\n}\n\n});\n\nace.define(\"ace/lib/scroll\",[\"require\",\"exports\",\"module\"], function(require, exports, module){exports.preventParentScroll = function preventParentScroll(event) {\n    event.stopPropagation();\n    var target = event.currentTarget;\n    var contentOverflows = target.scrollHeight > target.clientHeight;\n    if (!contentOverflows) {\n        event.preventDefault();\n    }\n};\n\n});\n\nace.define(\"ace/tooltip\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/range\",\"ace/lib/scroll\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar Range = require(\"./range\").Range;\nvar preventParentScroll = require(\"./lib/scroll\").preventParentScroll;\nvar CLASSNAME = \"ace_tooltip\";\nvar Tooltip = /** @class */ (function () {\n    function Tooltip(parentNode) {\n        this.isOpen = false;\n        this.$element = null;\n        this.$parentNode = parentNode;\n    }\n    Tooltip.prototype.$init = function () {\n        this.$element = dom.createElement(\"div\");\n        this.$element.className = CLASSNAME;\n        this.$element.style.display = \"none\";\n        this.$parentNode.appendChild(this.$element);\n        return this.$element;\n    };\n    Tooltip.prototype.getElement = function () {\n        return this.$element || this.$init();\n    };\n    Tooltip.prototype.setText = function (text) {\n        this.getElement().textContent = text;\n    };\n    Tooltip.prototype.setHtml = function (html) {\n        this.getElement().innerHTML = html;\n    };\n    Tooltip.prototype.setPosition = function (x, y) {\n        this.getElement().style.left = x + \"px\";\n        this.getElement().style.top = y + \"px\";\n    };\n    Tooltip.prototype.setClassName = function (className) {\n        dom.addCssClass(this.getElement(), className);\n    };\n    Tooltip.prototype.setTheme = function (theme) {\n        this.$element.className = CLASSNAME + \" \" +\n            (theme.isDark ? \"ace_dark \" : \"\") + (theme.cssClass || \"\");\n    };\n    Tooltip.prototype.show = function (text, x, y) {\n        if (text != null)\n            this.setText(text);\n        if (x != null && y != null)\n            this.setPosition(x, y);\n        if (!this.isOpen) {\n            this.getElement().style.display = \"block\";\n            this.isOpen = true;\n        }\n    };\n    Tooltip.prototype.hide = function (e) {\n        if (this.isOpen) {\n            this.getElement().style.display = \"none\";\n            this.getElement().className = CLASSNAME;\n            this.isOpen = false;\n        }\n    };\n    Tooltip.prototype.getHeight = function () {\n        return this.getElement().offsetHeight;\n    };\n    Tooltip.prototype.getWidth = function () {\n        return this.getElement().offsetWidth;\n    };\n    Tooltip.prototype.destroy = function () {\n        this.isOpen = false;\n        if (this.$element && this.$element.parentNode) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n    };\n    return Tooltip;\n}());\nvar PopupManager = /** @class */ (function () {\n    function PopupManager() {\n        this.popups = [];\n    }\n    PopupManager.prototype.addPopup = function (popup) {\n        this.popups.push(popup);\n        this.updatePopups();\n    };\n    PopupManager.prototype.removePopup = function (popup) {\n        var index = this.popups.indexOf(popup);\n        if (index !== -1) {\n            this.popups.splice(index, 1);\n            this.updatePopups();\n        }\n    };\n    PopupManager.prototype.updatePopups = function () {\n        var e_1, _a, e_2, _b;\n        this.popups.sort(function (a, b) { return b.priority - a.priority; });\n        var visiblepopups = [];\n        try {\n            for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var popup = _d.value;\n                var shouldDisplay = true;\n                try {\n                    for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {\n                        var visiblePopup = visiblepopups_1_1.value;\n                        if (this.doPopupsOverlap(visiblePopup, popup)) {\n                            shouldDisplay = false;\n                            break;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                if (shouldDisplay) {\n                    visiblepopups.push(popup);\n                }\n                else {\n                    popup.hide();\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    PopupManager.prototype.doPopupsOverlap = function (popupA, popupB) {\n        var rectA = popupA.getElement().getBoundingClientRect();\n        var rectB = popupB.getElement().getBoundingClientRect();\n        return (rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom\n            > rectB.top);\n    };\n    return PopupManager;\n}());\nvar popupManager = new PopupManager();\nexports.popupManager = popupManager;\nexports.Tooltip = Tooltip;\nvar HoverTooltip = /** @class */ (function (_super) {\n    __extends(HoverTooltip, _super);\n    function HoverTooltip(parentNode) {\n        if (parentNode === void 0) { parentNode = document.body; }\n        var _this = _super.call(this, parentNode) || this;\n        _this.timeout = undefined;\n        _this.lastT = 0;\n        _this.idleTime = 350;\n        _this.lastEvent = undefined;\n        _this.onMouseOut = _this.onMouseOut.bind(_this);\n        _this.onMouseMove = _this.onMouseMove.bind(_this);\n        _this.waitForHover = _this.waitForHover.bind(_this);\n        _this.hide = _this.hide.bind(_this);\n        var el = _this.getElement();\n        el.style.whiteSpace = \"pre-wrap\";\n        el.style.pointerEvents = \"auto\";\n        el.addEventListener(\"mouseout\", _this.onMouseOut);\n        el.tabIndex = -1;\n        el.addEventListener(\"blur\", function () {\n            if (!el.contains(document.activeElement))\n                this.hide();\n        }.bind(_this));\n        el.addEventListener(\"wheel\", preventParentScroll);\n        return _this;\n    }\n    HoverTooltip.prototype.addToEditor = function (editor) {\n        editor.on(\"mousemove\", this.onMouseMove);\n        editor.on(\"mousedown\", this.hide);\n        editor.renderer.getMouseEventTarget().addEventListener(\"mouseout\", this.onMouseOut, true);\n    };\n    HoverTooltip.prototype.removeFromEditor = function (editor) {\n        editor.off(\"mousemove\", this.onMouseMove);\n        editor.off(\"mousedown\", this.hide);\n        editor.renderer.getMouseEventTarget().removeEventListener(\"mouseout\", this.onMouseOut, true);\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    };\n    HoverTooltip.prototype.onMouseMove = function (e, editor) {\n        this.lastEvent = e;\n        this.lastT = Date.now();\n        var isMousePressed = editor.$mouseHandler.isMousePressed;\n        if (this.isOpen) {\n            var pos = this.lastEvent && this.lastEvent.getDocumentPosition();\n            if (!this.range\n                || !this.range.contains(pos.row, pos.column)\n                || isMousePressed\n                || this.isOutsideOfText(this.lastEvent)) {\n                this.hide();\n            }\n        }\n        if (this.timeout || isMousePressed)\n            return;\n        this.lastEvent = e;\n        this.timeout = setTimeout(this.waitForHover, this.idleTime);\n    };\n    HoverTooltip.prototype.waitForHover = function () {\n        if (this.timeout)\n            clearTimeout(this.timeout);\n        var dt = Date.now() - this.lastT;\n        if (this.idleTime - dt > 10) {\n            this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);\n            return;\n        }\n        this.timeout = null;\n        if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {\n            this.$gatherData(this.lastEvent, this.lastEvent.editor);\n        }\n    };\n    HoverTooltip.prototype.isOutsideOfText = function (e) {\n        var editor = e.editor;\n        var docPos = e.getDocumentPosition();\n        var line = editor.session.getLine(docPos.row);\n        if (docPos.column == line.length) {\n            var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);\n            var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);\n            if (clippedPos.column != screenPos.column\n                || clippedPos.row != screenPos.row) {\n                return true;\n            }\n        }\n        return false;\n    };\n    HoverTooltip.prototype.setDataProvider = function (value) {\n        this.$gatherData = value;\n    };\n    HoverTooltip.prototype.showForRange = function (editor, range, domNode, startingEvent) {\n        var MARGIN = 10;\n        if (startingEvent && startingEvent != this.lastEvent)\n            return;\n        if (this.isOpen && document.activeElement == this.getElement())\n            return;\n        var renderer = editor.renderer;\n        if (!this.isOpen) {\n            popupManager.addPopup(this);\n            this.$registerCloseEvents();\n            this.setTheme(renderer.theme);\n        }\n        this.isOpen = true;\n        this.addMarker(range, editor.session);\n        this.range = Range.fromPoints(range.start, range.end);\n        var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);\n        var rect = renderer.scroller.getBoundingClientRect();\n        if (position.pageX < rect.left)\n            position.pageX = rect.left;\n        var element = this.getElement();\n        element.innerHTML = \"\";\n        element.appendChild(domNode);\n        element.style.maxHeight = \"\";\n        element.style.display = \"block\";\n        var labelHeight = element.clientHeight;\n        var labelWidth = element.clientWidth;\n        var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;\n        var isAbove = true;\n        if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {\n            isAbove = false;\n        }\n        element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + \"px\";\n        element.style.top = isAbove ? \"\" : position.pageY + renderer.lineHeight + \"px\";\n        element.style.bottom = isAbove ? window.innerHeight - position.pageY + \"px\" : \"\";\n        element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + \"px\";\n    };\n    HoverTooltip.prototype.addMarker = function (range, session) {\n        if (this.marker) {\n            this.$markerSession.removeMarker(this.marker);\n        }\n        this.$markerSession = session;\n        this.marker = session && session.addMarker(range, \"ace_highlight-marker\", \"text\");\n    };\n    HoverTooltip.prototype.hide = function (e) {\n        if (!e && document.activeElement == this.getElement())\n            return;\n        if (e && e.target && (e.type != \"keydown\" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))\n            return;\n        this.lastEvent = null;\n        if (this.timeout)\n            clearTimeout(this.timeout);\n        this.timeout = null;\n        this.addMarker(null);\n        if (this.isOpen) {\n            this.$removeCloseEvents();\n            this.getElement().style.display = \"none\";\n            this.isOpen = false;\n            popupManager.removePopup(this);\n        }\n    };\n    HoverTooltip.prototype.$registerCloseEvents = function () {\n        window.addEventListener(\"keydown\", this.hide, true);\n        window.addEventListener(\"wheel\", this.hide, true);\n        window.addEventListener(\"mousedown\", this.hide, true);\n    };\n    HoverTooltip.prototype.$removeCloseEvents = function () {\n        window.removeEventListener(\"keydown\", this.hide, true);\n        window.removeEventListener(\"wheel\", this.hide, true);\n        window.removeEventListener(\"mousedown\", this.hide, true);\n    };\n    HoverTooltip.prototype.onMouseOut = function (e) {\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n        this.lastEvent = null;\n        if (!this.isOpen)\n            return;\n        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))\n            return;\n        if (e && e.currentTarget.contains(e.relatedTarget))\n            return;\n        if (!e.relatedTarget.classList.contains(\"ace_content\"))\n            this.hide();\n    };\n    return HoverTooltip;\n}(Tooltip));\nexports.HoverTooltip = HoverTooltip;\n\n});\n\nace.define(\"ace/mouse/default_gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/tooltip\",\"ace/config\",\"ace/lib/lang\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar Tooltip = require(\"../tooltip\").Tooltip;\nvar nls = require(\"../config\").nls;\nvar lang = require(\"../lib/lang\");\nfunction GutterHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var gutter = editor.renderer.$gutterLayer;\n    var tooltip = new GutterTooltip(editor);\n    mouseHandler.editor.setDefaultHandler(\"guttermousedown\", function (e) {\n        if (!editor.isFocused() || e.getButton() != 0)\n            return;\n        var gutterRegion = gutter.getRegion(e);\n        if (gutterRegion == \"foldWidgets\")\n            return;\n        var row = e.getDocumentPosition().row;\n        var selection = editor.session.selection;\n        if (e.getShiftKey())\n            selection.selectTo(row, 0);\n        else {\n            if (e.domEvent.detail == 2) {\n                editor.selectAll();\n                return e.preventDefault();\n            }\n            mouseHandler.$clickSelection = editor.selection.getLineRange(row);\n        }\n        mouseHandler.setState(\"selectByLines\");\n        mouseHandler.captureMouse(e);\n        return e.preventDefault();\n    });\n    var tooltipTimeout, mouseEvent;\n    function showTooltip() {\n        var row = mouseEvent.getDocumentPosition().row;\n        var maxRow = editor.session.getLength();\n        if (row == maxRow) {\n            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;\n            var pos = mouseEvent.$pos;\n            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))\n                return hideTooltip();\n        }\n        tooltip.showTooltip(row);\n        if (!tooltip.isOpen)\n            return;\n        editor.on(\"mousewheel\", hideTooltip);\n        if (mouseHandler.$tooltipFollowsMouse) {\n            moveTooltip(mouseEvent);\n        }\n        else {\n            var gutterRow = mouseEvent.getGutterRow();\n            var gutterCell = gutter.$lines.get(gutterRow);\n            if (gutterCell) {\n                var gutterElement = gutterCell.element.querySelector(\".ace_gutter_annotation\");\n                var rect = gutterElement.getBoundingClientRect();\n                var style = tooltip.getElement().style;\n                style.left = rect.right + \"px\";\n                style.top = rect.bottom + \"px\";\n            }\n            else {\n                moveTooltip(mouseEvent);\n            }\n        }\n    }\n    function hideTooltip() {\n        if (tooltipTimeout)\n            tooltipTimeout = clearTimeout(tooltipTimeout);\n        if (tooltip.isOpen) {\n            tooltip.hideTooltip();\n            editor.off(\"mousewheel\", hideTooltip);\n        }\n    }\n    function moveTooltip(e) {\n        tooltip.setPosition(e.x, e.y);\n    }\n    mouseHandler.editor.setDefaultHandler(\"guttermousemove\", function (e) {\n        var target = e.domEvent.target || e.domEvent.srcElement;\n        if (dom.hasCssClass(target, \"ace_fold-widget\"))\n            return hideTooltip();\n        if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)\n            moveTooltip(e);\n        mouseEvent = e;\n        if (tooltipTimeout)\n            return;\n        tooltipTimeout = setTimeout(function () {\n            tooltipTimeout = null;\n            if (mouseEvent && !mouseHandler.isMousePressed)\n                showTooltip();\n            else\n                hideTooltip();\n        }, 50);\n    });\n    event.addListener(editor.renderer.$gutter, \"mouseout\", function (e) {\n        mouseEvent = null;\n        if (!tooltip.isOpen || tooltipTimeout)\n            return;\n        tooltipTimeout = setTimeout(function () {\n            tooltipTimeout = null;\n            hideTooltip();\n        }, 50);\n    }, editor);\n    editor.on(\"changeSession\", hideTooltip);\n    editor.on(\"input\", hideTooltip);\n}\nexports.GutterHandler = GutterHandler;\nvar GutterTooltip = /** @class */ (function (_super) {\n    __extends(GutterTooltip, _super);\n    function GutterTooltip(editor) {\n        var _this = _super.call(this, editor.container) || this;\n        _this.editor = editor;\n        return _this;\n    }\n    GutterTooltip.prototype.setPosition = function (x, y) {\n        var windowWidth = window.innerWidth || document.documentElement.clientWidth;\n        var windowHeight = window.innerHeight || document.documentElement.clientHeight;\n        var width = this.getWidth();\n        var height = this.getHeight();\n        x += 15;\n        y += 15;\n        if (x + width > windowWidth) {\n            x -= (x + width) - windowWidth;\n        }\n        if (y + height > windowHeight) {\n            y -= 20 + height;\n        }\n        Tooltip.prototype.setPosition.call(this, x, y);\n    };\n    Object.defineProperty(GutterTooltip, \"annotationLabels\", {\n        get: function () {\n            return {\n                error: {\n                    singular: nls(\"gutter-tooltip.aria-label.error.singular\", \"error\"),\n                    plural: nls(\"gutter-tooltip.aria-label.error.plural\", \"errors\")\n                },\n                warning: {\n                    singular: nls(\"gutter-tooltip.aria-label.warning.singular\", \"warning\"),\n                    plural: nls(\"gutter-tooltip.aria-label.warning.plural\", \"warnings\")\n                },\n                info: {\n                    singular: nls(\"gutter-tooltip.aria-label.info.singular\", \"information message\"),\n                    plural: nls(\"gutter-tooltip.aria-label.info.plural\", \"information messages\")\n                }\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    GutterTooltip.prototype.showTooltip = function (row) {\n        var _a;\n        var gutter = this.editor.renderer.$gutterLayer;\n        var annotationsInRow = gutter.$annotations[row];\n        var annotation;\n        if (annotationsInRow)\n            annotation = { displayText: Array.from(annotationsInRow.displayText), type: Array.from(annotationsInRow.type) };\n        else\n            annotation = { displayText: [], type: [] };\n        var fold = gutter.session.getFoldLine(row);\n        if (fold && gutter.$showFoldedAnnotations) {\n            var annotationsInFold = { error: [], warning: [], info: [] };\n            var mostSevereAnnotationInFoldType;\n            for (var i = row + 1; i <= fold.end.row; i++) {\n                if (!gutter.$annotations[i])\n                    continue;\n                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {\n                    var annotationType = gutter.$annotations[i].type[j];\n                    annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);\n                    if (annotationType === \"error\") {\n                        mostSevereAnnotationInFoldType = \"error_fold\";\n                        continue;\n                    }\n                    if (annotationType === \"warning\") {\n                        mostSevereAnnotationInFoldType = \"warning_fold\";\n                        continue;\n                    }\n                }\n            }\n            if (mostSevereAnnotationInFoldType === \"error_fold\" || mostSevereAnnotationInFoldType === \"warning_fold\") {\n                var summaryFoldedAnnotations = \"\".concat(GutterTooltip.annotationsToSummaryString(annotationsInFold), \" in folded code.\");\n                annotation.displayText.push(summaryFoldedAnnotations);\n                annotation.type.push(mostSevereAnnotationInFoldType);\n            }\n        }\n        if (annotation.displayText.length === 0)\n            return this.hide();\n        var annotationMessages = { error: [], warning: [], info: [] };\n        var iconClassName = gutter.$useSvgGutterIcons ? \"ace_icon_svg\" : \"ace_icon\";\n        for (var i = 0; i < annotation.displayText.length; i++) {\n            var lineElement = dom.createElement(\"span\");\n            var iconElement = dom.createElement(\"span\");\n            (_a = iconElement.classList).add.apply(_a, [\"ace_\".concat(annotation.type[i]), iconClassName]);\n            iconElement.setAttribute(\"aria-label\", \"\".concat(GutterTooltip.annotationLabels[annotation.type[i].replace(\"_fold\", \"\")].singular));\n            iconElement.setAttribute(\"role\", \"img\");\n            iconElement.appendChild(dom.createTextNode(\" \"));\n            lineElement.appendChild(iconElement);\n            lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));\n            lineElement.appendChild(dom.createElement(\"br\"));\n            annotationMessages[annotation.type[i].replace(\"_fold\", \"\")].push(lineElement);\n        }\n        var tooltipElement = this.getElement();\n        dom.removeChildren(tooltipElement);\n        annotationMessages.error.forEach(function (el) { return tooltipElement.appendChild(el); });\n        annotationMessages.warning.forEach(function (el) { return tooltipElement.appendChild(el); });\n        annotationMessages.info.forEach(function (el) { return tooltipElement.appendChild(el); });\n        tooltipElement.setAttribute(\"aria-live\", \"polite\");\n        if (!this.isOpen) {\n            this.setTheme(this.editor.renderer.theme);\n            this.setClassName(\"ace_gutter-tooltip\");\n        }\n        this.show();\n        this.editor._signal(\"showGutterTooltip\", this);\n    };\n    GutterTooltip.prototype.hideTooltip = function () {\n        this.$element.removeAttribute(\"aria-live\");\n        this.hide();\n        this.editor._signal(\"hideGutterTooltip\", this);\n    };\n    GutterTooltip.annotationsToSummaryString = function (annotations) {\n        var e_1, _a;\n        var summary = [];\n        var annotationTypes = ['error', 'warning', 'info'];\n        try {\n            for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {\n                var annotationType = annotationTypes_1_1.value;\n                if (!annotations[annotationType].length)\n                    continue;\n                var label = annotations[annotationType].length === 1 ? GutterTooltip.annotationLabels[annotationType].singular : GutterTooltip.annotationLabels[annotationType].plural;\n                summary.push(\"\".concat(annotations[annotationType].length, \" \").concat(label));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return summary.join(\", \");\n    };\n    return GutterTooltip;\n}(Tooltip));\nexports.GutterTooltip = GutterTooltip;\n\n});\n\nace.define(\"ace/mouse/mouse_event\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar MouseEvent = /** @class */ (function () {\n    function MouseEvent(domEvent, editor) { this.speed; this.wheelX; this.wheelY;\n        this.domEvent = domEvent;\n        this.editor = editor;\n        this.x = this.clientX = domEvent.clientX;\n        this.y = this.clientY = domEvent.clientY;\n        this.$pos = null;\n        this.$inSelection = null;\n        this.propagationStopped = false;\n        this.defaultPrevented = false;\n    }\n    MouseEvent.prototype.stopPropagation = function () {\n        event.stopPropagation(this.domEvent);\n        this.propagationStopped = true;\n    };\n    MouseEvent.prototype.preventDefault = function () {\n        event.preventDefault(this.domEvent);\n        this.defaultPrevented = true;\n    };\n    MouseEvent.prototype.stop = function () {\n        this.stopPropagation();\n        this.preventDefault();\n    };\n    MouseEvent.prototype.getDocumentPosition = function () {\n        if (this.$pos)\n            return this.$pos;\n        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);\n        return this.$pos;\n    };\n    MouseEvent.prototype.getGutterRow = function () {\n        var documentRow = this.getDocumentPosition().row;\n        var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);\n        var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);\n        return screenRow - screenTopRow;\n    };\n    MouseEvent.prototype.inSelection = function () {\n        if (this.$inSelection !== null)\n            return this.$inSelection;\n        var editor = this.editor;\n        var selectionRange = editor.getSelectionRange();\n        if (selectionRange.isEmpty())\n            this.$inSelection = false;\n        else {\n            var pos = this.getDocumentPosition();\n            this.$inSelection = selectionRange.contains(pos.row, pos.column);\n        }\n        return this.$inSelection;\n    };\n    MouseEvent.prototype.getButton = function () {\n        return event.getButton(this.domEvent);\n    };\n    MouseEvent.prototype.getShiftKey = function () {\n        return this.domEvent.shiftKey;\n    };\n    MouseEvent.prototype.getAccelKey = function () {\n        return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;\n    };\n    return MouseEvent;\n}());\nexports.MouseEvent = MouseEvent;\n\n});\n\nace.define(\"ace/mouse/dragdrop_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar AUTOSCROLL_DELAY = 200;\nvar SCROLL_CURSOR_DELAY = 200;\nvar SCROLL_CURSOR_HYSTERESIS = 5;\nfunction DragdropHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var dragImage = dom.createElement(\"div\");\n    dragImage.style.cssText = \"top:-100px;position:absolute;z-index:2147483647;opacity:0.5\";\n    dragImage.textContent = \"\\xa0\";\n    var exports = [\"dragWait\", \"dragWaitEnd\", \"startDrag\", \"dragReadyEnd\", \"onMouseDrag\"];\n    exports.forEach(function (x) {\n        mouseHandler[x] = this[x];\n    }, this);\n    editor.on(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n    var mouseTarget = editor.container;\n    var dragSelectionMarker, x, y;\n    var timerId, range;\n    var dragCursor, counter = 0;\n    var dragOperation;\n    var isInternal;\n    var autoScrollStartTime;\n    var cursorMovedTime;\n    var cursorPointOnCaretMoved;\n    this.onDragStart = function (e) {\n        if (this.cancelDrag || !mouseTarget.draggable) {\n            var self = this;\n            setTimeout(function () {\n                self.startSelect();\n                self.captureMouse(e);\n            }, 0);\n            return e.preventDefault();\n        }\n        range = editor.getSelectionRange();\n        var dataTransfer = e.dataTransfer;\n        dataTransfer.effectAllowed = editor.getReadOnly() ? \"copy\" : \"copyMove\";\n        editor.container.appendChild(dragImage);\n        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);\n        setTimeout(function () {\n            editor.container.removeChild(dragImage);\n        });\n        dataTransfer.clearData();\n        dataTransfer.setData(\"Text\", editor.session.getTextRange());\n        isInternal = true;\n        this.setState(\"drag\");\n    };\n    this.onDragEnd = function (e) {\n        mouseTarget.draggable = false;\n        isInternal = false;\n        this.setState(null);\n        if (!editor.getReadOnly()) {\n            var dropEffect = e.dataTransfer.dropEffect;\n            if (!dragOperation && dropEffect == \"move\")\n                editor.session.remove(editor.getSelectionRange());\n            editor.$resetCursorStyle();\n        }\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n    };\n    this.onDragEnter = function (e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker)\n            addDragMarker();\n        counter++;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n    this.onDragOver = function (e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker) {\n            addDragMarker();\n            counter++;\n        }\n        if (onMouseMoveTimer !== null)\n            onMouseMoveTimer = null;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n    this.onDragLeave = function (e) {\n        counter--;\n        if (counter <= 0 && dragSelectionMarker) {\n            clearDragMarker();\n            dragOperation = null;\n            return event.preventDefault(e);\n        }\n    };\n    this.onDrop = function (e) {\n        if (!dragCursor)\n            return;\n        var dataTransfer = e.dataTransfer;\n        if (isInternal) {\n            switch (dragOperation) {\n                case \"move\":\n                    if (range.contains(dragCursor.row, dragCursor.column)) {\n                        range = {\n                            start: dragCursor,\n                            end: dragCursor\n                        };\n                    }\n                    else {\n                        range = editor.moveText(range, dragCursor);\n                    }\n                    break;\n                case \"copy\":\n                    range = editor.moveText(range, dragCursor, true);\n                    break;\n            }\n        }\n        else {\n            var dropData = dataTransfer.getData('Text');\n            range = {\n                start: dragCursor,\n                end: editor.session.insert(dragCursor, dropData)\n            };\n            editor.focus();\n            dragOperation = null;\n        }\n        clearDragMarker();\n        return event.preventDefault(e);\n    };\n    event.addListener(mouseTarget, \"dragstart\", this.onDragStart.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragend\", this.onDragEnd.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragenter\", this.onDragEnter.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragover\", this.onDragOver.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragleave\", this.onDragLeave.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"drop\", this.onDrop.bind(mouseHandler), editor);\n    function scrollCursorIntoView(cursor, prevCursor) {\n        var now = Date.now();\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        var hMovement = !prevCursor || cursor.column != prevCursor.column;\n        if (!cursorMovedTime || vMovement || hMovement) {\n            editor.moveCursorToPosition(cursor);\n            cursorMovedTime = now;\n            cursorPointOnCaretMoved = { x: x, y: y };\n        }\n        else {\n            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);\n            if (distance > SCROLL_CURSOR_HYSTERESIS) {\n                cursorMovedTime = null;\n            }\n            else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {\n                editor.renderer.scrollCursorIntoView();\n                cursorMovedTime = null;\n            }\n        }\n    }\n    function autoScroll(cursor, prevCursor) {\n        var now = Date.now();\n        var lineHeight = editor.renderer.layerConfig.lineHeight;\n        var characterWidth = editor.renderer.layerConfig.characterWidth;\n        var editorRect = editor.renderer.scroller.getBoundingClientRect();\n        var offsets = {\n            x: {\n                left: x - editorRect.left,\n                right: editorRect.right - x\n            },\n            y: {\n                top: y - editorRect.top,\n                bottom: editorRect.bottom - y\n            }\n        };\n        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);\n        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);\n        var scrollCursor = { row: cursor.row, column: cursor.column };\n        if (nearestXOffset / characterWidth <= 2) {\n            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);\n        }\n        if (nearestYOffset / lineHeight <= 1) {\n            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);\n        }\n        var vScroll = cursor.row != scrollCursor.row;\n        var hScroll = cursor.column != scrollCursor.column;\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        if (vScroll || (hScroll && !vMovement)) {\n            if (!autoScrollStartTime)\n                autoScrollStartTime = now;\n            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)\n                editor.renderer.scrollCursorIntoView(scrollCursor);\n        }\n        else {\n            autoScrollStartTime = null;\n        }\n    }\n    function onDragInterval() {\n        var prevCursor = dragCursor;\n        dragCursor = editor.renderer.screenToTextCoordinates(x, y);\n        scrollCursorIntoView(dragCursor, prevCursor);\n        autoScroll(dragCursor, prevCursor);\n    }\n    function addDragMarker() {\n        range = editor.selection.toOrientedRange();\n        dragSelectionMarker = editor.session.addMarker(range, \"ace_selection\", editor.getSelectionStyle());\n        editor.clearSelection();\n        if (editor.isFocused())\n            editor.renderer.$cursorLayer.setBlinking(false);\n        clearInterval(timerId);\n        onDragInterval();\n        timerId = setInterval(onDragInterval, 20);\n        counter = 0;\n        event.addListener(document, \"mousemove\", onMouseMove);\n    }\n    function clearDragMarker() {\n        clearInterval(timerId);\n        editor.session.removeMarker(dragSelectionMarker);\n        dragSelectionMarker = null;\n        editor.selection.fromOrientedRange(range);\n        if (editor.isFocused() && !isInternal)\n            editor.$resetCursorStyle();\n        range = null;\n        dragCursor = null;\n        counter = 0;\n        autoScrollStartTime = null;\n        cursorMovedTime = null;\n        event.removeListener(document, \"mousemove\", onMouseMove);\n    }\n    var onMouseMoveTimer = null;\n    function onMouseMove() {\n        if (onMouseMoveTimer == null) {\n            onMouseMoveTimer = setTimeout(function () {\n                if (onMouseMoveTimer != null && dragSelectionMarker)\n                    clearDragMarker();\n            }, 20);\n        }\n    }\n    function canAccept(dataTransfer) {\n        var types = dataTransfer.types;\n        return !types || Array.prototype.some.call(types, function (type) {\n            return type == 'text/plain' || type == 'Text';\n        });\n    }\n    function getDropEffect(e) {\n        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];\n        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];\n        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;\n        var effectAllowed = \"uninitialized\";\n        try {\n            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();\n        }\n        catch (e) { }\n        var dropEffect = \"none\";\n        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        else if (moveAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"move\";\n        else if (copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        return dropEffect;\n    }\n}\n(function () {\n    this.dragWait = function () {\n        var interval = Date.now() - this.mousedownEvent.time;\n        if (interval > this.editor.getDragDelay())\n            this.startDrag();\n    };\n    this.dragWaitEnd = function () {\n        var target = this.editor.container;\n        target.draggable = false;\n        this.startSelect(this.mousedownEvent.getDocumentPosition());\n        this.selectEnd();\n    };\n    this.dragReadyEnd = function (e) {\n        this.editor.$resetCursorStyle();\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n        this.dragWaitEnd();\n    };\n    this.startDrag = function () {\n        this.cancelDrag = false;\n        var editor = this.editor;\n        var target = editor.container;\n        target.draggable = true;\n        editor.renderer.$cursorLayer.setBlinking(false);\n        editor.setStyle(\"ace_dragging\");\n        var cursorStyle = useragent.isWin ? \"default\" : \"move\";\n        editor.renderer.setCursorStyle(cursorStyle);\n        this.setState(\"dragReady\");\n    };\n    this.onMouseDrag = function (e) {\n        var target = this.editor.container;\n        if (useragent.isIE && this.state == \"dragReady\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 3)\n                target.dragDrop();\n        }\n        if (this.state === \"dragWait\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 0) {\n                target.draggable = false;\n                this.startSelect(this.mousedownEvent.getDocumentPosition());\n            }\n        }\n    };\n    this.onMouseDown = function (e) {\n        if (!this.$dragEnabled)\n            return;\n        this.mousedownEvent = e;\n        var editor = this.editor;\n        var inSelection = e.inSelection();\n        var button = e.getButton();\n        var clickCount = e.domEvent.detail || 1;\n        if (clickCount === 1 && button === 0 && inSelection) {\n            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))\n                return;\n            this.mousedownEvent.time = Date.now();\n            var eventTarget = e.domEvent.target || e.domEvent.srcElement;\n            if (\"unselectable\" in eventTarget)\n                eventTarget.unselectable = \"on\";\n            if (editor.getDragDelay()) {\n                if (useragent.isWebKit) {\n                    this.cancelDrag = true;\n                    var mouseTarget = editor.container;\n                    mouseTarget.draggable = true;\n                }\n                this.setState(\"dragWait\");\n            }\n            else {\n                this.startDrag();\n            }\n            this.captureMouse(e, this.onMouseDrag.bind(this));\n            e.defaultPrevented = true;\n        }\n    };\n}).call(DragdropHandler.prototype);\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\nexports.DragdropHandler = DragdropHandler;\n\n});\n\nace.define(\"ace/mouse/touch_handler\",[\"require\",\"exports\",\"module\",\"ace/mouse/mouse_event\",\"ace/lib/event\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar event = require(\"../lib/event\");\nvar dom = require(\"../lib/dom\");\nexports.addTouchListeners = function (el, editor) {\n    var mode = \"scroll\";\n    var startX;\n    var startY;\n    var touchStartT;\n    var lastT;\n    var longTouchTimer;\n    var animationTimer;\n    var animationSteps = 0;\n    var pos;\n    var clickCount = 0;\n    var vX = 0;\n    var vY = 0;\n    var pressed;\n    var contextMenu;\n    function createContextMenu() {\n        var clipboard = window.navigator && window.navigator.clipboard;\n        var isOpen = false;\n        var updateMenu = function () {\n            var selected = editor.getCopyText();\n            var hasUndo = editor.session.getUndoManager().hasUndo();\n            contextMenu.replaceChild(dom.buildDom(isOpen ? [\"span\",\n                !selected && canExecuteCommand(\"selectall\") && [\"span\", { class: \"ace_mobile-button\", action: \"selectall\" }, \"Select All\"],\n                selected && canExecuteCommand(\"copy\") && [\"span\", { class: \"ace_mobile-button\", action: \"copy\" }, \"Copy\"],\n                selected && canExecuteCommand(\"cut\") && [\"span\", { class: \"ace_mobile-button\", action: \"cut\" }, \"Cut\"],\n                clipboard && canExecuteCommand(\"paste\") && [\"span\", { class: \"ace_mobile-button\", action: \"paste\" }, \"Paste\"],\n                hasUndo && canExecuteCommand(\"undo\") && [\"span\", { class: \"ace_mobile-button\", action: \"undo\" }, \"Undo\"],\n                canExecuteCommand(\"find\") && [\"span\", { class: \"ace_mobile-button\", action: \"find\" }, \"Find\"],\n                canExecuteCommand(\"openCommandPalette\") && [\"span\", { class: \"ace_mobile-button\", action: \"openCommandPalette\" }, \"Palette\"]\n            ] : [\"span\"]), contextMenu.firstChild);\n        };\n        var canExecuteCommand = function (/** @type {string} */ cmd) {\n            return editor.commands.canExecute(cmd, editor);\n        };\n        var handleClick = function (e) {\n            var action = e.target.getAttribute(\"action\");\n            if (action == \"more\" || !isOpen) {\n                isOpen = !isOpen;\n                return updateMenu();\n            }\n            if (action == \"paste\") {\n                clipboard.readText().then(function (text) {\n                    editor.execCommand(action, text);\n                });\n            }\n            else if (action) {\n                if (action == \"cut\" || action == \"copy\") {\n                    if (clipboard)\n                        clipboard.writeText(editor.getCopyText());\n                    else\n                        document.execCommand(\"copy\");\n                }\n                editor.execCommand(action);\n            }\n            contextMenu.firstChild.style.display = \"none\";\n            isOpen = false;\n            if (action != \"openCommandPalette\")\n                editor.focus();\n        };\n        contextMenu = dom.buildDom([\"div\",\n            {\n                class: \"ace_mobile-menu\",\n                ontouchstart: function (e) {\n                    mode = \"menu\";\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.textInput.focus();\n                },\n                ontouchend: function (e) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    handleClick(e);\n                },\n                onclick: handleClick\n            },\n            [\"span\"],\n            [\"span\", { class: \"ace_mobile-button\", action: \"more\" }, \"...\"]\n        ], editor.container);\n    }\n    function showContextMenu() {\n        if (!editor.getOption(\"enableMobileMenu\")) {\n            if (contextMenu) {\n                hideContextMenu();\n            }\n            return;\n        }\n        if (!contextMenu)\n            createContextMenu();\n        var cursor = editor.selection.cursor;\n        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);\n        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;\n        var scrollLeft = editor.renderer.scrollLeft;\n        var rect = editor.container.getBoundingClientRect();\n        contextMenu.style.top = pagePos.pageY - rect.top - 3 + \"px\";\n        if (pagePos.pageX - rect.left < rect.width - 70) {\n            contextMenu.style.left = \"\";\n            contextMenu.style.right = \"10px\";\n        }\n        else {\n            contextMenu.style.right = \"\";\n            contextMenu.style.left = leftOffset + scrollLeft - rect.left + \"px\";\n        }\n        contextMenu.style.display = \"\";\n        contextMenu.firstChild.style.display = \"none\";\n        editor.on(\"input\", hideContextMenu);\n    }\n    function hideContextMenu(e) {\n        if (contextMenu)\n            contextMenu.style.display = \"none\";\n        editor.off(\"input\", hideContextMenu);\n    }\n    function handleLongTap() {\n        longTouchTimer = null;\n        clearTimeout(longTouchTimer);\n        var range = editor.selection.getRange();\n        var inSelection = range.contains(pos.row, pos.column);\n        if (range.isEmpty() || !inSelection) {\n            editor.selection.moveToPosition(pos);\n            editor.selection.selectWord();\n        }\n        mode = \"wait\";\n        showContextMenu();\n    }\n    function switchToSelectionMode() {\n        longTouchTimer = null;\n        clearTimeout(longTouchTimer);\n        editor.selection.moveToPosition(pos);\n        var range = clickCount >= 2\n            ? editor.selection.getLineRange(pos.row)\n            : editor.session.getBracketRange(pos);\n        if (range && !range.isEmpty()) {\n            editor.selection.setRange(range);\n        }\n        else {\n            editor.selection.selectWord();\n        }\n        mode = \"wait\";\n    }\n    event.addListener(el, \"contextmenu\", function (e) {\n        if (!pressed)\n            return;\n        var textarea = editor.textInput.getElement();\n        textarea.focus();\n    }, editor);\n    event.addListener(el, \"touchstart\", function (e) {\n        var touches = e.touches;\n        if (longTouchTimer || touches.length > 1) {\n            clearTimeout(longTouchTimer);\n            longTouchTimer = null;\n            touchStartT = -1;\n            mode = \"zoom\";\n            return;\n        }\n        pressed = editor.$mouseHandler.isMousePressed = true;\n        var h = editor.renderer.layerConfig.lineHeight;\n        var w = editor.renderer.layerConfig.lineHeight;\n        var t = e.timeStamp;\n        lastT = t;\n        var touchObj = touches[0];\n        var x = touchObj.clientX;\n        var y = touchObj.clientY;\n        if (Math.abs(startX - x) + Math.abs(startY - y) > h)\n            touchStartT = -1;\n        startX = e.clientX = x;\n        startY = e.clientY = y;\n        vX = vY = 0;\n        var ev = new MouseEvent(e, editor);\n        pos = ev.getDocumentPosition();\n        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {\n            clickCount++;\n            e.preventDefault();\n            e.button = 0;\n            switchToSelectionMode();\n        }\n        else {\n            clickCount = 0;\n            var cursor = editor.selection.cursor;\n            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;\n            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);\n            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);\n            var rect = editor.renderer.scroller.getBoundingClientRect();\n            var offsetTop = editor.renderer.layerConfig.offset;\n            var offsetLeft = editor.renderer.scrollLeft;\n            var weightedDistance = function (x, y) {\n                x = x / w;\n                y = y / h - 0.75;\n                return x * x + y * y;\n            };\n            if (e.clientX < rect.left) {\n                mode = \"zoom\";\n                return;\n            }\n            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);\n            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);\n            if (diff1 < 3.5 && diff2 < 3.5)\n                mode = diff1 > diff2 ? \"cursor\" : \"anchor\";\n            if (diff2 < 3.5)\n                mode = \"anchor\";\n            else if (diff1 < 3.5)\n                mode = \"cursor\";\n            else\n                mode = \"scroll\";\n            longTouchTimer = setTimeout(handleLongTap, 450);\n        }\n        touchStartT = t;\n    }, editor);\n    event.addListener(el, \"touchend\", function (e) {\n        pressed = editor.$mouseHandler.isMousePressed = false;\n        if (animationTimer)\n            clearInterval(animationTimer);\n        if (mode == \"zoom\") {\n            mode = \"\";\n            animationSteps = 0;\n        }\n        else if (longTouchTimer) {\n            editor.selection.moveToPosition(pos);\n            animationSteps = 0;\n            showContextMenu();\n        }\n        else if (mode == \"scroll\") {\n            animate();\n            hideContextMenu();\n        }\n        else {\n            showContextMenu();\n        }\n        clearTimeout(longTouchTimer);\n        longTouchTimer = null;\n    }, editor);\n    event.addListener(el, \"touchmove\", function (e) {\n        if (longTouchTimer) {\n            clearTimeout(longTouchTimer);\n            longTouchTimer = null;\n        }\n        var touches = e.touches;\n        if (touches.length > 1 || mode == \"zoom\")\n            return;\n        var touchObj = touches[0];\n        var wheelX = startX - touchObj.clientX;\n        var wheelY = startY - touchObj.clientY;\n        if (mode == \"wait\") {\n            if (wheelX * wheelX + wheelY * wheelY > 4)\n                mode = \"cursor\";\n            else\n                return e.preventDefault();\n        }\n        startX = touchObj.clientX;\n        startY = touchObj.clientY;\n        e.clientX = touchObj.clientX;\n        e.clientY = touchObj.clientY;\n        var t = e.timeStamp;\n        var dt = t - lastT;\n        lastT = t;\n        if (mode == \"scroll\") {\n            var mouseEvent = new MouseEvent(e, editor);\n            mouseEvent.speed = 1;\n            mouseEvent.wheelX = wheelX;\n            mouseEvent.wheelY = wheelY;\n            if (10 * Math.abs(wheelX) < Math.abs(wheelY))\n                wheelX = 0;\n            if (10 * Math.abs(wheelY) < Math.abs(wheelX))\n                wheelY = 0;\n            if (dt != 0) {\n                vX = wheelX / dt;\n                vY = wheelY / dt;\n            }\n            editor._emit(\"mousewheel\", mouseEvent);\n            if (!mouseEvent.propagationStopped) {\n                vX = vY = 0;\n            }\n        }\n        else {\n            var ev = new MouseEvent(e, editor);\n            var pos = ev.getDocumentPosition();\n            if (mode == \"cursor\")\n                editor.selection.moveCursorToPosition(pos);\n            else if (mode == \"anchor\")\n                editor.selection.setSelectionAnchor(pos.row, pos.column);\n            editor.renderer.scrollCursorIntoView(pos);\n            e.preventDefault();\n        }\n    }, editor);\n    function animate() {\n        animationSteps += 60;\n        animationTimer = setInterval(function () {\n            if (animationSteps-- <= 0) {\n                clearInterval(animationTimer);\n                animationTimer = null;\n            }\n            if (Math.abs(vX) < 0.01)\n                vX = 0;\n            if (Math.abs(vY) < 0.01)\n                vY = 0;\n            if (animationSteps < 20)\n                vX = 0.9 * vX;\n            if (animationSteps < 20)\n                vY = 0.9 * vY;\n            var oldScrollTop = editor.session.getScrollTop();\n            editor.renderer.scrollBy(10 * vX, 10 * vY);\n            if (oldScrollTop == editor.session.getScrollTop())\n                animationSteps = 0;\n        }, 10);\n    }\n};\n\n});\n\nace.define(\"ace/mouse/mouse_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/mouse/default_handlers\",\"ace/mouse/default_gutter_handler\",\"ace/mouse/mouse_event\",\"ace/mouse/dragdrop_handler\",\"ace/mouse/touch_handler\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar DefaultHandlers = require(\"./default_handlers\").DefaultHandlers;\nvar DefaultGutterHandler = require(\"./default_gutter_handler\").GutterHandler;\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar DragdropHandler = require(\"./dragdrop_handler\").DragdropHandler;\nvar addTouchListeners = require(\"./touch_handler\").addTouchListeners;\nvar config = require(\"../config\");\nvar MouseHandler = /** @class */ (function () {\n    function MouseHandler(editor) { this.$dragDelay; this.$dragEnabled; this.$mouseMoved; this.mouseEvent; this.$focusTimeout;\n        var _self = this;\n        this.editor = editor;\n        new DefaultHandlers(this);\n        new DefaultGutterHandler(this);\n        new DragdropHandler(this);\n        var focusEditor = function (e) {\n            var windowBlurred = !document.hasFocus || !document.hasFocus()\n                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());\n            if (windowBlurred)\n                window.focus();\n            editor.focus();\n            setTimeout(function () {\n                if (!editor.isFocused())\n                    editor.focus();\n            });\n        };\n        var mouseTarget = editor.renderer.getMouseEventTarget();\n        event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"), editor);\n        event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"), editor);\n        event.addMultiMouseDownListener([\n            mouseTarget,\n            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,\n            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,\n            editor.textInput && editor.textInput.getElement()\n        ].filter(Boolean), [400, 300, 250], this, \"onMouseEvent\", editor);\n        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, \"mousewheel\"), editor);\n        addTouchListeners(editor.container, editor);\n        var gutterEl = editor.renderer.$gutter;\n        event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"), editor);\n        event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"), editor);\n        event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"), editor);\n        event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"), editor);\n        event.addListener(mouseTarget, \"mousedown\", focusEditor, editor);\n        event.addListener(gutterEl, \"mousedown\", focusEditor, editor);\n        if (useragent.isIE && editor.renderer.scrollBarV) {\n            event.addListener(editor.renderer.scrollBarV.element, \"mousedown\", focusEditor, editor);\n            event.addListener(editor.renderer.scrollBarH.element, \"mousedown\", focusEditor, editor);\n        }\n        editor.on(\"mousemove\", function (e) {\n            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)\n                return;\n            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);\n            var range = editor.session.selection.getRange();\n            var renderer = editor.renderer;\n            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {\n                renderer.setCursorStyle(\"default\");\n            }\n            else {\n                renderer.setCursorStyle(\"\");\n            }\n        }, //@ts-expect-error TODO: seems mistyping - should be boolean\n        editor);\n    }\n    MouseHandler.prototype.onMouseEvent = function (name, e) {\n        if (!this.editor.session)\n            return;\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n    MouseHandler.prototype.onMouseMove = function (name, e) {\n        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;\n        if (!listeners || !listeners.length)\n            return;\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n    MouseHandler.prototype.onMouseWheel = function (name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n        this.editor._emit(name, mouseEvent);\n    };\n    MouseHandler.prototype.setState = function (state) {\n        this.state = state;\n    };\n    MouseHandler.prototype.captureMouse = function (ev, mouseMoveHandler) {\n        this.x = ev.x;\n        this.y = ev.y;\n        this.isMousePressed = true;\n        var editor = this.editor;\n        var renderer = this.editor.renderer;\n        renderer.$isMousePressed = true;\n        var self = this;\n        var onMouseMove = function (e) {\n            if (!e)\n                return;\n            if (useragent.isWebKit && !e.which && self.releaseMouse)\n                return self.releaseMouse();\n            self.x = e.clientX;\n            self.y = e.clientY;\n            mouseMoveHandler && mouseMoveHandler(e);\n            self.mouseEvent = new MouseEvent(e, self.editor);\n            self.$mouseMoved = true;\n        };\n        var onCaptureEnd = function (e) {\n            editor.off(\"beforeEndOperation\", onOperationEnd);\n            clearInterval(timerId);\n            if (editor.session)\n                onCaptureInterval();\n            self[self.state + \"End\"] && self[self.state + \"End\"](e);\n            self.state = \"\";\n            self.isMousePressed = renderer.$isMousePressed = false;\n            if (renderer.$keepTextAreaAtCursor)\n                renderer.$moveTextAreaToCursor();\n            self.$onCaptureMouseMove = self.releaseMouse = null;\n            e && self.onMouseEvent(\"mouseup\", e);\n            editor.endOperation();\n        };\n        var onCaptureInterval = function () {\n            self[self.state] && self[self.state]();\n            self.$mouseMoved = false;\n        };\n        if (useragent.isOldIE && ev.domEvent.type == \"dblclick\") {\n            return setTimeout(function () { onCaptureEnd(ev); });\n        }\n        var onOperationEnd = function (e) {\n            if (!self.releaseMouse)\n                return;\n            if (editor.curOp.command.name && editor.curOp.selectionChanged) {\n                self[self.state + \"End\"] && self[self.state + \"End\"]();\n                self.state = \"\";\n                self.releaseMouse();\n            }\n        };\n        editor.on(\"beforeEndOperation\", onOperationEnd);\n        editor.startOperation({ command: { name: \"mouse\" } });\n        self.$onCaptureMouseMove = onMouseMove;\n        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);\n        var timerId = setInterval(onCaptureInterval, 20);\n    };\n    MouseHandler.prototype.cancelContextMenu = function () {\n        var stop = function (e) {\n            if (e && e.domEvent && e.domEvent.type != \"contextmenu\")\n                return;\n            this.editor.off(\"nativecontextmenu\", stop);\n            if (e && e.domEvent)\n                event.stopEvent(e.domEvent);\n        }.bind(this);\n        setTimeout(stop, 10);\n        this.editor.on(\"nativecontextmenu\", stop);\n    };\n    MouseHandler.prototype.destroy = function () {\n        if (this.releaseMouse)\n            this.releaseMouse();\n    };\n    return MouseHandler;\n}());\nMouseHandler.prototype.releaseMouse = null;\nconfig.defineOptions(MouseHandler.prototype, \"mouseHandler\", {\n    scrollSpeed: { initialValue: 2 },\n    dragDelay: { initialValue: (useragent.isMac ? 150 : 0) },\n    dragEnabled: { initialValue: true },\n    focusTimeout: { initialValue: 0 },\n    tooltipFollowsMouse: { initialValue: true }\n});\nexports.MouseHandler = MouseHandler;\n\n});\n\nace.define(\"ace/mouse/fold_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar FoldHandler = /** @class */ (function () {\n    function FoldHandler(editor) {\n        editor.on(\"click\", function (e) {\n            var position = e.getDocumentPosition();\n            var session = editor.session;\n            var fold = session.getFoldAt(position.row, position.column, 1);\n            if (fold) {\n                if (e.getAccelKey())\n                    session.removeFold(fold);\n                else\n                    session.expandFold(fold);\n                e.stop();\n            }\n            var target = e.domEvent && e.domEvent.target;\n            if (target && dom.hasCssClass(target, \"ace_inline_button\")) {\n                if (dom.hasCssClass(target, \"ace_toggle_wrap\")) {\n                    session.setOption(\"wrap\", !session.getUseWrapMode());\n                    editor.renderer.scrollCursorIntoView();\n                }\n            }\n        });\n        editor.on(\"gutterclick\", function (e) {\n            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n            if (gutterRegion == \"foldWidgets\") {\n                var row = e.getDocumentPosition().row;\n                var session = editor.session;\n                if (session.foldWidgets && session.foldWidgets[row])\n                    editor.session.onFoldWidgetClick(row, e);\n                if (!editor.isFocused())\n                    editor.focus();\n                e.stop();\n            }\n        });\n        editor.on(\"gutterdblclick\", function (e) {\n            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n            if (gutterRegion == \"foldWidgets\") {\n                var row = e.getDocumentPosition().row;\n                var session = editor.session;\n                var data = session.getParentFoldRangeData(row, true);\n                var range = data.range || data.firstRange;\n                if (range) {\n                    row = range.start.row;\n                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);\n                    if (fold) {\n                        session.removeFold(fold);\n                    }\n                    else {\n                        session.addFold(\"...\", range);\n                        editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });\n                    }\n                }\n                e.stop();\n            }\n        });\n    }\n    return FoldHandler;\n}());\nexports.FoldHandler = FoldHandler;\n\n});\n\nace.define(\"ace/keyboard/keybinding\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/event\"], function(require, exports, module){\"use strict\";\nvar keyUtil = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\nvar KeyBinding = /** @class */ (function () {\n    function KeyBinding(editor) {\n        this.$editor = editor;\n        this.$data = { editor: editor };\n        this.$handlers = [];\n        this.setDefaultHandler(editor.commands);\n    }\n    KeyBinding.prototype.setDefaultHandler = function (kb) {\n        this.removeKeyboardHandler(this.$defaultHandler);\n        this.$defaultHandler = kb;\n        this.addKeyboardHandler(kb, 0);\n    };\n    KeyBinding.prototype.setKeyboardHandler = function (kb) {\n        var h = this.$handlers;\n        if (h[h.length - 1] == kb)\n            return;\n        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)\n            this.removeKeyboardHandler(h[h.length - 1]);\n        this.addKeyboardHandler(kb, 1);\n    };\n    KeyBinding.prototype.addKeyboardHandler = function (kb, pos) {\n        if (!kb)\n            return;\n        if (typeof kb == \"function\" && !kb.handleKeyboard)\n            kb.handleKeyboard = kb;\n        var i = this.$handlers.indexOf(kb);\n        if (i != -1)\n            this.$handlers.splice(i, 1);\n        if (pos == undefined)\n            this.$handlers.push(kb);\n        else\n            this.$handlers.splice(pos, 0, kb);\n        if (i == -1 && kb.attach)\n            kb.attach(this.$editor);\n    };\n    KeyBinding.prototype.removeKeyboardHandler = function (kb) {\n        var i = this.$handlers.indexOf(kb);\n        if (i == -1)\n            return false;\n        this.$handlers.splice(i, 1);\n        kb.detach && kb.detach(this.$editor);\n        return true;\n    };\n    KeyBinding.prototype.getKeyboardHandler = function () {\n        return this.$handlers[this.$handlers.length - 1];\n    };\n    KeyBinding.prototype.getStatusText = function () {\n        var data = this.$data;\n        var editor = data.editor;\n        return this.$handlers.map(function (h) {\n            return h.getStatusText && h.getStatusText(editor, data) || \"\";\n        }).filter(Boolean).join(\" \");\n    };\n    KeyBinding.prototype.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {\n        var toExecute;\n        var success = false;\n        var commands = this.$editor.commands;\n        for (var i = this.$handlers.length; i--;) {\n            toExecute = this.$handlers[i].handleKeyboard(\n            this.$data, hashId, keyString, keyCode, e);\n            if (!toExecute || !toExecute.command)\n                continue;\n            if (toExecute.command == \"null\") {\n                success = true;\n            }\n            else {\n                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);\n            }\n            if (success && e && hashId != -1 &&\n                toExecute[\"passEvent\"] != true && toExecute.command[\"passEvent\"] != true) {\n                event.stopEvent(e);\n            }\n            if (success)\n                break;\n        }\n        if (!success && hashId == -1) {\n            toExecute = { command: \"insertstring\" };\n            success = commands.exec(\"insertstring\", this.$editor, keyString);\n        }\n        if (success && this.$editor._signal)\n            this.$editor._signal(\"keyboardActivity\", toExecute);\n        return success;\n    };\n    KeyBinding.prototype.onCommandKey = function (e, hashId, keyCode) {\n        var keyString = keyUtil.keyCodeToString(keyCode);\n        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);\n    };\n    KeyBinding.prototype.onTextInput = function (text) {\n        return this.$callKeyboardHandlers(-1, text);\n    };\n    return KeyBinding;\n}());\nexports.KeyBinding = KeyBinding;\n\n});\n\nace.define(\"ace/lib/bidiutil\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar ArabicAlefBetIntervalsBegine = ['\\u0621', '\\u0641'];\nvar ArabicAlefBetIntervalsEnd = ['\\u063A', '\\u064a'];\nvar dir = 0, hiLevel = 0;\nvar lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;\nvar impTab_LTR = [ [0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]\n];\nvar impTab_RTL = [ [2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]\n];\nvar LTR = 0, RTL = 1;\nvar L = 0;\nvar R = 1;\nvar EN = 2;\nvar AN = 3;\nvar ON = 4;\nvar B = 5;\nvar S = 6;\nvar AL = 7;\nvar WS = 8;\nvar CS = 9;\nvar ES = 10;\nvar ET = 11;\nvar NSM = 12;\nvar LRE = 13;\nvar RLE = 14;\nvar PDF = 15;\nvar LRO = 16;\nvar RLO = 17;\nvar BN = 18;\nvar UnicodeTBL00 = [\n    BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN,\n    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S,\n    WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,\n    EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,\n    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,\n    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON,\n    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,\n    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN,\n    BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,\n    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,\n    CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON,\n    ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON\n];\nvar UnicodeTBL20 = [\n    WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R,\n    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,\n    ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS,\n    ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,\n    ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,\n    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS\n];\nfunction _computeLevels(chars, levels, len, charTypes) {\n    var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];\n    if (!charTypes) {\n        for (i = 0, charTypes = []; i < len; i++) {\n            charTypes[i] = _getCharacterType(chars[i]);\n        }\n    }\n    hiLevel = dir;\n    lastArabic = false;\n    hasUBAT_AL = false;\n    hasUBAT_B = false;\n    hasUBAT_S = false;\n    for (ix = 0; ix < len; ix++) {\n        prevState = newState;\n        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);\n        newState = impTab[prevState][newClass];\n        action = newState & 0xF0;\n        newState &= 0x0F;\n        levels[ix] = newLevel = impTab[newState][5];\n        if (action > 0) {\n            if (action == 0x10) {\n                for (i = condPos; i < ix; i++) {\n                    levels[i] = 1;\n                }\n                condPos = -1;\n            }\n            else {\n                condPos = -1;\n            }\n        }\n        cond = impTab[newState][6];\n        if (cond) {\n            if (condPos == -1) {\n                condPos = ix;\n            }\n        }\n        else {\n            if (condPos > -1) {\n                for (i = condPos; i < ix; i++) {\n                    levels[i] = newLevel;\n                }\n                condPos = -1;\n            }\n        }\n        if (charTypes[ix] == B) {\n            levels[ix] = 0;\n        }\n        hiLevel |= newLevel;\n    }\n    if (hasUBAT_S) {\n        for (i = 0; i < len; i++) {\n            if (charTypes[i] == S) {\n                levels[i] = dir;\n                for (var j = i - 1; j >= 0; j--) {\n                    if (charTypes[j] == WS) {\n                        levels[j] = dir;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction _invertLevel(lev, levels, _array) {\n    if (hiLevel < lev) {\n        return;\n    }\n    if (lev == 1 && dir == RTL && !hasUBAT_B) {\n        _array.reverse();\n        return;\n    }\n    var len = _array.length, start = 0, end, lo, hi, tmp;\n    while (start < len) {\n        if (levels[start] >= lev) {\n            end = start + 1;\n            while (end < len && levels[end] >= lev) {\n                end++;\n            }\n            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {\n                tmp = _array[lo];\n                _array[lo] = _array[hi];\n                _array[hi] = tmp;\n            }\n            start = end;\n        }\n        start++;\n    }\n}\nfunction _getCharClass(chars, types, classes, ix) {\n    var cType = types[ix], wType, nType, len, i;\n    switch (cType) {\n        case L:\n        case R:\n            lastArabic = false;\n        case ON:\n        case AN:\n            return cType;\n        case EN:\n            return lastArabic ? AN : EN;\n        case AL:\n            lastArabic = true;\n            hasUBAT_AL = true;\n            return R;\n        case WS:\n            return ON;\n        case CS:\n            if (ix < 1 || (ix + 1) >= types.length ||\n                ((wType = classes[ix - 1]) != EN && wType != AN) ||\n                ((nType = types[ix + 1]) != EN && nType != AN)) {\n                return ON;\n            }\n            if (lastArabic) {\n                nType = AN;\n            }\n            return nType == wType ? nType : ON;\n        case ES:\n            wType = ix > 0 ? classes[ix - 1] : B;\n            if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN) {\n                return EN;\n            }\n            return ON;\n        case ET:\n            if (ix > 0 && classes[ix - 1] == EN) {\n                return EN;\n            }\n            if (lastArabic) {\n                return ON;\n            }\n            i = ix + 1;\n            len = types.length;\n            while (i < len && types[i] == ET) {\n                i++;\n            }\n            if (i < len && types[i] == EN) {\n                return EN;\n            }\n            return ON;\n        case NSM:\n            len = types.length;\n            i = ix + 1;\n            while (i < len && types[i] == NSM) {\n                i++;\n            }\n            if (i < len) {\n                var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;\n                wType = types[i];\n                if (rtlCandidate && (wType == R || wType == AL)) {\n                    return R;\n                }\n            }\n            if (ix < 1 || (wType = types[ix - 1]) == B) {\n                return ON;\n            }\n            return classes[ix - 1];\n        case B:\n            lastArabic = false;\n            hasUBAT_B = true;\n            return dir;\n        case S:\n            hasUBAT_S = true;\n            return ON;\n        case LRE:\n        case RLE:\n        case LRO:\n        case RLO:\n        case PDF:\n            lastArabic = false;\n        case BN:\n            return ON;\n    }\n}\nfunction _getCharacterType(ch) {\n    var uc = ch.charCodeAt(0), hi = uc >> 8;\n    if (hi == 0) {\n        return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);\n    }\n    else if (hi == 5) {\n        return (/[\\u0591-\\u05f4]/.test(ch) ? R : L);\n    }\n    else if (hi == 6) {\n        if (/[\\u0610-\\u061a\\u064b-\\u065f\\u06d6-\\u06e4\\u06e7-\\u06ed]/.test(ch))\n            return NSM;\n        else if (/[\\u0660-\\u0669\\u066b-\\u066c]/.test(ch))\n            return AN;\n        else if (uc == 0x066A)\n            return ET;\n        else if (/[\\u06f0-\\u06f9]/.test(ch))\n            return EN;\n        else\n            return AL;\n    }\n    else if (hi == 0x20 && uc <= 0x205F) {\n        return UnicodeTBL20[uc & 0xFF];\n    }\n    else if (hi == 0xFE) {\n        return (uc >= 0xFE70 ? AL : ON);\n    }\n    return ON;\n}\nfunction _isArabicDiacritics(ch) {\n    return (ch >= '\\u064b' && ch <= '\\u0655');\n}\nexports.L = L;\nexports.R = R;\nexports.EN = EN;\nexports.ON_R = 3;\nexports.AN = 4;\nexports.R_H = 5;\nexports.B = 6;\nexports.RLE = 7;\nexports.DOT = \"\\xB7\";\nexports.doBidiReorder = function (text, textCharTypes, isRtl) {\n    if (text.length < 2)\n        return {};\n    var chars = text.split(\"\"), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];\n    dir = isRtl ? RTL : LTR;\n    _computeLevels(chars, levels, chars.length, textCharTypes);\n    for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)\n        ;\n    _invertLevel(2, levels, logicalFromVisual);\n    _invertLevel(1, levels, logicalFromVisual);\n    for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width\n        if (textCharTypes[i] === AN) {\n            levels[i] = exports.AN;\n        }\n        else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE)\n            || textCharTypes[i] === ON || textCharTypes[i] === BN)) {\n            levels[i] = exports.ON_R;\n        }\n        else if ((i > 0 && chars[i - 1] === '\\u0644') && /\\u0622|\\u0623|\\u0625|\\u0627/.test(chars[i])) {\n            levels[i - 1] = levels[i] = exports.R_H;\n            i++;\n        }\n    }\n    if (chars[chars.length - 1] === exports.DOT)\n        levels[chars.length - 1] = exports.B;\n    if (chars[0] === '\\u202B')\n        levels[0] = exports.RLE;\n    for (var i = 0; i < logicalFromVisual.length; i++) {\n        bidiLevels[i] = levels[logicalFromVisual[i]];\n    }\n    return { 'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels };\n};\nexports.hasBidiCharacters = function (text, textCharTypes) {\n    var ret = false;\n    for (var i = 0; i < text.length; i++) {\n        textCharTypes[i] = _getCharacterType(text.charAt(i));\n        if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))\n            ret = true;\n    }\n    return ret;\n};\nexports.getVisualFromLogicalIdx = function (logIdx, rowMap) {\n    for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {\n        if (rowMap.logicalFromVisual[i] == logIdx)\n            return i;\n    }\n    return 0;\n};\n\n});\n\nace.define(\"ace/bidihandler\",[\"require\",\"exports\",\"module\",\"ace/lib/bidiutil\",\"ace/lib/lang\"], function(require, exports, module){\"use strict\";\nvar bidiUtil = require(\"./lib/bidiutil\");\nvar lang = require(\"./lib/lang\");\nvar bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\u202B]/;\nvar BidiHandler = /** @class */ (function () {\n    function BidiHandler(session) {\n        this.session = session;\n        this.bidiMap = {};\n        this.currentRow = null;\n        this.bidiUtil = bidiUtil;\n        this.charWidths = [];\n        this.EOL = \"\\xAC\";\n        this.showInvisibles = true;\n        this.isRtlDir = false;\n        this.$isRtl = false;\n        this.line = \"\";\n        this.wrapIndent = 0;\n        this.EOF = \"\\xB6\";\n        this.RLE = \"\\u202B\";\n        this.contentWidth = 0;\n        this.fontMetrics = null;\n        this.rtlLineOffset = 0;\n        this.wrapOffset = 0;\n        this.isMoveLeftOperation = false;\n        this.seenBidi = bidiRE.test(session.getValue());\n    }\n    BidiHandler.prototype.isBidiRow = function (screenRow, docRow, splitIndex) {\n        if (!this.seenBidi)\n            return false;\n        if (screenRow !== this.currentRow) {\n            this.currentRow = screenRow;\n            this.updateRowLine(docRow, splitIndex);\n            this.updateBidiMap();\n        }\n        return this.bidiMap.bidiLevels;\n    };\n    BidiHandler.prototype.onChange = function (delta) {\n        if (!this.seenBidi) {\n            if (delta.action == \"insert\" && bidiRE.test(delta.lines.join(\"\\n\"))) {\n                this.seenBidi = true;\n                this.currentRow = null;\n            }\n        }\n        else {\n            this.currentRow = null;\n        }\n    };\n    BidiHandler.prototype.getDocumentRow = function () {\n        var docRow = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            if (index >= 0)\n                docRow = this.session.$docRowCache[index];\n        }\n        return docRow;\n    };\n    BidiHandler.prototype.getSplitIndex = function () {\n        var splitIndex = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            while (this.currentRow - splitIndex > 0) {\n                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);\n                if (currentIndex !== prevIndex)\n                    break;\n                prevIndex = currentIndex;\n                splitIndex++;\n            }\n        }\n        else {\n            splitIndex = this.currentRow;\n        }\n        return splitIndex;\n    };\n    BidiHandler.prototype.updateRowLine = function (docRow, splitIndex) {\n        if (docRow === undefined)\n            docRow = this.getDocumentRow();\n        var isLastRow = (docRow === this.session.getLength() - 1), endOfLine = isLastRow ? this.EOF : this.EOL;\n        this.wrapIndent = 0;\n        this.line = this.session.getLine(docRow);\n        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;\n        if (this.session.$useWrapMode) {\n            var splits = this.session.$wrapData[docRow];\n            if (splits) {\n                if (splitIndex === undefined)\n                    splitIndex = this.getSplitIndex();\n                if (splitIndex > 0 && splits.length) {\n                    this.wrapIndent = splits.indent;\n                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];\n                    this.line = (splitIndex < splits.length) ?\n                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :\n                        this.line.substring(splits[splits.length - 1]);\n                }\n                else {\n                    this.line = this.line.substring(0, splits[splitIndex]);\n                }\n                if (splitIndex == splits.length) {\n                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;\n                }\n            }\n        }\n        else {\n            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;\n        }\n        var session = this.session, shift = 0, size;\n        this.line = this.line.replace(/\\t|[\\u1100-\\u2029, \\u202F-\\uFFE6]/g, function (ch, i) {\n            if (ch === '\\t' || session.isFullWidth(ch.charCodeAt(0))) {\n                size = (ch === '\\t') ? session.getScreenTabSize(i + shift) : 2;\n                shift += size - 1;\n                return lang.stringRepeat(bidiUtil.DOT, size);\n            }\n            return ch;\n        });\n        if (this.isRtlDir) {\n            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;\n            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;\n        }\n    };\n    BidiHandler.prototype.updateBidiMap = function () {\n        var textCharTypes = [];\n        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {\n            this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);\n        }\n        else {\n            this.bidiMap = {};\n        }\n    };\n    BidiHandler.prototype.markAsDirty = function () {\n        this.currentRow = null;\n    };\n    BidiHandler.prototype.updateCharacterWidths = function (fontMetrics) {\n        if (this.characterWidth === fontMetrics.$characterSize.width)\n            return;\n        this.fontMetrics = fontMetrics;\n        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;\n        var bidiCharWidth = fontMetrics.$measureCharWidth(\"\\u05d4\");\n        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;\n        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;\n        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;\n        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;\n        this.currentRow = null;\n    };\n    BidiHandler.prototype.setShowInvisibles = function (showInvisibles) {\n        this.showInvisibles = showInvisibles;\n        this.currentRow = null;\n    };\n    BidiHandler.prototype.setEolChar = function (eolChar) {\n        this.EOL = eolChar;\n    };\n    BidiHandler.prototype.setContentWidth = function (width) {\n        this.contentWidth = width;\n    };\n    BidiHandler.prototype.isRtlLine = function (row) {\n        if (this.$isRtl)\n            return true;\n        if (row != undefined)\n            return (this.session.getLine(row).charAt(0) == this.RLE);\n        else\n            return this.isRtlDir;\n    };\n    BidiHandler.prototype.setRtlDirection = function (editor, isRtlDir) {\n        var cursor = editor.getCursorPosition();\n        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {\n            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)\n                editor.session.doc.removeInLine(row, 0, 1);\n            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)\n                editor.session.doc.insert({ column: 0, row: row }, editor.session.$bidiHandler.RLE);\n        }\n    };\n    BidiHandler.prototype.getPosLeft = function (col) {\n        col -= this.wrapIndent;\n        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;\n        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;\n        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;\n        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)\n            visualIdx++;\n        for (var i = 0; i < visualIdx; i++) {\n            left += this.charWidths[levels[i]];\n        }\n        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))\n            left += this.charWidths[levels[visualIdx]];\n        if (this.wrapIndent)\n            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n        if (this.isRtlDir)\n            left += this.rtlLineOffset;\n        return left;\n    };\n    BidiHandler.prototype.getSelections = function (startCol, endCol) {\n        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;\n        if (this.wrapIndent)\n            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {\n            logIdx = map.logicalFromVisual[visIdx];\n            level = levels[visIdx];\n            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);\n            if (isSelected && !isSelectedPrev) {\n                selectionStart = offset;\n            }\n            else if (!isSelected && isSelectedPrev) {\n                selections.push({ left: selectionStart, width: offset - selectionStart });\n            }\n            offset += this.charWidths[level];\n            isSelectedPrev = isSelected;\n        }\n        if (isSelected && (visIdx === levels.length)) {\n            selections.push({ left: selectionStart, width: offset - selectionStart });\n        }\n        if (this.isRtlDir) {\n            for (var i = 0; i < selections.length; i++) {\n                selections[i].left += this.rtlLineOffset;\n            }\n        }\n        return selections;\n    };\n    BidiHandler.prototype.offsetToCol = function (posX) {\n        if (this.isRtlDir)\n            posX -= this.rtlLineOffset;\n        var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];\n        if (this.wrapIndent)\n            posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n        while (posX > offset + charWidth / 2) {\n            offset += charWidth;\n            if (visualIdx === levels.length - 1) {\n                charWidth = 0;\n                break;\n            }\n            charWidth = this.charWidths[levels[++visualIdx]];\n        }\n        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)) {\n            if (posX < offset)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n        else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)) {\n            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]\n                : this.bidiMap.logicalFromVisual[visualIdx - 1]);\n        }\n        else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))\n            || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))) {\n            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];\n        }\n        else {\n            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n        if (logicalIdx === 0 && this.isRtlDir)\n            logicalIdx++;\n        return (logicalIdx + this.wrapIndent);\n    };\n    return BidiHandler;\n}());\nexports.BidiHandler = BidiHandler;\n\n});\n\nace.define(\"ace/selection\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Selection = /** @class */ (function () {\n    function Selection(session) {\n        this.session = session;\n        this.doc = session.getDocument();\n        this.clearSelection();\n        this.cursor = this.lead = this.doc.createAnchor(0, 0);\n        this.anchor = this.doc.createAnchor(0, 0);\n        this.$silent = false;\n        var self = this;\n        this.cursor.on(\"change\", function (e) {\n            self.$cursorChanged = true;\n            if (!self.$silent)\n                self._emit(\"changeCursor\");\n            if (!self.$isEmpty && !self.$silent)\n                self._emit(\"changeSelection\");\n            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)\n                self.$desiredColumn = null;\n        });\n        this.anchor.on(\"change\", function () {\n            self.$anchorChanged = true;\n            if (!self.$isEmpty && !self.$silent)\n                self._emit(\"changeSelection\");\n        });\n    }\n    Selection.prototype.isEmpty = function () {\n        return this.$isEmpty || (this.anchor.row == this.lead.row &&\n            this.anchor.column == this.lead.column);\n    };\n    Selection.prototype.isMultiLine = function () {\n        return !this.$isEmpty && this.anchor.row != this.cursor.row;\n    };\n    Selection.prototype.getCursor = function () {\n        return this.lead.getPosition();\n    };\n    Selection.prototype.setAnchor = function (row, column) {\n        this.$isEmpty = false;\n        this.anchor.setPosition(row, column);\n    };\n    Selection.prototype.getAnchor = function () {\n        if (this.$isEmpty)\n            return this.getSelectionLead();\n        return this.anchor.getPosition();\n    };\n    Selection.prototype.getSelectionLead = function () {\n        return this.lead.getPosition();\n    };\n    Selection.prototype.isBackwards = function () {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));\n    };\n    Selection.prototype.getRange = function () {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        if (this.$isEmpty)\n            return Range.fromPoints(lead, lead);\n        return this.isBackwards()\n            ? Range.fromPoints(lead, anchor)\n            : Range.fromPoints(anchor, lead);\n    };\n    Selection.prototype.clearSelection = function () {\n        if (!this.$isEmpty) {\n            this.$isEmpty = true;\n            this._emit(\"changeSelection\");\n        }\n    };\n    Selection.prototype.selectAll = function () {\n        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);\n    };\n    Selection.prototype.setRange = function (range, reverse) {\n        var start = reverse ? range.end : range.start;\n        var end = reverse ? range.start : range.end;\n        this.$setSelection(start.row, start.column, end.row, end.column);\n    };\n    Selection.prototype.$setSelection = function (anchorRow, anchorColumn, cursorRow, cursorColumn) {\n        if (this.$silent)\n            return;\n        var wasEmpty = this.$isEmpty;\n        var wasMultiselect = this.inMultiSelectMode;\n        this.$silent = true;\n        this.$cursorChanged = this.$anchorChanged = false;\n        this.anchor.setPosition(anchorRow, anchorColumn);\n        this.cursor.setPosition(cursorRow, cursorColumn);\n        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);\n        this.$silent = false;\n        if (this.$cursorChanged)\n            this._emit(\"changeCursor\");\n        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)\n            this._emit(\"changeSelection\");\n    };\n    Selection.prototype.$moveSelection = function (mover) {\n        var lead = this.lead;\n        if (this.$isEmpty)\n            this.setSelectionAnchor(lead.row, lead.column);\n        mover.call(this);\n    };\n    Selection.prototype.selectTo = function (row, column) {\n        this.$moveSelection(function () {\n            this.moveCursorTo(row, column);\n        });\n    };\n    Selection.prototype.selectToPosition = function (pos) {\n        this.$moveSelection(function () {\n            this.moveCursorToPosition(pos);\n        });\n    };\n    Selection.prototype.moveTo = function (row, column) {\n        this.clearSelection();\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.moveToPosition = function (pos) {\n        this.clearSelection();\n        this.moveCursorToPosition(pos);\n    };\n    Selection.prototype.selectUp = function () {\n        this.$moveSelection(this.moveCursorUp);\n    };\n    Selection.prototype.selectDown = function () {\n        this.$moveSelection(this.moveCursorDown);\n    };\n    Selection.prototype.selectRight = function () {\n        this.$moveSelection(this.moveCursorRight);\n    };\n    Selection.prototype.selectLeft = function () {\n        this.$moveSelection(this.moveCursorLeft);\n    };\n    Selection.prototype.selectLineStart = function () {\n        this.$moveSelection(this.moveCursorLineStart);\n    };\n    Selection.prototype.selectLineEnd = function () {\n        this.$moveSelection(this.moveCursorLineEnd);\n    };\n    Selection.prototype.selectFileEnd = function () {\n        this.$moveSelection(this.moveCursorFileEnd);\n    };\n    Selection.prototype.selectFileStart = function () {\n        this.$moveSelection(this.moveCursorFileStart);\n    };\n    Selection.prototype.selectWordRight = function () {\n        this.$moveSelection(this.moveCursorWordRight);\n    };\n    Selection.prototype.selectWordLeft = function () {\n        this.$moveSelection(this.moveCursorWordLeft);\n    };\n    Selection.prototype.getWordRange = function (row, column) {\n        if (typeof column == \"undefined\") {\n            var cursor = row || this.lead;\n            row = cursor.row;\n            column = cursor.column;\n        }\n        return this.session.getWordRange(row, column);\n    };\n    Selection.prototype.selectWord = function () {\n        this.setSelectionRange(this.getWordRange());\n    };\n    Selection.prototype.selectAWord = function () {\n        var cursor = this.getCursor();\n        var range = this.session.getAWordRange(cursor.row, cursor.column);\n        this.setSelectionRange(range);\n    };\n    Selection.prototype.getLineRange = function (row, excludeLastChar) {\n        var rowStart = typeof row == \"number\" ? row : this.lead.row;\n        var rowEnd;\n        var foldLine = this.session.getFoldLine(rowStart);\n        if (foldLine) {\n            rowStart = foldLine.start.row;\n            rowEnd = foldLine.end.row;\n        }\n        else {\n            rowEnd = rowStart;\n        }\n        if (excludeLastChar === true)\n            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);\n        else\n            return new Range(rowStart, 0, rowEnd + 1, 0);\n    };\n    Selection.prototype.selectLine = function () {\n        this.setSelectionRange(this.getLineRange());\n    };\n    Selection.prototype.moveCursorUp = function () {\n        this.moveCursorBy(-1, 0);\n    };\n    Selection.prototype.moveCursorDown = function () {\n        this.moveCursorBy(1, 0);\n    };\n    Selection.prototype.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {\n        var start = cursor.column;\n        var end = cursor.column + tabSize;\n        if (direction < 0) {\n            start = cursor.column - tabSize;\n            end = cursor.column;\n        }\n        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(\" \").length - 1 == tabSize;\n    };\n    Selection.prototype.moveCursorLeft = function () {\n        var cursor = this.lead.getPosition(), fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n        }\n        else if (cursor.column === 0) {\n            if (cursor.row > 0) {\n                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, -tabSize);\n            }\n            else {\n                this.moveCursorBy(0, -1);\n            }\n        }\n    };\n    Selection.prototype.moveCursorRight = function () {\n        var cursor = this.lead.getPosition(), fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n        }\n        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {\n            if (this.lead.row < this.doc.getLength() - 1) {\n                this.moveCursorTo(this.lead.row + 1, 0);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            var cursor = this.lead;\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, tabSize);\n            }\n            else {\n                this.moveCursorBy(0, 1);\n            }\n        }\n    };\n    Selection.prototype.moveCursorLineStart = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var screenRow = this.session.documentToScreenRow(row, column);\n        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);\n        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);\n        var leadingSpace = beforeCursor.match(/^\\s*/);\n        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)\n            firstColumnPosition.column += leadingSpace[0].length;\n        this.moveCursorToPosition(firstColumnPosition);\n    };\n    Selection.prototype.moveCursorLineEnd = function () {\n        var lead = this.lead;\n        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);\n        if (this.lead.column == lineEnd.column) {\n            var line = this.session.getLine(lineEnd.row);\n            if (lineEnd.column == line.length) {\n                var textEnd = line.search(/\\s+$/);\n                if (textEnd > 0)\n                    lineEnd.column = textEnd;\n            }\n        }\n        this.moveCursorTo(lineEnd.row, lineEnd.column);\n    };\n    Selection.prototype.moveCursorFileEnd = function () {\n        var row = this.doc.getLength() - 1;\n        var column = this.doc.getLine(row).length;\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.moveCursorFileStart = function () {\n        this.moveCursorTo(0, 0);\n    };\n    Selection.prototype.moveCursorLongWordRight = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n            return;\n        }\n        if (this.session.nonTokenRe.exec(rightOfCursor)) {\n            column += this.session.nonTokenRe.lastIndex;\n            this.session.nonTokenRe.lastIndex = 0;\n            rightOfCursor = line.substring(column);\n        }\n        if (column >= line.length) {\n            this.moveCursorTo(row, line.length);\n            this.moveCursorRight();\n            if (row < this.doc.getLength() - 1)\n                this.moveCursorWordRight();\n            return;\n        }\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            column += this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.moveCursorLongWordLeft = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n            return;\n        }\n        var str = this.session.getFoldStringAt(row, column, -1);\n        if (str == null) {\n            str = this.doc.getLine(row).substring(0, column);\n        }\n        var leftOfCursor = lang.stringReverse(str);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        if (this.session.nonTokenRe.exec(leftOfCursor)) {\n            column -= this.session.nonTokenRe.lastIndex;\n            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);\n            this.session.nonTokenRe.lastIndex = 0;\n        }\n        if (column <= 0) {\n            this.moveCursorTo(row, 0);\n            this.moveCursorLeft();\n            if (row > 0)\n                this.moveCursorWordLeft();\n            return;\n        }\n        if (this.session.tokenRe.exec(leftOfCursor)) {\n            column -= this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.$shortWordEndIndex = function (rightOfCursor) {\n        var index = 0, ch;\n        var whitespaceRe = /\\s/;\n        var tokenRe = this.session.tokenRe;\n        tokenRe.lastIndex = 0;\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            index = this.session.tokenRe.lastIndex;\n        }\n        else {\n            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                index++;\n            if (index < 1) {\n                tokenRe.lastIndex = 0;\n                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {\n                    tokenRe.lastIndex = 0;\n                    index++;\n                    if (whitespaceRe.test(ch)) {\n                        if (index > 2) {\n                            index--;\n                            break;\n                        }\n                        else {\n                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                                index++;\n                            if (index > 2)\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        tokenRe.lastIndex = 0;\n        return index;\n    };\n    Selection.prototype.moveCursorShortWordRight = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold)\n            return this.moveCursorTo(fold.end.row, fold.end.column);\n        if (column == line.length) {\n            var l = this.doc.getLength();\n            do {\n                row++;\n                rightOfCursor = this.doc.getLine(row);\n            } while (row < l && /^\\s*$/.test(rightOfCursor));\n            if (!/^\\s+/.test(rightOfCursor))\n                rightOfCursor = \"\";\n            column = 0;\n        }\n        var index = this.$shortWordEndIndex(rightOfCursor);\n        this.moveCursorTo(row, column + index);\n    };\n    Selection.prototype.moveCursorShortWordLeft = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1))\n            return this.moveCursorTo(fold.start.row, fold.start.column);\n        var line = this.session.getLine(row).substring(0, column);\n        if (column === 0) {\n            do {\n                row--;\n                line = this.doc.getLine(row);\n            } while (row > 0 && /^\\s*$/.test(line));\n            column = line.length;\n            if (!/\\s+$/.test(line))\n                line = \"\";\n        }\n        var leftOfCursor = lang.stringReverse(line);\n        var index = this.$shortWordEndIndex(leftOfCursor);\n        return this.moveCursorTo(row, column - index);\n    };\n    Selection.prototype.moveCursorWordRight = function () {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordRight();\n        else\n            this.moveCursorShortWordRight();\n    };\n    Selection.prototype.moveCursorWordLeft = function () {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordLeft();\n        else\n            this.moveCursorShortWordLeft();\n    };\n    Selection.prototype.moveCursorBy = function (rows, chars) {\n        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);\n        var offsetX;\n        if (chars === 0) {\n            if (rows !== 0) {\n                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {\n                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);\n                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);\n                }\n                else {\n                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];\n                }\n            }\n            if (this.$desiredColumn)\n                screenPos.column = this.$desiredColumn;\n            else\n                this.$desiredColumn = screenPos.column;\n        }\n        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {\n            var widget = this.session.lineWidgets[this.lead.row];\n            if (rows < 0)\n                rows -= widget.rowsAbove || 0;\n            else if (rows > 0)\n                rows += widget.rowCount - (widget.rowsAbove || 0);\n        }\n        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);\n        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {\n        }\n        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);\n    };\n    Selection.prototype.moveCursorToPosition = function (position) {\n        this.moveCursorTo(position.row, position.column);\n    };\n    Selection.prototype.moveCursorTo = function (row, column, keepDesiredColumn) {\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            row = fold.start.row;\n            column = fold.start.column;\n        }\n        this.$keepDesiredColumnOnChange = true;\n        var line = this.session.getLine(row);\n        if (/[\\uDC00-\\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {\n            if (this.lead.row == row && this.lead.column == column + 1)\n                column = column - 1;\n            else\n                column = column + 1;\n        }\n        this.lead.setPosition(row, column);\n        this.$keepDesiredColumnOnChange = false;\n        if (!keepDesiredColumn)\n            this.$desiredColumn = null;\n    };\n    Selection.prototype.moveCursorToScreen = function (row, column, keepDesiredColumn) {\n        var pos = this.session.screenToDocumentPosition(row, column);\n        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);\n    };\n    Selection.prototype.detach = function () {\n        this.lead.detach();\n        this.anchor.detach();\n    };\n    Selection.prototype.fromOrientedRange = function (range) {\n        this.setSelectionRange(range, range.cursor == range.start);\n        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;\n    };\n    Selection.prototype.toOrientedRange = function (range) {\n        var r = this.getRange();\n        if (range) {\n            range.start.column = r.start.column;\n            range.start.row = r.start.row;\n            range.end.column = r.end.column;\n            range.end.row = r.end.row;\n        }\n        else {\n            range = r;\n        }\n        range.cursor = this.isBackwards() ? range.start : range.end;\n        range.desiredColumn = this.$desiredColumn;\n        return range;\n    };\n    Selection.prototype.getRangeOfMovements = function (func) {\n        var start = this.getCursor();\n        try {\n            func(this);\n            var end = this.getCursor();\n            return Range.fromPoints(start, end);\n        }\n        catch (e) {\n            return Range.fromPoints(start, start);\n        }\n        finally {\n            this.moveCursorToPosition(start);\n        }\n    };\n    Selection.prototype.toJSON = function () {\n        if (this.rangeCount) { var data = this.ranges.map(function (r) {\n                var r1 = r.clone();\n                r1.isBackwards = r.cursor == r.start;\n                return r1;\n            });\n        }\n        else { var data = this.getRange();\n            data.isBackwards = this.isBackwards();\n        }\n        return data;\n    };\n    Selection.prototype.fromJSON = function (data) {\n        if (data.start == undefined) {\n            if (this.rangeList && data.length > 1) {\n                this.toSingleRange(data[0]);\n                for (var i = data.length; i--;) {\n                    var r = Range.fromPoints(data[i].start, data[i].end);\n                    if (data[i].isBackwards)\n                        r.cursor = r.start;\n                    this.addRange(r, true);\n                }\n                return;\n            }\n            else {\n                data = data[0];\n            }\n        }\n        if (this.rangeList)\n            this.toSingleRange(data);\n        this.setSelectionRange(data, data.isBackwards);\n    };\n    Selection.prototype.isEqual = function (data) {\n        if ((data.length || this.rangeCount) && data.length != this.rangeCount)\n            return false;\n        if (!data.length || !this.ranges)\n            return this.getRange().isEqual(data);\n        for (var i = this.ranges.length; i--;) {\n            if (!this.ranges[i].isEqual(data[i]))\n                return false;\n        }\n        return true;\n    };\n    return Selection;\n}());\nSelection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;\nSelection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;\nSelection.prototype.setSelectionRange = Selection.prototype.setRange;\noop.implement(Selection.prototype, EventEmitter);\nexports.Selection = Selection;\n\n});\n\nace.define(\"ace/tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/report_error\"], function(require, exports, module){\"use strict\";\nvar reportError = require(\"./lib/report_error\").reportError;\nvar MAX_TOKEN_COUNT = 2000;\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(rules) {\n        this.splitRegex;\n        this.states = rules;\n        this.regExps = {};\n        this.matchMappings = {};\n        for (var key in this.states) {\n            var state = this.states[key];\n            var ruleRegExps = [];\n            var matchTotal = 0;\n            var mapping = this.matchMappings[key] = { defaultToken: \"text\" };\n            var flag = \"g\";\n            var splitterRurles = [];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.defaultToken)\n                    mapping.defaultToken = rule.defaultToken;\n                if (rule.caseInsensitive && flag.indexOf(\"i\") === -1)\n                    flag += \"i\";\n                if (rule.unicode && flag.indexOf(\"u\") === -1)\n                    flag += \"u\";\n                if (rule.regex == null)\n                    continue;\n                if (rule.regex instanceof RegExp)\n                    rule.regex = rule.regex.toString().slice(1, -1);\n                var adjustedregex = rule.regex;\n                var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n                if (Array.isArray(rule.token)) {\n                    if (rule.token.length == 1 || matchcount == 1) {\n                        rule.token = rule.token[0];\n                    }\n                    else if (matchcount - 1 != rule.token.length) {\n                        this.reportError(\"number of classes and regexp groups doesn't match\", {\n                            rule: rule,\n                            groupCount: matchcount - 1\n                        });\n                        rule.token = rule.token[0];\n                    }\n                    else {\n                        rule.tokenArray = rule.token;\n                        rule.token = null;\n                        rule.onMatch = this.$arrayTokens;\n                    }\n                }\n                else if (typeof rule.token == \"function\" && !rule.onMatch) {\n                    if (matchcount > 1)\n                        rule.onMatch = this.$applyToken;\n                    else\n                        rule.onMatch = rule.token;\n                }\n                if (matchcount > 1) {\n                    if (/\\\\\\d/.test(rule.regex)) {\n                        adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function (match, digit) {\n                            return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n                        });\n                    }\n                    else {\n                        matchcount = 1;\n                        adjustedregex = this.removeCapturingGroups(rule.regex);\n                    }\n                    if (!rule.splitRegex && typeof rule.token != \"string\")\n                        splitterRurles.push(rule); // flag will be known only at the very end\n                }\n                mapping[matchTotal] = i;\n                matchTotal += matchcount;\n                ruleRegExps.push(adjustedregex);\n                if (!rule.onMatch)\n                    rule.onMatch = null;\n            }\n            if (!ruleRegExps.length) {\n                mapping[0] = 0;\n                ruleRegExps.push(\"$\");\n            }\n            splitterRurles.forEach(function (rule) {\n                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n            }, this);\n            this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n        }\n    }\n    Tokenizer.prototype.$setMaxTokenCount = function (m) {\n        MAX_TOKEN_COUNT = m | 0;\n    };\n    Tokenizer.prototype.$applyToken = function (str) {\n        var values = this.splitRegex.exec(str).slice(1);\n        var types = this.token.apply(this, values);\n        if (typeof types === \"string\")\n            return [{ type: types, value: str }];\n        var tokens = [];\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i]\n                };\n        }\n        return tokens;\n    };\n    Tokenizer.prototype.$arrayTokens = function (str) {\n        if (!str)\n            return [];\n        var values = this.splitRegex.exec(str);\n        if (!values)\n            return \"text\";\n        var tokens = [];\n        var types = this.tokenArray;\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i + 1])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i + 1]\n                };\n        }\n        return tokens;\n    };\n    Tokenizer.prototype.removeCapturingGroups = function (src) {\n        var r = src.replace(/\\\\.|\\[(?:\\\\.|[^\\\\\\]])*|\\(\\?[:=!<]|(\\()/g, function (x, y) { return y ? \"(?:\" : x; });\n        return r;\n    };\n    Tokenizer.prototype.createSplitterRegexp = function (src, flag) {\n        if (src.indexOf(\"(?=\") != -1) {\n            var stack = 0;\n            var inChClass = false;\n            var lastCapture = {};\n            src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function (m, esc, parenOpen, parenClose, square, index) {\n                if (inChClass) {\n                    inChClass = square != \"]\";\n                }\n                else if (square) {\n                    inChClass = true;\n                }\n                else if (parenClose) {\n                    if (stack == lastCapture.stack) {\n                        lastCapture.end = index + 1;\n                        lastCapture.stack = -1;\n                    }\n                    stack--;\n                }\n                else if (parenOpen) {\n                    stack++;\n                    if (parenOpen.length != 1) {\n                        lastCapture.stack = stack;\n                        lastCapture.start = index;\n                    }\n                }\n                return m;\n            });\n            if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n        }\n        if (src.charAt(0) != \"^\")\n            src = \"^\" + src;\n        if (src.charAt(src.length - 1) != \"$\")\n            src += \"$\";\n        return new RegExp(src, (flag || \"\").replace(\"g\", \"\"));\n    };\n    Tokenizer.prototype.getLineTokens = function (line, startState) {\n        if (startState && typeof startState != \"string\") {\n            var stack = startState.slice(0);\n            startState = stack[0];\n            if (startState === \"#tmp\") {\n                stack.shift();\n                startState = stack.shift();\n            }\n        }\n        else\n            var stack = [];\n        var currentState = /**@type{string}*/ (startState) || \"start\";\n        var state = this.states[currentState];\n        if (!state) {\n            currentState = \"start\";\n            state = this.states[currentState];\n        }\n        var mapping = this.matchMappings[currentState];\n        var re = this.regExps[currentState];\n        re.lastIndex = 0;\n        var match, tokens = [];\n        var lastIndex = 0;\n        var matchAttempts = 0;\n        var token = { type: null, value: \"\" };\n        while (match = re.exec(line)) {\n            var type = mapping.defaultToken;\n            var rule = null;\n            var value = match[0];\n            var index = re.lastIndex;\n            if (index - value.length > lastIndex) {\n                var skipped = line.substring(lastIndex, index - value.length);\n                if (token.type == type) {\n                    token.value += skipped;\n                }\n                else {\n                    if (token.type)\n                        tokens.push(token);\n                    token = { type: type, value: skipped };\n                }\n            }\n            for (var i = 0; i < match.length - 2; i++) {\n                if (match[i + 1] === undefined)\n                    continue;\n                rule = state[mapping[i]];\n                if (rule.onMatch)\n                    type = rule.onMatch(value, currentState, stack, line);\n                else\n                    type = rule.token;\n                if (rule.next) {\n                    if (typeof rule.next == \"string\") {\n                        currentState = rule.next;\n                    }\n                    else {\n                        currentState = rule.next(currentState, stack);\n                    }\n                    state = this.states[currentState];\n                    if (!state) {\n                        this.reportError(\"state doesn't exist\", currentState);\n                        currentState = \"start\";\n                        state = this.states[currentState];\n                    }\n                    mapping = this.matchMappings[currentState];\n                    lastIndex = index;\n                    re = this.regExps[currentState];\n                    re.lastIndex = index;\n                }\n                if (rule.consumeLineEnd)\n                    lastIndex = index;\n                break;\n            }\n            if (value) {\n                if (typeof type === \"string\") {\n                    if ((!rule || rule.merge !== false) && token.type === type) {\n                        token.value += value;\n                    }\n                    else {\n                        if (token.type)\n                            tokens.push(token);\n                        token = { type: type, value: value };\n                    }\n                }\n                else if (type) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = { type: null, value: \"\" };\n                    for (var i = 0; i < type.length; i++)\n                        tokens.push(type[i]);\n                }\n            }\n            if (lastIndex == line.length)\n                break;\n            lastIndex = index;\n            if (matchAttempts++ > MAX_TOKEN_COUNT) {\n                if (matchAttempts > 2 * line.length) {\n                    this.reportError(\"infinite loop with in ace tokenizer\", {\n                        startState: startState,\n                        line: line\n                    });\n                }\n                while (lastIndex < line.length) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {\n                        value: line.substring(lastIndex, lastIndex += 500),\n                        type: \"overflow\"\n                    };\n                }\n                currentState = \"start\";\n                stack = [];\n                break;\n            }\n        }\n        if (token.type)\n            tokens.push(token);\n        if (stack.length > 1) {\n            if (stack[0] !== currentState)\n                stack.unshift(\"#tmp\", currentState);\n        }\n        return {\n            tokens: tokens,\n            state: stack.length ? stack : currentState\n        };\n    };\n    return Tokenizer;\n}());\nTokenizer.prototype.reportError = reportError;\nexports.Tokenizer = Tokenizer;\n\n});\n\nace.define(\"ace/mode/text_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/deep_copy\"], function(require, exports, module){\"use strict\";\nvar deepCopy = require(\"../lib/deep_copy\").deepCopy;\nvar TextHighlightRules;\nTextHighlightRules = function () {\n    this.$rules = {\n        \"start\": [{\n                token: \"empty_line\",\n                regex: '^$'\n            }, {\n                defaultToken: \"text\"\n            }]\n    };\n};\n(function () {\n    this.addRules = function (rules, prefix) {\n        if (!prefix) {\n            for (var key in rules)\n                this.$rules[key] = rules[key];\n            return;\n        }\n        for (var key in rules) {\n            var state = rules[key];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.next || rule.onMatch) {\n                    if (typeof rule.next == \"string\") {\n                        if (rule.next.indexOf(prefix) !== 0)\n                            rule.next = prefix + rule.next;\n                    }\n                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\n                        rule.nextState = prefix + rule.nextState;\n                }\n            }\n            this.$rules[prefix + key] = state;\n        }\n    };\n    this.getRules = function () {\n        return this.$rules;\n    };\n    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\n        var embedRules = typeof HighlightRules == \"function\"\n            ? new HighlightRules().getRules()\n            : HighlightRules;\n        if (states) {\n            for (var i = 0; i < states.length; i++)\n                states[i] = prefix + states[i];\n        }\n        else {\n            states = [];\n            for (var key in embedRules)\n                states.push(prefix + key);\n        }\n        this.addRules(embedRules, prefix);\n        if (escapeRules) {\n            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\n            for (var i = 0; i < states.length; i++)\n                addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));\n        }\n        if (!this.$embeds)\n            this.$embeds = [];\n        this.$embeds.push(prefix);\n    };\n    this.getEmbeds = function () {\n        return this.$embeds;\n    };\n    var pushState = function (currentState, stack) {\n        if (currentState != \"start\" || stack.length)\n            stack.unshift(this.nextState, currentState);\n        return this.nextState;\n    };\n    var popState = function (currentState, stack) {\n        stack.shift();\n        return stack.shift() || \"start\";\n    };\n    this.normalizeRules = function () {\n        var id = 0;\n        var rules = this.$rules;\n        function processState(key) {\n            var state = rules[key];\n            state[\"processed\"] = true;\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                var toInsert = null;\n                if (Array.isArray(rule)) {\n                    toInsert = rule;\n                    rule = {};\n                }\n                if (!rule.regex && rule.start) {\n                    rule.regex = rule.start;\n                    if (!rule.next)\n                        rule.next = [];\n                    rule.next.push({\n                        defaultToken: rule.token\n                    }, {\n                        token: rule.token + \".end\",\n                        regex: rule.end || rule.start,\n                        next: \"pop\"\n                    });\n                    rule.token = rule.token + \".start\";\n                    rule.push = true;\n                }\n                var next = rule.next || rule.push;\n                if (next && Array.isArray(next)) {\n                    var stateName = rule.stateName;\n                    if (!stateName) {\n                        stateName = rule.token;\n                        if (typeof stateName != \"string\")\n                            stateName = stateName[0] || \"\";\n                        if (rules[stateName])\n                            stateName += id++;\n                    }\n                    rules[stateName] = next;\n                    rule.next = stateName;\n                    processState(stateName);\n                }\n                else if (next == \"pop\") {\n                    rule.next = popState;\n                }\n                if (rule.push) {\n                    rule.nextState = rule.next || rule.push;\n                    rule.next = pushState;\n                    delete rule.push;\n                }\n                if (rule.rules) {\n                    for (var r in rule.rules) {\n                        if (rules[r]) {\n                            if (rules[r].push)\n                                rules[r].push.apply(rules[r], rule.rules[r]);\n                        }\n                        else {\n                            rules[r] = rule.rules[r];\n                        }\n                    }\n                }\n                var includeName = typeof rule == \"string\" ? rule : rule.include;\n                if (includeName) {\n                    if (includeName === \"$self\")\n                        includeName = \"start\";\n                    if (Array.isArray(includeName))\n                        toInsert = includeName.map(function (x) { return rules[x]; });\n                    else\n                        toInsert = rules[includeName];\n                }\n                if (toInsert) {\n                    var args = [i, 1].concat(toInsert);\n                    if (rule.noEscape)\n                        args = args.filter(function (x) { return !x.next; });\n                    state.splice.apply(state, args);\n                    i--;\n                }\n                if (rule.keywordMap) {\n                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive);\n                    delete rule.defaultToken;\n                }\n            }\n        }\n        Object.keys(rules).forEach(processState, this);\n    };\n    this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {\n        var keywords = Object.create(null);\n        this.$keywordList = [];\n        Object.keys(map).forEach(function (className) {\n            var a = map[className];\n            var list = a.split(splitChar || \"|\");\n            for (var i = list.length; i--;) {\n                var word = list[i];\n                this.$keywordList.push(word);\n                if (ignoreCase)\n                    word = word.toLowerCase();\n                keywords[word] = className;\n            }\n        }, this);\n        map = null;\n        return ignoreCase\n            ? function (value) { return keywords[value.toLowerCase()] || defaultToken; }\n            : function (value) { return keywords[value] || defaultToken; };\n    };\n    this.getKeywords = function () {\n        return this.$keywords;\n    };\n}).call(TextHighlightRules.prototype);\nexports.TextHighlightRules = TextHighlightRules;\n\n});\n\nace.define(\"ace/mode/behaviour\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar Behaviour;\nBehaviour = function () {\n    this.$behaviours = {};\n};\n(function () {\n    this.add = function (name, action, callback) {\n        switch (undefined) {\n            case this.$behaviours:\n                this.$behaviours = {};\n            case this.$behaviours[name]:\n                this.$behaviours[name] = {};\n        }\n        this.$behaviours[name][action] = callback;\n    };\n    this.addBehaviours = function (behaviours) {\n        for (var key in behaviours) {\n            for (var action in behaviours[key]) {\n                this.add(key, action, behaviours[key][action]);\n            }\n        }\n    };\n    this.remove = function (name) {\n        if (this.$behaviours && this.$behaviours[name]) {\n            delete this.$behaviours[name];\n        }\n    };\n    this.inherit = function (mode, filter) {\n        if (typeof mode === \"function\") {\n            var behaviours = new mode().getBehaviours(filter);\n        }\n        else {\n            var behaviours = mode.getBehaviours(filter);\n        }\n        this.addBehaviours(behaviours);\n    };\n    this.getBehaviours = function (filter) {\n        if (!filter) {\n            return this.$behaviours;\n        }\n        else {\n            var ret = {};\n            for (var i = 0; i < filter.length; i++) {\n                if (this.$behaviours[filter[i]]) {\n                    ret[filter[i]] = this.$behaviours[filter[i]];\n                }\n            }\n            return ret;\n        }\n    };\n}).call(Behaviour.prototype);\nexports.Behaviour = Behaviour;\n\n});\n\nace.define(\"ace/token_iterator\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"./range\").Range;\nvar TokenIterator = /** @class */ (function () {\n    function TokenIterator(session, initialRow, initialColumn) {\n        this.$session = session;\n        this.$row = initialRow;\n        this.$rowTokens = session.getTokens(initialRow);\n        var token = session.getTokenAt(initialRow, initialColumn);\n        this.$tokenIndex = token ? token.index : -1;\n    }\n    TokenIterator.prototype.stepBackward = function () {\n        this.$tokenIndex -= 1;\n        while (this.$tokenIndex < 0) {\n            this.$row -= 1;\n            if (this.$row < 0) {\n                this.$row = 0;\n                return null;\n            }\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = this.$rowTokens.length - 1;\n        }\n        return this.$rowTokens[this.$tokenIndex];\n    };\n    TokenIterator.prototype.stepForward = function () {\n        this.$tokenIndex += 1;\n        var rowCount;\n        while (this.$tokenIndex >= this.$rowTokens.length) {\n            this.$row += 1;\n            if (!rowCount)\n                rowCount = this.$session.getLength();\n            if (this.$row >= rowCount) {\n                this.$row = rowCount - 1;\n                return null;\n            }\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = 0;\n        }\n        return this.$rowTokens[this.$tokenIndex];\n    };\n    TokenIterator.prototype.getCurrentToken = function () {\n        return this.$rowTokens[this.$tokenIndex];\n    };\n    TokenIterator.prototype.getCurrentTokenRow = function () {\n        return this.$row;\n    };\n    TokenIterator.prototype.getCurrentTokenColumn = function () {\n        var rowTokens = this.$rowTokens;\n        var tokenIndex = this.$tokenIndex;\n        var column = rowTokens[tokenIndex].start;\n        if (column !== undefined)\n            return column;\n        column = 0;\n        while (tokenIndex > 0) {\n            tokenIndex -= 1;\n            column += rowTokens[tokenIndex].value.length;\n        }\n        return column;\n    };\n    TokenIterator.prototype.getCurrentTokenPosition = function () {\n        return { row: this.$row, column: this.getCurrentTokenColumn() };\n    };\n    TokenIterator.prototype.getCurrentTokenRange = function () {\n        var token = this.$rowTokens[this.$tokenIndex];\n        var column = this.getCurrentTokenColumn();\n        return new Range(this.$row, column, this.$row, column + token.value.length);\n    };\n    return TokenIterator;\n}());\nexports.TokenIterator = TokenIterator;\n\n});\n\nace.define(\"ace/mode/behaviour/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\nvar SAFE_INSERT_IN_TOKENS = [\"text\", \"paren.rparen\", \"rparen\", \"paren\", \"punctuation.operator\"];\nvar SAFE_INSERT_BEFORE_TOKENS = [\"text\", \"paren.rparen\", \"rparen\", \"paren\", \"punctuation.operator\", \"comment\"];\nvar context;\nvar contextCache = {};\nvar defaultQuotes = { '\"': '\"', \"'\": \"'\" };\nvar initContext = function (editor) {\n    var id = -1;\n    if (editor.multiSelect) {\n        id = editor.selection.index;\n        if (contextCache.rangeCount != editor.multiSelect.rangeCount)\n            contextCache = { rangeCount: editor.multiSelect.rangeCount };\n    }\n    if (contextCache[id])\n        return context = contextCache[id];\n    context = contextCache[id] = {\n        autoInsertedBrackets: 0,\n        autoInsertedRow: -1,\n        autoInsertedLineEnd: \"\",\n        maybeInsertedBrackets: 0,\n        maybeInsertedRow: -1,\n        maybeInsertedLineStart: \"\",\n        maybeInsertedLineEnd: \"\"\n    };\n};\nvar getWrapped = function (selection, selected, opening, closing) {\n    var rowDiff = selection.end.row - selection.start.row;\n    return {\n        text: opening + selected + closing,\n        selection: [\n            0,\n            selection.start.column + 1,\n            rowDiff,\n            selection.end.column + (rowDiff ? 0 : 1)\n        ]\n    };\n};\nvar CstyleBehaviour;\nCstyleBehaviour = function (options) {\n    options = options || {};\n    this.add(\"braces\", \"insertion\", function (state, action, editor, session, text) {\n        var cursor = editor.getCursorPosition();\n        var line = session.doc.getLine(cursor.row);\n        if (text == '{') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            var token = session.getTokenAt(cursor.row, cursor.column);\n            if (selected !== \"\" && selected !== \"{\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '{', '}');\n            }\n            else if (token && /(?:string)\\.quasi|\\.xml/.test(token.type)) {\n                var excludeTokens = [\n                    /tag\\-(?:open|name)/, /attribute\\-name/\n                ];\n                if (excludeTokens.some(function (el) { return el.test(token.type); }) || /(string)\\.quasi/.test(token.type)\n                    && token.value[cursor.column - token.start - 1] !== '$')\n                    return;\n                CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                return {\n                    text: '{}',\n                    selection: [1, 1]\n                };\n            }\n            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                if (/[\\]\\}\\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {\n                    CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                    return {\n                        text: '{}',\n                        selection: [1, 1]\n                    };\n                }\n                else {\n                    CstyleBehaviour.recordMaybeInsert(editor, session, \"{\");\n                    return {\n                        text: '{',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n        else if (text == '}') {\n            initContext(editor);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == '}') {\n                var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n        else if (text == \"\\n\" || text == \"\\r\\n\") {\n            initContext(editor);\n            var closing = \"\";\n            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {\n                closing = lang.stringRepeat(\"}\", context.maybeInsertedBrackets);\n                CstyleBehaviour.clearMaybeInsertedClosing();\n            }\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === '}') {\n                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');\n                if (!openBracePos)\n                    return null;\n                var next_indent = this.$getIndent(session.getLine(openBracePos.row));\n            }\n            else if (closing) {\n                var next_indent = this.$getIndent(line);\n            }\n            else {\n                CstyleBehaviour.clearMaybeInsertedClosing();\n                return;\n            }\n            var indent = next_indent + session.getTabString();\n            return {\n                text: '\\n' + indent + '\\n' + next_indent + closing,\n                selection: [1, indent.length, 1, indent.length]\n            };\n        }\n        else {\n            CstyleBehaviour.clearMaybeInsertedClosing();\n        }\n    });\n    this.add(\"braces\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '{') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.end.column, range.end.column + 1);\n            if (rightChar == '}') {\n                range.end.column++;\n                return range;\n            }\n            else {\n                context.maybeInsertedBrackets--;\n            }\n        }\n    });\n    this.add(\"parens\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '(') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '(', ')');\n            }\n            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \")\");\n                return {\n                    text: '()',\n                    selection: [1, 1]\n                };\n            }\n        }\n        else if (text == ')') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ')') {\n                var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n    this.add(\"parens\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '(') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ')') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n    this.add(\"brackets\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '[') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '[', ']');\n            }\n            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \"]\");\n                return {\n                    text: '[]',\n                    selection: [1, 1]\n                };\n            }\n        }\n        else if (text == ']') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ']') {\n                var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n    this.add(\"brackets\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '[') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ']') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n    this.add(\"string_dquotes\", \"insertion\", function (state, action, editor, session, text) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        if (text.length == 1 && quotes[text]) {\n            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)\n                return;\n            initContext(editor);\n            var quote = text;\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, quote, quote);\n            }\n            else if (!selected) {\n                var cursor = editor.getCursorPosition();\n                var line = session.doc.getLine(cursor.row);\n                var leftChar = line.substring(cursor.column - 1, cursor.column);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                var token = session.getTokenAt(cursor.row, cursor.column);\n                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);\n                if (leftChar == \"\\\\\" && token && /escape/.test(token.type))\n                    return null;\n                var stringBefore = token && /string|escape/.test(token.type);\n                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);\n                var pair;\n                if (rightChar == quote) {\n                    pair = stringBefore !== stringAfter;\n                    if (pair && /string\\.end/.test(rightToken.type))\n                        pair = false;\n                }\n                else {\n                    if (stringBefore && !stringAfter)\n                        return null; // wrap string with different quote\n                    if (stringBefore && stringAfter)\n                        return null; // do not pair quotes inside strings\n                    var wordRe = session.$mode.tokenRe;\n                    wordRe.lastIndex = 0;\n                    var isWordBefore = wordRe.test(leftChar);\n                    wordRe.lastIndex = 0;\n                    var isWordAfter = wordRe.test(rightChar);\n                    var pairQuotesAfter = session.$mode.$pairQuotesAfter;\n                    var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);\n                    if ((!shouldPairQuotes && isWordBefore) || isWordAfter)\n                        return null; // before or after alphanumeric\n                    if (rightChar && !/[\\s;,.})\\]\\\\]/.test(rightChar))\n                        return null; // there is rightChar and it isn't closing\n                    var charBefore = line[cursor.column - 2];\n                    if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))\n                        return null;\n                    pair = true;\n                }\n                return {\n                    text: pair ? quote + quote : \"\",\n                    selection: [1, 1]\n                };\n            }\n        }\n    });\n    this.add(\"string_dquotes\", \"deletion\", function (state, action, editor, session, range) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n    if (options.closeDocComment !== false) {\n        this.add(\"doc comment end\", \"insertion\", function (state, action, editor, session, text) {\n            if (state === \"doc-start\" && (text === \"\\n\" || text === \"\\r\\n\") && editor.selection.isEmpty()) {\n                var cursor = editor.getCursorPosition();\n                if (cursor.column === 0) {\n                    return;\n                }\n                var line = session.doc.getLine(cursor.row);\n                var nextLine = session.doc.getLine(cursor.row + 1);\n                var tokens = session.getTokens(cursor.row);\n                var index = 0;\n                for (var i = 0; i < tokens.length; i++) {\n                    index += tokens[i].value.length;\n                    var currentToken = tokens[i];\n                    if (index >= cursor.column) {\n                        if (index === cursor.column) {\n                            if (!/\\.doc/.test(currentToken.type)) {\n                                return;\n                            }\n                            if (/\\*\\//.test(currentToken.value)) {\n                                var nextToken = tokens[i + 1];\n                                if (!nextToken || !/\\.doc/.test(nextToken.type)) {\n                                    return;\n                                }\n                            }\n                        }\n                        var cursorPosInToken = cursor.column - (index - currentToken.value.length);\n                        var closeDocPos = currentToken.value.indexOf(\"*/\");\n                        var openDocPos = currentToken.value.indexOf(\"/**\", closeDocPos > -1 ? closeDocPos + 2 : 0);\n                        if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {\n                            return;\n                        }\n                        if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos\n                            && cursorPosInToken <= openDocPos || !/\\.doc/.test(currentToken.type)) {\n                            return;\n                        }\n                        break;\n                    }\n                }\n                var indent = this.$getIndent(line);\n                if (/\\s*\\*/.test(nextLine)) {\n                    if (/^\\s*\\*/.test(line)) {\n                        return {\n                            text: text + indent + \"* \",\n                            selection: [1, 2 + indent.length, 1, 2 + indent.length]\n                        };\n                    }\n                    else {\n                        return {\n                            text: text + indent + \" * \",\n                            selection: [1, 3 + indent.length, 1, 3 + indent.length]\n                        };\n                    }\n                }\n                if (/\\/\\*\\*/.test(line.substring(0, cursor.column))) {\n                    return {\n                        text: text + indent + \" * \" + text + \" \" + indent + \"*/\",\n                        selection: [1, 4 + indent.length, 1, 4 + indent.length]\n                    };\n                }\n            }\n        });\n    }\n};\nCstyleBehaviour.isSaneInsertion = function (editor, session) {\n    var cursor = editor.getCursorPosition();\n    var iterator = new TokenIterator(session, cursor.row, cursor.column);\n    if (!this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS)) {\n        if (/[)}\\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))\n            return true;\n        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);\n        if (!this.$matchTokenType(iterator2.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS))\n            return false;\n    }\n    iterator.stepForward();\n    return iterator.getCurrentTokenRow() !== cursor.row ||\n        this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_BEFORE_TOKENS);\n};\nCstyleBehaviour[\"$matchTokenType\"] = function (token, types) {\n    return types.indexOf(token.type || token) > -1;\n};\nCstyleBehaviour[\"recordAutoInsert\"] = function (editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this[\"isAutoInsertedClosing\"](cursor, line, context.autoInsertedLineEnd[0]))\n        context.autoInsertedBrackets = 0;\n    context.autoInsertedRow = cursor.row;\n    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);\n    context.autoInsertedBrackets++;\n};\nCstyleBehaviour[\"recordMaybeInsert\"] = function (editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this[\"isMaybeInsertedClosing\"](cursor, line))\n        context.maybeInsertedBrackets = 0;\n    context.maybeInsertedRow = cursor.row;\n    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;\n    context.maybeInsertedLineEnd = line.substr(cursor.column);\n    context.maybeInsertedBrackets++;\n};\nCstyleBehaviour[\"isAutoInsertedClosing\"] = function (cursor, line, bracket) {\n    return context.autoInsertedBrackets > 0 &&\n        cursor.row === context.autoInsertedRow &&\n        bracket === context.autoInsertedLineEnd[0] &&\n        line.substr(cursor.column) === context.autoInsertedLineEnd;\n};\nCstyleBehaviour[\"isMaybeInsertedClosing\"] = function (cursor, line) {\n    return context.maybeInsertedBrackets > 0 &&\n        cursor.row === context.maybeInsertedRow &&\n        line.substr(cursor.column) === context.maybeInsertedLineEnd &&\n        line.substr(0, cursor.column) == context.maybeInsertedLineStart;\n};\nCstyleBehaviour[\"popAutoInsertedClosing\"] = function () {\n    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);\n    context.autoInsertedBrackets--;\n};\nCstyleBehaviour[\"clearMaybeInsertedClosing\"] = function () {\n    if (context) {\n        context.maybeInsertedBrackets = 0;\n        context.maybeInsertedRow = -1;\n    }\n};\noop.inherits(CstyleBehaviour, Behaviour);\nexports.CstyleBehaviour = CstyleBehaviour;\n\n});\n\nace.define(\"ace/unicode\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];\nvar code = 0;\nvar str = [];\nfor (var i = 0; i < wordChars.length; i += 2) {\n    str.push(code += wordChars[i]);\n    if (wordChars[i + 1])\n        str.push(45, code += wordChars[i + 1]);\n}\nexports.wordChars = String.fromCharCode.apply(null, str);\n\n});\n\nace.define(\"ace/mode/text\",[\"require\",\"exports\",\"module\",\"ace/config\",\"ace/tokenizer\",\"ace/mode/text_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/unicode\",\"ace/lib/lang\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar config = require(\"../config\");\nvar Tokenizer = require(\"../tokenizer\").Tokenizer;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar unicode = require(\"../unicode\");\nvar lang = require(\"../lib/lang\");\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\nvar Mode;\nMode = function () {\n    this.HighlightRules = TextHighlightRules;\n};\n(function () {\n    this.$defaultBehaviour = new CstyleBehaviour();\n    this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"\\\\$_]+\", \"g\");\n    this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"\\\\$_]|\\\\s])+\", \"g\");\n    this.getTokenizer = function () {\n        if (!this.$tokenizer) {\n            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);\n            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\n        }\n        return this.$tokenizer;\n    };\n    this.lineCommentStart = \"\";\n    this.blockComment = \"\";\n    this.toggleCommentLines = function (state, session, startRow, endRow) {\n        var doc = session.doc;\n        var ignoreBlankLines = true;\n        var shouldRemove = true;\n        var minIndent = Infinity;\n        var tabSize = session.getTabSize();\n        var insertAtTabStop = false;\n        if (!this.lineCommentStart) {\n            if (!this.blockComment)\n                return false;\n            var lineCommentStart = this.blockComment.start;\n            var lineCommentEnd = this.blockComment.end;\n            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\n            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\n            var comment = function (line, i) {\n                if (testRemove(line, i))\n                    return;\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);\n                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);\n                }\n            };\n            var uncomment = function (line, i) {\n                var m;\n                if (m = line.match(regexpEnd))\n                    doc.removeInLine(i, line.length - m[0].length, line.length);\n                if (m = line.match(regexpStart))\n                    doc.removeInLine(i, m[1].length, m[0].length);\n            };\n            var testRemove = function (line, row) {\n                if (regexpStart.test(line))\n                    return true;\n                var tokens = session.getTokens(row);\n                for (var i = 0; i < tokens.length; i++) {\n                    if (tokens[i].type === \"comment\")\n                        return true;\n                }\n            };\n        }\n        else {\n            if (Array.isArray(this.lineCommentStart)) {\n                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\n                var lineCommentStart = this.lineCommentStart[0];\n            }\n            else {\n                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\n                var lineCommentStart = this.lineCommentStart;\n            }\n            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\n            insertAtTabStop = session.getUseSoftTabs();\n            var uncomment = function (line, i) {\n                var m = line.match(regexpStart);\n                if (!m)\n                    return;\n                var start = m[1].length, end = m[0].length;\n                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\n                    end--;\n                doc.removeInLine(i, start, end);\n            };\n            var commentWithSpace = lineCommentStart + \" \";\n            var comment = function (line, i) {\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    if (shouldInsertSpace(line, minIndent, minIndent))\n                        doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);\n                    else\n                        doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);\n                }\n            };\n            var testRemove = function (line, i) {\n                return regexpStart.test(line);\n            };\n            var shouldInsertSpace = function (line, before, after) {\n                var spaces = 0;\n                while (before-- && line.charAt(before) == \" \")\n                    spaces++;\n                if (spaces % tabSize != 0)\n                    return false;\n                var spaces = 0;\n                while (line.charAt(after++) == \" \")\n                    spaces++;\n                if (tabSize > 2)\n                    return spaces % tabSize != tabSize - 1;\n                else\n                    return spaces % tabSize == 0;\n            };\n        }\n        function iter(fun) {\n            for (var i = startRow; i <= endRow; i++)\n                fun(doc.getLine(i), i);\n        }\n        var minEmptyLength = Infinity;\n        iter(function (line, i) {\n            var indent = line.search(/\\S/);\n            if (indent !== -1) {\n                if (indent < minIndent)\n                    minIndent = indent;\n                if (shouldRemove && !testRemove(line, i))\n                    shouldRemove = false;\n            }\n            else if (minEmptyLength > line.length) {\n                minEmptyLength = line.length;\n            }\n        });\n        if (minIndent == Infinity) {\n            minIndent = minEmptyLength;\n            ignoreBlankLines = false;\n            shouldRemove = false;\n        }\n        if (insertAtTabStop && minIndent % tabSize != 0)\n            minIndent = Math.floor(minIndent / tabSize) * tabSize;\n        iter(shouldRemove ? uncomment : comment);\n    };\n    this.toggleBlockComment = function (state, session, range, cursor) {\n        var comment = this.blockComment;\n        if (!comment)\n            return;\n        if (!comment.start && comment[0])\n            comment = comment[0];\n        var iterator = new TokenIterator(session, cursor.row, cursor.column);\n        var token = iterator.getCurrentToken();\n        var sel = session.selection;\n        var initialRange = session.selection.toOrientedRange();\n        var startRow, colDiff;\n        if (token && /comment/.test(token.type)) {\n            var startRange, endRange;\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.start);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    startRange = new Range(row, column, row, column + comment.start.length);\n                    break;\n                }\n                token = iterator.stepBackward();\n            }\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.end);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    endRange = new Range(row, column, row, column + comment.end.length);\n                    break;\n                }\n                token = iterator.stepForward();\n            }\n            if (endRange)\n                session.remove(endRange);\n            if (startRange) {\n                session.remove(startRange);\n                startRow = startRange.start.row;\n                colDiff = -comment.start.length;\n            }\n        }\n        else {\n            colDiff = comment.start.length;\n            startRow = range.start.row;\n            session.insert(range.end, comment.end);\n            session.insert(range.start, comment.start);\n        }\n        if (initialRange.start.row == startRow)\n            initialRange.start.column += colDiff;\n        if (initialRange.end.row == startRow)\n            initialRange.end.column += colDiff;\n        session.selection.fromOrientedRange(initialRange);\n    };\n    this.getNextLineIndent = function (state, line, tab) {\n        return this.$getIndent(line);\n    };\n    this.checkOutdent = function (state, line, input) {\n        return false;\n    };\n    this.autoOutdent = function (state, doc, row) {\n    };\n    this.$getIndent = function (line) {\n        return line.match(/^\\s*/)[0];\n    };\n    this.createWorker = function (session) {\n        return null;\n    };\n    this.createModeDelegates = function (mapping) {\n        this.$embeds = [];\n        this.$modes = {};\n        for (var i in mapping) {\n            if (mapping[i]) {\n                var Mode = mapping[i];\n                var id = Mode.prototype.$id;\n                var mode = config.$modes[id];\n                if (!mode)\n                    config.$modes[id] = mode = new Mode();\n                if (!config.$modes[i])\n                    config.$modes[i] = mode;\n                this.$embeds.push(i);\n                this.$modes[i] = mode;\n            }\n        }\n        var delegations = [\"toggleBlockComment\", \"toggleCommentLines\", \"getNextLineIndent\",\n            \"checkOutdent\", \"autoOutdent\", \"transformAction\", \"getCompletions\"];\n        var _loop_1 = function (i) {\n            (function (scope) {\n                var functionName = delegations[i];\n                var defaultHandler = scope[functionName];\n                scope[delegations[i]] =\n                    function () {\n                        return this.$delegator(functionName, arguments, defaultHandler);\n                    };\n            }(this_1));\n        };\n        var this_1 = this;\n        for (var i = 0; i < delegations.length; i++) {\n            _loop_1(i);\n        }\n    };\n    this.$delegator = function (method, args, defaultHandler) {\n        var state = args[0] || \"start\";\n        if (typeof state != \"string\") {\n            if (Array.isArray(state[2])) {\n                var language = state[2][state[2].length - 1];\n                var mode = this.$modes[language];\n                if (mode)\n                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));\n            }\n            state = state[0] || \"start\";\n        }\n        for (var i = 0; i < this.$embeds.length; i++) {\n            if (!this.$modes[this.$embeds[i]])\n                continue;\n            var split = state.split(this.$embeds[i]);\n            if (!split[0] && split[1]) {\n                args[0] = split[1];\n                var mode = this.$modes[this.$embeds[i]];\n                return mode[method].apply(mode, args);\n            }\n        }\n        var ret = defaultHandler.apply(this, args);\n        return defaultHandler ? ret : undefined;\n    };\n    this.transformAction = function (state, action, editor, session, param) {\n        if (this.$behaviour) {\n            var behaviours = this.$behaviour.getBehaviours();\n            for (var key in behaviours) {\n                if (behaviours[key][action]) {\n                    var ret = behaviours[key][action].apply(this, arguments);\n                    if (ret) {\n                        return ret;\n                    }\n                }\n            }\n        }\n    };\n    this.getKeywords = function (append) {\n        if (!this.completionKeywords) {\n            var rules = this.$tokenizer[\"rules\"];\n            var completionKeywords = [];\n            for (var rule in rules) {\n                var ruleItr = rules[rule];\n                for (var r = 0, l = ruleItr.length; r < l; r++) {\n                    if (typeof ruleItr[r].token === \"string\") {\n                        if (/keyword|support|storage/.test(ruleItr[r].token))\n                            completionKeywords.push(ruleItr[r].regex);\n                    }\n                    else if (typeof ruleItr[r].token === \"object\") {\n                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {\n                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\n                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\n                                completionKeywords.push(rule.substr(1, rule.length - 2));\n                            }\n                        }\n                    }\n                }\n            }\n            this.completionKeywords = completionKeywords;\n        }\n        if (!append)\n            return this.$keywordList;\n        return completionKeywords.concat(this.$keywordList || []);\n    };\n    this.$createKeywordList = function () {\n        if (!this.$highlightRules)\n            this.getTokenizer();\n        return this.$keywordList = this.$highlightRules.$keywordList || [];\n    };\n    this.getCompletions = function (state, session, pos, prefix) {\n        var keywords = this.$keywordList || this.$createKeywordList();\n        return keywords.map(function (word) {\n            return {\n                name: word,\n                value: word,\n                score: 0,\n                meta: \"keyword\"\n            };\n        });\n    };\n    this.$id = \"ace/mode/text\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});\n\nace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nfunction throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\nfunction positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length &&\n        position.column >= 0 && position.column <= docLines[position.row].length;\n}\nfunction validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end)\n        throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\nexports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            }\n            else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            }\n            else {\n                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n            }\n            break;\n    }\n};\n\n});\n\nace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Anchor = /** @class */ (function () {\n    function Anchor(doc, row, column) {\n        this.$onChange = this.onChange.bind(this);\n        this.attach(doc);\n        if (typeof row != \"number\")\n            this.setPosition(row.row, row.column);\n        else\n            this.setPosition(row, column);\n    }\n    Anchor.prototype.getPosition = function () {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n    Anchor.prototype.getDocument = function () {\n        return this.document;\n    };\n    Anchor.prototype.onChange = function (delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n        if (delta.start.row > this.row)\n            return;\n        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    Anchor.prototype.setPosition = function (row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        }\n        else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n    Anchor.prototype.detach = function () {\n        this.document.off(\"change\", this.$onChange);\n    };\n    Anchor.prototype.attach = function (doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n    Anchor.prototype.$clipPositionToDocument = function (row, column) {\n        var pos = {};\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n        if (column < 0)\n            pos.column = 0;\n        return pos;\n    };\n    return Anchor;\n}());\nAnchor.prototype.$insertRight = false;\noop.implement(Anchor.prototype, EventEmitter);\nfunction $pointsInOrder(point1, point2, equalPointsInOrder) {\n    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n    return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n}\nfunction $getTransformedPoint(delta, point, moveIfEqual) {\n    var deltaIsInsert = delta.action == \"insert\";\n    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n    var deltaStart = delta.start;\n    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n            row: point.row,\n            column: point.column\n        };\n    }\n    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n            row: point.row + deltaRowShift,\n            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n    }\n    return {\n        row: deltaStart.row,\n        column: deltaStart.column\n    };\n}\nexports.Anchor = Anchor;\n\n});\n\nace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\nvar Document = /** @class */ (function () {\n    function Document(textOrLines) {\n        this.$lines = [\"\"];\n        if (textOrLines.length === 0) {\n            this.$lines = [\"\"];\n        }\n        else if (Array.isArray(textOrLines)) {\n            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);\n        }\n        else {\n            this.insert({ row: 0, column: 0 }, textOrLines);\n        }\n    }\n    Document.prototype.setValue = function (text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({ row: 0, column: 0 }, text || \"\");\n    };\n    Document.prototype.getValue = function () {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    Document.prototype.createAnchor = function (row, column) {\n        return new Anchor(this, row, column);\n    };\n    Document.prototype.$detectNewLine = function (text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n    Document.prototype.getNewLineCharacter = function () {\n        switch (this.$newLineMode) {\n            case \"windows\":\n                return \"\\r\\n\";\n            case \"unix\":\n                return \"\\n\";\n            default:\n                return this.$autoNewLine || \"\\n\";\n        }\n    };\n    Document.prototype.setNewLineMode = function (newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n    Document.prototype.getNewLineMode = function () {\n        return this.$newLineMode;\n    };\n    Document.prototype.isNewLine = function (text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n    Document.prototype.getLine = function (row) {\n        return this.$lines[row] || \"\";\n    };\n    Document.prototype.getLines = function (firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    Document.prototype.getAllLines = function () {\n        return this.getLines(0, this.getLength());\n    };\n    Document.prototype.getLength = function () {\n        return this.$lines.length;\n    };\n    Document.prototype.getTextRange = function (range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    Document.prototype.getLinesForRange = function (range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        }\n        else {\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n    Document.prototype.insertLines = function (row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    Document.prototype.removeLines = function (firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    Document.prototype.insertNewLine = function (position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    Document.prototype.insert = function (position, text) {\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        return this.insertMergedLines(position, this.$split(text));\n    };\n    Document.prototype.insertInLine = function (position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        return this.clonePos(end);\n    };\n    Document.prototype.clippedPos = function (row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        }\n        else if (row < 0) {\n            row = 0;\n        }\n        else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return { row: row, column: column };\n    };\n    Document.prototype.clonePos = function (pos) {\n        return { row: pos.row, column: pos.column };\n    };\n    Document.prototype.pos = function (row, column) {\n        return { row: row, column: column };\n    };\n    Document.prototype.$clipPosition = function (position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        }\n        else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n    Document.prototype.insertFullLines = function (row, lines) {\n        row = Math.min(Math.max(row, 0), this.getLength());\n        var column = 0;\n        if (row < this.getLength()) {\n            lines = lines.concat([\"\"]);\n            column = 0;\n        }\n        else {\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        this.insertMergedLines({ row: row, column: column }, lines);\n    };\n    Document.prototype.insertMergedLines = function (position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        return this.clonePos(end);\n    };\n    Document.prototype.remove = function (range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        });\n        return this.clonePos(start);\n    };\n    Document.prototype.removeInLine = function (row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        }, true);\n        return this.clonePos(start);\n    };\n    Document.prototype.removeFullLines = function (firstRow, lastRow) {\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine = lastRow < this.getLength() - 1;\n        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);\n        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);\n        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);\n        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);\n        var range = new Range(startRow, startCol, endRow, endCol);\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        return deletedLines;\n    };\n    Document.prototype.removeNewLine = function (row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n    Document.prototype.replace = function (range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n        if (text == this.getTextRange(range))\n            return range.end;\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        return end;\n    };\n    Document.prototype.applyDeltas = function (deltas) {\n        for (var i = 0; i < deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    Document.prototype.revertDeltas = function (deltas) {\n        for (var i = deltas.length - 1; i >= 0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    Document.prototype.applyDelta = function (delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    Document.prototype.$safeApplyDelta = function (delta) {\n        var docLength = this.$lines.length;\n        if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength\n            || delta.action == \"insert\" && delta.start.row <= docLength) {\n            this.applyDelta(delta);\n        }\n    };\n    Document.prototype.$splitAndapplyLargeDelta = function (delta, MAX) {\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row;\n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    Document.prototype.revertDelta = function (delta) {\n        this.$safeApplyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    Document.prototype.indexToPosition = function (index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return { row: i, column: index + lines[i].length + newlineLength };\n        }\n        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };\n    };\n    Document.prototype.positionToIndex = function (pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n        return index + pos.column;\n    };\n    Document.prototype.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n    };\n    return Document;\n}());\nDocument.prototype.$autoNewLine = \"\";\nDocument.prototype.$newLineMode = \"auto\";\noop.implement(Document.prototype, EventEmitter);\nexports.Document = Document;\n\n});\n\nace.define(\"ace/background_tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar BackgroundTokenizer = /** @class */ (function () {\n    function BackgroundTokenizer(tokenizer, session) {\n        this.running = false;\n        this.lines = [];\n        this.states = [];\n        this.currentLine = 0;\n        this.tokenizer = tokenizer;\n        var self = this;\n        this.$worker = function () {\n            if (!self.running) {\n                return;\n            }\n            var workerStart = new Date();\n            var currentLine = self.currentLine;\n            var endLine = -1;\n            var doc = self.doc;\n            var startLine = currentLine;\n            while (self.lines[currentLine])\n                currentLine++;\n            var len = doc.getLength();\n            var processedLines = 0;\n            self.running = false;\n            while (currentLine < len) {\n                self.$tokenizeRow(currentLine);\n                endLine = currentLine;\n                do {\n                    currentLine++;\n                } while (self.lines[currentLine]);\n                processedLines++;\n                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {\n                    self.running = setTimeout(self.$worker, 20);\n                    break;\n                }\n            }\n            self.currentLine = currentLine;\n            if (endLine == -1)\n                endLine = currentLine;\n            if (startLine <= endLine)\n                self.fireUpdateEvent(startLine, endLine);\n        };\n    }\n    BackgroundTokenizer.prototype.setTokenizer = function (tokenizer) {\n        this.tokenizer = tokenizer;\n        this.lines = [];\n        this.states = [];\n        this.start(0);\n    };\n    BackgroundTokenizer.prototype.setDocument = function (doc) {\n        this.doc = doc;\n        this.lines = [];\n        this.states = [];\n        this.stop();\n    };\n    BackgroundTokenizer.prototype.fireUpdateEvent = function (firstRow, lastRow) {\n        var data = {\n            first: firstRow,\n            last: lastRow\n        };\n        this._signal(\"update\", { data: data });\n    };\n    BackgroundTokenizer.prototype.start = function (startRow) {\n        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\n        this.lines.splice(this.currentLine, this.lines.length);\n        this.states.splice(this.currentLine, this.states.length);\n        this.stop();\n        this.running = setTimeout(this.$worker, 700);\n    };\n    BackgroundTokenizer.prototype.scheduleStart = function () {\n        if (!this.running)\n            this.running = setTimeout(this.$worker, 700);\n    };\n    BackgroundTokenizer.prototype.$updateOnChange = function (delta) {\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n        if (len === 0) {\n            this.lines[startRow] = null;\n        }\n        else if (delta.action == \"remove\") {\n            this.lines.splice(startRow, len + 1, null);\n            this.states.splice(startRow, len + 1, null);\n        }\n        else {\n            var args = Array(len + 1);\n            args.unshift(startRow, 1);\n            this.lines.splice.apply(this.lines, args);\n            this.states.splice.apply(this.states, args);\n        }\n        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\n        this.stop();\n    };\n    BackgroundTokenizer.prototype.stop = function () {\n        if (this.running)\n            clearTimeout(this.running);\n        this.running = false;\n    };\n    BackgroundTokenizer.prototype.getTokens = function (row) {\n        return this.lines[row] || this.$tokenizeRow(row);\n    };\n    BackgroundTokenizer.prototype.getState = function (row) {\n        if (this.currentLine == row)\n            this.$tokenizeRow(row);\n        return this.states[row] || \"start\";\n    };\n    BackgroundTokenizer.prototype.$tokenizeRow = function (row) {\n        var line = this.doc.getLine(row);\n        var state = this.states[row - 1];\n        var data = this.tokenizer.getLineTokens(line, state, row);\n        if (this.states[row] + \"\" !== data.state + \"\") {\n            this.states[row] = data.state;\n            this.lines[row + 1] = null;\n            if (this.currentLine > row + 1)\n                this.currentLine = row + 1;\n        }\n        else if (this.currentLine == row) {\n            this.currentLine = row + 1;\n        }\n        return this.lines[row] = data.tokens;\n    };\n    BackgroundTokenizer.prototype.cleanup = function () {\n        this.running = false;\n        this.lines = [];\n        this.states = [];\n        this.currentLine = 0;\n        this.removeAllListeners();\n    };\n    return BackgroundTokenizer;\n}());\noop.implement(BackgroundTokenizer.prototype, EventEmitter);\nexports.BackgroundTokenizer = BackgroundTokenizer;\n\n});\n\nace.define(\"ace/search_highlight\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar lang = require(\"./lib/lang\");\nvar Range = require(\"./range\").Range;\nvar SearchHighlight = /** @class */ (function () {\n    function SearchHighlight(regExp, clazz, type) {\n        if (type === void 0) { type = \"text\"; }\n        this.setRegexp(regExp);\n        this.clazz = clazz;\n        this.type = type;\n    }\n    SearchHighlight.prototype.setRegexp = function (regExp) {\n        if (this.regExp + \"\" == regExp + \"\")\n            return;\n        this.regExp = regExp;\n        this.cache = [];\n    };\n    SearchHighlight.prototype.update = function (html, markerLayer, session, config) {\n        if (!this.regExp)\n            return;\n        var start = config.firstRow, end = config.lastRow;\n        var renderedMarkerRanges = {};\n        for (var i = start; i <= end; i++) {\n            var ranges = this.cache[i];\n            if (ranges == null) {\n                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);\n                if (ranges.length > this.MAX_RANGES)\n                    ranges = ranges.slice(0, this.MAX_RANGES);\n                ranges = ranges.map(function (match) {\n                    return new Range(i, match.offset, i, match.offset + match.length);\n                });\n                this.cache[i] = ranges.length ? ranges : \"\";\n            }\n            for (var j = ranges.length; j--;) {\n                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);\n                var rangeAsString = rangeToAddMarkerTo.toString();\n                if (renderedMarkerRanges[rangeAsString])\n                    continue;\n                renderedMarkerRanges[rangeAsString] = true;\n                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);\n            }\n        }\n    };\n    return SearchHighlight;\n}());\nSearchHighlight.prototype.MAX_RANGES = 500;\nexports.SearchHighlight = SearchHighlight;\n\n});\n\nace.define(\"ace/undomanager\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar UndoManager = /** @class */ (function () {\n    function UndoManager() {\n        this.$keepRedoStack;\n        this.$maxRev = 0;\n        this.$fromUndo = false;\n        this.$undoDepth = Infinity;\n        this.reset();\n    }\n    UndoManager.prototype.addSession = function (session) {\n        this.$session = session;\n    };\n    UndoManager.prototype.add = function (delta, allowMerge, session) {\n        if (this.$fromUndo)\n            return;\n        if (delta == this.$lastDelta)\n            return;\n        if (!this.$keepRedoStack)\n            this.$redoStack.length = 0;\n        if (allowMerge === false || !this.lastDeltas) {\n            this.lastDeltas = [];\n            var undoStackLength = this.$undoStack.length;\n            if (undoStackLength > this.$undoDepth - 1) {\n                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);\n            }\n            this.$undoStack.push(this.lastDeltas);\n            delta.id = this.$rev = ++this.$maxRev;\n        }\n        if (delta.action == \"remove\" || delta.action == \"insert\")\n            this.$lastDelta = delta;\n        this.lastDeltas.push(delta);\n    };\n    UndoManager.prototype.addSelection = function (selection, rev) {\n        this.selections.push({\n            value: selection,\n            rev: rev || this.$rev\n        });\n    };\n    UndoManager.prototype.startNewGroup = function () {\n        this.lastDeltas = null;\n        return this.$rev;\n    };\n    UndoManager.prototype.markIgnored = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n        var stack = this.$undoStack;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id <= from)\n                break;\n            if (delta.id < to)\n                delta.ignore = true;\n        }\n        this.lastDeltas = null;\n    };\n    UndoManager.prototype.getSelection = function (rev, after) {\n        var stack = this.selections;\n        for (var i = stack.length; i--;) {\n            var selection = stack[i];\n            if (selection.rev < rev) {\n                if (after)\n                    selection = stack[i + 1];\n                return selection;\n            }\n        }\n    };\n    UndoManager.prototype.getRevision = function () {\n        return this.$rev;\n    };\n    UndoManager.prototype.getDeltas = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n        var stack = this.$undoStack;\n        var end = null, start = 0;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id < to && !end)\n                end = i + 1;\n            if (delta.id <= from) {\n                start = i + 1;\n                break;\n            }\n        }\n        return stack.slice(start, end);\n    };\n    UndoManager.prototype.getChangedRanges = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n    };\n    UndoManager.prototype.getChangedLines = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n    };\n    UndoManager.prototype.undo = function (session, dontSelect) {\n        this.lastDeltas = null;\n        var stack = this.$undoStack;\n        if (!rearrangeUndoStack(stack, stack.length))\n            return;\n        if (!session)\n            session = this.$session;\n        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)\n            this.$redoStack = [];\n        this.$fromUndo = true;\n        var deltaSet = stack.pop();\n        var undoSelectionRange = null;\n        if (deltaSet) {\n            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);\n            this.$redoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        return undoSelectionRange;\n    };\n    UndoManager.prototype.redo = function (session, dontSelect) {\n        this.lastDeltas = null;\n        if (!session)\n            session = this.$session;\n        this.$fromUndo = true;\n        if (this.$redoStackBaseRev != this.$rev) {\n            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);\n            rebaseRedoStack(this.$redoStack, diff);\n            this.$redoStackBaseRev = this.$rev;\n            this.$redoStack.forEach(function (x) {\n                x[0].id = ++this.$maxRev;\n            }, this);\n        }\n        var deltaSet = this.$redoStack.pop();\n        var redoSelectionRange = null;\n        if (deltaSet) {\n            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);\n            this.$undoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        return redoSelectionRange;\n    };\n    UndoManager.prototype.$syncRev = function () {\n        var stack = this.$undoStack;\n        var nextDelta = stack[stack.length - 1];\n        var id = nextDelta && nextDelta[0].id || 0;\n        this.$redoStackBaseRev = id;\n        this.$rev = id;\n    };\n    UndoManager.prototype.reset = function () {\n        this.lastDeltas = null;\n        this.$lastDelta = null;\n        this.$undoStack = [];\n        this.$redoStack = [];\n        this.$rev = 0;\n        this.mark = 0;\n        this.$redoStackBaseRev = this.$rev;\n        this.selections = [];\n    };\n    UndoManager.prototype.canUndo = function () {\n        return this.$undoStack.length > 0;\n    };\n    UndoManager.prototype.canRedo = function () {\n        return this.$redoStack.length > 0;\n    };\n    UndoManager.prototype.bookmark = function (rev) {\n        if (rev == undefined)\n            rev = this.$rev;\n        this.mark = rev;\n    };\n    UndoManager.prototype.isAtBookmark = function () {\n        return this.$rev === this.mark;\n    };\n    UndoManager.prototype.toJSON = function () {\n        return {\n            $redoStack: this.$redoStack,\n            $undoStack: this.$undoStack\n        };\n    };\n    UndoManager.prototype.fromJSON = function (json) {\n        this.reset();\n        this.$undoStack = json.$undoStack;\n        this.$redoStack = json.$redoStack;\n    };\n    UndoManager.prototype.$prettyPrint = function (delta) {\n        if (delta)\n            return stringifyDelta(delta);\n        return stringifyDelta(this.$undoStack) + \"\\n---\\n\" + stringifyDelta(this.$redoStack);\n    };\n    return UndoManager;\n}());\nUndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;\nUndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;\nUndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;\nUndoManager.prototype.markClean = UndoManager.prototype.bookmark;\nfunction rearrangeUndoStack(stack, pos) {\n    for (var i = pos; i--;) {\n        var deltaSet = stack[i];\n        if (deltaSet && !deltaSet[0].ignore) {\n            while (i < pos - 1) {\n                var swapped = swapGroups(stack[i], stack[i + 1]);\n                stack[i] = swapped[0];\n                stack[i + 1] = swapped[1];\n                i++;\n            }\n            return true;\n        }\n    }\n}\nvar Range = require(\"./range\").Range;\nvar cmp = Range.comparePoints;\nvar comparePoints = Range.comparePoints;\nfunction $updateMarkers(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert)\n        end = start;\n    for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = comparePoints(point, start);\n        if (cmp < 0) {\n            continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n            if (isInsert) {\n                if (point.bias == 1) {\n                    cmp = 1;\n                }\n                else {\n                    point.bias == -1;\n                    continue;\n                }\n            }\n        }\n        var cmp2 = isInsert ? cmp : comparePoints(point, end);\n        if (cmp2 > 0) {\n            point.row += rowShift;\n            point.column += point.row == end.row ? colShift : 0;\n            continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n            point.row = start.row;\n            point.column = start.column;\n            if (cmp2 === 0)\n                point.bias = 1;\n        }\n    }\n}\nfunction clonePos(pos) {\n    return { row: pos.row, column: pos.column };\n}\nfunction cloneDelta(d) {\n    return {\n        start: clonePos(d.start),\n        end: clonePos(d.end),\n        action: d.action,\n        lines: d.lines.slice()\n    };\n}\nfunction stringifyDelta(d) {\n    d = d || this;\n    if (Array.isArray(d)) {\n        return d.map(stringifyDelta).join(\"\\n\");\n    }\n    var type = \"\";\n    if (d.action) {\n        type = d.action == \"insert\" ? \"+\" : \"-\";\n        type += \"[\" + d.lines + \"]\";\n    }\n    else if (d.value) {\n        if (Array.isArray(d.value)) {\n            type = d.value.map(stringifyRange).join(\"\\n\");\n        }\n        else {\n            type = stringifyRange(d.value);\n        }\n    }\n    if (d.start) {\n        type += stringifyRange(d);\n    }\n    if (d.id || d.rev) {\n        type += \"\\t(\" + (d.id || d.rev) + \")\";\n    }\n    return type;\n}\nfunction stringifyRange(r) {\n    return r.start.row + \":\" + r.start.column\n        + \"=>\" + r.end.row + \":\" + r.end.column;\n}\nfunction swap(d1, d2) {\n    var i1 = d1.action == \"insert\";\n    var i2 = d2.action == \"insert\";\n    if (i1 && i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        }\n        else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        }\n        else {\n            return null;\n        }\n    }\n    else if (i1 && !i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        }\n        else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        }\n        else {\n            return null;\n        }\n    }\n    else if (!i1 && i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        }\n        else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        }\n        else {\n            return null;\n        }\n    }\n    else if (!i1 && !i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        }\n        else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        }\n        else {\n            return null;\n        }\n    }\n    return [d2, d1];\n}\nfunction swapGroups(ds1, ds2) {\n    for (var i = ds1.length; i--;) {\n        for (var j = 0; j < ds2.length; j++) {\n            if (!swap(ds1[i], ds2[j])) {\n                while (i < ds1.length) {\n                    while (j--) {\n                        swap(ds2[j], ds1[i]);\n                    }\n                    j = ds2.length;\n                    i++;\n                }\n                return [ds1, ds2];\n            }\n        }\n    }\n    ds1.selectionBefore = ds2.selectionBefore =\n        ds1.selectionAfter = ds2.selectionAfter = null;\n    return [ds2, ds1];\n}\nfunction xform(d1, c1) {\n    var i1 = d1.action == \"insert\";\n    var i2 = c1.action == \"insert\";\n    if (i1 && i2) {\n        if (cmp(d1.start, c1.start) < 0) {\n            shift(c1, d1, 1);\n        }\n        else {\n            shift(d1, c1, 1);\n        }\n    }\n    else if (i1 && !i2) {\n        if (cmp(d1.start, c1.end) >= 0) {\n            shift(d1, c1, -1);\n        }\n        else if (cmp(d1.start, c1.start) <= 0) {\n            shift(c1, d1, +1);\n        }\n        else {\n            shift(d1, Range.fromPoints(c1.start, d1.start), -1);\n            shift(c1, d1, +1);\n        }\n    }\n    else if (!i1 && i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        }\n        else if (cmp(c1.start, d1.start) <= 0) {\n            shift(d1, c1, +1);\n        }\n        else {\n            shift(c1, Range.fromPoints(d1.start, c1.start), -1);\n            shift(d1, c1, +1);\n        }\n    }\n    else if (!i1 && !i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        }\n        else if (cmp(c1.end, d1.start) <= 0) {\n            shift(d1, c1, -1);\n        }\n        else {\n            var before, after;\n            if (cmp(d1.start, c1.start) < 0) {\n                before = d1;\n                d1 = splitDelta(d1, c1.start);\n            }\n            if (cmp(d1.end, c1.end) > 0) {\n                after = splitDelta(d1, c1.end);\n            }\n            shiftPos(c1.end, d1.start, d1.end, -1);\n            if (after && !before) {\n                d1.lines = after.lines;\n                d1.start = after.start;\n                d1.end = after.end;\n                after = d1;\n            }\n            return [c1, before, after].filter(Boolean);\n        }\n    }\n    return [c1, d1];\n}\nfunction shift(d1, d2, dir) {\n    shiftPos(d1.start, d2.start, d2.end, dir);\n    shiftPos(d1.end, d2.start, d2.end, dir);\n}\nfunction shiftPos(pos, start, end, dir) {\n    if (pos.row == (dir == 1 ? start : end).row) {\n        pos.column += dir * (end.column - start.column);\n    }\n    pos.row += dir * (end.row - start.row);\n}\nfunction splitDelta(c, pos) {\n    var lines = c.lines;\n    var end = c.end;\n    c.end = clonePos(pos);\n    var rowsBefore = c.end.row - c.start.row;\n    var otherLines = lines.splice(rowsBefore, lines.length);\n    var col = rowsBefore ? pos.column : pos.column - c.start.column;\n    lines.push(otherLines[0].substring(0, col));\n    otherLines[0] = otherLines[0].substr(col);\n    var rest = {\n        start: clonePos(pos),\n        end: end,\n        lines: otherLines,\n        action: c.action\n    };\n    return rest;\n}\nfunction moveDeltasByOne(redoStack, d) {\n    d = cloneDelta(d);\n    for (var j = redoStack.length; j--;) {\n        var deltaSet = redoStack[j];\n        for (var i = 0; i < deltaSet.length; i++) {\n            var x = deltaSet[i];\n            var xformed = xform(x, d);\n            d = xformed[0];\n            if (xformed.length != 2) {\n                if (xformed[2]) {\n                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);\n                    i++;\n                }\n                else if (!xformed[1]) {\n                    deltaSet.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (!deltaSet.length) {\n            redoStack.splice(j, 1);\n        }\n    }\n    return redoStack;\n}\nfunction rebaseRedoStack(redoStack, deltaSets) {\n    for (var i = 0; i < deltaSets.length; i++) {\n        var deltas = deltaSets[i];\n        for (var j = 0; j < deltas.length; j++) {\n            moveDeltasByOne(redoStack, deltas[j]);\n        }\n    }\n}\nexports.UndoManager = UndoManager;\n\n});\n\nace.define(\"ace/edit_session/fold_line\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar FoldLine = /** @class */ (function () {\n    function FoldLine(foldData, folds) {\n        this.foldData = foldData;\n        if (Array.isArray(folds)) {\n            this.folds = folds;\n        }\n        else {\n            folds = this.folds = [folds];\n        }\n        var last = folds[folds.length - 1];\n        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);\n        this.start = this.range.start;\n        this.end = this.range.end;\n        this.folds.forEach(function (fold) {\n            fold.setFoldLine(this);\n        }, this);\n    }\n    FoldLine.prototype.shiftRow = function (shift) {\n        this.start.row += shift;\n        this.end.row += shift;\n        this.folds.forEach(function (fold) {\n            fold.start.row += shift;\n            fold.end.row += shift;\n        });\n    };\n    FoldLine.prototype.addFold = function (fold) {\n        if (fold.sameRow) {\n            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\n                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\n            }\n            this.folds.push(fold);\n            this.folds.sort(function (a, b) {\n                return -a.range.compareEnd(b.start.row, b.start.column);\n            });\n            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\n                this.end.row = fold.end.row;\n                this.end.column = fold.end.column;\n            }\n            else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\n                this.start.row = fold.start.row;\n                this.start.column = fold.start.column;\n            }\n        }\n        else if (fold.start.row == this.end.row) {\n            this.folds.push(fold);\n            this.end.row = fold.end.row;\n            this.end.column = fold.end.column;\n        }\n        else if (fold.end.row == this.start.row) {\n            this.folds.unshift(fold);\n            this.start.row = fold.start.row;\n            this.start.column = fold.start.column;\n        }\n        else {\n            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\n        }\n        fold.foldLine = this;\n    };\n    FoldLine.prototype.containsRow = function (row) {\n        return row >= this.start.row && row <= this.end.row;\n    };\n    FoldLine.prototype.walk = function (callback, endRow, endColumn) {\n        var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;\n        if (endRow == null) {\n            endRow = this.end.row;\n            endColumn = this.end.column;\n        }\n        for (var i = 0; i < folds.length; i++) {\n            fold = folds[i];\n            cmp = fold.range.compareStart(endRow, endColumn);\n            if (cmp == -1) {\n                callback(null, endRow, endColumn, lastEnd, isNewRow);\n                return;\n            }\n            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\n            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\n            if (stop || cmp === 0) {\n                return;\n            }\n            isNewRow = !fold.sameRow;\n            lastEnd = fold.end.column;\n        }\n        callback(null, endRow, endColumn, lastEnd, isNewRow);\n    };\n    FoldLine.prototype.getNextFoldTo = function (row, column) {\n        var fold, cmp;\n        for (var i = 0; i < this.folds.length; i++) {\n            fold = this.folds[i];\n            cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                return {\n                    fold: fold,\n                    kind: \"after\"\n                };\n            }\n            else if (cmp === 0) {\n                return {\n                    fold: fold,\n                    kind: \"inside\"\n                };\n            }\n        }\n        return null;\n    };\n    FoldLine.prototype.addRemoveChars = function (row, column, len) {\n        var ret = this.getNextFoldTo(row, column), fold, folds;\n        if (ret) {\n            fold = ret.fold;\n            if (ret.kind == \"inside\"\n                && fold.start.column != column\n                && fold.start.row != row) {\n                window.console && window.console.log(row, column, fold);\n            }\n            else if (fold.start.row == row) {\n                folds = this.folds;\n                var i = folds.indexOf(fold);\n                if (i === 0) {\n                    this.start.column += len;\n                }\n                for (i; i < folds.length; i++) {\n                    fold = folds[i];\n                    fold.start.column += len;\n                    if (!fold.sameRow) {\n                        return;\n                    }\n                    fold.end.column += len;\n                }\n                this.end.column += len;\n            }\n        }\n    };\n    FoldLine.prototype.split = function (row, column) {\n        var pos = this.getNextFoldTo(row, column);\n        if (!pos || pos.kind == \"inside\")\n            return null;\n        var fold = pos.fold;\n        var folds = this.folds;\n        var foldData = this.foldData;\n        var i = folds.indexOf(fold);\n        var foldBefore = folds[i - 1];\n        this.end.row = foldBefore.end.row;\n        this.end.column = foldBefore.end.column;\n        folds = folds.splice(i, folds.length - i);\n        var newFoldLine = new FoldLine(foldData, folds);\n        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\n        return newFoldLine;\n    };\n    FoldLine.prototype.merge = function (foldLineNext) {\n        var folds = foldLineNext.folds;\n        for (var i = 0; i < folds.length; i++) {\n            this.addFold(folds[i]);\n        }\n        var foldData = this.foldData;\n        foldData.splice(foldData.indexOf(foldLineNext), 1);\n    };\n    FoldLine.prototype.toString = function () {\n        var ret = [this.range.toString() + \": [\"];\n        this.folds.forEach(function (fold) {\n            ret.push(\"  \" + fold.toString());\n        });\n        ret.push(\"]\");\n        return ret.join(\"\\n\");\n    };\n    FoldLine.prototype.idxToPosition = function (idx) {\n        var lastFoldEndColumn = 0;\n        for (var i = 0; i < this.folds.length; i++) {\n            var fold = this.folds[i];\n            idx -= fold.start.column - lastFoldEndColumn;\n            if (idx < 0) {\n                return {\n                    row: fold.start.row,\n                    column: fold.start.column + idx\n                };\n            }\n            idx -= fold.placeholder.length;\n            if (idx < 0) {\n                return fold.start;\n            }\n            lastFoldEndColumn = fold.end.column;\n        }\n        return {\n            row: this.end.row,\n            column: this.end.column + idx\n        };\n    };\n    return FoldLine;\n}());\nexports.FoldLine = FoldLine;\n\n});\n\nace.define(\"ace/range_list\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"./range\").Range;\nvar comparePoints = Range.comparePoints;\nvar RangeList = /** @class */ (function () {\n    function RangeList() {\n        this.ranges = [];\n        this.$bias = 1;\n    }\n    RangeList.prototype.pointIndex = function (pos, excludeEdges, startIndex) {\n        var list = this.ranges;\n        for (var i = startIndex || 0; i < list.length; i++) {\n            var range = list[i];\n            var cmpEnd = comparePoints(pos, range.end);\n            if (cmpEnd > 0)\n                continue;\n            var cmpStart = comparePoints(pos, range.start);\n            if (cmpEnd === 0)\n                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;\n            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))\n                return i;\n            return -i - 1;\n        }\n        return -i - 1;\n    };\n    RangeList.prototype.add = function (range) {\n        var excludeEdges = !range.isEmpty();\n        var startIndex = this.pointIndex(range.start, excludeEdges);\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        else\n            endIndex++;\n        return this.ranges.splice(startIndex, endIndex - startIndex, range);\n    };\n    RangeList.prototype.addList = function (list) {\n        var removed = [];\n        for (var i = list.length; i--;) {\n            removed.push.apply(removed, this.add(list[i]));\n        }\n        return removed;\n    };\n    RangeList.prototype.substractPoint = function (pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges.splice(i, 1);\n    };\n    RangeList.prototype.merge = function () {\n        var removed = [];\n        var list = this.ranges;\n        list = list.sort(function (a, b) {\n            return comparePoints(a.start, b.start);\n        });\n        var next = list[0], range;\n        for (var i = 1; i < list.length; i++) {\n            range = next;\n            next = list[i];\n            var cmp = comparePoints(range.end, next.start);\n            if (cmp < 0)\n                continue;\n            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())\n                continue;\n            if (comparePoints(range.end, next.end) < 0) {\n                range.end.row = next.end.row;\n                range.end.column = next.end.column;\n            }\n            list.splice(i, 1);\n            removed.push(next);\n            next = range;\n            i--;\n        }\n        this.ranges = list;\n        return removed;\n    };\n    RangeList.prototype.contains = function (row, column) {\n        return this.pointIndex({ row: row, column: column }) >= 0;\n    };\n    RangeList.prototype.containsPoint = function (pos) {\n        return this.pointIndex(pos) >= 0;\n    };\n    RangeList.prototype.rangeAtPoint = function (pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges[i];\n    };\n    RangeList.prototype.clipRows = function (startRow, endRow) {\n        var list = this.ranges;\n        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)\n            return [];\n        var startIndex = this.pointIndex({ row: startRow, column: 0 });\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        var clipped = [];\n        for (var i = startIndex; i < endIndex; i++) {\n            clipped.push(list[i]);\n        }\n        return clipped;\n    };\n    RangeList.prototype.removeAll = function () {\n        return this.ranges.splice(0, this.ranges.length);\n    };\n    RangeList.prototype.attach = function (session) {\n        if (this.session)\n            this.detach();\n        this.session = session;\n        this.onChange = this.$onChange.bind(this);\n        this.session.on('change', this.onChange);\n    };\n    RangeList.prototype.detach = function () {\n        if (!this.session)\n            return;\n        this.session.removeListener('change', this.onChange);\n        this.session = null;\n    };\n    RangeList.prototype.$onChange = function (delta) {\n        var start = delta.start;\n        var end = delta.end;\n        var startRow = start.row;\n        var endRow = end.row;\n        var ranges = this.ranges;\n        for (var i = 0, n = ranges.length; i < n; i++) {\n            var r = ranges[i];\n            if (r.end.row >= startRow)\n                break;\n        }\n        if (delta.action == \"insert\") {\n            var lineDif = endRow - startRow;\n            var colDiff = -start.column + end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > startRow)\n                    break;\n                if (r.start.row == startRow && r.start.column >= start.column) {\n                    if (r.start.column == start.column && this.$bias <= 0) {\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                if (r.end.row == startRow && r.end.column >= start.column) {\n                    if (r.end.column == start.column && this.$bias < 0) {\n                        continue;\n                    }\n                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {\n                        if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)\n                            r.end.column -= colDiff;\n                    }\n                    r.end.column += colDiff;\n                    r.end.row += lineDif;\n                }\n            }\n        }\n        else {\n            var lineDif = startRow - endRow;\n            var colDiff = start.column - end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > endRow)\n                    break;\n                if (r.end.row < endRow\n                    && (startRow < r.end.row\n                        || startRow == r.end.row && start.column < r.end.column)) {\n                    r.end.row = startRow;\n                    r.end.column = start.column;\n                }\n                else if (r.end.row == endRow) {\n                    if (r.end.column <= end.column) {\n                        if (lineDif || r.end.column > start.column) {\n                            r.end.column = start.column;\n                            r.end.row = start.row;\n                        }\n                    }\n                    else {\n                        r.end.column += colDiff;\n                        r.end.row += lineDif;\n                    }\n                }\n                else if (r.end.row > endRow) {\n                    r.end.row += lineDif;\n                }\n                if (r.start.row < endRow\n                    && (startRow < r.start.row\n                        || startRow == r.start.row && start.column < r.start.column)) {\n                    r.start.row = startRow;\n                    r.start.column = start.column;\n                }\n                else if (r.start.row == endRow) {\n                    if (r.start.column <= end.column) {\n                        if (lineDif || r.start.column > start.column) {\n                            r.start.column = start.column;\n                            r.start.row = start.row;\n                        }\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                else if (r.start.row > endRow) {\n                    r.start.row += lineDif;\n                }\n            }\n        }\n        if (lineDif != 0 && i < n) {\n            for (; i < n; i++) {\n                var r = ranges[i];\n                r.start.row += lineDif;\n                r.end.row += lineDif;\n            }\n        }\n    };\n    return RangeList;\n}());\nRangeList.prototype.comparePoints = comparePoints;\nexports.RangeList = RangeList;\n\n});\n\nace.define(\"ace/edit_session/fold\",[\"require\",\"exports\",\"module\",\"ace/range_list\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar RangeList = require(\"../range_list\").RangeList;\nvar Fold = /** @class */ (function (_super) {\n    __extends(Fold, _super);\n    function Fold(range, placeholder) {\n        var _this = _super.call(this) || this;\n        _this.foldLine = null;\n        _this.placeholder = placeholder;\n        _this.range = range;\n        _this.start = range.start;\n        _this.end = range.end;\n        _this.sameRow = range.start.row == range.end.row;\n        _this.subFolds = _this.ranges = [];\n        return _this;\n    }\n    Fold.prototype.toString = function () {\n        return '\"' + this.placeholder + '\" ' + this.range.toString();\n    };\n    Fold.prototype.setFoldLine = function (foldLine) {\n        this.foldLine = foldLine;\n        this.subFolds.forEach(function (fold) {\n            fold.setFoldLine(foldLine);\n        });\n    };\n    Fold.prototype.clone = function () {\n        var range = this.range.clone();\n        var fold = new Fold(range, this.placeholder);\n        this.subFolds.forEach(function (subFold) {\n            fold.subFolds.push(subFold.clone());\n        });\n        fold.collapseChildren = this.collapseChildren;\n        return fold;\n    };\n    Fold.prototype.addSubFold = function (fold) {\n        if (this.range.isEqual(fold))\n            return;\n        consumeRange(fold, this.start);\n        var row = fold.start.row, column = fold.start.column;\n        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {\n            cmp = this.subFolds[i].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterStart = this.subFolds[i];\n        var firstConsumed = 0;\n        if (cmp == 0) {\n            if (afterStart.range.containsRange(fold))\n                return afterStart.addSubFold(fold);\n            else\n                firstConsumed = 1;\n        }\n        var row = fold.range.end.row, column = fold.range.end.column;\n        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {\n            cmp = this.subFolds[j].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        if (cmp == 0)\n            j++;\n        var consumedFolds = this.subFolds.splice(i, j - i, fold);\n        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;\n        for (var k = firstConsumed; k < last; k++) {\n            fold.addSubFold(consumedFolds[k]);\n        }\n        fold.setFoldLine(this.foldLine);\n        return fold;\n    };\n    Fold.prototype.restoreRange = function (range) {\n        return restoreRange(range, this.start);\n    };\n    return Fold;\n}(RangeList));\nfunction consumePoint(point, anchor) {\n    point.row -= anchor.row;\n    if (point.row == 0)\n        point.column -= anchor.column;\n}\nfunction consumeRange(range, anchor) {\n    consumePoint(range.start, anchor);\n    consumePoint(range.end, anchor);\n}\nfunction restorePoint(point, anchor) {\n    if (point.row == 0)\n        point.column += anchor.column;\n    point.row += anchor.row;\n}\nfunction restoreRange(range, anchor) {\n    restorePoint(range.start, anchor);\n    restorePoint(range.end, anchor);\n}\nexports.Fold = Fold;\n\n});\n\nace.define(\"ace/edit_session/folding\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/edit_session/fold_line\",\"ace/edit_session/fold\",\"ace/token_iterator\",\"ace/mouse/mouse_event\"], function(require, exports, module){// @ts-nocheck\n\"use strict\";\nvar Range = require(\"../range\").Range;\nvar FoldLine = require(\"./fold_line\").FoldLine;\nvar Fold = require(\"./fold\").Fold;\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar MouseEvent = require(\"../mouse/mouse_event\").MouseEvent;\nfunction Folding() {\n    this.getFoldAt = function (row, column, side) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n        var folds = foldLine.folds;\n        for (var i = 0; i < folds.length; i++) {\n            var range = folds[i].range;\n            if (range.contains(row, column)) {\n                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {\n                    continue;\n                }\n                else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {\n                    continue;\n                }\n                return folds[i];\n            }\n        }\n    };\n    this.getFoldsInRange = function (range) {\n        var start = range.start;\n        var end = range.end;\n        var foldLines = this.$foldData;\n        var foundFolds = [];\n        start.column += 1;\n        end.column -= 1;\n        for (var i = 0; i < foldLines.length; i++) {\n            var cmp = foldLines[i].range.compareRange(range);\n            if (cmp == 2) {\n                continue;\n            }\n            else if (cmp == -2) {\n                break;\n            }\n            var folds = foldLines[i].folds;\n            for (var j = 0; j < folds.length; j++) {\n                var fold = folds[j];\n                cmp = fold.range.compareRange(range);\n                if (cmp == -2) {\n                    break;\n                }\n                else if (cmp == 2) {\n                    continue;\n                }\n                else \n                if (cmp == 42) {\n                    break;\n                }\n                foundFolds.push(fold);\n            }\n        }\n        start.column -= 1;\n        end.column += 1;\n        return foundFolds;\n    };\n    this.getFoldsInRangeList = function (ranges) {\n        if (Array.isArray(ranges)) {\n            var folds = [];\n            ranges.forEach(function (range) {\n                folds = folds.concat(this.getFoldsInRange(range));\n            }, this);\n        }\n        else {\n            var folds = this.getFoldsInRange(ranges);\n        }\n        return folds;\n    };\n    this.getAllFolds = function () {\n        var folds = [];\n        var foldLines = this.$foldData;\n        for (var i = 0; i < foldLines.length; i++)\n            for (var j = 0; j < foldLines[i].folds.length; j++)\n                folds.push(foldLines[i].folds[j]);\n        return folds;\n    };\n    this.getFoldStringAt = function (row, column, trim, foldLine) {\n        foldLine = foldLine || this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n        var lastFold = {\n            end: { column: 0 }\n        };\n        var str, fold;\n        for (var i = 0; i < foldLine.folds.length; i++) {\n            fold = foldLine.folds[i];\n            var cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                str = this\n                    .getLine(fold.start.row)\n                    .substring(lastFold.end.column, fold.start.column);\n                break;\n            }\n            else if (cmp === 0) {\n                return null;\n            }\n            lastFold = fold;\n        }\n        if (!str)\n            str = this.getLine(fold.start.row).substring(lastFold.end.column);\n        if (trim == -1)\n            return str.substring(0, column - lastFold.end.column);\n        else if (trim == 1)\n            return str.substring(column - lastFold.end.column);\n        else\n            return str;\n    };\n    this.getFoldLine = function (docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n            else if (foldLine.end.row > docRow) {\n                return null;\n            }\n        }\n        return null;\n    };\n    this.getNextFoldLine = function (docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n        }\n        return null;\n    };\n    this.getFoldedRowCount = function (first, last) {\n        var foldData = this.$foldData, rowCount = last - first + 1;\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;\n            if (end >= last) {\n                if (start < last) {\n                    if (start >= first)\n                        rowCount -= last - start;\n                    else\n                        rowCount = 0; // in one fold\n                }\n                break;\n            }\n            else if (end >= first) {\n                if (start >= first) // fold inside range\n                    rowCount -= end - start;\n                else\n                    rowCount -= end - first + 1;\n            }\n        }\n        return rowCount;\n    };\n    this.$addFoldLine = function (foldLine) {\n        this.$foldData.push(foldLine);\n        this.$foldData.sort(function (a, b) {\n            return a.start.row - b.start.row;\n        });\n        return foldLine;\n    };\n    this.addFold = function (placeholder, range) {\n        var foldData = this.$foldData;\n        var added = false;\n        var fold;\n        if (placeholder instanceof Fold)\n            fold = placeholder;\n        else {\n            fold = new Fold(range, placeholder);\n            fold.collapseChildren = range.collapseChildren;\n        }\n        this.$clipRangeToDocument(fold.range);\n        var startRow = fold.start.row;\n        var startColumn = fold.start.column;\n        var endRow = fold.end.row;\n        var endColumn = fold.end.column;\n        var startFold = this.getFoldAt(startRow, startColumn, 1);\n        var endFold = this.getFoldAt(endRow, endColumn, -1);\n        if (startFold && endFold == startFold)\n            return startFold.addSubFold(fold);\n        if (startFold && !startFold.range.isStart(startRow, startColumn))\n            this.removeFold(startFold);\n        if (endFold && !endFold.range.isEnd(endRow, endColumn))\n            this.removeFold(endFold);\n        var folds = this.getFoldsInRange(fold.range);\n        if (folds.length > 0) {\n            this.removeFolds(folds);\n            if (!fold.collapseChildren) {\n                folds.forEach(function (subFold) {\n                    fold.addSubFold(subFold);\n                });\n            }\n        }\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (endRow == foldLine.start.row) {\n                foldLine.addFold(fold);\n                added = true;\n                break;\n            }\n            else if (startRow == foldLine.end.row) {\n                foldLine.addFold(fold);\n                added = true;\n                if (!fold.sameRow) {\n                    var foldLineNext = foldData[i + 1];\n                    if (foldLineNext && foldLineNext.start.row == endRow) {\n                        foldLine.merge(foldLineNext);\n                        break;\n                    }\n                }\n                break;\n            }\n            else if (endRow <= foldLine.start.row) {\n                break;\n            }\n        }\n        if (!added)\n            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\n        if (this.$useWrapMode)\n            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\n        else\n            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"add\" });\n        return fold;\n    };\n    this.addFolds = function (folds) {\n        folds.forEach(function (fold) {\n            this.addFold(fold);\n        }, this);\n    };\n    this.removeFold = function (fold) {\n        var foldLine = fold.foldLine;\n        var startRow = foldLine.start.row;\n        var endRow = foldLine.end.row;\n        var foldLines = this.$foldData;\n        var folds = foldLine.folds;\n        if (folds.length == 1) {\n            foldLines.splice(foldLines.indexOf(foldLine), 1);\n        }\n        else \n        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\n            folds.pop();\n            foldLine.end.row = folds[folds.length - 1].end.row;\n            foldLine.end.column = folds[folds.length - 1].end.column;\n        }\n        else \n        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\n            folds.shift();\n            foldLine.start.row = folds[0].start.row;\n            foldLine.start.column = folds[0].start.column;\n        }\n        else \n        if (fold.sameRow) {\n            folds.splice(folds.indexOf(fold), 1);\n        }\n        else \n        {\n            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\n            folds = newFoldLine.folds;\n            folds.shift();\n            newFoldLine.start.row = folds[0].start.row;\n            newFoldLine.start.column = folds[0].start.column;\n        }\n        if (!this.$updating) {\n            if (this.$useWrapMode)\n                this.$updateWrapData(startRow, endRow);\n            else\n                this.$updateRowLengthCache(startRow, endRow);\n        }\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"remove\" });\n    };\n    this.removeFolds = function (folds) {\n        var cloneFolds = [];\n        for (var i = 0; i < folds.length; i++) {\n            cloneFolds.push(folds[i]);\n        }\n        cloneFolds.forEach(function (fold) {\n            this.removeFold(fold);\n        }, this);\n        this.$modified = true;\n    };\n    this.expandFold = function (fold) {\n        this.removeFold(fold);\n        fold.subFolds.forEach(function (subFold) {\n            fold.restoreRange(subFold);\n            this.addFold(subFold);\n        }, this);\n        if (fold.collapseChildren > 0) {\n            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);\n        }\n        fold.subFolds = [];\n    };\n    this.expandFolds = function (folds) {\n        folds.forEach(function (fold) {\n            this.expandFold(fold);\n        }, this);\n    };\n    this.unfold = function (location, expandInner) {\n        var range, folds;\n        if (location == null) {\n            range = new Range(0, 0, this.getLength(), 0);\n            if (expandInner == null)\n                expandInner = true;\n        }\n        else if (typeof location == \"number\") {\n            range = new Range(location, 0, location, this.getLine(location).length);\n        }\n        else if (\"row\" in location) {\n            range = Range.fromPoints(location, location);\n        }\n        else if (Array.isArray(location)) {\n            folds = [];\n            location.forEach(function (range) {\n                folds = folds.concat(this.unfold(range));\n            }, this);\n            return folds;\n        }\n        else {\n            range = location;\n        }\n        folds = this.getFoldsInRangeList(range);\n        var outermostFolds = folds;\n        while (folds.length == 1\n            && Range.comparePoints(folds[0].start, range.start) < 0\n            && Range.comparePoints(folds[0].end, range.end) > 0) {\n            this.expandFolds(folds);\n            folds = this.getFoldsInRangeList(range);\n        }\n        if (expandInner != false) {\n            this.removeFolds(folds);\n        }\n        else {\n            this.expandFolds(folds);\n        }\n        if (outermostFolds.length)\n            return outermostFolds;\n    };\n    this.isRowFolded = function (docRow, startFoldRow) {\n        return !!this.getFoldLine(docRow, startFoldRow);\n    };\n    this.getRowFoldEnd = function (docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.end.row : docRow;\n    };\n    this.getRowFoldStart = function (docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.start.row : docRow;\n    };\n    this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {\n        if (startRow == null)\n            startRow = foldLine.start.row;\n        if (startColumn == null)\n            startColumn = 0;\n        if (endRow == null)\n            endRow = foldLine.end.row;\n        if (endColumn == null)\n            endColumn = this.getLine(endRow).length;\n        var doc = this.doc;\n        var textLine = \"\";\n        foldLine.walk(function (placeholder, row, column, lastColumn) {\n            if (row < startRow)\n                return;\n            if (row == startRow) {\n                if (column < startColumn)\n                    return;\n                lastColumn = Math.max(startColumn, lastColumn);\n            }\n            if (placeholder != null) {\n                textLine += placeholder;\n            }\n            else {\n                textLine += doc.getLine(row).substring(lastColumn, column);\n            }\n        }, endRow, endColumn);\n        return textLine;\n    };\n    this.getDisplayLine = function (row, endColumn, startRow, startColumn) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine) {\n            var line;\n            line = this.doc.getLine(row);\n            return line.substring(startColumn || 0, endColumn || line.length);\n        }\n        else {\n            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);\n        }\n    };\n    this.$cloneFoldData = function () {\n        var fd = [];\n        fd = this.$foldData.map(function (foldLine) {\n            var folds = foldLine.folds.map(function (fold) {\n                return fold.clone();\n            });\n            return new FoldLine(fd, folds);\n        });\n        return fd;\n    };\n    this.toggleFold = function (tryToUnfold) {\n        var selection = this.selection;\n        var range = selection.getRange();\n        var fold;\n        var bracketPos;\n        if (range.isEmpty()) {\n            var cursor = range.start;\n            fold = this.getFoldAt(cursor.row, cursor.column);\n            if (fold) {\n                this.expandFold(fold);\n                return;\n            }\n            else if (bracketPos = this.findMatchingBracket(cursor)) {\n                if (range.comparePoint(bracketPos) == 1) {\n                    range.end = bracketPos;\n                }\n                else {\n                    range.start = bracketPos;\n                    range.start.column++;\n                    range.end.column--;\n                }\n            }\n            else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {\n                if (range.comparePoint(bracketPos) == 1)\n                    range.end = bracketPos;\n                else\n                    range.start = bracketPos;\n                range.start.column++;\n            }\n            else {\n                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\n            }\n        }\n        else {\n            var folds = this.getFoldsInRange(range);\n            if (tryToUnfold && folds.length) {\n                this.expandFolds(folds);\n                return;\n            }\n            else if (folds.length == 1) {\n                fold = folds[0];\n            }\n        }\n        if (!fold)\n            fold = this.getFoldAt(range.start.row, range.start.column);\n        if (fold && fold.range.toString() == range.toString()) {\n            this.expandFold(fold);\n            return;\n        }\n        var placeholder = \"...\";\n        if (!range.isMultiLine()) {\n            placeholder = this.getTextRange(range);\n            if (placeholder.length < 4)\n                return;\n            placeholder = placeholder.trim().substring(0, 2) + \"..\";\n        }\n        this.addFold(placeholder, range);\n    };\n    this.getCommentFoldRange = function (row, column, dir) {\n        var iterator = new TokenIterator(this, row, column);\n        var token = iterator.getCurrentToken();\n        var type = token && token.type;\n        if (token && /^comment|string/.test(type)) {\n            type = type.match(/comment|string/)[0];\n            if (type == \"comment\")\n                type += \"|doc-start|\\\\.doc\";\n            var re = new RegExp(type);\n            var range = new Range();\n            if (dir != 1) {\n                do {\n                    token = iterator.stepBackward();\n                } while (token && re.test(token.type));\n                token = iterator.stepForward();\n            }\n            range.start.row = iterator.getCurrentTokenRow();\n            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;\n            iterator = new TokenIterator(this, row, column);\n            var initState = this.getState(iterator.$row);\n            if (dir != -1) {\n                var lastRow = -1;\n                do {\n                    token = iterator.stepForward();\n                    if (lastRow == -1) {\n                        var state = this.getState(iterator.$row);\n                        if (initState.toString() !== state.toString())\n                            lastRow = iterator.$row;\n                    }\n                    else if (iterator.$row > lastRow) {\n                        break;\n                    }\n                } while (token && re.test(token.type));\n                token = iterator.stepBackward();\n            }\n            else\n                token = iterator.getCurrentToken();\n            range.end.row = iterator.getCurrentTokenRow();\n            range.end.column = iterator.getCurrentTokenColumn();\n            return range;\n        }\n    };\n    this.foldAll = function (startRow, endRow, depth, test) {\n        if (depth == undefined)\n            depth = 100000; // JSON.stringify doesn't hanle Infinity\n        var foldWidgets = this.foldWidgets;\n        if (!foldWidgets)\n            return; // mode doesn't support folding\n        endRow = endRow || this.getLength();\n        startRow = startRow || 0;\n        for (var row = startRow; row < endRow; row++) {\n            if (foldWidgets[row] == null)\n                foldWidgets[row] = this.getFoldWidget(row);\n            if (foldWidgets[row] != \"start\")\n                continue;\n            if (test && !test(row))\n                continue;\n            var range = this.getFoldWidgetRange(row);\n            if (range && range.isMultiLine()\n                && range.end.row <= endRow\n                && range.start.row >= startRow) {\n                row = range.end.row;\n                range.collapseChildren = depth;\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n    this.foldToLevel = function (level) {\n        this.foldAll();\n        while (level-- > 0)\n            this.unfold(null, false);\n    };\n    this.foldAllComments = function () {\n        var session = this;\n        this.foldAll(null, null, null, function (row) {\n            var tokens = session.getTokens(row);\n            for (var i = 0; i < tokens.length; i++) {\n                var token = tokens[i];\n                if (token.type == \"text\" && /^\\s+$/.test(token.value))\n                    continue;\n                if (/comment/.test(token.type))\n                    return true;\n                return false;\n            }\n        });\n    };\n    this.$foldStyles = {\n        \"manual\": 1,\n        \"markbegin\": 1,\n        \"markbeginend\": 1\n    };\n    this.$foldStyle = \"markbegin\";\n    this.setFoldStyle = function (style) {\n        if (!this.$foldStyles[style])\n            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\n        if (this.$foldStyle == style)\n            return;\n        this.$foldStyle = style;\n        if (style == \"manual\")\n            this.unfold();\n        var mode = this.$foldMode;\n        this.$setFolding(null);\n        this.$setFolding(mode);\n    };\n    this.$setFolding = function (foldMode) {\n        if (this.$foldMode == foldMode)\n            return;\n        this.$foldMode = foldMode;\n        this.off('change', this.$updateFoldWidgets);\n        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n        this._signal(\"changeAnnotation\");\n        if (!foldMode || this.$foldStyle == \"manual\") {\n            this.foldWidgets = null;\n            return;\n        }\n        this.foldWidgets = [];\n        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\n        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\n        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\n        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);\n        this.on('change', this.$updateFoldWidgets);\n        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n    };\n    this.getParentFoldRangeData = function (row, ignoreCurrent) {\n        var fw = this.foldWidgets;\n        if (!fw || (ignoreCurrent && fw[row]))\n            return {};\n        var i = row - 1, firstRange;\n        while (i >= 0) {\n            var c = fw[i];\n            if (c == null)\n                c = fw[i] = this.getFoldWidget(i);\n            if (c == \"start\") {\n                var range = this.getFoldWidgetRange(i);\n                if (!firstRange)\n                    firstRange = range;\n                if (range && range.end.row >= row)\n                    break;\n            }\n            i--;\n        }\n        return {\n            range: i !== -1 && range,\n            firstRange: firstRange\n        };\n    };\n    this.onFoldWidgetClick = function (row, e) {\n        if (e instanceof MouseEvent)\n            e = e.domEvent;\n        var options = {\n            children: e.shiftKey,\n            all: e.ctrlKey || e.metaKey,\n            siblings: e.altKey\n        };\n        var range = this.$toggleFoldWidget(row, options);\n        if (!range) {\n            var el = (e.target || e.srcElement);\n            if (el && /ace_fold-widget/.test(el.className))\n                el.className += \" ace_invalid\";\n        }\n    };\n    this.$toggleFoldWidget = function (row, options) {\n        if (!this.getFoldWidget)\n            return;\n        var type = this.getFoldWidget(row);\n        var line = this.getLine(row);\n        var dir = type === \"end\" ? -1 : 1;\n        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\n        if (fold) {\n            if (options.children || options.all)\n                this.removeFold(fold);\n            else\n                this.expandFold(fold);\n            return fold;\n        }\n        var range = this.getFoldWidgetRange(row, true);\n        if (range && !range.isMultiLine()) {\n            fold = this.getFoldAt(range.start.row, range.start.column, 1);\n            if (fold && range.isEqual(fold.range)) {\n                this.removeFold(fold);\n                return fold;\n            }\n        }\n        if (options.siblings) {\n            var data = this.getParentFoldRangeData(row);\n            if (data.range) {\n                var startRow = data.range.start.row + 1;\n                var endRow = data.range.end.row;\n            }\n            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\n        }\n        else if (options.children) {\n            endRow = range ? range.end.row : this.getLength();\n            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);\n        }\n        else if (range) {\n            if (options.all)\n                range.collapseChildren = 10000;\n            this.addFold(\"...\", range);\n        }\n        return range;\n    };\n    this.toggleFoldWidget = function (toggleParent) {\n        var row = this.selection.getCursor().row;\n        row = this.getRowFoldStart(row);\n        var range = this.$toggleFoldWidget(row, {});\n        if (range)\n            return;\n        var data = this.getParentFoldRangeData(row, true);\n        range = data.range || data.firstRange;\n        if (range) {\n            row = range.start.row;\n            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\n            if (fold) {\n                this.removeFold(fold);\n            }\n            else {\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n    this.updateFoldWidgets = function (delta) {\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n            this.foldWidgets[firstRow] = null;\n        }\n        else if (delta.action == 'remove') {\n            this.foldWidgets.splice(firstRow, len + 1, null);\n        }\n        else {\n            var args = Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.foldWidgets.splice.apply(this.foldWidgets, args);\n        }\n    };\n    this.tokenizerUpdateFoldWidgets = function (e) {\n        var rows = e.data;\n        if (rows.first != rows.last) {\n            if (this.foldWidgets.length > rows.first)\n                this.foldWidgets.splice(rows.first, this.foldWidgets.length);\n        }\n    };\n}\nexports.Folding = Folding;\n\n});\n\nace.define(\"ace/edit_session/bracket_match\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\nfunction BracketMatch() {\n    this.findMatchingBracket = function (position, chr) {\n        if (position.column == 0)\n            return null;\n        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);\n        if (charBeforeCursor == \"\")\n            return null;\n        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match)\n            return null;\n        if (match[1])\n            return this.$findClosingBracket(match[1], position);\n        else\n            return this.$findOpeningBracket(match[2], position);\n    };\n    this.getBracketRange = function (pos) {\n        var line = this.getLine(pos.row);\n        var before = true, range;\n        var chr = line.charAt(pos.column - 1);\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match) {\n            chr = line.charAt(pos.column);\n            pos = { row: pos.row, column: pos.column + 1 };\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n            before = false;\n        }\n        if (!match)\n            return null;\n        if (match[1]) {\n            var bracketPos = this.$findClosingBracket(match[1], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(pos, bracketPos);\n            if (!before) {\n                range.end.column++;\n                range.start.column--;\n            }\n            range.cursor = range.end;\n        }\n        else {\n            var bracketPos = this.$findOpeningBracket(match[2], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(bracketPos, pos);\n            if (!before) {\n                range.start.column++;\n                range.end.column--;\n            }\n            range.cursor = range.start;\n        }\n        return range;\n    };\n    this.getMatchingBracketRanges = function (pos, isBackwards) {\n        var line = this.getLine(pos.row);\n        var bracketsRegExp = /([\\(\\[\\{])|([\\)\\]\\}])/;\n        var chr = !isBackwards && line.charAt(pos.column - 1);\n        var match = chr && chr.match(bracketsRegExp);\n        if (!match) {\n            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);\n            pos = {\n                row: pos.row,\n                column: pos.column + 1\n            };\n            match = chr && chr.match(bracketsRegExp);\n        }\n        if (!match)\n            return null;\n        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);\n        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)\n            : this.$findOpeningBracket(match[2], pos);\n        if (!bracketPos)\n            return [startRange];\n        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);\n        return [startRange, endRange];\n    };\n    this.$brackets = {\n        \")\": \"(\",\n        \"(\": \")\",\n        \"]\": \"[\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"<\": \">\",\n        \">\": \"<\"\n    };\n    this.$findOpeningBracket = function (bracket, position, typeRe) {\n        var openBracket = this.$brackets[bracket];\n        var depth = 1;\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        if (!typeRe) {\n            typeRe = new RegExp(\"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\n                    .replace(/\\b(?:end)\\b/, \"(?:start|begin|end)\")\n                    .replace(/-close\\b/, \"-(close|open)\")\n                + \")+\");\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\n        var value = token.value;\n        while (true) {\n            while (valueIndex >= 0) {\n                var chr = value.charAt(valueIndex);\n                if (chr == openBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return { row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn() };\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex -= 1;\n            }\n            do {\n                token = iterator.stepBackward();\n            } while (token && !typeRe.test(token.type));\n            if (token == null)\n                break;\n            value = token.value;\n            valueIndex = value.length - 1;\n        }\n        return null;\n    };\n    this.$findClosingBracket = function (bracket, position, typeRe) {\n        var closingBracket = this.$brackets[bracket];\n        var depth = 1;\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        if (!typeRe) {\n            typeRe = new RegExp(\"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\n                    .replace(/\\b(?:start|begin)\\b/, \"(?:start|begin|end)\")\n                    .replace(/-open\\b/, \"-(close|open)\")\n                + \")+\");\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn();\n        while (true) {\n            var value = token.value;\n            var valueLength = value.length;\n            while (valueIndex < valueLength) {\n                var chr = value.charAt(valueIndex);\n                if (chr == closingBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return { row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn() };\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex += 1;\n            }\n            do {\n                token = iterator.stepForward();\n            } while (token && !typeRe.test(token.type));\n            if (token == null)\n                break;\n            valueIndex = 0;\n        }\n        return null;\n    };\n    this.getMatchingTags = function (pos) {\n        var iterator = new TokenIterator(this, pos.row, pos.column);\n        var token = this.$findTagName(iterator);\n        if (!token)\n            return;\n        var prevToken = iterator.stepBackward();\n        if (prevToken.value === '<') {\n            return this.$findClosingTag(iterator, token);\n        }\n        else {\n            return this.$findOpeningTag(iterator, token);\n        }\n    };\n    this.$findTagName = function (iterator) {\n        var token = iterator.getCurrentToken();\n        var found = false;\n        var backward = false;\n        if (token && token.type.indexOf('tag-name') === -1) {\n            do {\n                if (backward)\n                    token = iterator.stepBackward();\n                else\n                    token = iterator.stepForward();\n                if (token) {\n                    if (token.value === \"/>\") {\n                        backward = true;\n                    }\n                    else if (token.type.indexOf('tag-name') !== -1) {\n                        found = true;\n                    }\n                }\n            } while (token && !found);\n        }\n        return token;\n    };\n    this.$findClosingTag = function (iterator, token) {\n        var prevToken;\n        var currentTag = token.value;\n        var tag = token.value;\n        var depth = 0;\n        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);\n        token = iterator.stepForward();\n        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);\n        var foundOpenTagEnd = false;\n        do {\n            prevToken = token;\n            if (prevToken.type.indexOf('tag-close') !== -1 && !foundOpenTagEnd) {\n                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`\n                foundOpenTagEnd = true;\n            }\n            token = iterator.stepForward();\n            if (token) {\n                if (token.value === '>' && !foundOpenTagEnd) {\n                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`\n                    foundOpenTagEnd = true;\n                }\n                if (token.type.indexOf('tag-name') !== -1) {\n                    currentTag = token.value;\n                    if (tag === currentTag) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                        }\n                        else if (prevToken.value === '</') {\n                            depth--;\n                            if (depth < 0) { //found closing tag\n                                iterator.stepBackward();\n                                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for </\n                                token = iterator.stepForward();\n                                var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);\n                                if (token.type.indexOf('tag-close') === -1) {\n                                    token = iterator.stepForward();\n                                }\n                                if (token && token.value === '>') {\n                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >\n                                }\n                                else {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (tag === currentTag && token.value === '/>') { // self-closing tag\n                    depth--;\n                    if (depth < 0) { //found self-closing tag end\n                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);\n                        var closeTagName = closeTagStart;\n                        var closeTagEnd = closeTagName;\n                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);\n                    }\n                }\n            }\n        } while (token && depth >= 0);\n        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {\n            return {\n                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),\n                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),\n                openTagName: openTagName,\n                closeTagName: closeTagName\n            };\n        }\n    };\n    this.$findOpeningTag = function (iterator, token) {\n        var prevToken = iterator.getCurrentToken();\n        var tag = token.value;\n        var depth = 0;\n        var startRow = iterator.getCurrentTokenRow();\n        var startColumn = iterator.getCurrentTokenColumn();\n        var endColumn = startColumn + 2;\n        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </\n        iterator.stepForward();\n        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);\n        if (token.type.indexOf('tag-close') === -1) {\n            token = iterator.stepForward();\n        }\n        if (!token || token.value !== \">\")\n            return;\n        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >\n        iterator.stepBackward();\n        iterator.stepBackward();\n        do {\n            token = prevToken;\n            startRow = iterator.getCurrentTokenRow();\n            startColumn = iterator.getCurrentTokenColumn();\n            endColumn = startColumn + token.value.length;\n            prevToken = iterator.stepBackward();\n            if (token) {\n                if (token.type.indexOf('tag-name') !== -1) {\n                    if (tag === token.value) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                            if (depth > 0) { //found opening tag\n                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);\n                                var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for <\n                                do {\n                                    token = iterator.stepForward();\n                                } while (token && token.value !== '>');\n                                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >\n                            }\n                        }\n                        else if (prevToken.value === '</') {\n                            depth--;\n                        }\n                    }\n                }\n                else if (token.value === '/>') { // self-closing tag\n                    var stepCount = 0;\n                    var tmpToken = prevToken;\n                    while (tmpToken) {\n                        if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {\n                            depth--;\n                            break;\n                        }\n                        else if (tmpToken.value === '<') {\n                            break;\n                        }\n                        tmpToken = iterator.stepBackward();\n                        stepCount++;\n                    }\n                    for (var i = 0; i < stepCount; i++) {\n                        iterator.stepForward();\n                    }\n                }\n            }\n        } while (prevToken && depth <= 0);\n        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {\n            return {\n                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),\n                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),\n                openTagName: openTagName,\n                closeTagName: closeTagName\n            };\n        }\n    };\n}\nexports.BracketMatch = BracketMatch;\n\n});\n\nace.define(\"ace/edit_session\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/bidihandler\",\"ace/config\",\"ace/lib/event_emitter\",\"ace/selection\",\"ace/mode/text\",\"ace/range\",\"ace/document\",\"ace/background_tokenizer\",\"ace/search_highlight\",\"ace/undomanager\",\"ace/edit_session/folding\",\"ace/edit_session/bracket_match\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar BidiHandler = require(\"./bidihandler\").BidiHandler;\nvar config = require(\"./config\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Selection = require(\"./selection\").Selection;\nvar TextMode = require(\"./mode/text\").Mode;\nvar Range = require(\"./range\").Range;\nvar Document = require(\"./document\").Document;\nvar BackgroundTokenizer = require(\"./background_tokenizer\").BackgroundTokenizer;\nvar SearchHighlight = require(\"./search_highlight\").SearchHighlight;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar EditSession = /** @class */ (function () {\n    function EditSession(text, mode) { this.doc;\n        this.$breakpoints = [];\n        this.$decorations = [];\n        this.$frontMarkers = {};\n        this.$backMarkers = {};\n        this.$markerId = 1;\n        this.$undoSelect = true;\n        this.$foldData = [];\n        this.id = \"session\" + (++EditSession.$uid);\n        this.$foldData.toString = function () {\n            return this.join(\"\\n\");\n        };\n        this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);\n        var _self = this;\n        this.bgTokenizer.on(\"update\", function (e) {\n            _self._signal(\"tokenizerUpdate\", e);\n        });\n        this.on(\"changeFold\", this.onChangeFold.bind(this));\n        this.$onChange = this.onChange.bind(this);\n        if (typeof text != \"object\" || !text.getLine)\n            text = new Document(/**@type{string}*/ (text));\n        this.setDocument(text);\n        this.selection = new Selection(this);\n        this.$bidiHandler = new BidiHandler(this);\n        config.resetOptions(this);\n        this.setMode(mode);\n        config._signal(\"session\", this);\n        this.destroyed = false;\n    }\n    EditSession.prototype.setDocument = function (doc) {\n        if (this.doc)\n            this.doc.off(\"change\", this.$onChange);\n        this.doc = doc;\n        doc.on(\"change\", this.$onChange, true);\n        this.bgTokenizer.setDocument(this.getDocument());\n        this.resetCaches();\n    };\n    EditSession.prototype.getDocument = function () {\n        return this.doc;\n    };\n    EditSession.prototype.$resetRowCache = function (docRow) {\n        if (!docRow) {\n            this.$docRowCache = [];\n            this.$screenRowCache = [];\n            return;\n        }\n        var l = this.$docRowCache.length;\n        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\n        if (l > i) {\n            this.$docRowCache.splice(i, l);\n            this.$screenRowCache.splice(i, l);\n        }\n    };\n    EditSession.prototype.$getRowCacheIndex = function (cacheArray, val) {\n        var low = 0;\n        var hi = cacheArray.length - 1;\n        while (low <= hi) {\n            var mid = (low + hi) >> 1;\n            var c = cacheArray[mid];\n            if (val > c)\n                low = mid + 1;\n            else if (val < c)\n                hi = mid - 1;\n            else\n                return mid;\n        }\n        return low - 1;\n    };\n    EditSession.prototype.resetCaches = function () {\n        this.$modified = true;\n        this.$wrapData = [];\n        this.$rowLengthCache = [];\n        this.$resetRowCache(0);\n        if (!this.destroyed)\n            this.bgTokenizer.start(0);\n    };\n    EditSession.prototype.onChangeFold = function (e) {\n        var fold = e.data;\n        this.$resetRowCache(fold.start.row);\n    };\n    EditSession.prototype.onChange = function (delta) {\n        this.$modified = true;\n        this.$bidiHandler.onChange(delta);\n        this.$resetRowCache(delta.start.row);\n        var removedFolds = this.$updateInternalDataOnChange(delta);\n        if (!this.$fromUndo && this.$undoManager) {\n            if (removedFolds && removedFolds.length) {\n                this.$undoManager.add({\n                    action: \"removeFolds\",\n                    folds: removedFolds\n                }, this.mergeUndoDeltas);\n                this.mergeUndoDeltas = true;\n            }\n            this.$undoManager.add(delta, this.mergeUndoDeltas);\n            this.mergeUndoDeltas = true;\n            this.$informUndoManager.schedule();\n        }\n        this.bgTokenizer.$updateOnChange(delta);\n        this._signal(\"change\", delta);\n    };\n    EditSession.prototype.setValue = function (text) {\n        this.doc.setValue(text);\n        this.selection.moveTo(0, 0);\n        this.$resetRowCache(0);\n        this.setUndoManager(this.$undoManager);\n        this.getUndoManager().reset();\n    };\n    EditSession.fromJSON = function (session) {\n        if (typeof session == \"string\")\n            session = JSON.parse(session);\n        var undoManager = new UndoManager();\n        undoManager.$undoStack = session.history.undo;\n        undoManager.$redoStack = session.history.redo;\n        undoManager.mark = session.history.mark;\n        undoManager.$rev = session.history.rev;\n        var editSession = new EditSession(session.value);\n        session.folds.forEach(function (fold) {\n            editSession.addFold(\"...\", Range.fromPoints(fold.start, fold.end));\n        });\n        editSession.setAnnotations(session.annotations);\n        editSession.setBreakpoints(session.breakpoints);\n        editSession.setMode(session.mode);\n        editSession.setScrollLeft(session.scrollLeft);\n        editSession.setScrollTop(session.scrollTop);\n        editSession.setUndoManager(undoManager);\n        editSession.selection.fromJSON(session.selection);\n        return editSession;\n    };\n    EditSession.prototype.toJSON = function () {\n        return {\n            annotations: this.$annotations,\n            breakpoints: this.$breakpoints,\n            folds: this.getAllFolds().map(function (fold) {\n                return fold.range;\n            }),\n            history: this.getUndoManager(),\n            mode: this.$mode.$id,\n            scrollLeft: this.$scrollLeft,\n            scrollTop: this.$scrollTop,\n            selection: this.selection.toJSON(),\n            value: this.doc.getValue()\n        };\n    };\n    EditSession.prototype.toString = function () {\n        return this.doc.getValue();\n    };\n    EditSession.prototype.getSelection = function () {\n        return this.selection;\n    };\n    EditSession.prototype.getState = function (row) {\n        return this.bgTokenizer.getState(row);\n    };\n    EditSession.prototype.getTokens = function (row) {\n        return this.bgTokenizer.getTokens(row);\n    };\n    EditSession.prototype.getTokenAt = function (row, column) {\n        var tokens = this.bgTokenizer.getTokens(row);\n        var token, c = 0;\n        if (column == null) {\n            var i = tokens.length - 1;\n            c = this.getLine(row).length;\n        }\n        else {\n            for (var i = 0; i < tokens.length; i++) {\n                c += tokens[i].value.length;\n                if (c >= column)\n                    break;\n            }\n        }\n        token = tokens[i];\n        if (!token)\n            return null;\n        token.index = i;\n        token.start = c - token.value.length;\n        return token;\n    };\n    EditSession.prototype.setUndoManager = function (undoManager) {\n        this.$undoManager = undoManager;\n        if (this.$informUndoManager)\n            this.$informUndoManager.cancel();\n        if (undoManager) {\n            var self = this;\n            undoManager.addSession(this);\n            this.$syncInformUndoManager = function () {\n                self.$informUndoManager.cancel();\n                self.mergeUndoDeltas = false;\n            };\n            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\n        }\n        else {\n            this.$syncInformUndoManager = function () { };\n        }\n    };\n    EditSession.prototype.markUndoGroup = function () {\n        if (this.$syncInformUndoManager)\n            this.$syncInformUndoManager();\n    };\n    EditSession.prototype.getUndoManager = function () {\n        return this.$undoManager || this.$defaultUndoManager;\n    };\n    EditSession.prototype.getTabString = function () {\n        if (this.getUseSoftTabs()) {\n            return lang.stringRepeat(\" \", this.getTabSize());\n        }\n        else {\n            return \"\\t\";\n        }\n    };\n    EditSession.prototype.setUseSoftTabs = function (val) {\n        this.setOption(\"useSoftTabs\", val);\n    };\n    EditSession.prototype.getUseSoftTabs = function () {\n        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\n    };\n    EditSession.prototype.setTabSize = function (tabSize) {\n        this.setOption(\"tabSize\", tabSize);\n    };\n    EditSession.prototype.getTabSize = function () {\n        return this.$tabSize;\n    };\n    EditSession.prototype.isTabStop = function (position) {\n        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\n    };\n    EditSession.prototype.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {\n        this.setOption(\"navigateWithinSoftTabs\", navigateWithinSoftTabs);\n    };\n    EditSession.prototype.getNavigateWithinSoftTabs = function () {\n        return this.$navigateWithinSoftTabs;\n    };\n    EditSession.prototype.setOverwrite = function (overwrite) {\n        this.setOption(\"overwrite\", overwrite);\n    };\n    EditSession.prototype.getOverwrite = function () {\n        return this.$overwrite;\n    };\n    EditSession.prototype.toggleOverwrite = function () {\n        this.setOverwrite(!this.$overwrite);\n    };\n    EditSession.prototype.addGutterDecoration = function (row, className) {\n        if (!this.$decorations[row])\n            this.$decorations[row] = \"\";\n        this.$decorations[row] += \" \" + className;\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.removeGutterDecoration = function (row, className) {\n        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.getBreakpoints = function () {\n        return this.$breakpoints;\n    };\n    EditSession.prototype.setBreakpoints = function (rows) {\n        this.$breakpoints = [];\n        for (var i = 0; i < rows.length; i++) {\n            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\n        }\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.clearBreakpoints = function () {\n        this.$breakpoints = [];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.setBreakpoint = function (row, className) {\n        if (className === undefined)\n            className = \"ace_breakpoint\";\n        if (className)\n            this.$breakpoints[row] = className;\n        else\n            delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.clearBreakpoint = function (row) {\n        delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.addMarker = function (range, clazz, type, inFront) {\n        var id = this.$markerId++;\n        var marker = {\n            range: range,\n            type: type || \"line\",\n            renderer: typeof type == \"function\" ? type : null,\n            clazz: clazz,\n            inFront: !!inFront,\n            id: id\n        };\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        }\n        else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n        return id;\n    };\n    EditSession.prototype.addDynamicMarker = function (marker, inFront) {\n        if (!marker.update)\n            return;\n        var id = this.$markerId++;\n        marker.id = id;\n        marker.inFront = !!inFront;\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        }\n        else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n        return marker;\n    };\n    EditSession.prototype.removeMarker = function (markerId) {\n        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\n        if (!marker)\n            return;\n        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\n        delete (markers[markerId]);\n        this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\n    };\n    EditSession.prototype.getMarkers = function (inFront) {\n        return inFront ? this.$frontMarkers : this.$backMarkers;\n    };\n    EditSession.prototype.highlight = function (re) {\n        if (!this.$searchHighlight) {\n            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\n            this.$searchHighlight = this.addDynamicMarker(highlight);\n        }\n        this.$searchHighlight.setRegexp(re);\n    };\n    EditSession.prototype.highlightLines = function (startRow, endRow, clazz, inFront) {\n        if (typeof endRow != \"number\") {\n            clazz = endRow;\n            endRow = startRow;\n        }\n        if (!clazz)\n            clazz = \"ace_step\";\n        var range = new Range(startRow, 0, endRow, Infinity);\n        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\n        return range;\n    };\n    EditSession.prototype.setAnnotations = function (annotations) {\n        this.$annotations = annotations;\n        this._signal(\"changeAnnotation\", {});\n    };\n    EditSession.prototype.getAnnotations = function () {\n        return this.$annotations || [];\n    };\n    EditSession.prototype.clearAnnotations = function () {\n        this.setAnnotations([]);\n    };\n    EditSession.prototype.$detectNewLine = function (text) {\n        var match = text.match(/^.*?(\\r?\\n)/m);\n        if (match) {\n            this.$autoNewLine = match[1];\n        }\n        else {\n            this.$autoNewLine = \"\\n\";\n        }\n    };\n    EditSession.prototype.getWordRange = function (row, column) {\n        var line = this.getLine(row);\n        var inToken = false;\n        if (column > 0)\n            inToken = !!line.charAt(column - 1).match(this.tokenRe);\n        if (!inToken)\n            inToken = !!line.charAt(column).match(this.tokenRe);\n        if (inToken)\n            var re = this.tokenRe;\n        else if (/^\\s+$/.test(line.slice(column - 1, column + 1)))\n            var re = /\\s/;\n        else\n            var re = this.nonTokenRe;\n        var start = column;\n        if (start > 0) {\n            do {\n                start--;\n            } while (start >= 0 && line.charAt(start).match(re));\n            start++;\n        }\n        var end = column;\n        while (end < line.length && line.charAt(end).match(re)) {\n            end++;\n        }\n        return new Range(row, start, row, end);\n    };\n    EditSession.prototype.getAWordRange = function (row, column) {\n        var wordRange = this.getWordRange(row, column);\n        var line = this.getLine(wordRange.end.row);\n        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\n            wordRange.end.column += 1;\n        }\n        return wordRange;\n    };\n    EditSession.prototype.setNewLineMode = function (newLineMode) {\n        this.doc.setNewLineMode(newLineMode);\n    };\n    EditSession.prototype.getNewLineMode = function () {\n        return this.doc.getNewLineMode();\n    };\n    EditSession.prototype.setUseWorker = function (useWorker) { this.setOption(\"useWorker\", useWorker); };\n    EditSession.prototype.getUseWorker = function () { return this.$useWorker; };\n    EditSession.prototype.onReloadTokenizer = function (e) {\n        var rows = e.data;\n        this.bgTokenizer.start(rows.first);\n        this._signal(\"tokenizerUpdate\", e);\n    };\n    EditSession.prototype.setMode = function (mode, cb) {\n        if (mode && typeof mode === \"object\") {\n            if (mode.getTokenizer)\n                return this.$onChangeMode(mode);\n            var options = mode;\n            var path = options.path;\n        }\n        else {\n            path = /**@type{string}*/ (mode) || \"ace/mode/text\";\n        }\n        if (!this.$modes[\"ace/mode/text\"])\n            this.$modes[\"ace/mode/text\"] = new TextMode();\n        if (this.$modes[path] && !options) {\n            this.$onChangeMode(this.$modes[path]);\n            cb && cb();\n            return;\n        }\n        this.$modeId = path;\n        config.loadModule([\"mode\", path], function (m) {\n            if (this.$modeId !== path)\n                return cb && cb();\n            if (this.$modes[path] && !options) {\n                this.$onChangeMode(this.$modes[path]);\n            }\n            else if (m && m.Mode) {\n                m = new m.Mode(options);\n                if (!options) {\n                    this.$modes[path] = m;\n                    m.$id = path;\n                }\n                this.$onChangeMode(m);\n            }\n            cb && cb();\n        }.bind(this));\n        if (!this.$mode)\n            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\n    };\n    EditSession.prototype.$onChangeMode = function (mode, $isPlaceholder) {\n        if (!$isPlaceholder)\n            this.$modeId = mode.$id;\n        if (this.$mode === mode)\n            return;\n        var oldMode = this.$mode;\n        this.$mode = mode;\n        this.$stopWorker();\n        if (this.$useWorker)\n            this.$startWorker();\n        var tokenizer = mode.getTokenizer();\n        if (tokenizer.on !== undefined) {\n            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\n            tokenizer.on(\"update\", onReloadTokenizer);\n        }\n        this.bgTokenizer.setTokenizer(tokenizer);\n        this.bgTokenizer.setDocument(this.getDocument());\n        this.tokenRe = mode.tokenRe;\n        this.nonTokenRe = mode.nonTokenRe;\n        if (!$isPlaceholder) {\n            if (mode.attachToSession)\n                mode.attachToSession(this);\n            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\n            this.$setFolding(mode.foldingRules);\n            this.bgTokenizer.start(0);\n            this._emit(\"changeMode\", { oldMode: oldMode, mode: mode });\n        }\n    };\n    EditSession.prototype.$stopWorker = function () {\n        if (this.$worker) {\n            this.$worker.terminate();\n            this.$worker = null;\n        }\n    };\n    EditSession.prototype.$startWorker = function () {\n        try {\n            this.$worker = this.$mode.createWorker(this);\n        }\n        catch (e) {\n            config.warn(\"Could not load worker\", e);\n            this.$worker = null;\n        }\n    };\n    EditSession.prototype.getMode = function () {\n        return this.$mode;\n    };\n    EditSession.prototype.setScrollTop = function (scrollTop) {\n        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\n            return;\n        this.$scrollTop = scrollTop;\n        this._signal(\"changeScrollTop\", scrollTop);\n    };\n    EditSession.prototype.getScrollTop = function () {\n        return this.$scrollTop;\n    };\n    EditSession.prototype.setScrollLeft = function (scrollLeft) {\n        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\n            return;\n        this.$scrollLeft = scrollLeft;\n        this._signal(\"changeScrollLeft\", scrollLeft);\n    };\n    EditSession.prototype.getScrollLeft = function () {\n        return this.$scrollLeft;\n    };\n    EditSession.prototype.getScreenWidth = function () {\n        this.$computeWidth();\n        if (this.lineWidgets)\n            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\n        return this.screenWidth;\n    };\n    EditSession.prototype.getLineWidgetMaxWidth = function () {\n        if (this.lineWidgetsWidth != null)\n            return this.lineWidgetsWidth;\n        var width = 0;\n        this.lineWidgets.forEach(function (w) {\n            if (w && w.screenWidth > width)\n                width = w.screenWidth;\n        });\n        return this.lineWidgetWidth = width;\n    };\n    EditSession.prototype.$computeWidth = function (force) {\n        if (this.$modified || force) {\n            this.$modified = false;\n            if (this.$useWrapMode)\n                return this.screenWidth = this.$wrapLimit;\n            var lines = this.doc.getAllLines();\n            var cache = this.$rowLengthCache;\n            var longestScreenLine = 0;\n            var foldIndex = 0;\n            var foldLine = this.$foldData[foldIndex];\n            var foldStart = foldLine ? foldLine.start.row : Infinity;\n            var len = lines.length;\n            for (var i = 0; i < len; i++) {\n                if (i > foldStart) {\n                    i = foldLine.end.row + 1;\n                    if (i >= len)\n                        break;\n                    foldLine = this.$foldData[foldIndex++];\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n                if (cache[i] == null)\n                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\n                if (cache[i] > longestScreenLine)\n                    longestScreenLine = cache[i];\n            }\n            this.screenWidth = longestScreenLine;\n        }\n    };\n    EditSession.prototype.getLine = function (row) {\n        return this.doc.getLine(row);\n    };\n    EditSession.prototype.getLines = function (firstRow, lastRow) {\n        return this.doc.getLines(firstRow, lastRow);\n    };\n    EditSession.prototype.getLength = function () {\n        return this.doc.getLength();\n    };\n    EditSession.prototype.getTextRange = function (range) {\n        return this.doc.getTextRange(range || this.selection.getRange());\n    };\n    EditSession.prototype.insert = function (position, text) {\n        return this.doc.insert(position, text);\n    };\n    EditSession.prototype.remove = function (range) {\n        return this.doc.remove(range);\n    };\n    EditSession.prototype.removeFullLines = function (firstRow, lastRow) {\n        return this.doc.removeFullLines(firstRow, lastRow);\n    };\n    EditSession.prototype.undoChanges = function (deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n        this.$fromUndo = true;\n        for (var i = deltas.length - 1; i != -1; i--) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.revertDelta(delta);\n            }\n            else if (delta.folds) {\n                this.addFolds(delta.folds);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionBefore)\n                this.selection.fromJSON(deltas.selectionBefore);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, true));\n        }\n        this.$fromUndo = false;\n    };\n    EditSession.prototype.redoChanges = function (deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n        this.$fromUndo = true;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.$safeApplyDelta(delta);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionAfter)\n                this.selection.fromJSON(deltas.selectionAfter);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, false));\n        }\n        this.$fromUndo = false;\n    };\n    EditSession.prototype.setUndoSelect = function (enable) {\n        this.$undoSelect = enable;\n    };\n    EditSession.prototype.$getUndoSelection = function (deltas, isUndo) {\n        function isInsert(delta) {\n            return isUndo ? delta.action !== \"insert\" : delta.action === \"insert\";\n        }\n        var range, point;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (!delta.start)\n                continue; // skip folds\n            if (!range) {\n                if (isInsert(delta)) {\n                    range = Range.fromPoints(delta.start, delta.end);\n                }\n                else {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n                continue;\n            }\n            if (isInsert(delta)) {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range.setStart(point);\n                }\n                point = delta.end;\n                if (range.compare(point.row, point.column) == 1) {\n                    range.setEnd(point);\n                }\n            }\n            else {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n            }\n        }\n        return range;\n    };\n    EditSession.prototype.replace = function (range, text) {\n        return this.doc.replace(range, text);\n    };\n    EditSession.prototype.moveText = function (fromRange, toPosition, copy) {\n        var text = this.getTextRange(fromRange);\n        var folds = this.getFoldsInRange(fromRange);\n        var toRange = Range.fromPoints(toPosition, toPosition);\n        if (!copy) {\n            this.remove(fromRange);\n            var rowDiff = fromRange.start.row - fromRange.end.row;\n            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\n            if (collDiff) {\n                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\n                    toRange.start.column += collDiff;\n                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\n                    toRange.end.column += collDiff;\n            }\n            if (rowDiff && toRange.start.row >= fromRange.end.row) {\n                toRange.start.row += rowDiff;\n                toRange.end.row += rowDiff;\n            }\n        }\n        toRange.end = this.insert(toRange.start, text);\n        if (folds.length) {\n            var oldStart = fromRange.start;\n            var newStart = toRange.start;\n            var rowDiff = newStart.row - oldStart.row;\n            var collDiff = newStart.column - oldStart.column;\n            this.addFolds(folds.map(function (x) {\n                x = x.clone();\n                if (x.start.row == oldStart.row)\n                    x.start.column += collDiff;\n                if (x.end.row == oldStart.row)\n                    x.end.column += collDiff;\n                x.start.row += rowDiff;\n                x.end.row += rowDiff;\n                return x;\n            }));\n        }\n        return toRange;\n    };\n    EditSession.prototype.indentRows = function (startRow, endRow, indentString) {\n        indentString = indentString.replace(/\\t/g, this.getTabString());\n        for (var row = startRow; row <= endRow; row++)\n            this.doc.insertInLine({ row: row, column: 0 }, indentString);\n    };\n    EditSession.prototype.outdentRows = function (range) {\n        var rowRange = range.collapseRows();\n        var deleteRange = new Range(0, 0, 0, 0);\n        var size = this.getTabSize();\n        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\n            var line = this.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            for (var j = 0; j < size; ++j)\n                if (line.charAt(j) != ' ')\n                    break;\n            if (j < size && line.charAt(j) == '\\t') {\n                deleteRange.start.column = j;\n                deleteRange.end.column = j + 1;\n            }\n            else {\n                deleteRange.start.column = 0;\n                deleteRange.end.column = j;\n            }\n            this.remove(deleteRange);\n        }\n    };\n    EditSession.prototype.$moveLines = function (firstRow, lastRow, dir) {\n        firstRow = this.getRowFoldStart(firstRow);\n        lastRow = this.getRowFoldEnd(lastRow);\n        if (dir < 0) {\n            var row = this.getRowFoldStart(firstRow + dir);\n            if (row < 0)\n                return 0;\n            var diff = row - firstRow;\n        }\n        else if (dir > 0) {\n            var row = this.getRowFoldEnd(lastRow + dir);\n            if (row > this.doc.getLength() - 1)\n                return 0;\n            var diff = row - lastRow;\n        }\n        else {\n            firstRow = this.$clipRowToDocument(firstRow);\n            lastRow = this.$clipRowToDocument(lastRow);\n            var diff = lastRow - firstRow + 1;\n        }\n        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\n        var folds = this.getFoldsInRange(range).map(function (x) {\n            x = x.clone();\n            x.start.row += diff;\n            x.end.row += diff;\n            return x;\n        });\n        var lines = dir == 0\n            ? this.doc.getLines(firstRow, lastRow)\n            : this.doc.removeFullLines(firstRow, lastRow);\n        this.doc.insertFullLines(firstRow + diff, lines);\n        folds.length && this.addFolds(folds);\n        return diff;\n    };\n    EditSession.prototype.moveLinesUp = function (firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, -1);\n    };\n    EditSession.prototype.moveLinesDown = function (firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 1);\n    };\n    EditSession.prototype.duplicateLines = function (firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 0);\n    };\n    EditSession.prototype.$clipRowToDocument = function (row) {\n        return Math.max(0, Math.min(row, this.doc.getLength() - 1));\n    };\n    EditSession.prototype.$clipColumnToRow = function (row, column) {\n        if (column < 0)\n            return 0;\n        return Math.min(this.doc.getLine(row).length, column);\n    };\n    EditSession.prototype.$clipPositionToDocument = function (row, column) {\n        column = Math.max(0, column);\n        if (row < 0) {\n            row = 0;\n            column = 0;\n        }\n        else {\n            var len = this.doc.getLength();\n            if (row >= len) {\n                row = len - 1;\n                column = this.doc.getLine(len - 1).length;\n            }\n            else {\n                column = Math.min(this.doc.getLine(row).length, column);\n            }\n        }\n        return {\n            row: row,\n            column: column\n        };\n    };\n    EditSession.prototype.$clipRangeToDocument = function (range) {\n        if (range.start.row < 0) {\n            range.start.row = 0;\n            range.start.column = 0;\n        }\n        else {\n            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);\n        }\n        var len = this.doc.getLength() - 1;\n        if (range.end.row > len) {\n            range.end.row = len;\n            range.end.column = this.doc.getLine(len).length;\n        }\n        else {\n            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);\n        }\n        return range;\n    };\n    EditSession.prototype.setUseWrapMode = function (useWrapMode) {\n        if (useWrapMode != this.$useWrapMode) {\n            this.$useWrapMode = useWrapMode;\n            this.$modified = true;\n            this.$resetRowCache(0);\n            if (useWrapMode) {\n                var len = this.getLength();\n                this.$wrapData = Array(len);\n                this.$updateWrapData(0, len - 1);\n            }\n            this._signal(\"changeWrapMode\");\n        }\n    };\n    EditSession.prototype.getUseWrapMode = function () {\n        return this.$useWrapMode;\n    };\n    EditSession.prototype.setWrapLimitRange = function (min, max) {\n        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\n            this.$wrapLimitRange = { min: min, max: max };\n            this.$modified = true;\n            this.$bidiHandler.markAsDirty();\n            if (this.$useWrapMode)\n                this._signal(\"changeWrapMode\");\n        }\n    };\n    EditSession.prototype.adjustWrapLimit = function (desiredLimit, $printMargin) {\n        var limits = this.$wrapLimitRange;\n        if (limits.max < 0)\n            limits = { min: $printMargin, max: $printMargin };\n        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\n        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\n            this.$wrapLimit = wrapLimit;\n            this.$modified = true;\n            if (this.$useWrapMode) {\n                this.$updateWrapData(0, this.getLength() - 1);\n                this.$resetRowCache(0);\n                this._signal(\"changeWrapLimit\");\n            }\n            return true;\n        }\n        return false;\n    };\n    EditSession.prototype.$constrainWrapLimit = function (wrapLimit, min, max) {\n        if (min)\n            wrapLimit = Math.max(min, wrapLimit);\n        if (max)\n            wrapLimit = Math.min(max, wrapLimit);\n        return wrapLimit;\n    };\n    EditSession.prototype.getWrapLimit = function () {\n        return this.$wrapLimit;\n    };\n    EditSession.prototype.setWrapLimit = function (limit) {\n        this.setWrapLimitRange(limit, limit);\n    };\n    EditSession.prototype.getWrapLimitRange = function () {\n        return {\n            min: this.$wrapLimitRange.min,\n            max: this.$wrapLimitRange.max\n        };\n    };\n    EditSession.prototype.$updateInternalDataOnChange = function (delta) {\n        var useWrapMode = this.$useWrapMode;\n        var action = delta.action;\n        var start = delta.start;\n        var end = delta.end;\n        var firstRow = start.row;\n        var lastRow = end.row;\n        var len = lastRow - firstRow;\n        var removedFolds = null;\n        this.$updating = true;\n        if (len != 0) {\n            if (action === \"remove\") {\n                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\n                var foldLines = this.$foldData;\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n                var foldLine = this.getFoldLine(end.row);\n                var idx = 0;\n                if (foldLine) {\n                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\n                    foldLine.shiftRow(-len);\n                    var foldLineBefore = this.getFoldLine(firstRow);\n                    if (foldLineBefore && foldLineBefore !== foldLine) {\n                        foldLineBefore.merge(foldLine);\n                        foldLine = foldLineBefore;\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= end.row) {\n                        foldLine.shiftRow(-len);\n                    }\n                }\n                lastRow = firstRow;\n            }\n            else {\n                var args = Array(len);\n                args.unshift(firstRow, 0);\n                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;\n                arr.splice.apply(arr, args);\n                var foldLines = this.$foldData;\n                var foldLine = this.getFoldLine(firstRow);\n                var idx = 0;\n                if (foldLine) {\n                    var cmp = foldLine.range.compareInside(start.row, start.column);\n                    if (cmp == 0) {\n                        foldLine = foldLine.split(start.row, start.column);\n                        if (foldLine) {\n                            foldLine.shiftRow(len);\n                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\n                        }\n                    }\n                    else \n                    if (cmp == -1) {\n                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\n                        foldLine.shiftRow(len);\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= firstRow) {\n                        foldLine.shiftRow(len);\n                    }\n                }\n            }\n        }\n        else {\n            len = Math.abs(delta.start.column - delta.end.column);\n            if (action === \"remove\") {\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n                len = -len;\n            }\n            var foldLine = this.getFoldLine(firstRow);\n            if (foldLine) {\n                foldLine.addRemoveChars(firstRow, start.column, len);\n            }\n        }\n        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\n            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\n        }\n        this.$updating = false;\n        if (useWrapMode)\n            this.$updateWrapData(firstRow, lastRow);\n        else\n            this.$updateRowLengthCache(firstRow, lastRow);\n        return removedFolds;\n    };\n    EditSession.prototype.$updateRowLengthCache = function (firstRow, lastRow) {\n        this.$rowLengthCache[firstRow] = null;\n        this.$rowLengthCache[lastRow] = null;\n    };\n    EditSession.prototype.$updateWrapData = function (firstRow, lastRow) {\n        var lines = this.doc.getAllLines();\n        var tabSize = this.getTabSize();\n        var wrapData = this.$wrapData;\n        var wrapLimit = this.$wrapLimit;\n        var tokens;\n        var foldLine;\n        var row = firstRow;\n        lastRow = Math.min(lastRow, lines.length - 1);\n        while (row <= lastRow) {\n            foldLine = this.getFoldLine(row, foldLine);\n            if (!foldLine) {\n                tokens = this.$getDisplayTokens(lines[row]);\n                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row++;\n            }\n            else {\n                tokens = [];\n                foldLine.walk(function (placeholder, row, column, lastColumn) {\n                    var walkTokens;\n                    if (placeholder != null) {\n                        walkTokens = this.$getDisplayTokens(placeholder, tokens.length);\n                        walkTokens[0] = PLACEHOLDER_START;\n                        for (var i = 1; i < walkTokens.length; i++) {\n                            walkTokens[i] = PLACEHOLDER_BODY;\n                        }\n                    }\n                    else {\n                        walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);\n                    }\n                    tokens = tokens.concat(walkTokens);\n                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);\n                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row = foldLine.end.row + 1;\n            }\n        }\n    };\n    EditSession.prototype.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {\n        if (tokens.length == 0) {\n            return [];\n        }\n        var splits = [];\n        var displayLength = tokens.length;\n        var lastSplit = 0, lastDocSplit = 0;\n        var isCode = this.$wrapAsCode;\n        var indentedSoftWrap = this.$indentedSoftWrap;\n        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)\n            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);\n        function getWrapIndent() {\n            var indentation = 0;\n            if (maxIndent === 0)\n                return indentation;\n            if (indentedSoftWrap) {\n                for (var i = 0; i < tokens.length; i++) {\n                    var token = tokens[i];\n                    if (token == SPACE)\n                        indentation += 1;\n                    else if (token == TAB)\n                        indentation += tabSize;\n                    else if (token == TAB_SPACE)\n                        continue;\n                    else\n                        break;\n                }\n            }\n            if (isCode && indentedSoftWrap !== false)\n                indentation += tabSize;\n            return Math.min(indentation, maxIndent);\n        }\n        function addSplit(screenPos) {\n            var len = screenPos - lastSplit;\n            for (var i = lastSplit; i < screenPos; i++) {\n                var ch = tokens[i];\n                if (ch === 12 || ch === 2)\n                    len -= 1;\n            }\n            if (!splits.length) {\n                indent = getWrapIndent();\n                splits.indent = indent;\n            }\n            lastDocSplit += len;\n            splits.push(lastDocSplit);\n            lastSplit = screenPos;\n        }\n        var indent = 0;\n        while (displayLength - lastSplit > wrapLimit - indent) {\n            var split = lastSplit + wrapLimit - indent;\n            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\n                addSplit(split);\n                continue;\n            }\n            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\n                for (split; split != lastSplit - 1; split--) {\n                    if (tokens[split] == PLACEHOLDER_START) {\n                        break;\n                    }\n                }\n                if (split > lastSplit) {\n                    addSplit(split);\n                    continue;\n                }\n                split = lastSplit + wrapLimit;\n                for (split; split < tokens.length; split++) {\n                    if (tokens[split] != PLACEHOLDER_BODY) {\n                        break;\n                    }\n                }\n                if (split == tokens.length) {\n                    break; // Breaks the while-loop.\n                }\n                addSplit(split);\n                continue;\n            }\n            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);\n            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                split--;\n            }\n            if (isCode) {\n                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                    split--;\n                }\n                while (split > minSplit && tokens[split] == PUNCTUATION) {\n                    split--;\n                }\n            }\n            else {\n                while (split > minSplit && tokens[split] < SPACE) {\n                    split--;\n                }\n            }\n            if (split > minSplit) {\n                addSplit(++split);\n                continue;\n            }\n            split = lastSplit + wrapLimit;\n            if (tokens[split] == CHAR_EXT)\n                split--;\n            addSplit(split - indent);\n        }\n        return splits;\n    };\n    EditSession.prototype.$getDisplayTokens = function (str, offset) {\n        var arr = [];\n        var tabSize;\n        offset = offset || 0;\n        for (var i = 0; i < str.length; i++) {\n            var c = str.charCodeAt(i);\n            if (c == 9) {\n                tabSize = this.getScreenTabSize(arr.length + offset);\n                arr.push(TAB);\n                for (var n = 1; n < tabSize; n++) {\n                    arr.push(TAB_SPACE);\n                }\n            }\n            else if (c == 32) {\n                arr.push(SPACE);\n            }\n            else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {\n                arr.push(PUNCTUATION);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                arr.push(CHAR, CHAR_EXT);\n            }\n            else {\n                arr.push(CHAR);\n            }\n        }\n        return arr;\n    };\n    EditSession.prototype.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {\n        if (maxScreenColumn == 0)\n            return [0, 0];\n        if (maxScreenColumn == null)\n            maxScreenColumn = Infinity;\n        screenColumn = screenColumn || 0;\n        var c, column;\n        for (column = 0; column < str.length; column++) {\n            c = str.charCodeAt(column);\n            if (c == 9) {\n                screenColumn += this.getScreenTabSize(screenColumn);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                screenColumn += 2;\n            }\n            else {\n                screenColumn += 1;\n            }\n            if (screenColumn > maxScreenColumn) {\n                break;\n            }\n        }\n        return [screenColumn, column];\n    };\n    EditSession.prototype.getRowLength = function (row) {\n        var h = 1;\n        if (this.lineWidgets)\n            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        if (!this.$useWrapMode || !this.$wrapData[row])\n            return h;\n        else\n            return this.$wrapData[row].length + h;\n    };\n    EditSession.prototype.getRowLineCount = function (row) {\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1;\n        }\n        else {\n            return this.$wrapData[row].length + 1;\n        }\n    };\n    EditSession.prototype.getRowWrapIndent = function (screenRow) {\n        if (this.$useWrapMode) {\n            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n            var splits = this.$wrapData[pos.row];\n            return splits.length && splits[0] < pos.column ? splits.indent : 0;\n        }\n        else {\n            return 0;\n        }\n    };\n    EditSession.prototype.getScreenLastRowColumn = function (screenRow) {\n        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n        return this.documentToScreenColumn(pos.row, pos.column);\n    };\n    EditSession.prototype.getDocumentLastRowColumn = function (docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.getScreenLastRowColumn(screenRow);\n    };\n    EditSession.prototype.getDocumentLastRowColumnPosition = function (docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\n    };\n    EditSession.prototype.getRowSplitData = function (row) {\n        if (!this.$useWrapMode) {\n            return undefined;\n        }\n        else {\n            return this.$wrapData[row];\n        }\n    };\n    EditSession.prototype.getScreenTabSize = function (screenColumn) {\n        return this.$tabSize - (screenColumn % this.$tabSize | 0);\n    };\n    EditSession.prototype.screenToDocumentRow = function (screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).row;\n    };\n    EditSession.prototype.screenToDocumentColumn = function (screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).column;\n    };\n    EditSession.prototype.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {\n        if (screenRow < 0)\n            return { row: 0, column: 0 };\n        var line;\n        var docRow = 0;\n        var docColumn = 0;\n        var column;\n        var row = 0;\n        var rowLength = 0;\n        var rowCache = this.$screenRowCache;\n        var i = this.$getRowCacheIndex(rowCache, screenRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var docRow = this.$docRowCache[i];\n            var doCache = screenRow > rowCache[l - 1];\n        }\n        else {\n            var doCache = !l;\n        }\n        var maxRow = this.getLength() - 1;\n        var foldLine = this.getNextFoldLine(docRow);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (row <= screenRow) {\n            rowLength = this.getRowLength(docRow);\n            if (row + rowLength > screenRow || docRow >= maxRow) {\n                break;\n            }\n            else {\n                row += rowLength;\n                docRow++;\n                if (docRow > foldStart) {\n                    docRow = foldLine.end.row + 1;\n                    foldLine = this.getNextFoldLine(docRow, foldLine);\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n            }\n            if (doCache) {\n                this.$docRowCache.push(docRow);\n                this.$screenRowCache.push(row);\n            }\n        }\n        if (foldLine && foldLine.start.row <= docRow) {\n            line = this.getFoldDisplayLine(foldLine);\n            docRow = foldLine.start.row;\n        }\n        else if (row + rowLength <= screenRow || docRow > maxRow) {\n            return {\n                row: maxRow,\n                column: this.getLine(maxRow).length\n            };\n        }\n        else {\n            line = this.getLine(docRow);\n            foldLine = null;\n        }\n        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);\n        if (this.$useWrapMode) {\n            var splits = this.$wrapData[docRow];\n            if (splits) {\n                column = splits[splitIndex];\n                if (splitIndex > 0 && splits.length) {\n                    wrapIndent = splits.indent;\n                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\n                    line = line.substring(docColumn);\n                }\n            }\n        }\n        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))\n            screenColumn = this.$bidiHandler.offsetToCol(offsetX);\n        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];\n        if (this.$useWrapMode && docColumn >= column)\n            docColumn = column - 1;\n        if (foldLine)\n            return foldLine.idxToPosition(docColumn);\n        return { row: docRow, column: docColumn };\n    };\n    EditSession.prototype.documentToScreenPosition = function (docRow, docColumn) {\n        if (typeof docColumn === \"undefined\")\n            var pos = this.$clipPositionToDocument(/**@type{Point}*/ (docRow).row, /**@type{Point}*/ (docRow).column);\n        else\n            pos = this.$clipPositionToDocument(/**@type{number}*/ (docRow), docColumn);\n        docRow = pos.row;\n        docColumn = pos.column;\n        var screenRow = 0;\n        var foldStartRow = null;\n        var fold = null;\n        fold = this.getFoldAt(docRow, docColumn, 1);\n        if (fold) {\n            docRow = fold.start.row;\n            docColumn = fold.start.column;\n        }\n        var rowEnd, row = 0;\n        var rowCache = this.$docRowCache;\n        var i = this.$getRowCacheIndex(rowCache, docRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var screenRow = this.$screenRowCache[i];\n            var doCache = docRow > rowCache[l - 1];\n        }\n        else {\n            var doCache = !l;\n        }\n        var foldLine = this.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (row < docRow) {\n            if (row >= foldStart) {\n                rowEnd = foldLine.end.row + 1;\n                if (rowEnd > docRow)\n                    break;\n                foldLine = this.getNextFoldLine(rowEnd, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            else {\n                rowEnd = row + 1;\n            }\n            screenRow += this.getRowLength(row);\n            row = rowEnd;\n            if (doCache) {\n                this.$docRowCache.push(row);\n                this.$screenRowCache.push(screenRow);\n            }\n        }\n        var textLine = \"\";\n        if (foldLine && row >= foldStart) {\n            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\n            foldStartRow = foldLine.start.row;\n        }\n        else {\n            textLine = this.getLine(docRow).substring(0, docColumn);\n            foldStartRow = docRow;\n        }\n        var wrapIndent = 0;\n        if (this.$useWrapMode) {\n            var wrapRow = this.$wrapData[foldStartRow];\n            if (wrapRow) {\n                var screenRowOffset = 0;\n                while (textLine.length >= wrapRow[screenRowOffset]) {\n                    screenRow++;\n                    screenRowOffset++;\n                }\n                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);\n                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;\n            }\n        }\n        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)\n            screenRow += this.lineWidgets[row].rowsAbove;\n        return {\n            row: screenRow,\n            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]\n        };\n    };\n    EditSession.prototype.documentToScreenColumn = function (row, docColumn) {\n        return this.documentToScreenPosition(row, docColumn).column;\n    };\n    EditSession.prototype.documentToScreenRow = function (docRow, docColumn) {\n        return this.documentToScreenPosition(docRow, docColumn).row;\n    };\n    EditSession.prototype.getScreenLength = function () {\n        var screenRows = 0;\n        var fold = null;\n        if (!this.$useWrapMode) {\n            screenRows = this.getLength();\n            var foldData = this.$foldData;\n            for (var i = 0; i < foldData.length; i++) {\n                fold = foldData[i];\n                screenRows -= fold.end.row - fold.start.row;\n            }\n        }\n        else {\n            var lastRow = this.$wrapData.length;\n            var row = 0, i = 0;\n            var fold = this.$foldData[i++];\n            var foldStart = fold ? fold.start.row : Infinity;\n            while (row < lastRow) {\n                var splits = this.$wrapData[row];\n                screenRows += splits ? splits.length + 1 : 1;\n                row++;\n                if (row > foldStart) {\n                    row = fold.end.row + 1;\n                    fold = this.$foldData[i++];\n                    foldStart = fold ? fold.start.row : Infinity;\n                }\n            }\n        }\n        if (this.lineWidgets)\n            screenRows += this.$getWidgetScreenLength();\n        return screenRows;\n    };\n    EditSession.prototype.$setFontMetrics = function (fm) {\n        if (!this.$enableVarChar)\n            return;\n        this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {\n            if (maxScreenColumn === 0)\n                return [0, 0];\n            if (!maxScreenColumn)\n                maxScreenColumn = Infinity;\n            screenColumn = screenColumn || 0;\n            var c, column;\n            for (column = 0; column < str.length; column++) {\n                c = str.charAt(column);\n                if (c === \"\\t\") {\n                    screenColumn += this.getScreenTabSize(screenColumn);\n                }\n                else {\n                    screenColumn += fm.getCharacterWidth(c);\n                }\n                if (screenColumn > maxScreenColumn) {\n                    break;\n                }\n            }\n            return [screenColumn, column];\n        };\n    };\n    EditSession.prototype.getPrecedingCharacter = function () {\n        var pos = this.selection.getCursor();\n        if (pos.column === 0) {\n            return pos.row === 0 ? \"\" : this.doc.getNewLineCharacter();\n        }\n        var currentLine = this.getLine(pos.row);\n        return currentLine[pos.column - 1];\n    };\n    EditSession.prototype.destroy = function () {\n        if (!this.destroyed) {\n            this.bgTokenizer.setDocument(null);\n            this.bgTokenizer.cleanup();\n            this.destroyed = true;\n        }\n        this.$stopWorker();\n        this.removeAllListeners();\n        if (this.doc) {\n            this.doc.off(\"change\", this.$onChange);\n        }\n        this.selection.detach();\n    };\n    return EditSession;\n}());\nEditSession.$uid = 0;\nEditSession.prototype.$modes = config.$modes;\nEditSession.prototype.getValue = EditSession.prototype.toString;\nEditSession.prototype.$defaultUndoManager = {\n    undo: function () { },\n    redo: function () { },\n    hasUndo: function () { },\n    hasRedo: function () { },\n    reset: function () { },\n    add: function () { },\n    addSelection: function () { },\n    startNewGroup: function () { },\n    addSession: function () { }\n};\nEditSession.prototype.$overwrite = false;\nEditSession.prototype.$mode = null;\nEditSession.prototype.$modeId = null;\nEditSession.prototype.$scrollTop = 0;\nEditSession.prototype.$scrollLeft = 0;\nEditSession.prototype.$wrapLimit = 80;\nEditSession.prototype.$useWrapMode = false;\nEditSession.prototype.$wrapLimitRange = {\n    min: null,\n    max: null\n};\nEditSession.prototype.lineWidgets = null;\nEditSession.prototype.isFullWidth = isFullWidth;\noop.implement(EditSession.prototype, EventEmitter);\nvar CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;\nfunction isFullWidth(c) {\n    if (c < 0x1100)\n        return false;\n    return c >= 0x1100 && c <= 0x115F ||\n        c >= 0x11A3 && c <= 0x11A7 ||\n        c >= 0x11FA && c <= 0x11FF ||\n        c >= 0x2329 && c <= 0x232A ||\n        c >= 0x2E80 && c <= 0x2E99 ||\n        c >= 0x2E9B && c <= 0x2EF3 ||\n        c >= 0x2F00 && c <= 0x2FD5 ||\n        c >= 0x2FF0 && c <= 0x2FFB ||\n        c >= 0x3000 && c <= 0x303E ||\n        c >= 0x3041 && c <= 0x3096 ||\n        c >= 0x3099 && c <= 0x30FF ||\n        c >= 0x3105 && c <= 0x312D ||\n        c >= 0x3131 && c <= 0x318E ||\n        c >= 0x3190 && c <= 0x31BA ||\n        c >= 0x31C0 && c <= 0x31E3 ||\n        c >= 0x31F0 && c <= 0x321E ||\n        c >= 0x3220 && c <= 0x3247 ||\n        c >= 0x3250 && c <= 0x32FE ||\n        c >= 0x3300 && c <= 0x4DBF ||\n        c >= 0x4E00 && c <= 0xA48C ||\n        c >= 0xA490 && c <= 0xA4C6 ||\n        c >= 0xA960 && c <= 0xA97C ||\n        c >= 0xAC00 && c <= 0xD7A3 ||\n        c >= 0xD7B0 && c <= 0xD7C6 ||\n        c >= 0xD7CB && c <= 0xD7FB ||\n        c >= 0xF900 && c <= 0xFAFF ||\n        c >= 0xFE10 && c <= 0xFE19 ||\n        c >= 0xFE30 && c <= 0xFE52 ||\n        c >= 0xFE54 && c <= 0xFE66 ||\n        c >= 0xFE68 && c <= 0xFE6B ||\n        c >= 0xFF01 && c <= 0xFF60 ||\n        c >= 0xFFE0 && c <= 0xFFE6;\n}\nrequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\nrequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\nconfig.defineOptions(EditSession.prototype, \"session\", {\n    wrap: {\n        set: function (value) {\n            if (!value || value == \"off\")\n                value = false;\n            else if (value == \"free\")\n                value = true;\n            else if (value == \"printMargin\")\n                value = -1;\n            else if (typeof value == \"string\")\n                value = parseInt(value, 10) || false;\n            if (this.$wrap == value)\n                return;\n            this.$wrap = value;\n            if (!value) {\n                this.setUseWrapMode(false);\n            }\n            else {\n                var col = typeof value == \"number\" ? value : null;\n                this.setWrapLimitRange(col, col);\n                this.setUseWrapMode(true);\n            }\n        },\n        get: function () {\n            if (this.getUseWrapMode()) {\n                if (this.$wrap == -1)\n                    return \"printMargin\";\n                if (!this.getWrapLimitRange().min)\n                    return \"free\";\n                return this.$wrap;\n            }\n            return \"off\";\n        },\n        handlesSet: true\n    },\n    wrapMethod: {\n        set: function (val) {\n            val = val == \"auto\"\n                ? this.$mode.type != \"text\"\n                : val != \"text\";\n            if (val != this.$wrapAsCode) {\n                this.$wrapAsCode = val;\n                if (this.$useWrapMode) {\n                    this.$useWrapMode = false;\n                    this.setUseWrapMode(true);\n                }\n            }\n        },\n        initialValue: \"auto\"\n    },\n    indentedSoftWrap: {\n        set: function () {\n            if (this.$useWrapMode) {\n                this.$useWrapMode = false;\n                this.setUseWrapMode(true);\n            }\n        },\n        initialValue: true\n    },\n    firstLineNumber: {\n        set: function () { this._signal(\"changeBreakpoint\"); },\n        initialValue: 1\n    },\n    useWorker: {\n        set: function (useWorker) {\n            this.$useWorker = useWorker;\n            this.$stopWorker();\n            if (useWorker)\n                this.$startWorker();\n        },\n        initialValue: true\n    },\n    useSoftTabs: { initialValue: true },\n    tabSize: {\n        set: function (tabSize) {\n            tabSize = parseInt(tabSize);\n            if (tabSize > 0 && this.$tabSize !== tabSize) {\n                this.$modified = true;\n                this.$rowLengthCache = [];\n                this.$tabSize = tabSize;\n                this._signal(\"changeTabSize\");\n            }\n        },\n        initialValue: 4,\n        handlesSet: true\n    },\n    navigateWithinSoftTabs: { initialValue: false },\n    foldStyle: {\n        set: function (val) { this.setFoldStyle(val); },\n        handlesSet: true\n    },\n    overwrite: {\n        set: function (val) { this._signal(\"changeOverwrite\"); },\n        initialValue: false\n    },\n    newLineMode: {\n        set: function (val) { this.doc.setNewLineMode(val); },\n        get: function () { return this.doc.getNewLineMode(); },\n        handlesSet: true\n    },\n    mode: {\n        set: function (val) { this.setMode(val); },\n        get: function () { return this.$modeId; },\n        handlesSet: true\n    }\n});\nexports.EditSession = EditSession;\n\n});\n\nace.define(\"ace/search\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\nvar Search = /** @class */ (function () {\n    function Search() {\n        this.$options = {};\n    }\n    Search.prototype.set = function (options) {\n        oop.mixin(this.$options, options);\n        return this;\n    };\n    Search.prototype.getOptions = function () {\n        return lang.copyObject(this.$options);\n    };\n    Search.prototype.setOptions = function (options) {\n        this.$options = options;\n    };\n    Search.prototype.find = function (session) {\n        var options = this.$options;\n        var iterator = this.$matchIterator(session, options);\n        if (!iterator)\n            return false;\n        var firstRange = null;\n        iterator.forEach(function (sr, sc, er, ec) {\n            firstRange = new Range(sr, sc, er, ec);\n            if (sc == ec && options.start && /**@type{Range}*/ (options.start).start\n                && options.skipCurrent != false && firstRange.isEqual(/**@type{Range}*/ (options.start))) {\n                firstRange = null;\n                return false;\n            }\n            return true;\n        });\n        return firstRange;\n    };\n    Search.prototype.findAll = function (session) {\n        var options = this.$options;\n        if (!options.needle)\n            return [];\n        this.$assembleRegExp(options);\n        var range = options.range;\n        var lines = range\n            ? session.getLines(range.start.row, range.end.row)\n            : session.doc.getAllLines();\n        var ranges = [];\n        var re = options.re;\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var maxRow = lines.length - len;\n            var prevRange;\n            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\n                for (var j = 0; j < len; j++)\n                    if (lines[row + j].search(re[j]) == -1)\n                        continue outer;\n                var startLine = lines[row];\n                var line = lines[row + len - 1];\n                var startIndex = startLine.length - startLine.match(re[0])[0].length;\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (prevRange && prevRange.end.row === row &&\n                    prevRange.end.column > startIndex) {\n                    continue;\n                }\n                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));\n                if (len > 2)\n                    row = row + len - 2;\n            }\n        }\n        else {\n            for (var i = 0; i < lines.length; i++) {\n                var matches = lang.getMatchOffsets(lines[i], re);\n                for (var j = 0; j < matches.length; j++) {\n                    var match = matches[j];\n                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));\n                }\n            }\n        }\n        if (range) {\n            var startColumn = range.start.column;\n            var endColumn = range.end.column;\n            var i = 0, j = ranges.length - 1;\n            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)\n                i++;\n            var endRow = range.end.row - range.start.row;\n            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)\n                j--;\n            ranges = ranges.slice(i, j + 1);\n            for (i = 0, j = ranges.length; i < j; i++) {\n                ranges[i].start.row += range.start.row;\n                ranges[i].end.row += range.start.row;\n            }\n        }\n        return ranges;\n    };\n    Search.prototype.replace = function (input, replacement) {\n        var options = this.$options;\n        var re = this.$assembleRegExp(options);\n        if (options.$isMultiLine)\n            return replacement;\n        if (!re)\n            return;\n        var match = re.exec(input);\n        if (!match || match[0].length != input.length)\n            return null;\n        if (!options.regExp) {\n            replacement = replacement.replace(/\\$/g, \"$$$$\");\n        }\n        replacement = input.replace(re, replacement);\n        if (options.preserveCase) {\n            replacement = replacement.split(\"\");\n            for (var i = Math.min(input.length, input.length); i--;) {\n                var ch = input[i];\n                if (ch && ch.toLowerCase() != ch)\n                    replacement[i] = replacement[i].toUpperCase();\n                else\n                    replacement[i] = replacement[i].toLowerCase();\n            }\n            replacement = replacement.join(\"\");\n        }\n        return replacement;\n    };\n    Search.prototype.$assembleRegExp = function (options, $disableFakeMultiline) {\n        if (options.needle instanceof RegExp)\n            return options.re = options.needle;\n        var needle = options.needle;\n        if (!options.needle)\n            return options.re = false;\n        if (!options.regExp)\n            needle = lang.escapeRegExp(needle);\n        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\n        try {\n            new RegExp(needle, \"u\");\n            options.$supportsUnicodeFlag = true;\n            modifier += \"u\";\n        }\n        catch (e) {\n            options.$supportsUnicodeFlag = false; //left for backward compatibility with previous versions for cases like /ab\\{2}/gu\n        }\n        if (options.wholeWord)\n            needle = addWordBoundary(needle, options);\n        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\n        if (options.$isMultiLine)\n            return options.re = this.$assembleMultilineRegExp(needle, modifier);\n        try {\n            var re = new RegExp(needle, modifier);\n        }\n        catch (e) {\n            re = false;\n        }\n        return options.re = re;\n    };\n    Search.prototype.$assembleMultilineRegExp = function (needle, modifier) {\n        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\n        var re = [];\n        for (var i = 0; i < parts.length; i++)\n            try {\n                re.push(new RegExp(parts[i], modifier));\n            }\n            catch (e) {\n                return false;\n            }\n        return re;\n    };\n    Search.prototype.$matchIterator = function (session, options) {\n        var re = this.$assembleRegExp(options);\n        if (!re)\n            return false;\n        var backwards = options.backwards == true;\n        var skipCurrent = options.skipCurrent != false;\n        var supportsUnicodeFlag = re.unicode;\n        var range = options.range;\n        var start = options.start;\n        if (!start)\n            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\n        if (start.start)\n            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\n        var firstRow = range ? range.start.row : 0;\n        var lastRow = range ? range.end.row : session.getLength() - 1;\n        if (backwards) {\n            var forEach = function (callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row--; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n            };\n        }\n        else {\n            var forEach = function (callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row = row + 1; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n            };\n        }\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var forEachInLine = function (row, offset, callback) {\n                var startRow = backwards ? row - len + 1 : row;\n                if (startRow < 0 || startRow + len > session.getLength())\n                    return;\n                var line = session.getLine(startRow);\n                var startIndex = line.search(re[0]);\n                if (!backwards && startIndex < offset || startIndex === -1)\n                    return;\n                for (var i = 1; i < len; i++) {\n                    line = session.getLine(startRow + i);\n                    if (line.search(re[i]) == -1)\n                        return;\n                }\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (backwards && endIndex > offset)\n                    return;\n                if (callback(startRow, startIndex, startRow + len - 1, endIndex))\n                    return true;\n            };\n        }\n        else if (backwards) {\n            var forEachInLine = function (row, endIndex, callback) {\n                var line = session.getLine(row);\n                var matches = [];\n                var m, last = 0;\n                re.lastIndex = 0;\n                while ((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (!length) {\n                        if (last >= line.length)\n                            break;\n                        re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);\n                    }\n                    if (m.index + length > endIndex)\n                        break;\n                    matches.push(m.index, length);\n                }\n                for (var i = matches.length - 1; i >= 0; i -= 2) {\n                    var column = matches[i - 1];\n                    var length = matches[i];\n                    if (callback(row, column, row, column + length))\n                        return true;\n                }\n            };\n        }\n        else {\n            var forEachInLine = function (row, startIndex, callback) {\n                var line = session.getLine(row);\n                var last;\n                var m;\n                re.lastIndex = startIndex;\n                while ((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (callback(row, last, row, last + length))\n                        return true;\n                    if (!length) {\n                        re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);\n                        if (last >= line.length)\n                            return false;\n                    }\n                }\n            };\n        }\n        return { forEach: forEach };\n    };\n    return Search;\n}());\nfunction addWordBoundary(needle, options) {\n    var supportsLookbehind = lang.supportsLookbehind();\n    function wordBoundary(c, firstChar) {\n        if (firstChar === void 0) { firstChar = true; }\n        var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp(\"[\\\\p{L}\\\\p{N}_]\", \"u\") : new RegExp(\"\\\\w\");\n        if (wordRegExp.test(c) || options.regExp) {\n            if (supportsLookbehind && options.$supportsUnicodeFlag) {\n                if (firstChar)\n                    return \"(?<=^|[^\\\\p{L}\\\\p{N}_])\";\n                return \"(?=[^\\\\p{L}\\\\p{N}_]|$)\";\n            }\n            return \"\\\\b\";\n        }\n        return \"\";\n    }\n    var needleArray = Array.from(needle);\n    var firstChar = needleArray[0];\n    var lastChar = needleArray[needleArray.length - 1];\n    return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);\n}\nexports.Search = Search;\n\n});\n\nace.define(\"ace/keyboard/hash_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})(); var keyUtil = require(\"../lib/keys\");\nvar useragent = require(\"../lib/useragent\");\nvar KEY_MODS = keyUtil.KEY_MODS;\nvar MultiHashHandler = /** @class */ (function () {\n    function MultiHashHandler(config, platform) {\n        this.$init(config, platform, false);\n    }\n    MultiHashHandler.prototype.$init = function (config, platform, $singleCommand) {\n        this.platform = platform || (useragent.isMac ? \"mac\" : \"win\");\n        this.commands = {};\n        this.commandKeyBinding = {};\n        this.addCommands(config);\n        this.$singleCommand = $singleCommand;\n    };\n    MultiHashHandler.prototype.addCommand = function (command) {\n        if (this.commands[command.name])\n            this.removeCommand(command);\n        this.commands[command.name] = command;\n        if (command.bindKey)\n            this._buildKeyHash(command);\n    };\n    MultiHashHandler.prototype.removeCommand = function (command, keepCommand) {\n        var name = command && (typeof command === 'string' ? command : command.name);\n        command = this.commands[name];\n        if (!keepCommand)\n            delete this.commands[name];\n        var ckb = this.commandKeyBinding;\n        for (var keyId in ckb) {\n            var cmdGroup = ckb[keyId];\n            if (cmdGroup == command) {\n                delete ckb[keyId];\n            }\n            else if (Array.isArray(cmdGroup)) {\n                var i = cmdGroup.indexOf(command);\n                if (i != -1) {\n                    cmdGroup.splice(i, 1);\n                    if (cmdGroup.length == 1)\n                        ckb[keyId] = cmdGroup[0];\n                }\n            }\n        }\n    };\n    MultiHashHandler.prototype.bindKey = function (key, command, position) {\n        if (typeof key == \"object\" && key) {\n            if (position == undefined)\n                position = key.position;\n            key = key[this.platform];\n        }\n        if (!key)\n            return;\n        if (typeof command == \"function\")\n            return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/ (key) }); (key).split(\"|\").forEach(function (keyPart) {\n            var chain = \"\";\n            if (keyPart.indexOf(\" \") != -1) {\n                var parts = keyPart.split(/\\s+/);\n                keyPart = parts.pop();\n                parts.forEach(function (keyPart) {\n                    var binding = this.parseKeys(keyPart);\n                    var id = KEY_MODS[binding.hashId] + binding.key;\n                    chain += (chain ? \" \" : \"\") + id;\n                    this._addCommandToBinding(chain, \"chainKeys\");\n                }, this);\n                chain += \" \";\n            }\n            var binding = this.parseKeys(keyPart);\n            var id = KEY_MODS[binding.hashId] + binding.key;\n            this._addCommandToBinding(chain + id, command, position);\n        }, this);\n    };\n    MultiHashHandler.prototype._addCommandToBinding = function (keyId, command, position) {\n        var ckb = this.commandKeyBinding, i;\n        if (!command) {\n            delete ckb[keyId];\n        }\n        else if (!ckb[keyId] || this.$singleCommand) {\n            ckb[keyId] = command;\n        }\n        else {\n            if (!Array.isArray(ckb[keyId])) {\n                ckb[keyId] = [ckb[keyId]];\n            }\n            else if ((i = ckb[keyId].indexOf(command)) != -1) {\n                ckb[keyId].splice(i, 1);\n            }\n            if (typeof position != \"number\") {\n                position = getPosition(command);\n            }\n            var commands = ckb[keyId];\n            for (i = 0; i < commands.length; i++) {\n                var other = commands[i];\n                var otherPos = getPosition(other);\n                if (otherPos > position)\n                    break;\n            }\n            commands.splice(i, 0, command);\n        }\n    };\n    MultiHashHandler.prototype.addCommands = function (commands) {\n        commands && Object.keys(commands).forEach(function (name) {\n            var command = commands[name];\n            if (!command)\n                return;\n            if (typeof command === \"string\")\n                return this.bindKey(command, name);\n            if (typeof command === \"function\")\n                command = { exec: command };\n            if (typeof command !== \"object\")\n                return;\n            if (!command.name)\n                command.name = name;\n            this.addCommand(command);\n        }, this);\n    };\n    MultiHashHandler.prototype.removeCommands = function (commands) {\n        Object.keys(commands).forEach(function (name) {\n            this.removeCommand(commands[name]);\n        }, this);\n    };\n    MultiHashHandler.prototype.bindKeys = function (keyList) {\n        Object.keys(keyList).forEach(function (key) {\n            this.bindKey(key, keyList[key]);\n        }, this);\n    };\n    MultiHashHandler.prototype._buildKeyHash = function (command) {\n        this.bindKey(command.bindKey, command);\n    };\n    MultiHashHandler.prototype.parseKeys = function (keys) {\n        var parts = keys.toLowerCase().split(/[\\-\\+]([\\-\\+])?/).filter(function (x) { return x; });\n        var key = parts.pop();\n        var keyCode = keyUtil[key];\n        if (keyUtil.FUNCTION_KEYS[keyCode])\n            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();\n        else if (!parts.length)\n            return { key: key, hashId: -1 };\n        else if (parts.length == 1 && parts[0] == \"shift\")\n            return { key: key.toUpperCase(), hashId: -1 };\n        var hashId = 0;\n        for (var i = parts.length; i--;) {\n            var modifier = keyUtil.KEY_MODS[parts[i]];\n            if (modifier == null) {\n                if (typeof console != \"undefined\")\n                    console.error(\"invalid modifier \" + parts[i] + \" in \" + keys);\n                return false;\n            }\n            hashId |= modifier;\n        }\n        return { key: key, hashId: hashId };\n    };\n    MultiHashHandler.prototype.findKeyCommand = function (hashId, keyString) {\n        var key = KEY_MODS[hashId] + keyString;\n        return this.commandKeyBinding[key];\n    };\n    MultiHashHandler.prototype.handleKeyboard = function (data, hashId, keyString, keyCode) {\n        if (keyCode < 0)\n            return;\n        var key = KEY_MODS[hashId] + keyString;\n        var command = this.commandKeyBinding[key];\n        if (data.$keyChain) {\n            data.$keyChain += \" \" + key;\n            command = this.commandKeyBinding[data.$keyChain] || command;\n        }\n        if (command) {\n            if (command == \"chainKeys\" || command[command.length - 1] == \"chainKeys\") {\n                data.$keyChain = data.$keyChain || key;\n                return { command: \"null\" };\n            }\n        }\n        if (data.$keyChain) {\n            if ((!hashId || hashId == 4) && keyString.length == 1)\n                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input\n            else if (hashId == -1 || keyCode > 0)\n                data.$keyChain = \"\"; // reset keyChain\n        }\n        return { command: command };\n    };\n    MultiHashHandler.prototype.getStatusText = function (editor, data) {\n        return data.$keyChain || \"\";\n    };\n    return MultiHashHandler;\n}());\nfunction getPosition(command) {\n    return typeof command == \"object\" && command.bindKey\n        && command.bindKey.position\n        || (command.isDefault ? -100 : 0);\n}\nvar HashHandler = /** @class */ (function (_super) {\n    __extends(HashHandler, _super);\n    function HashHandler(config, platform) {\n        var _this = _super.call(this, config, platform) || this;\n        _this.$singleCommand = true;\n        return _this;\n    }\n    return HashHandler;\n}(MultiHashHandler));\nHashHandler.call = function (thisArg, config, platform) {\n    MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);\n};\nMultiHashHandler.call = function (thisArg, config, platform) {\n    MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);\n};\nexports.HashHandler = HashHandler;\nexports.MultiHashHandler = MultiHashHandler;\n\n});\n\nace.define(\"ace/commands/command_manager\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/keyboard/hash_handler\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar oop = require(\"../lib/oop\");\nvar MultiHashHandler = require(\"../keyboard/hash_handler\").MultiHashHandler;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar CommandManager = /** @class */ (function (_super) {\n    __extends(CommandManager, _super);\n    function CommandManager(platform, commands) {\n        var _this = _super.call(this, commands, platform) || this;\n        _this.byName = _this.commands;\n        _this.setDefaultHandler(\"exec\", function (e) {\n            if (!e.args) {\n                return e.command.exec(e.editor, {}, e.event, true);\n            }\n            return e.command.exec(e.editor, e.args, e.event, false);\n        });\n        return _this;\n    }\n    CommandManager.prototype.exec = function (command, editor, args) {\n        if (Array.isArray(command)) {\n            for (var i = command.length; i--;) {\n                if (this.exec(command[i], editor, args))\n                    return true;\n            }\n            return false;\n        }\n        if (typeof command === \"string\")\n            command = this.commands[command];\n        if (!this.canExecute(command, editor)) {\n            return false;\n        }\n        var e = { editor: editor, command: command, args: args };\n        e.returnValue = this._emit(\"exec\", e);\n        this._signal(\"afterExec\", e);\n        return e.returnValue === false ? false : true;\n    };\n    CommandManager.prototype.canExecute = function (command, editor) {\n        if (typeof command === \"string\")\n            command = this.commands[command];\n        if (!command)\n            return false;\n        if (editor && editor.$readOnly && !command.readOnly)\n            return false;\n        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))\n            return false;\n        return true;\n    };\n    CommandManager.prototype.toggleRecording = function (editor) {\n        if (this.$inReplay)\n            return;\n        editor && editor._emit(\"changeStatus\");\n        if (this.recording) {\n            this.macro.pop();\n            this.off(\"exec\", this.$addCommandToMacro);\n            if (!this.macro.length)\n                this.macro = this.oldMacro;\n            return this.recording = false;\n        }\n        if (!this.$addCommandToMacro) {\n            this.$addCommandToMacro = function (e) {\n                this.macro.push([e.command, e.args]);\n            }.bind(this);\n        }\n        this.oldMacro = this.macro;\n        this.macro = [];\n        this.on(\"exec\", this.$addCommandToMacro);\n        return this.recording = true;\n    };\n    CommandManager.prototype.replay = function (editor) {\n        if (this.$inReplay || !this.macro)\n            return;\n        if (this.recording)\n            return this.toggleRecording(editor);\n        try {\n            this.$inReplay = true;\n            this.macro.forEach(function (x) {\n                if (typeof x == \"string\")\n                    this.exec(x, editor);\n                else\n                    this.exec(x[0], editor, x[1]);\n            }, this);\n        }\n        finally {\n            this.$inReplay = false;\n        }\n    };\n    CommandManager.prototype.trimMacro = function (m) {\n        return m.map(function (x) {\n            if (typeof x[0] != \"string\")\n                x[0] = x[0].name;\n            if (!x[1])\n                x = x[0];\n            return x;\n        });\n    };\n    return CommandManager;\n}(MultiHashHandler));\noop.implement(CommandManager.prototype, EventEmitter);\nexports.CommandManager = CommandManager;\n\n});\n\nace.define(\"ace/commands/default_commands\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/config\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar lang = require(\"../lib/lang\");\nvar config = require(\"../config\");\nvar Range = require(\"../range\").Range;\nfunction bindKey(win, mac) {\n    return { win: win, mac: mac };\n}\nexports.commands = [{\n        name: \"showSettingsMenu\",\n        description: \"Show settings menu\",\n        bindKey: bindKey(\"Ctrl-,\", \"Command-,\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/settings_menu\", function (module) {\n                module.init(editor);\n                editor.showSettingsMenu();\n            });\n        },\n        readOnly: true\n    }, {\n        name: \"goToNextError\",\n        description: \"Go to next error\",\n        bindKey: bindKey(\"Alt-E\", \"F4\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/error_marker\", function (module) {\n                module.showErrorMarker(editor, 1);\n            });\n        },\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"goToPreviousError\",\n        description: \"Go to previous error\",\n        bindKey: bindKey(\"Alt-Shift-E\", \"Shift-F4\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/error_marker\", function (module) {\n                module.showErrorMarker(editor, -1);\n            });\n        },\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"selectall\",\n        description: \"Select all\",\n        bindKey: bindKey(\"Ctrl-A\", \"Command-A\"),\n        exec: function (editor) { editor.selectAll(); },\n        readOnly: true\n    }, {\n        name: \"centerselection\",\n        description: \"Center selection\",\n        bindKey: bindKey(null, \"Ctrl-L\"),\n        exec: function (editor) { editor.centerSelection(); },\n        readOnly: true\n    }, {\n        name: \"gotoline\",\n        description: \"Go to line...\",\n        bindKey: bindKey(\"Ctrl-L\", \"Command-L\"),\n        exec: function (editor, line) {\n            if (typeof line === \"number\" && !isNaN(line))\n                editor.gotoLine(line);\n            editor.prompt({ $type: \"gotoLine\" });\n        },\n        readOnly: true\n    }, {\n        name: \"fold\",\n        bindKey: bindKey(\"Alt-L|Ctrl-F1\", \"Command-Alt-L|Command-F1\"),\n        exec: function (editor) { editor.session.toggleFold(false); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"unfold\",\n        bindKey: bindKey(\"Alt-Shift-L|Ctrl-Shift-F1\", \"Command-Alt-Shift-L|Command-Shift-F1\"),\n        exec: function (editor) { editor.session.toggleFold(true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"toggleFoldWidget\",\n        description: \"Toggle fold widget\",\n        bindKey: bindKey(\"F2\", \"F2\"),\n        exec: function (editor) { editor.session.toggleFoldWidget(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"toggleParentFoldWidget\",\n        description: \"Toggle parent fold widget\",\n        bindKey: bindKey(\"Alt-F2\", \"Alt-F2\"),\n        exec: function (editor) { editor.session.toggleFoldWidget(true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"foldall\",\n        description: \"Fold all\",\n        bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n        exec: function (editor) { editor.session.foldAll(); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"foldAllComments\",\n        description: \"Fold all comments\",\n        bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n        exec: function (editor) { editor.session.foldAllComments(); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"foldOther\",\n        description: \"Fold other\",\n        bindKey: bindKey(\"Alt-0\", \"Command-Option-0\"),\n        exec: function (editor) {\n            editor.session.foldAll();\n            editor.session.unfold(editor.selection.getAllRanges());\n        },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"unfoldall\",\n        description: \"Unfold all\",\n        bindKey: bindKey(\"Alt-Shift-0\", \"Command-Option-Shift-0\"),\n        exec: function (editor) { editor.session.unfold(); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"findnext\",\n        description: \"Find next\",\n        bindKey: bindKey(\"Ctrl-K\", \"Command-G\"),\n        exec: function (editor) { editor.findNext(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"findprevious\",\n        description: \"Find previous\",\n        bindKey: bindKey(\"Ctrl-Shift-K\", \"Command-Shift-G\"),\n        exec: function (editor) { editor.findPrevious(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"selectOrFindNext\",\n        description: \"Select or find next\",\n        bindKey: bindKey(\"Alt-K\", \"Ctrl-G\"),\n        exec: function (editor) {\n            if (editor.selection.isEmpty())\n                editor.selection.selectWord();\n            else\n                editor.findNext();\n        },\n        readOnly: true\n    }, {\n        name: \"selectOrFindPrevious\",\n        description: \"Select or find previous\",\n        bindKey: bindKey(\"Alt-Shift-K\", \"Ctrl-Shift-G\"),\n        exec: function (editor) {\n            if (editor.selection.isEmpty())\n                editor.selection.selectWord();\n            else\n                editor.findPrevious();\n        },\n        readOnly: true\n    }, {\n        name: \"find\",\n        description: \"Find\",\n        bindKey: bindKey(\"Ctrl-F\", \"Command-F\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/searchbox\", function (e) { e.Search(editor); });\n        },\n        readOnly: true\n    }, {\n        name: \"overwrite\",\n        description: \"Overwrite\",\n        bindKey: \"Insert\",\n        exec: function (editor) { editor.toggleOverwrite(); },\n        readOnly: true\n    }, {\n        name: \"selecttostart\",\n        description: \"Select to start\",\n        bindKey: bindKey(\"Ctrl-Shift-Home\", \"Command-Shift-Home|Command-Shift-Up\"),\n        exec: function (editor) { editor.getSelection().selectFileStart(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"gotostart\",\n        description: \"Go to start\",\n        bindKey: bindKey(\"Ctrl-Home\", \"Command-Home|Command-Up\"),\n        exec: function (editor) { editor.navigateFileStart(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"selectup\",\n        description: \"Select up\",\n        bindKey: bindKey(\"Shift-Up\", \"Shift-Up|Ctrl-Shift-P\"),\n        exec: function (editor) { editor.getSelection().selectUp(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"golineup\",\n        description: \"Go line up\",\n        bindKey: bindKey(\"Up\", \"Up|Ctrl-P\"),\n        exec: function (editor, args) { editor.navigateUp(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selecttoend\",\n        description: \"Select to end\",\n        bindKey: bindKey(\"Ctrl-Shift-End\", \"Command-Shift-End|Command-Shift-Down\"),\n        exec: function (editor) { editor.getSelection().selectFileEnd(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"gotoend\",\n        description: \"Go to end\",\n        bindKey: bindKey(\"Ctrl-End\", \"Command-End|Command-Down\"),\n        exec: function (editor) { editor.navigateFileEnd(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"selectdown\",\n        description: \"Select down\",\n        bindKey: bindKey(\"Shift-Down\", \"Shift-Down|Ctrl-Shift-N\"),\n        exec: function (editor) { editor.getSelection().selectDown(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"golinedown\",\n        description: \"Go line down\",\n        bindKey: bindKey(\"Down\", \"Down|Ctrl-N\"),\n        exec: function (editor, args) { editor.navigateDown(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectwordleft\",\n        description: \"Select word left\",\n        bindKey: bindKey(\"Ctrl-Shift-Left\", \"Option-Shift-Left\"),\n        exec: function (editor) { editor.getSelection().selectWordLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotowordleft\",\n        description: \"Go to word left\",\n        bindKey: bindKey(\"Ctrl-Left\", \"Option-Left\"),\n        exec: function (editor) { editor.navigateWordLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selecttolinestart\",\n        description: \"Select to line start\",\n        bindKey: bindKey(\"Alt-Shift-Left\", \"Command-Shift-Left|Ctrl-Shift-A\"),\n        exec: function (editor) { editor.getSelection().selectLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotolinestart\",\n        description: \"Go to line start\",\n        bindKey: bindKey(\"Alt-Left|Home\", \"Command-Left|Home|Ctrl-A\"),\n        exec: function (editor) { editor.navigateLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectleft\",\n        description: \"Select left\",\n        bindKey: bindKey(\"Shift-Left\", \"Shift-Left|Ctrl-Shift-B\"),\n        exec: function (editor) { editor.getSelection().selectLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotoleft\",\n        description: \"Go to left\",\n        bindKey: bindKey(\"Left\", \"Left|Ctrl-B\"),\n        exec: function (editor, args) { editor.navigateLeft(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectwordright\",\n        description: \"Select word right\",\n        bindKey: bindKey(\"Ctrl-Shift-Right\", \"Option-Shift-Right\"),\n        exec: function (editor) { editor.getSelection().selectWordRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotowordright\",\n        description: \"Go to word right\",\n        bindKey: bindKey(\"Ctrl-Right\", \"Option-Right\"),\n        exec: function (editor) { editor.navigateWordRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selecttolineend\",\n        description: \"Select to line end\",\n        bindKey: bindKey(\"Alt-Shift-Right\", \"Command-Shift-Right|Shift-End|Ctrl-Shift-E\"),\n        exec: function (editor) { editor.getSelection().selectLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotolineend\",\n        description: \"Go to line end\",\n        bindKey: bindKey(\"Alt-Right|End\", \"Command-Right|End|Ctrl-E\"),\n        exec: function (editor) { editor.navigateLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectright\",\n        description: \"Select right\",\n        bindKey: bindKey(\"Shift-Right\", \"Shift-Right\"),\n        exec: function (editor) { editor.getSelection().selectRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotoright\",\n        description: \"Go to right\",\n        bindKey: bindKey(\"Right\", \"Right|Ctrl-F\"),\n        exec: function (editor, args) { editor.navigateRight(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectpagedown\",\n        description: \"Select page down\",\n        bindKey: \"Shift-PageDown\",\n        exec: function (editor) { editor.selectPageDown(); },\n        readOnly: true\n    }, {\n        name: \"pagedown\",\n        description: \"Page down\",\n        bindKey: bindKey(null, \"Option-PageDown\"),\n        exec: function (editor) { editor.scrollPageDown(); },\n        readOnly: true\n    }, {\n        name: \"gotopagedown\",\n        description: \"Go to page down\",\n        bindKey: bindKey(\"PageDown\", \"PageDown|Ctrl-V\"),\n        exec: function (editor) { editor.gotoPageDown(); },\n        readOnly: true\n    }, {\n        name: \"selectpageup\",\n        description: \"Select page up\",\n        bindKey: \"Shift-PageUp\",\n        exec: function (editor) { editor.selectPageUp(); },\n        readOnly: true\n    }, {\n        name: \"pageup\",\n        description: \"Page up\",\n        bindKey: bindKey(null, \"Option-PageUp\"),\n        exec: function (editor) { editor.scrollPageUp(); },\n        readOnly: true\n    }, {\n        name: \"gotopageup\",\n        description: \"Go to page up\",\n        bindKey: \"PageUp\",\n        exec: function (editor) { editor.gotoPageUp(); },\n        readOnly: true\n    }, {\n        name: \"scrollup\",\n        description: \"Scroll up\",\n        bindKey: bindKey(\"Ctrl-Up\", null),\n        exec: function (e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },\n        readOnly: true\n    }, {\n        name: \"scrolldown\",\n        description: \"Scroll down\",\n        bindKey: bindKey(\"Ctrl-Down\", null),\n        exec: function (e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },\n        readOnly: true\n    }, {\n        name: \"selectlinestart\",\n        description: \"Select line start\",\n        bindKey: \"Shift-Home\",\n        exec: function (editor) { editor.getSelection().selectLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectlineend\",\n        description: \"Select line end\",\n        bindKey: \"Shift-End\",\n        exec: function (editor) { editor.getSelection().selectLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"togglerecording\",\n        description: \"Toggle recording\",\n        bindKey: bindKey(\"Ctrl-Alt-E\", \"Command-Option-E\"),\n        exec: function (editor) { editor.commands.toggleRecording(editor); },\n        readOnly: true\n    }, {\n        name: \"replaymacro\",\n        description: \"Replay macro\",\n        bindKey: bindKey(\"Ctrl-Shift-E\", \"Command-Shift-E\"),\n        exec: function (editor) { editor.commands.replay(editor); },\n        readOnly: true\n    }, {\n        name: \"jumptomatching\",\n        description: \"Jump to matching\",\n        bindKey: bindKey(\"Ctrl-\\\\|Ctrl-P\", \"Command-\\\\\"),\n        exec: function (editor) { editor.jumpToMatching(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"selecttomatching\",\n        description: \"Select to matching\",\n        bindKey: bindKey(\"Ctrl-Shift-\\\\|Ctrl-Shift-P\", \"Command-Shift-\\\\\"),\n        exec: function (editor) { editor.jumpToMatching(true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"expandToMatching\",\n        description: \"Expand to matching\",\n        bindKey: bindKey(\"Ctrl-Shift-M\", \"Ctrl-Shift-M\"),\n        exec: function (editor) { editor.jumpToMatching(true, true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"passKeysToBrowser\",\n        description: \"Pass keys to browser\",\n        bindKey: bindKey(null, null),\n        exec: function () { },\n        passEvent: true,\n        readOnly: true\n    }, {\n        name: \"copy\",\n        description: \"Copy\",\n        exec: function (editor) {\n        },\n        readOnly: true\n    },\n    {\n        name: \"cut\",\n        description: \"Cut\",\n        exec: function (editor) {\n            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();\n            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();\n            editor._emit(\"cut\", range);\n            if (!range.isEmpty())\n                editor.session.remove(range);\n            editor.clearSelection();\n        },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"paste\",\n        description: \"Paste\",\n        exec: function (editor, args) {\n            editor.$handlePaste(args);\n        },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removeline\",\n        description: \"Remove line\",\n        bindKey: bindKey(\"Ctrl-D\", \"Command-D\"),\n        exec: function (editor) { editor.removeLines(); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEachLine\"\n    }, {\n        name: \"duplicateSelection\",\n        description: \"Duplicate selection\",\n        bindKey: bindKey(\"Ctrl-Shift-D\", \"Command-Shift-D\"),\n        exec: function (editor) { editor.duplicateSelection(); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"sortlines\",\n        description: \"Sort lines\",\n        bindKey: bindKey(\"Ctrl-Alt-S\", \"Command-Alt-S\"),\n        exec: function (editor) { editor.sortLines(); },\n        scrollIntoView: \"selection\",\n        multiSelectAction: \"forEachLine\"\n    }, {\n        name: \"togglecomment\",\n        description: \"Toggle comment\",\n        bindKey: bindKey(\"Ctrl-/\", \"Command-/\"),\n        exec: function (editor) { editor.toggleCommentLines(); },\n        multiSelectAction: \"forEachLine\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"toggleBlockComment\",\n        description: \"Toggle block comment\",\n        bindKey: bindKey(\"Ctrl-Shift-/\", \"Command-Shift-/\"),\n        exec: function (editor) { editor.toggleBlockComment(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"modifyNumberUp\",\n        description: \"Modify number up\",\n        bindKey: bindKey(\"Ctrl-Shift-Up\", \"Alt-Shift-Up\"),\n        exec: function (editor) { editor.modifyNumber(1); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"modifyNumberDown\",\n        description: \"Modify number down\",\n        bindKey: bindKey(\"Ctrl-Shift-Down\", \"Alt-Shift-Down\"),\n        exec: function (editor) { editor.modifyNumber(-1); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"replace\",\n        description: \"Replace\",\n        bindKey: bindKey(\"Ctrl-H\", \"Command-Option-F\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/searchbox\", function (e) { e.Search(editor, true); });\n        }\n    }, {\n        name: \"undo\",\n        description: \"Undo\",\n        bindKey: bindKey(\"Ctrl-Z\", \"Command-Z\"),\n        exec: function (editor) { editor.undo(); }\n    }, {\n        name: \"redo\",\n        description: \"Redo\",\n        bindKey: bindKey(\"Ctrl-Shift-Z|Ctrl-Y\", \"Command-Shift-Z|Command-Y\"),\n        exec: function (editor) { editor.redo(); }\n    }, {\n        name: \"copylinesup\",\n        description: \"Copy lines up\",\n        bindKey: bindKey(\"Alt-Shift-Up\", \"Command-Option-Up\"),\n        exec: function (editor) { editor.copyLinesUp(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"movelinesup\",\n        description: \"Move lines up\",\n        bindKey: bindKey(\"Alt-Up\", \"Option-Up\"),\n        exec: function (editor) { editor.moveLinesUp(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"copylinesdown\",\n        description: \"Copy lines down\",\n        bindKey: bindKey(\"Alt-Shift-Down\", \"Command-Option-Down\"),\n        exec: function (editor) { editor.copyLinesDown(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"movelinesdown\",\n        description: \"Move lines down\",\n        bindKey: bindKey(\"Alt-Down\", \"Option-Down\"),\n        exec: function (editor) { editor.moveLinesDown(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"del\",\n        description: \"Delete\",\n        bindKey: bindKey(\"Delete\", \"Delete|Ctrl-D|Shift-Delete\"),\n        exec: function (editor) { editor.remove(\"right\"); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"backspace\",\n        description: \"Backspace\",\n        bindKey: bindKey(\"Shift-Backspace|Backspace\", \"Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H\"),\n        exec: function (editor) { editor.remove(\"left\"); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"cut_or_delete\",\n        description: \"Cut or delete\",\n        bindKey: bindKey(\"Shift-Delete\", null),\n        exec: function (editor) {\n            if (editor.selection.isEmpty()) {\n                editor.remove(\"left\");\n            }\n            else {\n                return false;\n            }\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolinestart\",\n        description: \"Remove to line start\",\n        bindKey: bindKey(\"Alt-Backspace\", \"Command-Backspace\"),\n        exec: function (editor) { editor.removeToLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolineend\",\n        description: \"Remove to line end\",\n        bindKey: bindKey(\"Alt-Delete\", \"Ctrl-K|Command-Delete\"),\n        exec: function (editor) { editor.removeToLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolinestarthard\",\n        description: \"Remove to line start hard\",\n        bindKey: bindKey(\"Ctrl-Shift-Backspace\", null),\n        exec: function (editor) {\n            var range = editor.selection.getRange();\n            range.start.column = 0;\n            editor.session.remove(range);\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolineendhard\",\n        description: \"Remove to line end hard\",\n        bindKey: bindKey(\"Ctrl-Shift-Delete\", null),\n        exec: function (editor) {\n            var range = editor.selection.getRange();\n            range.end.column = Number.MAX_VALUE;\n            editor.session.remove(range);\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removewordleft\",\n        description: \"Remove word left\",\n        bindKey: bindKey(\"Ctrl-Backspace\", \"Alt-Backspace|Ctrl-Alt-Backspace\"),\n        exec: function (editor) { editor.removeWordLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removewordright\",\n        description: \"Remove word right\",\n        bindKey: bindKey(\"Ctrl-Delete\", \"Alt-Delete\"),\n        exec: function (editor) { editor.removeWordRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"outdent\",\n        description: \"Outdent\",\n        bindKey: bindKey(\"Shift-Tab\", \"Shift-Tab\"),\n        exec: function (editor) { editor.blockOutdent(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"indent\",\n        description: \"Indent\",\n        bindKey: bindKey(\"Tab\", \"Tab\"),\n        exec: function (editor) { editor.indent(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"blockoutdent\",\n        description: \"Block outdent\",\n        bindKey: bindKey(\"Ctrl-[\", \"Ctrl-[\"),\n        exec: function (editor) { editor.blockOutdent(); },\n        multiSelectAction: \"forEachLine\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"blockindent\",\n        description: \"Block indent\",\n        bindKey: bindKey(\"Ctrl-]\", \"Ctrl-]\"),\n        exec: function (editor) { editor.blockIndent(); },\n        multiSelectAction: \"forEachLine\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"insertstring\",\n        description: \"Insert string\",\n        exec: function (editor, str) { editor.insert(str); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"inserttext\",\n        description: \"Insert text\",\n        exec: function (editor, args) {\n            editor.insert(lang.stringRepeat(args.text || \"\", args.times || 1));\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"splitline\",\n        description: \"Split line\",\n        bindKey: bindKey(null, \"Ctrl-O\"),\n        exec: function (editor) { editor.splitLine(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"transposeletters\",\n        description: \"Transpose letters\",\n        bindKey: bindKey(\"Alt-Shift-X\", \"Ctrl-T\"),\n        exec: function (editor) { editor.transposeLetters(); },\n        multiSelectAction: function (editor) { editor.transposeSelections(1); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"touppercase\",\n        description: \"To uppercase\",\n        bindKey: bindKey(\"Ctrl-U\", \"Ctrl-U\"),\n        exec: function (editor) { editor.toUpperCase(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"tolowercase\",\n        description: \"To lowercase\",\n        bindKey: bindKey(\"Ctrl-Shift-U\", \"Ctrl-Shift-U\"),\n        exec: function (editor) { editor.toLowerCase(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"autoindent\",\n        description: \"Auto Indent\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) { editor.autoIndent(); },\n        scrollIntoView: \"animate\"\n    }, {\n        name: \"expandtoline\",\n        description: \"Expand to line\",\n        bindKey: bindKey(\"Ctrl-Shift-L\", \"Command-Shift-L\"),\n        exec: function (editor) {\n            var range = editor.selection.getRange();\n            range.start.column = range.end.column = 0;\n            range.end.row++;\n            editor.selection.setRange(range, false);\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"openlink\",\n        bindKey: bindKey(\"Ctrl+F3\", \"F3\"),\n        exec: function (editor) { editor.openLink(); }\n    }, {\n        name: \"joinlines\",\n        description: \"Join lines\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) {\n            var isBackwards = editor.selection.isBackwards();\n            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();\n            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();\n            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;\n            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());\n            var selectedCount = selectedText.replace(/\\n\\s*/, \" \").length;\n            var insertLine = editor.session.doc.getLine(selectionStart.row);\n            for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {\n                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));\n                if (curLine.length !== 0) {\n                    curLine = \" \" + curLine;\n                }\n                insertLine += curLine;\n            }\n            if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {\n                insertLine += editor.session.doc.getNewLineCharacter();\n            }\n            editor.clearSelection();\n            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);\n            if (selectedCount > 0) {\n                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);\n                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);\n            }\n            else {\n                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;\n                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);\n            }\n        },\n        multiSelectAction: \"forEach\",\n        readOnly: true\n    }, {\n        name: \"invertSelection\",\n        description: \"Invert selection\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) {\n            var endRow = editor.session.doc.getLength() - 1;\n            var endCol = editor.session.doc.getLine(endRow).length;\n            var ranges = editor.selection.rangeList.ranges;\n            var newRanges = [];\n            if (ranges.length < 1) {\n                ranges = [editor.selection.getRange()];\n            }\n            for (var i = 0; i < ranges.length; i++) {\n                if (i == (ranges.length - 1)) {\n                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {\n                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));\n                    }\n                }\n                if (i === 0) {\n                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {\n                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));\n                    }\n                }\n                else {\n                    newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));\n                }\n            }\n            editor.exitMultiSelectMode();\n            editor.clearSelection();\n            for (var i = 0; i < newRanges.length; i++) {\n                editor.selection.addRange(newRanges[i], false);\n            }\n        },\n        readOnly: true,\n        scrollIntoView: \"none\"\n    }, {\n        name: \"addLineAfter\",\n        description: \"Add new line after the current line\",\n        exec: function (editor) {\n            editor.selection.clearSelection();\n            editor.navigateLineEnd();\n            editor.insert(\"\\n\");\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"addLineBefore\",\n        description: \"Add new line before the current line\",\n        exec: function (editor) {\n            editor.selection.clearSelection();\n            var cursor = editor.getCursorPosition();\n            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);\n            editor.insert(\"\\n\");\n            if (cursor.row === 0)\n                editor.navigateUp();\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"openCommandPallete\",\n        exec: function (editor) {\n            console.warn(\"This is an obsolete command. Please use `openCommandPalette` instead.\");\n            editor.prompt({ $type: \"commands\" });\n        },\n        readOnly: true\n    }, {\n        name: \"openCommandPalette\",\n        description: \"Open command palette\",\n        bindKey: bindKey(\"F1\", \"F1\"),\n        exec: function (editor) {\n            editor.prompt({ $type: \"commands\" });\n        },\n        readOnly: true\n    }, {\n        name: \"modeSelect\",\n        description: \"Change language mode...\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) {\n            editor.prompt({ $type: \"modes\" });\n        },\n        readOnly: true\n    }];\nfor (var i = 1; i < 9; i++) {\n    exports.commands.push({\n        name: \"foldToLevel\" + i,\n        description: \"Fold To Level \" + i,\n        level: i,\n        exec: function (editor) { editor.session.foldToLevel(this.level); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    });\n}\n\n});\n\nace.define(\"ace/line_widgets\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"./lib/dom\");\nvar LineWidgets = /** @class */ (function () {\n    function LineWidgets(session) {\n        this.session = session;\n        this.session.widgetManager = this;\n        this.session.getRowLength = this.getRowLength;\n        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;\n        this.updateOnChange = this.updateOnChange.bind(this);\n        this.renderWidgets = this.renderWidgets.bind(this);\n        this.measureWidgets = this.measureWidgets.bind(this);\n        this.session._changedWidgets = [];\n        this.$onChangeEditor = this.$onChangeEditor.bind(this);\n        this.session.on(\"change\", this.updateOnChange);\n        this.session.on(\"changeFold\", this.updateOnFold);\n        this.session.on(\"changeEditor\", this.$onChangeEditor);\n    }\n    LineWidgets.prototype.getRowLength = function (row) {\n        var h;\n        if (this.lineWidgets)\n            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else\n            h = 0;\n        if (!this[\"$useWrapMode\"] || !this[\"$wrapData\"][row]) {\n            return 1 + h;\n        }\n        else {\n            return this[\"$wrapData\"][row].length + 1 + h;\n        }\n    };\n    LineWidgets.prototype.$getWidgetScreenLength = function () {\n        var screenRows = 0;\n        this.lineWidgets.forEach(function (w) {\n            if (w && w.rowCount && !w.hidden)\n                screenRows += w.rowCount;\n        });\n        return screenRows;\n    };\n    LineWidgets.prototype.$onChangeEditor = function (e) {\n        this.attach(e.editor);\n    };\n    LineWidgets.prototype.attach = function (editor) {\n        if (editor && editor.widgetManager && editor.widgetManager != this)\n            editor.widgetManager.detach();\n        if (this.editor == editor)\n            return;\n        this.detach();\n        this.editor = editor;\n        if (editor) {\n            editor.widgetManager = this;\n            editor.renderer.on(\"beforeRender\", this.measureWidgets);\n            editor.renderer.on(\"afterRender\", this.renderWidgets);\n        }\n    };\n    LineWidgets.prototype.detach = function (e) {\n        var editor = this.editor;\n        if (!editor)\n            return;\n        this.editor = null;\n        editor.widgetManager = null;\n        editor.renderer.off(\"beforeRender\", this.measureWidgets);\n        editor.renderer.off(\"afterRender\", this.renderWidgets);\n        var lineWidgets = this.session.lineWidgets;\n        lineWidgets && lineWidgets.forEach(function (w) {\n            if (w && w.el && w.el.parentNode) {\n                w._inDocument = false;\n                w.el.parentNode.removeChild(w.el);\n            }\n        });\n    };\n    LineWidgets.prototype.updateOnFold = function (e, session) {\n        var lineWidgets = session.lineWidgets;\n        if (!lineWidgets || !e.action)\n            return;\n        var fold = e.data;\n        var start = fold.start.row;\n        var end = fold.end.row;\n        var hide = e.action == \"add\";\n        for (var i = start + 1; i < end; i++) {\n            if (lineWidgets[i])\n                lineWidgets[i].hidden = hide;\n        }\n        if (lineWidgets[end]) {\n            if (hide) {\n                if (!lineWidgets[start])\n                    lineWidgets[start] = lineWidgets[end];\n                else\n                    lineWidgets[end].hidden = hide;\n            }\n            else {\n                if (lineWidgets[start] == lineWidgets[end])\n                    lineWidgets[start] = undefined;\n                lineWidgets[end].hidden = hide;\n            }\n        }\n    };\n    LineWidgets.prototype.updateOnChange = function (delta) {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n        if (len === 0) {\n        }\n        else if (delta.action == \"remove\") {\n            var removed = lineWidgets.splice(startRow + 1, len);\n            if (!lineWidgets[startRow] && removed[removed.length - 1]) {\n                lineWidgets[startRow] = removed.pop();\n            }\n            removed.forEach(function (w) {\n                w && this.removeLineWidget(w);\n            }, this);\n            this.$updateRows();\n        }\n        else {\n            var args = new Array(len);\n            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {\n                if (delta.start.column > lineWidgets[startRow].column)\n                    startRow++;\n            }\n            args.unshift(startRow, 0);\n            lineWidgets.splice.apply(lineWidgets, args);\n            this.$updateRows();\n        }\n    };\n    LineWidgets.prototype.$updateRows = function () {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var noWidgets = true;\n        lineWidgets.forEach(function (w, i) {\n            if (w) {\n                noWidgets = false;\n                w.row = i;\n                while (w.$oldWidget) {\n                    w.$oldWidget.row = i;\n                    w = w.$oldWidget;\n                }\n            }\n        });\n        if (noWidgets)\n            this.session.lineWidgets = null;\n    };\n    LineWidgets.prototype.$registerLineWidget = function (w) {\n        if (!this.session.lineWidgets)\n            this.session.lineWidgets = new Array(this.session.getLength());\n        var old = this.session.lineWidgets[w.row];\n        if (old) {\n            w.$oldWidget = old;\n            if (old.el && old.el.parentNode) {\n                old.el.parentNode.removeChild(old.el);\n                old._inDocument = false;\n            }\n        }\n        this.session.lineWidgets[w.row] = w;\n        return w;\n    };\n    LineWidgets.prototype.addLineWidget = function (w) {\n        this.$registerLineWidget(w);\n        w.session = this.session;\n        if (!this.editor)\n            return w;\n        var renderer = this.editor.renderer;\n        if (w.html && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.innerHTML = w.html;\n        }\n        if (w.text && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.textContent = w.text;\n        }\n        if (w.el) {\n            dom.addCssClass(w.el, \"ace_lineWidgetContainer\");\n            if (w.className) {\n                dom.addCssClass(w.el, w.className);\n            }\n            w.el.style.position = \"absolute\";\n            w.el.style.zIndex = \"5\";\n            renderer.container.appendChild(w.el);\n            w._inDocument = true;\n            if (!w.coverGutter) {\n                w.el.style.zIndex = \"3\";\n            }\n            if (w.pixelHeight == null) {\n                w.pixelHeight = w.el.offsetHeight;\n            }\n        }\n        if (w.rowCount == null) {\n            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;\n        }\n        var fold = this.session.getFoldAt(w.row, 0);\n        w.$fold = fold;\n        if (fold) {\n            var lineWidgets = this.session.lineWidgets;\n            if (w.row == fold.end.row && !lineWidgets[fold.start.row])\n                lineWidgets[fold.start.row] = w;\n            else\n                w.hidden = true;\n        }\n        this.session._emit(\"changeFold\", { data: { start: { row: w.row } } });\n        this.$updateRows();\n        this.renderWidgets(null, renderer);\n        this.onWidgetChanged(w);\n        return w;\n    };\n    LineWidgets.prototype.removeLineWidget = function (w) {\n        w._inDocument = false;\n        w.session = null;\n        if (w.el && w.el.parentNode)\n            w.el.parentNode.removeChild(w.el);\n        if (w.editor && w.editor.destroy)\n            try {\n                w.editor.destroy();\n            }\n            catch (e) { }\n        if (this.session.lineWidgets) {\n            var w1 = this.session.lineWidgets[w.row];\n            if (w1 == w) {\n                this.session.lineWidgets[w.row] = w.$oldWidget;\n                if (w.$oldWidget)\n                    this.onWidgetChanged(w.$oldWidget);\n            }\n            else {\n                while (w1) {\n                    if (w1.$oldWidget == w) {\n                        w1.$oldWidget = w.$oldWidget;\n                        break;\n                    }\n                    w1 = w1.$oldWidget;\n                }\n            }\n        }\n        this.session._emit(\"changeFold\", { data: { start: { row: w.row } } });\n        this.$updateRows();\n    };\n    LineWidgets.prototype.getWidgetsAtRow = function (row) {\n        var lineWidgets = this.session.lineWidgets;\n        var w = lineWidgets && lineWidgets[row];\n        var list = [];\n        while (w) {\n            list.push(w);\n            w = w.$oldWidget;\n        }\n        return list;\n    };\n    LineWidgets.prototype.onWidgetChanged = function (w) {\n        this.session._changedWidgets.push(w);\n        this.editor && this.editor.renderer.updateFull();\n    };\n    LineWidgets.prototype.measureWidgets = function (e, renderer) {\n        var changedWidgets = this.session._changedWidgets;\n        var config = renderer.layerConfig;\n        if (!changedWidgets || !changedWidgets.length)\n            return;\n        var min = Infinity;\n        for (var i = 0; i < changedWidgets.length; i++) {\n            var w = changedWidgets[i];\n            if (!w || !w.el)\n                continue;\n            if (w.session != this.session)\n                continue;\n            if (!w._inDocument) {\n                if (this.session.lineWidgets[w.row] != w)\n                    continue;\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            w.h = w.el.offsetHeight;\n            if (!w.fixedWidth) {\n                w.w = w.el.offsetWidth;\n                w.screenWidth = Math.ceil(w.w / config.characterWidth);\n            }\n            var rowCount = w.h / config.lineHeight;\n            if (w.coverLine) {\n                rowCount -= this.session.getRowLineCount(w.row);\n                if (rowCount < 0)\n                    rowCount = 0;\n            }\n            if (w.rowCount != rowCount) {\n                w.rowCount = rowCount;\n                if (w.row < min)\n                    min = w.row;\n            }\n        }\n        if (min != Infinity) {\n            this.session._emit(\"changeFold\", { data: { start: { row: min } } });\n            this.session.lineWidgetWidth = null;\n        }\n        this.session._changedWidgets = [];\n    };\n    LineWidgets.prototype.renderWidgets = function (e, renderer) {\n        var config = renderer.layerConfig;\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var first = Math.min(this.firstRow, config.firstRow);\n        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);\n        while (first > 0 && !lineWidgets[first])\n            first--;\n        this.firstRow = config.firstRow;\n        this.lastRow = config.lastRow;\n        renderer.$cursorLayer.config = config;\n        for (var i = first; i <= last; i++) {\n            var w = lineWidgets[i];\n            if (!w || !w.el)\n                continue;\n            if (w.hidden) {\n                w.el.style.top = -100 - (w.pixelHeight || 0) + \"px\";\n                continue;\n            }\n            if (!w._inDocument) {\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;\n            if (!w.coverLine)\n                top += config.lineHeight * this.session.getRowLineCount(w.row);\n            w.el.style.top = top - config.offset + \"px\";\n            var left = w.coverGutter ? 0 : renderer.gutterWidth;\n            if (!w.fixedWidth)\n                left -= renderer.scrollLeft;\n            w.el.style.left = left + \"px\";\n            if (w.fullWidth && w.screenWidth) {\n                w.el.style.minWidth = config.width + 2 * config.padding + \"px\";\n            }\n            if (w.fixedWidth) {\n                w.el.style.right = renderer.scrollBar.getWidth() + \"px\";\n            }\n            else {\n                w.el.style.right = \"\";\n            }\n        }\n    };\n    return LineWidgets;\n}());\nexports.LineWidgets = LineWidgets;\n\n});\n\nace.define(\"ace/keyboard/gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/mouse/default_gutter_handler\"], function(require, exports, module){\"use strict\";\nvar keys = require('../lib/keys');\nvar GutterTooltip = require(\"../mouse/default_gutter_handler\").GutterTooltip;\nvar GutterKeyboardHandler = /** @class */ (function () {\n    function GutterKeyboardHandler(editor) {\n        this.editor = editor;\n        this.gutterLayer = editor.renderer.$gutterLayer;\n        this.element = editor.renderer.$gutter;\n        this.lines = editor.renderer.$gutterLayer.$lines;\n        this.activeRowIndex = null;\n        this.activeLane = null;\n        this.annotationTooltip = new GutterTooltip(this.editor);\n    }\n    GutterKeyboardHandler.prototype.addListener = function () {\n        this.element.addEventListener(\"keydown\", this.$onGutterKeyDown.bind(this));\n        this.element.addEventListener(\"focusout\", this.$blurGutter.bind(this));\n        this.editor.on(\"mousewheel\", this.$blurGutter.bind(this));\n    };\n    GutterKeyboardHandler.prototype.removeListener = function () {\n        this.element.removeEventListener(\"keydown\", this.$onGutterKeyDown.bind(this));\n        this.element.removeEventListener(\"focusout\", this.$blurGutter.bind(this));\n        this.editor.off(\"mousewheel\", this.$blurGutter.bind(this));\n    };\n    GutterKeyboardHandler.prototype.$onGutterKeyDown = function (e) {\n        if (this.annotationTooltip.isOpen) {\n            e.preventDefault();\n            if (e.keyCode === keys[\"escape\"])\n                this.annotationTooltip.hideTooltip();\n            return;\n        }\n        if (e.target === this.element) {\n            if (e.keyCode != keys[\"enter\"]) {\n                return;\n            }\n            e.preventDefault();\n            var row = this.editor.getCursorPosition().row;\n            if (!this.editor.isRowVisible(row))\n                this.editor.scrollToLine(row, true, true);\n            setTimeout(\n            function () {\n                var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);\n                var nearestFoldIndex = this.$findNearestFoldWidget(index);\n                var nearestAnnotationIndex = this.$findNearestAnnotation(index);\n                if (nearestFoldIndex === null && nearestAnnotationIndex === null)\n                    return;\n                if (nearestFoldIndex === null && nearestAnnotationIndex !== null) {\n                    this.activeRowIndex = nearestAnnotationIndex;\n                    this.activeLane = \"annotation\";\n                    this.$focusAnnotation(this.activeRowIndex);\n                    return;\n                }\n                if (nearestFoldIndex !== null && nearestAnnotationIndex === null) {\n                    this.activeRowIndex = nearestFoldIndex;\n                    this.activeLane = \"fold\";\n                    this.$focusFoldWidget(this.activeRowIndex);\n                    return;\n                }\n                if (Math.abs(nearestAnnotationIndex - index) < Math.abs(nearestFoldIndex - index)) {\n                    this.activeRowIndex = nearestAnnotationIndex;\n                    this.activeLane = \"annotation\";\n                    this.$focusAnnotation(this.activeRowIndex);\n                    return;\n                }\n                else {\n                    this.activeRowIndex = nearestFoldIndex;\n                    this.activeLane = \"fold\";\n                    this.$focusFoldWidget(this.activeRowIndex);\n                    return;\n                }\n            }.bind(this), 10);\n            return;\n        }\n        this.$handleGutterKeyboardInteraction(e);\n        setTimeout(function () {\n            this.editor._signal(\"gutterkeydown\", new GutterKeyboardEvent(e, this));\n        }.bind(this), 10);\n    };\n    GutterKeyboardHandler.prototype.$handleGutterKeyboardInteraction = function (e) {\n        if (e.keyCode === keys[\"tab\"]) {\n            e.preventDefault();\n            return;\n        }\n        if (e.keyCode === keys[\"escape\"]) {\n            e.preventDefault();\n            this.$blurGutter();\n            this.element.focus();\n            this.lane = null;\n            return;\n        }\n        if (e.keyCode === keys[\"up\"]) {\n            e.preventDefault();\n            switch (this.activeLane) {\n                case \"fold\":\n                    this.$moveFoldWidgetUp();\n                    break;\n                case \"annotation\":\n                    this.$moveAnnotationUp();\n                    break;\n            }\n            return;\n        }\n        if (e.keyCode === keys[\"down\"]) {\n            e.preventDefault();\n            switch (this.activeLane) {\n                case \"fold\":\n                    this.$moveFoldWidgetDown();\n                    break;\n                case \"annotation\":\n                    this.$moveAnnotationDown();\n                    break;\n            }\n            return;\n        }\n        if (e.keyCode === keys[\"left\"]) {\n            e.preventDefault();\n            this.$switchLane(\"annotation\");\n            return;\n        }\n        if (e.keyCode === keys[\"right\"]) {\n            e.preventDefault();\n            this.$switchLane(\"fold\");\n            return;\n        }\n        if (e.keyCode === keys[\"enter\"] || e.keyCode === keys[\"space\"]) {\n            e.preventDefault();\n            switch (this.activeLane) {\n                case \"fold\":\n                    if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'start') {\n                        var rowFoldingWidget = this.$rowIndexToRow(this.activeRowIndex);\n                        this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);\n                        setTimeout(\n                        function () {\n                            if (this.$rowIndexToRow(this.activeRowIndex) !== rowFoldingWidget) {\n                                this.$blurFoldWidget(this.activeRowIndex);\n                                this.activeRowIndex = this.$rowToRowIndex(rowFoldingWidget);\n                                this.$focusFoldWidget(this.activeRowIndex);\n                            }\n                        }.bind(this), 10);\n                        break;\n                    }\n                    else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'end') {\n                        break;\n                    }\n                    return;\n                case \"annotation\":\n                    var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];\n                    var rect = gutterElement.getBoundingClientRect();\n                    var style = this.annotationTooltip.getElement().style;\n                    style.left = rect.right + \"px\";\n                    style.top = rect.bottom + \"px\";\n                    this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));\n                    break;\n            }\n            return;\n        }\n    };\n    GutterKeyboardHandler.prototype.$blurGutter = function () {\n        if (this.activeRowIndex !== null) {\n            switch (this.activeLane) {\n                case \"fold\":\n                    this.$blurFoldWidget(this.activeRowIndex);\n                    break;\n                case \"annotation\":\n                    this.$blurAnnotation(this.activeRowIndex);\n                    break;\n            }\n        }\n        if (this.annotationTooltip.isOpen)\n            this.annotationTooltip.hideTooltip();\n        return;\n    };\n    GutterKeyboardHandler.prototype.$isFoldWidgetVisible = function (index) {\n        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));\n        var isIconVisible = this.$getFoldWidget(index).style.display !== \"none\";\n        return isRowFullyVisible && isIconVisible;\n    };\n    GutterKeyboardHandler.prototype.$isAnnotationVisible = function (index) {\n        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));\n        var isIconVisible = this.$getAnnotation(index).style.display !== \"none\";\n        return isRowFullyVisible && isIconVisible;\n    };\n    GutterKeyboardHandler.prototype.$getFoldWidget = function (index) {\n        var cell = this.lines.get(index);\n        var element = cell.element;\n        return element.childNodes[1];\n    };\n    GutterKeyboardHandler.prototype.$getAnnotation = function (index) {\n        var cell = this.lines.get(index);\n        var element = cell.element;\n        return element.childNodes[2];\n    };\n    GutterKeyboardHandler.prototype.$findNearestFoldWidget = function (index) {\n        if (this.$isFoldWidgetVisible(index))\n            return index;\n        var i = 0;\n        while (index - i > 0 || index + i < this.lines.getLength() - 1) {\n            i++;\n            if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))\n                return index - i;\n            if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))\n                return index + i;\n        }\n        return null;\n    };\n    GutterKeyboardHandler.prototype.$findNearestAnnotation = function (index) {\n        if (this.$isAnnotationVisible(index))\n            return index;\n        var i = 0;\n        while (index - i > 0 || index + i < this.lines.getLength() - 1) {\n            i++;\n            if (index - i >= 0 && this.$isAnnotationVisible(index - i))\n                return index - i;\n            if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))\n                return index + i;\n        }\n        return null;\n    };\n    GutterKeyboardHandler.prototype.$focusFoldWidget = function (index) {\n        if (index == null)\n            return;\n        var foldWidget = this.$getFoldWidget(index);\n        foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);\n        foldWidget.focus();\n    };\n    GutterKeyboardHandler.prototype.$focusAnnotation = function (index) {\n        if (index == null)\n            return;\n        var annotation = this.$getAnnotation(index);\n        annotation.classList.add(this.editor.renderer.keyboardFocusClassName);\n        annotation.focus();\n    };\n    GutterKeyboardHandler.prototype.$blurFoldWidget = function (index) {\n        var foldWidget = this.$getFoldWidget(index);\n        foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);\n        foldWidget.blur();\n    };\n    GutterKeyboardHandler.prototype.$blurAnnotation = function (index) {\n        var annotation = this.$getAnnotation(index);\n        annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);\n        annotation.blur();\n    };\n    GutterKeyboardHandler.prototype.$moveFoldWidgetUp = function () {\n        var index = this.activeRowIndex;\n        while (index > 0) {\n            index--;\n            if (this.$isFoldWidgetVisible(index)) {\n                this.$blurFoldWidget(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusFoldWidget(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$moveFoldWidgetDown = function () {\n        var index = this.activeRowIndex;\n        while (index < this.lines.getLength() - 1) {\n            index++;\n            if (this.$isFoldWidgetVisible(index)) {\n                this.$blurFoldWidget(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusFoldWidget(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$moveAnnotationUp = function () {\n        var index = this.activeRowIndex;\n        while (index > 0) {\n            index--;\n            if (this.$isAnnotationVisible(index)) {\n                this.$blurAnnotation(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusAnnotation(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$moveAnnotationDown = function () {\n        var index = this.activeRowIndex;\n        while (index < this.lines.getLength() - 1) {\n            index++;\n            if (this.$isAnnotationVisible(index)) {\n                this.$blurAnnotation(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusAnnotation(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$switchLane = function (desinationLane) {\n        switch (desinationLane) {\n            case \"annotation\":\n                if (this.activeLane === \"annotation\") {\n                    break;\n                }\n                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);\n                if (annotationIndex == null) {\n                    break;\n                }\n                this.activeLane = \"annotation\";\n                this.$blurFoldWidget(this.activeRowIndex);\n                this.activeRowIndex = annotationIndex;\n                this.$focusAnnotation(this.activeRowIndex);\n                break;\n            case \"fold\":\n                if (this.activeLane === \"fold\") {\n                    break;\n                }\n                var foldWidgetIndex = this.$findNearestFoldWidget(this.activeRowIndex);\n                if (foldWidgetIndex == null) {\n                    break;\n                }\n                this.activeLane = \"fold\";\n                this.$blurAnnotation(this.activeRowIndex);\n                this.activeRowIndex = foldWidgetIndex;\n                this.$focusFoldWidget(this.activeRowIndex);\n                break;\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$rowIndexToRow = function (index) {\n        var cell = this.lines.get(index);\n        if (cell)\n            return cell.row;\n        return null;\n    };\n    GutterKeyboardHandler.prototype.$rowToRowIndex = function (row) {\n        for (var i = 0; i < this.lines.getLength(); i++) {\n            var cell = this.lines.get(i);\n            if (cell.row == row)\n                return i;\n        }\n        return null;\n    };\n    return GutterKeyboardHandler;\n}());\nexports.GutterKeyboardHandler = GutterKeyboardHandler;\nvar GutterKeyboardEvent = /** @class */ (function () {\n    function GutterKeyboardEvent(domEvent, gutterKeyboardHandler) {\n        this.gutterKeyboardHandler = gutterKeyboardHandler;\n        this.domEvent = domEvent;\n    }\n    GutterKeyboardEvent.prototype.getKey = function () {\n        return keys.keyCodeToString(this.domEvent.keyCode);\n    };\n    GutterKeyboardEvent.prototype.getRow = function () {\n        return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);\n    };\n    GutterKeyboardEvent.prototype.isInAnnotationLane = function () {\n        return this.gutterKeyboardHandler.activeLane === \"annotation\";\n    };\n    GutterKeyboardEvent.prototype.isInFoldLane = function () {\n        return this.gutterKeyboardHandler.activeLane === \"fold\";\n    };\n    return GutterKeyboardEvent;\n}());\nexports.GutterKeyboardEvent = GutterKeyboardEvent;\n\n});\n\nace.define(\"ace/editor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/keyboard/textinput\",\"ace/mouse/mouse_handler\",\"ace/mouse/fold_handler\",\"ace/keyboard/keybinding\",\"ace/edit_session\",\"ace/search\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/commands/command_manager\",\"ace/commands/default_commands\",\"ace/config\",\"ace/token_iterator\",\"ace/line_widgets\",\"ace/keyboard/gutter_handler\",\"ace/config\",\"ace/clipboard\",\"ace/lib/keys\"], function(require, exports, module){\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar useragent = require(\"./lib/useragent\");\nvar TextInput = require(\"./keyboard/textinput\").TextInput;\nvar MouseHandler = require(\"./mouse/mouse_handler\").MouseHandler;\nvar FoldHandler = require(\"./mouse/fold_handler\").FoldHandler;\nvar KeyBinding = require(\"./keyboard/keybinding\").KeyBinding;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar Search = require(\"./search\").Search;\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar CommandManager = require(\"./commands/command_manager\").CommandManager;\nvar defaultCommands = require(\"./commands/default_commands\").commands;\nvar config = require(\"./config\");\nvar TokenIterator = require(\"./token_iterator\").TokenIterator;\nvar LineWidgets = require(\"./line_widgets\").LineWidgets;\nvar GutterKeyboardHandler = require(\"./keyboard/gutter_handler\").GutterKeyboardHandler;\nvar nls = require(\"./config\").nls;\nvar clipboard = require(\"./clipboard\");\nvar keys = require('./lib/keys');\nvar Editor = /** @class */ (function () {\n    function Editor(renderer, session, options) { this.session;\n        this.$toDestroy = [];\n        var container = renderer.getContainerElement();\n        this.container = container;\n        this.renderer = renderer;\n        this.id = \"editor\" + (++Editor.$uid);\n        this.commands = new CommandManager(useragent.isMac ? \"mac\" : \"win\", defaultCommands);\n        if (typeof document == \"object\") {\n            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);\n            this.renderer.textarea = this.textInput.getElement();\n            this.$mouseHandler = new MouseHandler(this);\n            new FoldHandler(this);\n        }\n        this.keyBinding = new KeyBinding(this);\n        this.$search = new Search().set({\n            wrap: true\n        });\n        this.$historyTracker = this.$historyTracker.bind(this);\n        this.commands.on(\"exec\", this.$historyTracker);\n        this.$initOperationListeners();\n        this._$emitInputEvent = lang.delayedCall(function () {\n            this._signal(\"input\", {});\n            if (this.session && !this.session.destroyed)\n                this.session.bgTokenizer.scheduleStart();\n        }.bind(this));\n        this.on(\"change\", function (_, _self) {\n            _self._$emitInputEvent.schedule(31);\n        });\n        this.setSession(session || options && options.session || new EditSession(\"\"));\n        config.resetOptions(this);\n        if (options)\n            this.setOptions(options);\n        config._signal(\"editor\", this);\n    }\n    Editor.prototype.$initOperationListeners = function () {\n        this.commands.on(\"exec\", this.startOperation.bind(this), true);\n        this.commands.on(\"afterExec\", this.endOperation.bind(this), true);\n        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));\n        this.on(\"change\", function () {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.docChanged = true;\n        }.bind(this), true);\n        this.on(\"changeSelection\", function () {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.selectionChanged = true;\n        }.bind(this), true);\n    };\n    Editor.prototype.startOperation = function (commandEvent) {\n        if (this.curOp) {\n            if (!commandEvent || this.curOp.command)\n                return;\n            this.prevOp = this.curOp;\n        }\n        if (!commandEvent) {\n            this.previousCommand = null;\n            commandEvent = {};\n        }\n        this.$opResetTimer.schedule();\n        this.curOp = this.session.curOp = {\n            command: commandEvent.command || {},\n            args: commandEvent.args,\n            scrollTop: this.renderer.scrollTop\n        };\n        this.curOp.selectionBefore = this.selection.toJSON();\n    };\n    Editor.prototype.endOperation = function (e) {\n        if (this.curOp && this.session) {\n            if (e && e.returnValue === false || !this.session)\n                return (this.curOp = null);\n            if (e == true && this.curOp.command && this.curOp.command.name == \"mouse\")\n                return;\n            this._signal(\"beforeEndOperation\");\n            if (!this.curOp)\n                return;\n            var command = this.curOp.command;\n            var scrollIntoView = command && command.scrollIntoView;\n            if (scrollIntoView) {\n                switch (scrollIntoView) {\n                    case \"center-animate\":\n                        scrollIntoView = \"animate\";\n                    case \"center\":\n                        this.renderer.scrollCursorIntoView(null, 0.5);\n                        break;\n                    case \"animate\":\n                    case \"cursor\":\n                        this.renderer.scrollCursorIntoView();\n                        break;\n                    case \"selectionPart\":\n                        var range = this.selection.getRange();\n                        var config = this.renderer.layerConfig;\n                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {\n                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                if (scrollIntoView == \"animate\")\n                    this.renderer.animateScrolling(this.curOp.scrollTop);\n            }\n            var sel = this.selection.toJSON();\n            this.curOp.selectionAfter = sel;\n            this.$lastSel = this.selection.toJSON();\n            this.session.getUndoManager().addSelection(sel);\n            this.prevOp = this.curOp;\n            this.curOp = null;\n        }\n    };\n    Editor.prototype.$historyTracker = function (e) {\n        if (!this.$mergeUndoDeltas)\n            return;\n        var prev = this.prevOp;\n        var mergeableCommands = this.$mergeableCommands;\n        var shouldMerge = prev.command && (e.command.name == prev.command.name);\n        if (e.command.name == \"insertstring\") {\n            var text = e.args;\n            if (this.mergeNextCommand === undefined)\n                this.mergeNextCommand = true;\n            shouldMerge = shouldMerge\n                && this.mergeNextCommand // previous command allows to coalesce with\n                && (!/\\s/.test(text) || /\\s/.test(prev.args)); // previous insertion was of same type\n            this.mergeNextCommand = true;\n        }\n        else {\n            shouldMerge = shouldMerge\n                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable\n        }\n        if (this.$mergeUndoDeltas != \"always\"\n            && Date.now() - this.sequenceStartTime > 2000) {\n            shouldMerge = false; // the sequence is too long\n        }\n        if (shouldMerge)\n            this.session.mergeUndoDeltas = true;\n        else if (mergeableCommands.indexOf(e.command.name) !== -1)\n            this.sequenceStartTime = Date.now();\n    };\n    Editor.prototype.setKeyboardHandler = function (keyboardHandler, cb) {\n        if (keyboardHandler && typeof keyboardHandler === \"string\" && keyboardHandler != \"ace\") {\n            this.$keybindingId = keyboardHandler;\n            var _self = this;\n            config.loadModule([\"keybinding\", keyboardHandler], function (module) {\n                if (_self.$keybindingId == keyboardHandler)\n                    _self.keyBinding.setKeyboardHandler(module && module.handler);\n                cb && cb();\n            });\n        }\n        else {\n            this.$keybindingId = null;\n            this.keyBinding.setKeyboardHandler(keyboardHandler);\n            cb && cb();\n        }\n    };\n    Editor.prototype.getKeyboardHandler = function () {\n        return this.keyBinding.getKeyboardHandler();\n    };\n    Editor.prototype.setSession = function (session) {\n        if (this.session == session)\n            return;\n        if (this.curOp)\n            this.endOperation();\n        this.curOp = {};\n        var oldSession = this.session;\n        if (oldSession) {\n            this.session.off(\"change\", this.$onDocumentChange);\n            this.session.off(\"changeMode\", this.$onChangeMode);\n            this.session.off(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.session.off(\"changeTabSize\", this.$onChangeTabSize);\n            this.session.off(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.session.off(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.session.off(\"changeFold\", this.$onChangeFold);\n            this.session.off(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.session.off(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.session.off(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.session.off(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.session.off(\"changeOverwrite\", this.$onCursorChange);\n            this.session.off(\"changeScrollTop\", this.$onScrollTopChange);\n            this.session.off(\"changeScrollLeft\", this.$onScrollLeftChange);\n            var selection = this.session.getSelection();\n            selection.off(\"changeCursor\", this.$onCursorChange);\n            selection.off(\"changeSelection\", this.$onSelectionChange);\n        }\n        this.session = session;\n        if (session) {\n            this.$onDocumentChange = this.onDocumentChange.bind(this);\n            session.on(\"change\", this.$onDocumentChange);\n            this.renderer.setSession(session);\n            this.$onChangeMode = this.onChangeMode.bind(this);\n            session.on(\"changeMode\", this.$onChangeMode);\n            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);\n            session.on(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);\n            session.on(\"changeTabSize\", this.$onChangeTabSize);\n            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n            session.on(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);\n            session.on(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.$onChangeFold = this.onChangeFold.bind(this);\n            session.on(\"changeFold\", this.$onChangeFold);\n            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);\n            this.session.on(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);\n            this.session.on(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);\n            this.session.on(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);\n            this.session.on(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.$onCursorChange = this.onCursorChange.bind(this);\n            this.session.on(\"changeOverwrite\", this.$onCursorChange);\n            this.$onScrollTopChange = this.onScrollTopChange.bind(this);\n            this.session.on(\"changeScrollTop\", this.$onScrollTopChange);\n            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);\n            this.session.on(\"changeScrollLeft\", this.$onScrollLeftChange);\n            this.selection = session.getSelection();\n            this.selection.on(\"changeCursor\", this.$onCursorChange);\n            this.$onSelectionChange = this.onSelectionChange.bind(this);\n            this.selection.on(\"changeSelection\", this.$onSelectionChange);\n            this.onChangeMode();\n            this.onCursorChange();\n            this.onScrollTopChange();\n            this.onScrollLeftChange();\n            this.onSelectionChange();\n            this.onChangeFrontMarker();\n            this.onChangeBackMarker();\n            this.onChangeBreakpoint();\n            this.onChangeAnnotation();\n            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();\n            this.renderer.updateFull();\n        }\n        else {\n            this.selection = null;\n            this.renderer.setSession(session);\n        }\n        this._signal(\"changeSession\", {\n            session: session,\n            oldSession: oldSession\n        });\n        this.curOp = null;\n        oldSession && oldSession._signal(\"changeEditor\", { oldEditor: this });\n        session && session._signal(\"changeEditor\", { editor: this });\n        if (session && !session.destroyed)\n            session.bgTokenizer.scheduleStart();\n    };\n    Editor.prototype.getSession = function () {\n        return this.session;\n    };\n    Editor.prototype.setValue = function (val, cursorPos) {\n        this.session.doc.setValue(val);\n        if (!cursorPos)\n            this.selectAll();\n        else if (cursorPos == 1)\n            this.navigateFileEnd();\n        else if (cursorPos == -1)\n            this.navigateFileStart();\n        return val;\n    };\n    Editor.prototype.getValue = function () {\n        return this.session.getValue();\n    };\n    Editor.prototype.getSelection = function () {\n        return this.selection;\n    };\n    Editor.prototype.resize = function (force) {\n        this.renderer.onResize(force);\n    };\n    Editor.prototype.setTheme = function (theme, cb) {\n        this.renderer.setTheme(theme, cb);\n    };\n    Editor.prototype.getTheme = function () {\n        return this.renderer.getTheme();\n    };\n    Editor.prototype.setStyle = function (style) {\n        this.renderer.setStyle(style);\n    };\n    Editor.prototype.unsetStyle = function (style) {\n        this.renderer.unsetStyle(style);\n    };\n    Editor.prototype.getFontSize = function () {\n        return this.getOption(\"fontSize\") ||\n            dom.computedStyle(this.container).fontSize;\n    };\n    Editor.prototype.setFontSize = function (size) {\n        this.setOption(\"fontSize\", size);\n    };\n    Editor.prototype.$highlightBrackets = function () {\n        if (this.$highlightPending) {\n            return;\n        }\n        var self = this;\n        this.$highlightPending = true;\n        setTimeout(function () {\n            self.$highlightPending = false;\n            var session = self.session;\n            if (!session || session.destroyed)\n                return;\n            if (session.$bracketHighlight) {\n                session.$bracketHighlight.markerIds.forEach(function (id) {\n                    session.removeMarker(id);\n                });\n                session.$bracketHighlight = null;\n            }\n            var pos = self.getCursorPosition();\n            var handler = self.getKeyboardHandler();\n            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self);\n            var ranges = session.getMatchingBracketRanges(pos, isBackwards);\n            if (!ranges) {\n                var iterator = new TokenIterator(session, pos.row, pos.column);\n                var token = iterator.getCurrentToken();\n                if (token && /\\b(?:tag-open|tag-name)/.test(token.type)) {\n                    var tagNamesRanges = session.getMatchingTags(pos);\n                    if (tagNamesRanges) {\n                        ranges = [\n                            tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,\n                            tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName\n                        ];\n                    }\n                }\n            }\n            if (!ranges && session.$mode.getMatching)\n                ranges = session.$mode.getMatching(self.session);\n            if (!ranges) {\n                if (self.getHighlightIndentGuides())\n                    self.renderer.$textLayer.$highlightIndentGuide();\n                return;\n            }\n            var markerType = \"ace_bracket\";\n            if (!Array.isArray(ranges)) {\n                ranges = [ranges];\n            }\n            else if (ranges.length == 1) {\n                markerType = \"ace_error_bracket\";\n            }\n            if (ranges.length == 2) {\n                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)\n                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];\n                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)\n                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];\n            }\n            session.$bracketHighlight = {\n                ranges: ranges,\n                markerIds: ranges.map(function (range) {\n                    return session.addMarker(range, markerType, \"text\");\n                })\n            };\n            if (self.getHighlightIndentGuides())\n                self.renderer.$textLayer.$highlightIndentGuide();\n        }, 50);\n    };\n    Editor.prototype.focus = function () {\n        this.textInput.focus();\n    };\n    Editor.prototype.isFocused = function () {\n        return this.textInput.isFocused();\n    };\n    Editor.prototype.blur = function () {\n        this.textInput.blur();\n    };\n    Editor.prototype.onFocus = function (e) {\n        if (this.$isFocused)\n            return;\n        this.$isFocused = true;\n        this.renderer.showCursor();\n        this.renderer.visualizeFocus();\n        this._emit(\"focus\", e);\n    };\n    Editor.prototype.onBlur = function (e) {\n        if (!this.$isFocused)\n            return;\n        this.$isFocused = false;\n        this.renderer.hideCursor();\n        this.renderer.visualizeBlur();\n        this._emit(\"blur\", e);\n    };\n    Editor.prototype.$cursorChange = function () {\n        this.renderer.updateCursor();\n        this.$highlightBrackets();\n        this.$updateHighlightActiveLine();\n    };\n    Editor.prototype.onDocumentChange = function (delta) {\n        var wrap = this.session.$useWrapMode;\n        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);\n        this.renderer.updateLines(delta.start.row, lastRow, wrap);\n        this._signal(\"change\", delta);\n        this.$cursorChange();\n    };\n    Editor.prototype.onTokenizerUpdate = function (e) {\n        var rows = e.data;\n        this.renderer.updateLines(rows.first, rows.last);\n    };\n    Editor.prototype.onScrollTopChange = function () {\n        this.renderer.scrollToY(this.session.getScrollTop());\n    };\n    Editor.prototype.onScrollLeftChange = function () {\n        this.renderer.scrollToX(this.session.getScrollLeft());\n    };\n    Editor.prototype.onCursorChange = function () {\n        this.$cursorChange();\n        this._signal(\"changeSelection\");\n    };\n    Editor.prototype.$updateHighlightActiveLine = function () {\n        var session = this.getSession();\n        var highlight;\n        if (this.$highlightActiveLine) {\n            if (this.$selectionStyle != \"line\" || !this.selection.isMultiLine())\n                highlight = this.getCursorPosition();\n            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())\n                highlight = false;\n            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))\n                highlight = false;\n        }\n        if (session.$highlightLineMarker && !highlight) {\n            session.removeMarker(session.$highlightLineMarker.id);\n            session.$highlightLineMarker = null;\n        }\n        else if (!session.$highlightLineMarker && highlight) {\n            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);\n            range.id = session.addMarker(range, \"ace_active-line\", \"screenLine\");\n            session.$highlightLineMarker = range;\n        }\n        else if (highlight) {\n            session.$highlightLineMarker.start.row = highlight.row;\n            session.$highlightLineMarker.end.row = highlight.row;\n            session.$highlightLineMarker.start.column = highlight.column;\n            session._signal(\"changeBackMarker\");\n        }\n    };\n    Editor.prototype.onSelectionChange = function (e) {\n        var session = this.session;\n        if (session.$selectionMarker) {\n            session.removeMarker(session.$selectionMarker);\n        }\n        session.$selectionMarker = null;\n        if (!this.selection.isEmpty()) {\n            var range = this.selection.getRange();\n            var style = this.getSelectionStyle();\n            session.$selectionMarker = session.addMarker(range, \"ace_selection\", style);\n        }\n        else {\n            this.$updateHighlightActiveLine();\n        }\n        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();\n        this.session.highlight(re);\n        this._signal(\"changeSelection\");\n    };\n    Editor.prototype.$getSelectionHighLightRegexp = function () {\n        var session = this.session;\n        var selection = this.getSelectionRange();\n        if (selection.isEmpty() || selection.isMultiLine())\n            return;\n        var startColumn = selection.start.column;\n        var endColumn = selection.end.column;\n        var line = session.getLine(selection.start.row);\n        var needle = line.substring(startColumn, endColumn);\n        if (needle.length > 5000 || !/[\\w\\d]/.test(needle))\n            return;\n        var re = this.$search.$assembleRegExp({\n            wholeWord: true,\n            caseSensitive: true,\n            needle: needle\n        });\n        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);\n        if (!re.test(wordWithBoundary))\n            return;\n        return re;\n    };\n    Editor.prototype.onChangeFrontMarker = function () {\n        this.renderer.updateFrontMarkers();\n    };\n    Editor.prototype.onChangeBackMarker = function () {\n        this.renderer.updateBackMarkers();\n    };\n    Editor.prototype.onChangeBreakpoint = function () {\n        this.renderer.updateBreakpoints();\n    };\n    Editor.prototype.onChangeAnnotation = function () {\n        this.renderer.setAnnotations(this.session.getAnnotations());\n    };\n    Editor.prototype.onChangeMode = function (e) {\n        this.renderer.updateText();\n        this._emit(\"changeMode\", e);\n    };\n    Editor.prototype.onChangeWrapLimit = function () {\n        this.renderer.updateFull();\n    };\n    Editor.prototype.onChangeWrapMode = function () {\n        this.renderer.onResize(true);\n    };\n    Editor.prototype.onChangeFold = function () {\n        this.$updateHighlightActiveLine();\n        this.renderer.updateFull();\n    };\n    Editor.prototype.getSelectedText = function () {\n        return this.session.getTextRange(this.getSelectionRange());\n    };\n    Editor.prototype.getCopyText = function () {\n        var text = this.getSelectedText();\n        var nl = this.session.doc.getNewLineCharacter();\n        var copyLine = false;\n        if (!text && this.$copyWithEmptySelection) {\n            copyLine = true;\n            var ranges = this.selection.getAllRanges();\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (i && ranges[i - 1].start.row == range.start.row)\n                    continue;\n                text += this.session.getLine(range.start.row) + nl;\n            }\n        }\n        var e = { text: text };\n        this._signal(\"copy\", e);\n        clipboard.lineMode = copyLine ? e.text : false;\n        return e.text;\n    };\n    Editor.prototype.onCopy = function () {\n        this.commands.exec(\"copy\", this);\n    };\n    Editor.prototype.onCut = function () {\n        this.commands.exec(\"cut\", this);\n    };\n    Editor.prototype.onPaste = function (text, event) {\n        var e = { text: text, event: event };\n        this.commands.exec(\"paste\", this, e);\n    };\n    Editor.prototype.$handlePaste = function (e) {\n        if (typeof e == \"string\")\n            e = { text: e };\n        this._signal(\"paste\", e);\n        var text = e.text;\n        var lineMode = text === clipboard.lineMode;\n        var session = this.session;\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {\n            if (lineMode)\n                session.insert({ row: this.selection.lead.row, column: 0 }, text);\n            else\n                this.insert(text);\n        }\n        else if (lineMode) {\n            this.selection.rangeList.ranges.forEach(function (range) {\n                session.insert({ row: range.start.row, column: 0 }, text);\n            });\n        }\n        else {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var ranges = this.selection.rangeList.ranges;\n            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);\n            if (lines.length != ranges.length || isFullLine)\n                return this.commands.exec(\"insertstring\", this, text);\n            for (var i = ranges.length; i--;) {\n                var range = ranges[i];\n                if (!range.isEmpty())\n                    session.remove(range);\n                session.insert(range.start, lines[i]);\n            }\n        }\n    };\n    Editor.prototype.execCommand = function (command, args) {\n        return this.commands.exec(command, this, args);\n    };\n    Editor.prototype.insert = function (text, pasted) {\n        var session = this.session;\n        var mode = session.getMode();\n        var cursor = this.getCursorPosition();\n        if (this.getBehavioursEnabled() && !pasted) {\n            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);\n            if (transform) {\n                if (text !== transform.text) {\n                    if (!this.inVirtualSelectionMode) {\n                        this.session.mergeUndoDeltas = false;\n                        this.mergeNextCommand = false;\n                    }\n                }\n                text = transform.text;\n            }\n        }\n        if (text == \"\\t\")\n            text = this.session.getTabString();\n        if (!this.selection.isEmpty()) {\n            var range = this.getSelectionRange();\n            cursor = this.session.remove(range);\n            this.clearSelection();\n        }\n        else if (this.session.getOverwrite() && text.indexOf(\"\\n\") == -1) {\n            var range = Range.fromPoints(cursor, cursor);\n            range.end.column += text.length;\n            this.session.remove(range);\n        }\n        if (text == \"\\n\" || text == \"\\r\\n\") {\n            var line = session.getLine(cursor.row);\n            if (cursor.column > line.search(/\\S|$/)) {\n                var d = line.substr(cursor.column).search(/\\S|$/);\n                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);\n            }\n        }\n        this.clearSelection();\n        var start = cursor.column;\n        var lineState = session.getState(cursor.row);\n        var line = session.getLine(cursor.row);\n        var shouldOutdent = mode.checkOutdent(lineState, line, text);\n        session.insert(cursor, text);\n        if (transform && transform.selection) {\n            if (transform.selection.length == 2) { // Transform relative to the current column\n                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));\n            }\n            else { // Transform relative to the current row.\n                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));\n            }\n        }\n        if (this.$enableAutoIndent) {\n            if (session.getDocument().isNewLine(text)) {\n                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());\n                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);\n            }\n            if (shouldOutdent)\n                mode.autoOutdent(lineState, session, cursor.row);\n        }\n    };\n    Editor.prototype.autoIndent = function () {\n        var session = this.session;\n        var mode = session.getMode();\n        var ranges = this.selection.isEmpty()\n            ? [new Range(0, 0, session.doc.getLength() - 1, 0)]\n            : this.selection.getAllRanges();\n        var prevLineState = \"\";\n        var prevLine = \"\";\n        var lineIndent = \"\";\n        var tab = session.getTabString();\n        for (var i = 0; i < ranges.length; i++) {\n            var startRow = ranges[i].start.row;\n            var endRow = ranges[i].end.row;\n            for (var row = startRow; row <= endRow; row++) {\n                if (row > 0) {\n                    prevLineState = session.getState(row - 1);\n                    prevLine = session.getLine(row - 1);\n                    lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);\n                }\n                var line = session.getLine(row);\n                var currIndent = mode.$getIndent(line);\n                if (lineIndent !== currIndent) {\n                    if (currIndent.length > 0) {\n                        var range = new Range(row, 0, row, currIndent.length);\n                        session.remove(range);\n                    }\n                    if (lineIndent.length > 0) {\n                        session.insert({ row: row, column: 0 }, lineIndent);\n                    }\n                }\n                mode.autoOutdent(prevLineState, session, row);\n            }\n        }\n    };\n    Editor.prototype.onTextInput = function (text, composition) {\n        if (!composition)\n            return this.keyBinding.onTextInput(text);\n        this.startOperation({ command: { name: \"insertstring\" } });\n        var applyComposition = this.applyComposition.bind(this, text, composition);\n        if (this.selection.rangeCount)\n            this.forEachSelection(applyComposition);\n        else\n            applyComposition();\n        this.endOperation();\n    };\n    Editor.prototype.applyComposition = function (text, composition) {\n        if (composition.extendLeft || composition.extendRight) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.extendLeft;\n            r.end.column += composition.extendRight;\n            if (r.start.column < 0) {\n                r.start.row--;\n                r.start.column += this.session.getLine(r.start.row).length + 1;\n            }\n            this.selection.setRange(r);\n            if (!text && !r.isEmpty())\n                this.remove();\n        }\n        if (text || !this.selection.isEmpty())\n            this.insert(text, true);\n        if (composition.restoreStart || composition.restoreEnd) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.restoreStart;\n            r.end.column -= composition.restoreEnd;\n            this.selection.setRange(r);\n        }\n    };\n    Editor.prototype.onCommandKey = function (e, hashId, keyCode) {\n        return this.keyBinding.onCommandKey(e, hashId, keyCode);\n    };\n    Editor.prototype.setOverwrite = function (overwrite) {\n        this.session.setOverwrite(overwrite);\n    };\n    Editor.prototype.getOverwrite = function () {\n        return this.session.getOverwrite();\n    };\n    Editor.prototype.toggleOverwrite = function () {\n        this.session.toggleOverwrite();\n    };\n    Editor.prototype.setScrollSpeed = function (speed) {\n        this.setOption(\"scrollSpeed\", speed);\n    };\n    Editor.prototype.getScrollSpeed = function () {\n        return this.getOption(\"scrollSpeed\");\n    };\n    Editor.prototype.setDragDelay = function (dragDelay) {\n        this.setOption(\"dragDelay\", dragDelay);\n    };\n    Editor.prototype.getDragDelay = function () {\n        return this.getOption(\"dragDelay\");\n    };\n    Editor.prototype.setSelectionStyle = function (val) {\n        this.setOption(\"selectionStyle\", val);\n    };\n    Editor.prototype.getSelectionStyle = function () {\n        return this.getOption(\"selectionStyle\");\n    };\n    Editor.prototype.setHighlightActiveLine = function (shouldHighlight) {\n        this.setOption(\"highlightActiveLine\", shouldHighlight);\n    };\n    Editor.prototype.getHighlightActiveLine = function () {\n        return this.getOption(\"highlightActiveLine\");\n    };\n    Editor.prototype.setHighlightGutterLine = function (shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n    Editor.prototype.getHighlightGutterLine = function () {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    Editor.prototype.setHighlightSelectedWord = function (shouldHighlight) {\n        this.setOption(\"highlightSelectedWord\", shouldHighlight);\n    };\n    Editor.prototype.getHighlightSelectedWord = function () {\n        return this.$highlightSelectedWord;\n    };\n    Editor.prototype.setAnimatedScroll = function (shouldAnimate) {\n        this.renderer.setAnimatedScroll(shouldAnimate);\n    };\n    Editor.prototype.getAnimatedScroll = function () {\n        return this.renderer.getAnimatedScroll();\n    };\n    Editor.prototype.setShowInvisibles = function (showInvisibles) {\n        this.renderer.setShowInvisibles(showInvisibles);\n    };\n    Editor.prototype.getShowInvisibles = function () {\n        return this.renderer.getShowInvisibles();\n    };\n    Editor.prototype.setDisplayIndentGuides = function (display) {\n        this.renderer.setDisplayIndentGuides(display);\n    };\n    Editor.prototype.getDisplayIndentGuides = function () {\n        return this.renderer.getDisplayIndentGuides();\n    };\n    Editor.prototype.setHighlightIndentGuides = function (highlight) {\n        this.renderer.setHighlightIndentGuides(highlight);\n    };\n    Editor.prototype.getHighlightIndentGuides = function () {\n        return this.renderer.getHighlightIndentGuides();\n    };\n    Editor.prototype.setShowPrintMargin = function (showPrintMargin) {\n        this.renderer.setShowPrintMargin(showPrintMargin);\n    };\n    Editor.prototype.getShowPrintMargin = function () {\n        return this.renderer.getShowPrintMargin();\n    };\n    Editor.prototype.setPrintMarginColumn = function (showPrintMargin) {\n        this.renderer.setPrintMarginColumn(showPrintMargin);\n    };\n    Editor.prototype.getPrintMarginColumn = function () {\n        return this.renderer.getPrintMarginColumn();\n    };\n    Editor.prototype.setReadOnly = function (readOnly) {\n        this.setOption(\"readOnly\", readOnly);\n    };\n    Editor.prototype.getReadOnly = function () {\n        return this.getOption(\"readOnly\");\n    };\n    Editor.prototype.setBehavioursEnabled = function (enabled) {\n        this.setOption(\"behavioursEnabled\", enabled);\n    };\n    Editor.prototype.getBehavioursEnabled = function () {\n        return this.getOption(\"behavioursEnabled\");\n    };\n    Editor.prototype.setWrapBehavioursEnabled = function (enabled) {\n        this.setOption(\"wrapBehavioursEnabled\", enabled);\n    };\n    Editor.prototype.getWrapBehavioursEnabled = function () {\n        return this.getOption(\"wrapBehavioursEnabled\");\n    };\n    Editor.prototype.setShowFoldWidgets = function (show) {\n        this.setOption(\"showFoldWidgets\", show);\n    };\n    Editor.prototype.getShowFoldWidgets = function () {\n        return this.getOption(\"showFoldWidgets\");\n    };\n    Editor.prototype.setFadeFoldWidgets = function (fade) {\n        this.setOption(\"fadeFoldWidgets\", fade);\n    };\n    Editor.prototype.getFadeFoldWidgets = function () {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    Editor.prototype.remove = function (dir) {\n        if (this.selection.isEmpty()) {\n            if (dir == \"left\")\n                this.selection.selectLeft();\n            else\n                this.selection.selectRight();\n        }\n        var range = this.getSelectionRange();\n        if (this.getBehavioursEnabled()) {\n            var session = this.session;\n            var state = session.getState(range.start.row);\n            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);\n            if (range.end.column === 0) {\n                var text = session.getTextRange(range);\n                if (text[text.length - 1] == \"\\n\") {\n                    var line = session.getLine(range.end.row);\n                    if (/^\\s+$/.test(line)) {\n                        range.end.column = line.length;\n                    }\n                }\n            }\n            if (new_range)\n                range = new_range;\n        }\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    Editor.prototype.removeWordRight = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectWordRight();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    Editor.prototype.removeWordLeft = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectWordLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    Editor.prototype.removeToLineStart = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectLineStart();\n        if (this.selection.isEmpty())\n            this.selection.selectLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    Editor.prototype.removeToLineEnd = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectLineEnd();\n        var range = this.getSelectionRange();\n        if (range.start.column == range.end.column && range.start.row == range.end.row) {\n            range.end.column = 0;\n            range.end.row++;\n        }\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    Editor.prototype.splitLine = function () {\n        if (!this.selection.isEmpty()) {\n            this.session.remove(this.getSelectionRange());\n            this.clearSelection();\n        }\n        var cursor = this.getCursorPosition();\n        this.insert(\"\\n\");\n        this.moveCursorToPosition(cursor);\n    };\n    Editor.prototype.setGhostText = function (text, position) {\n        if (!this.session.widgetManager) {\n            this.session.widgetManager = new LineWidgets(this.session);\n            this.session.widgetManager.attach(this);\n        }\n        this.renderer.setGhostText(text, position);\n    };\n    Editor.prototype.removeGhostText = function () {\n        if (!this.session.widgetManager)\n            return;\n        this.renderer.removeGhostText();\n    };\n    Editor.prototype.transposeLetters = function () {\n        if (!this.selection.isEmpty()) {\n            return;\n        }\n        var cursor = this.getCursorPosition();\n        var column = cursor.column;\n        if (column === 0)\n            return;\n        var line = this.session.getLine(cursor.row);\n        var swap, range;\n        if (column < line.length) {\n            swap = line.charAt(column) + line.charAt(column - 1);\n            range = new Range(cursor.row, column - 1, cursor.row, column + 1);\n        }\n        else {\n            swap = line.charAt(column - 1) + line.charAt(column - 2);\n            range = new Range(cursor.row, column - 2, cursor.row, column);\n        }\n        this.session.replace(range, swap);\n        this.session.selection.moveToPosition(range.end);\n    };\n    Editor.prototype.toLowerCase = function () {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toLowerCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    Editor.prototype.toUpperCase = function () {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toUpperCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    Editor.prototype.indent = function () {\n        var session = this.session;\n        var range = this.getSelectionRange();\n        if (range.start.row < range.end.row) {\n            var rows = this.$getSelectedRows();\n            session.indentRows(rows.first, rows.last, \"\\t\");\n            return;\n        }\n        else if (range.start.column < range.end.column) {\n            var text = session.getTextRange(range);\n            if (!/^\\s+$/.test(text)) {\n                var rows = this.$getSelectedRows();\n                session.indentRows(rows.first, rows.last, \"\\t\");\n                return;\n            }\n        }\n        var line = session.getLine(range.start.row);\n        var position = range.start;\n        var size = session.getTabSize();\n        var column = session.documentToScreenColumn(position.row, position.column);\n        if (this.session.getUseSoftTabs()) {\n            var count = (size - column % size);\n            var indentString = lang.stringRepeat(\" \", count);\n        }\n        else {\n            var count = column % size;\n            while (line[range.start.column - 1] == \" \" && count) {\n                range.start.column--;\n                count--;\n            }\n            this.selection.setSelectionRange(range);\n            indentString = \"\\t\";\n        }\n        return this.insert(indentString);\n    };\n    Editor.prototype.blockIndent = function () {\n        var rows = this.$getSelectedRows();\n        this.session.indentRows(rows.first, rows.last, \"\\t\");\n    };\n    Editor.prototype.blockOutdent = function () {\n        var selection = this.session.getSelection();\n        this.session.outdentRows(selection.getRange());\n    };\n    Editor.prototype.sortLines = function () {\n        var rows = this.$getSelectedRows();\n        var session = this.session;\n        var lines = [];\n        for (var i = rows.first; i <= rows.last; i++)\n            lines.push(session.getLine(i));\n        lines.sort(function (a, b) {\n            if (a.toLowerCase() < b.toLowerCase())\n                return -1;\n            if (a.toLowerCase() > b.toLowerCase())\n                return 1;\n            return 0;\n        });\n        var deleteRange = new Range(0, 0, 0, 0);\n        for (var i = rows.first; i <= rows.last; i++) {\n            var line = session.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            deleteRange.end.column = line.length;\n            session.replace(deleteRange, lines[i - rows.first]);\n        }\n    };\n    Editor.prototype.toggleCommentLines = function () {\n        var state = this.session.getState(this.getCursorPosition().row);\n        var rows = this.$getSelectedRows();\n        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);\n    };\n    Editor.prototype.toggleBlockComment = function () {\n        var cursor = this.getCursorPosition();\n        var state = this.session.getState(cursor.row);\n        var range = this.getSelectionRange();\n        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);\n    };\n    Editor.prototype.getNumberAt = function (row, column) {\n        var _numberRx = /[\\-]?[0-9]+(?:\\.[0-9]+)?/g;\n        _numberRx.lastIndex = 0;\n        var s = this.session.getLine(row);\n        while (_numberRx.lastIndex < column) {\n            var m = _numberRx.exec(s);\n            if (m.index <= column && m.index + m[0].length >= column) {\n                var number = {\n                    value: m[0],\n                    start: m.index,\n                    end: m.index + m[0].length\n                };\n                return number;\n            }\n        }\n        return null;\n    };\n    Editor.prototype.modifyNumber = function (amount) {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        var charRange = new Range(row, column - 1, row, column);\n        var c = this.session.getTextRange(charRange);\n        if (!isNaN(parseFloat(c)) && isFinite(c)) {\n            var nr = this.getNumberAt(row, column);\n            if (nr) {\n                var fp = nr.value.indexOf(\".\") >= 0 ? nr.start + nr.value.indexOf(\".\") + 1 : nr.end;\n                var decimals = nr.start + nr.value.length - fp;\n                var t = parseFloat(nr.value);\n                t *= Math.pow(10, decimals);\n                if (fp !== nr.end && column < fp) {\n                    amount *= Math.pow(10, nr.end - column - 1);\n                }\n                else {\n                    amount *= Math.pow(10, nr.end - column);\n                }\n                t += amount;\n                t /= Math.pow(10, decimals);\n                var nnr = t.toFixed(decimals);\n                var replaceRange = new Range(row, nr.start, row, nr.end);\n                this.session.replace(replaceRange, nnr);\n                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));\n            }\n        }\n        else {\n            this.toggleWord();\n        }\n    };\n    Editor.prototype.toggleWord = function () {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        this.selection.selectWord();\n        var currentState = this.getSelectedText();\n        var currWordStart = this.selection.getWordRange().start.column;\n        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\\s/);\n        var delta = column - currWordStart - 1;\n        if (delta < 0)\n            delta = 0;\n        var curLength = 0, itLength = 0;\n        var that = this;\n        if (currentState.match(/[A-Za-z0-9_]+/)) {\n            wordParts.forEach(function (item, i) {\n                itLength = curLength + item.length;\n                if (delta >= curLength && delta <= itLength) {\n                    currentState = item;\n                    that.selection.clearSelection();\n                    that.moveCursorTo(row, curLength + currWordStart);\n                    that.selection.selectTo(row, itLength + currWordStart);\n                }\n                curLength = itLength;\n            });\n        }\n        var wordPairs = this.$toggleWordPairs;\n        var reg;\n        for (var i = 0; i < wordPairs.length; i++) {\n            var item = wordPairs[i];\n            for (var j = 0; j <= 1; j++) {\n                var negate = +!j;\n                var firstCondition = currentState.match(new RegExp('^\\\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\\\s?$', 'i'));\n                if (firstCondition) {\n                    var secondCondition = currentState.match(new RegExp('([_]|^|\\\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\\\s)', 'g'));\n                    if (secondCondition) {\n                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {\n                            var res = item[negate];\n                            if (result.toUpperCase() == result) {\n                                res = res.toUpperCase();\n                            }\n                            else if (result.charAt(0).toUpperCase() == result.charAt(0)) {\n                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);\n                            }\n                            return res;\n                        });\n                        this.insert(reg);\n                        reg = \"\";\n                    }\n                }\n            }\n        }\n    };\n    Editor.prototype.findLinkAt = function (row, column) {\n        var e_1, _a;\n        var line = this.session.getLine(row);\n        var wordParts = line.split(/((?:https?|ftp):\\/\\/[\\S]+)/);\n        var columnPosition = column;\n        if (columnPosition < 0)\n            columnPosition = 0;\n        var previousPosition = 0, currentPosition = 0, match;\n        try {\n            for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {\n                var item = wordParts_1_1.value;\n                currentPosition = previousPosition + item.length;\n                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {\n                    if (item.match(/((?:https?|ftp):\\/\\/[\\S]+)/)) {\n                        match = item.replace(/[\\s:.,'\";}\\]]+$/, \"\");\n                        break;\n                    }\n                }\n                previousPosition = currentPosition;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return match;\n    };\n    Editor.prototype.openLink = function () {\n        var cursor = this.selection.getCursor();\n        var url = this.findLinkAt(cursor.row, cursor.column);\n        if (url)\n            window.open(url, '_blank');\n        return url != null;\n    };\n    Editor.prototype.removeLines = function () {\n        var rows = this.$getSelectedRows();\n        this.session.removeFullLines(rows.first, rows.last);\n        this.clearSelection();\n    };\n    Editor.prototype.duplicateSelection = function () {\n        var sel = this.selection;\n        var doc = this.session;\n        var range = sel.getRange();\n        var reverse = sel.isBackwards();\n        if (range.isEmpty()) {\n            var row = range.start.row;\n            doc.duplicateLines(row, row);\n        }\n        else {\n            var point = reverse ? range.start : range.end;\n            var endPoint = doc.insert(point, doc.getTextRange(range));\n            range.start = point;\n            range.end = endPoint;\n            sel.setSelectionRange(range, reverse);\n        }\n    };\n    Editor.prototype.moveLinesDown = function () {\n        this.$moveLines(1, false);\n    };\n    Editor.prototype.moveLinesUp = function () {\n        this.$moveLines(-1, false);\n    };\n    Editor.prototype.moveText = function (range, toPosition, copy) {\n        return this.session.moveText(range, toPosition, copy);\n    };\n    Editor.prototype.copyLinesUp = function () {\n        this.$moveLines(-1, true);\n    };\n    Editor.prototype.copyLinesDown = function () {\n        this.$moveLines(1, true);\n    };\n    Editor.prototype.$moveLines = function (dir, copy) {\n        var rows, moved;\n        var selection = this.selection;\n        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {\n            var range = selection.toOrientedRange();\n            rows = this.$getSelectedRows(range);\n            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);\n            if (copy && dir == -1)\n                moved = 0;\n            range.moveBy(moved, 0);\n            selection.fromOrientedRange(range);\n        }\n        else {\n            var ranges = selection.rangeList.ranges;\n            selection.rangeList.detach(this.session);\n            this.inVirtualSelectionMode = true;\n            var diff = 0;\n            var totalDiff = 0;\n            var l = ranges.length;\n            for (var i = 0; i < l; i++) {\n                var rangeIndex = i;\n                ranges[i].moveBy(diff, 0);\n                rows = this.$getSelectedRows(ranges[i]);\n                var first = rows.first;\n                var last = rows.last;\n                while (++i < l) {\n                    if (totalDiff)\n                        ranges[i].moveBy(totalDiff, 0);\n                    var subRows = this.$getSelectedRows(ranges[i]);\n                    if (copy && subRows.first != last)\n                        break;\n                    else if (!copy && subRows.first > last + 1)\n                        break;\n                    last = subRows.last;\n                }\n                i--;\n                diff = this.session.$moveLines(first, last, copy ? 0 : dir);\n                if (copy && dir == -1)\n                    rangeIndex = i + 1;\n                while (rangeIndex <= i) {\n                    ranges[rangeIndex].moveBy(diff, 0);\n                    rangeIndex++;\n                }\n                if (!copy)\n                    diff = 0;\n                totalDiff += diff;\n            }\n            selection.fromOrientedRange(selection.ranges[0]);\n            selection.rangeList.attach(this.session);\n            this.inVirtualSelectionMode = false;\n        }\n    };\n    Editor.prototype.$getSelectedRows = function (range) {\n        range = (range || this.getSelectionRange()).collapseRows();\n        return {\n            first: this.session.getRowFoldStart(range.start.row),\n            last: this.session.getRowFoldEnd(range.end.row)\n        };\n    };\n    Editor.prototype.onCompositionStart = function (compositionState) {\n        this.renderer.showComposition(compositionState);\n    };\n    Editor.prototype.onCompositionUpdate = function (text) {\n        this.renderer.setCompositionText(text);\n    };\n    Editor.prototype.onCompositionEnd = function () {\n        this.renderer.hideComposition();\n    };\n    Editor.prototype.getFirstVisibleRow = function () {\n        return this.renderer.getFirstVisibleRow();\n    };\n    Editor.prototype.getLastVisibleRow = function () {\n        return this.renderer.getLastVisibleRow();\n    };\n    Editor.prototype.isRowVisible = function (row) {\n        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());\n    };\n    Editor.prototype.isRowFullyVisible = function (row) {\n        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());\n    };\n    Editor.prototype.$getVisibleRowCount = function () {\n        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;\n    };\n    Editor.prototype.$moveByPage = function (dir, select) {\n        var renderer = this.renderer;\n        var config = this.renderer.layerConfig;\n        var rows = dir * Math.floor(config.height / config.lineHeight);\n        if (select === true) {\n            this.selection.$moveSelection(function () {\n                this.moveCursorBy(rows, 0);\n            });\n        }\n        else if (select === false) {\n            this.selection.moveCursorBy(rows, 0);\n            this.selection.clearSelection();\n        }\n        var scrollTop = renderer.scrollTop;\n        renderer.scrollBy(0, rows * config.lineHeight);\n        if (select != null)\n            renderer.scrollCursorIntoView(null, 0.5);\n        renderer.animateScrolling(scrollTop);\n    };\n    Editor.prototype.selectPageDown = function () {\n        this.$moveByPage(1, true);\n    };\n    Editor.prototype.selectPageUp = function () {\n        this.$moveByPage(-1, true);\n    };\n    Editor.prototype.gotoPageDown = function () {\n        this.$moveByPage(1, false);\n    };\n    Editor.prototype.gotoPageUp = function () {\n        this.$moveByPage(-1, false);\n    };\n    Editor.prototype.scrollPageDown = function () {\n        this.$moveByPage(1);\n    };\n    Editor.prototype.scrollPageUp = function () {\n        this.$moveByPage(-1);\n    };\n    Editor.prototype.scrollToRow = function (row) {\n        this.renderer.scrollToRow(row);\n    };\n    Editor.prototype.scrollToLine = function (line, center, animate, callback) {\n        this.renderer.scrollToLine(line, center, animate, callback);\n    };\n    Editor.prototype.centerSelection = function () {\n        var range = this.getSelectionRange();\n        var pos = {\n            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),\n            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)\n        };\n        this.renderer.alignCursor(pos, 0.5);\n    };\n    Editor.prototype.getCursorPosition = function () {\n        return this.selection.getCursor();\n    };\n    Editor.prototype.getCursorPositionScreen = function () {\n        return this.session.documentToScreenPosition(this.getCursorPosition());\n    };\n    Editor.prototype.getSelectionRange = function () {\n        return this.selection.getRange();\n    };\n    Editor.prototype.selectAll = function () {\n        this.selection.selectAll();\n    };\n    Editor.prototype.clearSelection = function () {\n        this.selection.clearSelection();\n    };\n    Editor.prototype.moveCursorTo = function (row, column) {\n        this.selection.moveCursorTo(row, column);\n    };\n    Editor.prototype.moveCursorToPosition = function (pos) {\n        this.selection.moveCursorToPosition(pos);\n    };\n    Editor.prototype.jumpToMatching = function (select, expand) {\n        var cursor = this.getCursorPosition();\n        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);\n        var prevToken = iterator.getCurrentToken();\n        var tokenCount = 0;\n        if (prevToken && prevToken.type.indexOf('tag-name') !== -1) {\n            prevToken = iterator.stepBackward();\n        }\n        var token = prevToken || iterator.stepForward();\n        if (!token)\n            return;\n        var matchType;\n        var found = false;\n        var depth = {};\n        var i = cursor.column - token.start;\n        var bracketType;\n        var brackets = {\n            \")\": \"(\",\n            \"(\": \"(\",\n            \"]\": \"[\",\n            \"[\": \"[\",\n            \"{\": \"{\",\n            \"}\": \"{\"\n        };\n        do {\n            if (token.value.match(/[{}()\\[\\]]/g)) {\n                for (; i < token.value.length && !found; i++) {\n                    if (!brackets[token.value[i]]) {\n                        continue;\n                    }\n                    bracketType = brackets[token.value[i]] + '.' + token.type.replace(\"rparen\", \"lparen\");\n                    if (isNaN(depth[bracketType])) {\n                        depth[bracketType] = 0;\n                    }\n                    switch (token.value[i]) {\n                        case '(':\n                        case '[':\n                        case '{':\n                            depth[bracketType]++;\n                            break;\n                        case ')':\n                        case ']':\n                        case '}':\n                            depth[bracketType]--;\n                            if (depth[bracketType] === -1) {\n                                matchType = 'bracket';\n                                found = true;\n                            }\n                            break;\n                    }\n                }\n            }\n            else if (token.type.indexOf('tag-name') !== -1) {\n                if (isNaN(depth[token.value])) {\n                    depth[token.value] = 0;\n                }\n                if (prevToken.value === '<' && tokenCount > 1) {\n                    depth[token.value]++;\n                }\n                else if (prevToken.value === '</') {\n                    depth[token.value]--;\n                }\n                if (depth[token.value] === -1) {\n                    matchType = 'tag';\n                    found = true;\n                }\n            }\n            if (!found) {\n                prevToken = token;\n                tokenCount++;\n                token = iterator.stepForward();\n                i = 0;\n            }\n        } while (token && !found);\n        if (!matchType)\n            return;\n        var range, pos;\n        if (matchType === 'bracket') {\n            range = this.session.getBracketRange(cursor);\n            if (!range) {\n                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);\n                pos = range.start;\n                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column)\n                    < 2)\n                    range = this.session.getBracketRange(pos);\n            }\n        }\n        else if (matchType === 'tag') {\n            if (!token || token.type.indexOf('tag-name') === -1)\n                return;\n            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);\n            if (range.compare(cursor.row, cursor.column) === 0) {\n                var tagsRanges = this.session.getMatchingTags(cursor);\n                if (tagsRanges) {\n                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {\n                        range = tagsRanges.closeTag;\n                        pos = range.start;\n                    }\n                    else {\n                        range = tagsRanges.openTag;\n                        if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column\n                            === cursor.column)\n                            pos = range.end;\n                        else\n                            pos = range.start;\n                    }\n                }\n            }\n            pos = pos || range.start;\n        }\n        pos = range && range.cursor || pos;\n        if (pos) {\n            if (select) {\n                if (range && expand) {\n                    this.selection.setRange(range);\n                }\n                else if (range && range.isEqual(this.getSelectionRange())) {\n                    this.clearSelection();\n                }\n                else {\n                    this.selection.selectTo(pos.row, pos.column);\n                }\n            }\n            else {\n                this.selection.moveTo(pos.row, pos.column);\n            }\n        }\n    };\n    Editor.prototype.gotoLine = function (lineNumber, column, animate) {\n        this.selection.clearSelection();\n        this.session.unfold({ row: lineNumber - 1, column: column || 0 });\n        this.exitMultiSelectMode && this.exitMultiSelectMode();\n        this.moveCursorTo(lineNumber - 1, column || 0);\n        if (!this.isRowFullyVisible(lineNumber - 1))\n            this.scrollToLine(lineNumber - 1, true, animate);\n    };\n    Editor.prototype.navigateTo = function (row, column) {\n        this.selection.moveTo(row, column);\n    };\n    Editor.prototype.navigateUp = function (times) {\n        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {\n            var selectionStart = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionStart);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(-times || -1, 0);\n    };\n    Editor.prototype.navigateDown = function (times) {\n        if (this.selection.isMultiLine() && this.selection.isBackwards()) {\n            var selectionEnd = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionEnd);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(times || 1, 0);\n    };\n    Editor.prototype.navigateLeft = function (times) {\n        if (!this.selection.isEmpty()) {\n            var selectionStart = this.getSelectionRange().start;\n            this.moveCursorToPosition(selectionStart);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorLeft();\n            }\n        }\n        this.clearSelection();\n    };\n    Editor.prototype.navigateRight = function (times) {\n        if (!this.selection.isEmpty()) {\n            var selectionEnd = this.getSelectionRange().end;\n            this.moveCursorToPosition(selectionEnd);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorRight();\n            }\n        }\n        this.clearSelection();\n    };\n    Editor.prototype.navigateLineStart = function () {\n        this.selection.moveCursorLineStart();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateLineEnd = function () {\n        this.selection.moveCursorLineEnd();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateFileEnd = function () {\n        this.selection.moveCursorFileEnd();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateFileStart = function () {\n        this.selection.moveCursorFileStart();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateWordRight = function () {\n        this.selection.moveCursorWordRight();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateWordLeft = function () {\n        this.selection.moveCursorWordLeft();\n        this.clearSelection();\n    };\n    Editor.prototype.replace = function (replacement, options) {\n        if (options)\n            this.$search.set(options);\n        var range = this.$search.find(this.session);\n        var replaced = 0;\n        if (!range)\n            return replaced;\n        if (this.$tryReplace(range, replacement)) {\n            replaced = 1;\n        }\n        this.selection.setSelectionRange(range);\n        this.renderer.scrollSelectionIntoView(range.start, range.end);\n        return replaced;\n    };\n    Editor.prototype.replaceAll = function (replacement, options) {\n        if (options) {\n            this.$search.set(options);\n        }\n        var ranges = this.$search.findAll(this.session);\n        var replaced = 0;\n        if (!ranges.length)\n            return replaced;\n        var selection = this.getSelectionRange();\n        this.selection.moveTo(0, 0);\n        for (var i = ranges.length - 1; i >= 0; --i) {\n            if (this.$tryReplace(ranges[i], replacement)) {\n                replaced++;\n            }\n        }\n        this.selection.setSelectionRange(selection);\n        return replaced;\n    };\n    Editor.prototype.$tryReplace = function (range, replacement) {\n        var input = this.session.getTextRange(range);\n        replacement = this.$search.replace(input, replacement);\n        if (replacement !== null) {\n            range.end = this.session.replace(range, replacement);\n            return range;\n        }\n        else {\n            return null;\n        }\n    };\n    Editor.prototype.getLastSearchOptions = function () {\n        return this.$search.getOptions();\n    };\n    Editor.prototype.find = function (needle, options, animate) {\n        if (!options)\n            options = {};\n        if (typeof needle == \"string\" || needle instanceof RegExp)\n            options.needle = needle;\n        else if (typeof needle == \"object\")\n            oop.mixin(options, needle);\n        var range = this.selection.getRange();\n        if (options.needle == null) {\n            needle = this.session.getTextRange(range)\n                || this.$search.$options.needle;\n            if (!needle) {\n                range = this.session.getWordRange(range.start.row, range.start.column);\n                needle = this.session.getTextRange(range);\n            }\n            this.$search.set({ needle: needle });\n        }\n        this.$search.set(options);\n        if (!options.start)\n            this.$search.set({ start: range });\n        var newRange = this.$search.find(this.session);\n        if (options.preventScroll)\n            return newRange;\n        if (newRange) {\n            this.revealRange(newRange, animate);\n            return newRange;\n        }\n        if (options.backwards)\n            range.start = range.end;\n        else\n            range.end = range.start;\n        this.selection.setRange(range);\n    };\n    Editor.prototype.findNext = function (options, animate) {\n        this.find({ skipCurrent: true, backwards: false }, options, animate);\n    };\n    Editor.prototype.findPrevious = function (options, animate) {\n        this.find(options, { skipCurrent: true, backwards: true }, animate);\n    };\n    Editor.prototype.revealRange = function (range, animate) {\n        this.session.unfold(range);\n        this.selection.setSelectionRange(range);\n        var scrollTop = this.renderer.scrollTop;\n        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);\n        if (animate !== false)\n            this.renderer.animateScrolling(scrollTop);\n    };\n    Editor.prototype.undo = function () {\n        this.session.getUndoManager().undo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    Editor.prototype.redo = function () {\n        this.session.getUndoManager().redo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    Editor.prototype.destroy = function () {\n        if (this.$toDestroy) {\n            this.$toDestroy.forEach(function (el) {\n                el.destroy();\n            });\n            this.$toDestroy = null;\n        }\n        if (this.$mouseHandler)\n            this.$mouseHandler.destroy();\n        this.renderer.destroy();\n        this._signal(\"destroy\", this);\n        if (this.session)\n            this.session.destroy();\n        if (this._$emitInputEvent)\n            this._$emitInputEvent.cancel();\n        this.removeAllListeners();\n    };\n    Editor.prototype.setAutoScrollEditorIntoView = function (enable) {\n        if (!enable)\n            return;\n        var rect;\n        var self = this;\n        var shouldScroll = false;\n        if (!this.$scrollAnchor)\n            this.$scrollAnchor = document.createElement(\"div\");\n        var scrollAnchor = this.$scrollAnchor;\n        scrollAnchor.style.cssText = \"position:absolute\";\n        this.container.insertBefore(scrollAnchor, this.container.firstChild);\n        var onChangeSelection = this.on(\"changeSelection\", function () {\n            shouldScroll = true;\n        });\n        var onBeforeRender = this.renderer.on(\"beforeRender\", function () {\n            if (shouldScroll)\n                rect = self.renderer.container.getBoundingClientRect();\n        });\n        var onAfterRender = this.renderer.on(\"afterRender\", function () {\n            if (shouldScroll && rect && (self.isFocused()\n                || self.searchBox && self.searchBox.isFocused())) {\n                var renderer = self.renderer;\n                var pos = renderer.$cursorLayer.$pixelPos;\n                var config = renderer.layerConfig;\n                var top = pos.top - config.offset;\n                if (pos.top >= 0 && top + rect.top < 0) {\n                    shouldScroll = true;\n                }\n                else if (pos.top < config.height &&\n                    pos.top + rect.top + config.lineHeight > window.innerHeight) {\n                    shouldScroll = false;\n                }\n                else {\n                    shouldScroll = null;\n                }\n                if (shouldScroll != null) {\n                    scrollAnchor.style.top = top + \"px\";\n                    scrollAnchor.style.left = pos.left + \"px\";\n                    scrollAnchor.style.height = config.lineHeight + \"px\";\n                    scrollAnchor.scrollIntoView(shouldScroll);\n                }\n                shouldScroll = rect = null;\n            }\n        });\n        this.setAutoScrollEditorIntoView = function (enable) {\n            if (enable)\n                return;\n            delete this.setAutoScrollEditorIntoView;\n            this.off(\"changeSelection\", onChangeSelection);\n            this.renderer.off(\"afterRender\", onAfterRender);\n            this.renderer.off(\"beforeRender\", onBeforeRender);\n        };\n    };\n    Editor.prototype.$resetCursorStyle = function () {\n        var style = this.$cursorStyle || \"ace\";\n        var cursorLayer = this.renderer.$cursorLayer;\n        if (!cursorLayer)\n            return;\n        cursorLayer.setSmoothBlinking(/smooth/.test(style));\n        cursorLayer.isBlinking = !this.$readOnly && style != \"wide\";\n        dom.setCssClass(cursorLayer.element, \"ace_slim-cursors\", /slim/.test(style));\n    };\n    Editor.prototype.prompt = function (message, options, callback) {\n        var editor = this;\n        config.loadModule(\"ace/ext/prompt\", function (module) {\n            module.prompt(editor, message, options, callback);\n        });\n    };\n    return Editor;\n}());\nEditor.$uid = 0;\nEditor.prototype.curOp = null;\nEditor.prototype.prevOp = {};\nEditor.prototype.$mergeableCommands = [\"backspace\", \"del\", \"insertstring\"];\nEditor.prototype.$toggleWordPairs = [\n    [\"first\", \"last\"],\n    [\"true\", \"false\"],\n    [\"yes\", \"no\"],\n    [\"width\", \"height\"],\n    [\"top\", \"bottom\"],\n    [\"right\", \"left\"],\n    [\"on\", \"off\"],\n    [\"x\", \"y\"],\n    [\"get\", \"set\"],\n    [\"max\", \"min\"],\n    [\"horizontal\", \"vertical\"],\n    [\"show\", \"hide\"],\n    [\"add\", \"remove\"],\n    [\"up\", \"down\"],\n    [\"before\", \"after\"],\n    [\"even\", \"odd\"],\n    [\"in\", \"out\"],\n    [\"inside\", \"outside\"],\n    [\"next\", \"previous\"],\n    [\"increase\", \"decrease\"],\n    [\"attach\", \"detach\"],\n    [\"&&\", \"||\"],\n    [\"==\", \"!=\"]\n];\noop.implement(Editor.prototype, EventEmitter);\nconfig.defineOptions(Editor.prototype, \"editor\", {\n    selectionStyle: {\n        set: function (style) {\n            this.onSelectionChange();\n            this._signal(\"changeSelectionStyle\", { data: style });\n        },\n        initialValue: \"line\"\n    },\n    highlightActiveLine: {\n        set: function () { this.$updateHighlightActiveLine(); },\n        initialValue: true\n    },\n    highlightSelectedWord: {\n        set: function (shouldHighlight) { this.$onSelectionChange(); },\n        initialValue: true\n    },\n    readOnly: {\n        set: function (readOnly) {\n            this.textInput.setReadOnly(readOnly);\n            this.$resetCursorStyle();\n        },\n        initialValue: false\n    },\n    copyWithEmptySelection: {\n        set: function (value) {\n            this.textInput.setCopyWithEmptySelection(value);\n        },\n        initialValue: false\n    },\n    cursorStyle: {\n        set: function (val) { this.$resetCursorStyle(); },\n        values: [\"ace\", \"slim\", \"smooth\", \"wide\"],\n        initialValue: \"ace\"\n    },\n    mergeUndoDeltas: {\n        values: [false, true, \"always\"],\n        initialValue: true\n    },\n    behavioursEnabled: { initialValue: true },\n    wrapBehavioursEnabled: { initialValue: true },\n    enableAutoIndent: { initialValue: true },\n    autoScrollEditorIntoView: {\n        set: function (val) { this.setAutoScrollEditorIntoView(val); }\n    },\n    keyboardHandler: {\n        set: function (val) { this.setKeyboardHandler(val); },\n        get: function () { return this.$keybindingId; },\n        handlesSet: true\n    },\n    value: {\n        set: function (val) { this.session.setValue(val); },\n        get: function () { return this.getValue(); },\n        handlesSet: true,\n        hidden: true\n    },\n    session: {\n        set: function (val) { this.setSession(val); },\n        get: function () { return this.session; },\n        handlesSet: true,\n        hidden: true\n    },\n    showLineNumbers: {\n        set: function (show) {\n            this.renderer.$gutterLayer.setShowLineNumbers(show);\n            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);\n            if (show && this.$relativeLineNumbers)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        },\n        initialValue: true\n    },\n    relativeLineNumbers: {\n        set: function (value) {\n            if (this.$showLineNumbers && value)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        }\n    },\n    placeholder: {\n        set: function (message) {\n            if (!this.$updatePlaceholder) {\n                this.$updatePlaceholder = function () {\n                    var hasValue = this.session && (this.renderer.$composition ||\n                        this.session.getLength() > 1 || this.session.getLine(0).length > 0);\n                    if (hasValue && this.renderer.placeholderNode) {\n                        this.renderer.off(\"afterRender\", this.$updatePlaceholder);\n                        dom.removeCssClass(this.container, \"ace_hasPlaceholder\");\n                        this.renderer.placeholderNode.remove();\n                        this.renderer.placeholderNode = null;\n                    }\n                    else if (!hasValue && !this.renderer.placeholderNode) {\n                        this.renderer.on(\"afterRender\", this.$updatePlaceholder);\n                        dom.addCssClass(this.container, \"ace_hasPlaceholder\");\n                        var el = dom.createElement(\"div\");\n                        el.className = \"ace_placeholder\";\n                        el.textContent = this.$placeholder || \"\";\n                        this.renderer.placeholderNode = el;\n                        this.renderer.content.appendChild(this.renderer.placeholderNode);\n                    }\n                    else if (!hasValue && this.renderer.placeholderNode) {\n                        this.renderer.placeholderNode.textContent = this.$placeholder || \"\";\n                    }\n                }.bind(this);\n                this.on(\"input\", this.$updatePlaceholder);\n            }\n            this.$updatePlaceholder();\n        }\n    },\n    enableKeyboardAccessibility: {\n        set: function (value) {\n            var blurCommand = {\n                name: \"blurTextInput\",\n                description: \"Set focus to the editor content div to allow tabbing through the page\",\n                bindKey: \"Esc\",\n                exec: function (editor) {\n                    editor.blur();\n                    editor.renderer.scroller.focus();\n                },\n                readOnly: true\n            };\n            var focusOnEnterKeyup = function (e) {\n                if (e.target == this.renderer.scroller && e.keyCode === keys['enter']) {\n                    e.preventDefault();\n                    var row = this.getCursorPosition().row;\n                    if (!this.isRowVisible(row))\n                        this.scrollToLine(row, true, true);\n                    this.focus();\n                }\n            };\n            var gutterKeyboardHandler;\n            if (value) {\n                this.renderer.enableKeyboardAccessibility = true;\n                this.renderer.keyboardFocusClassName = \"ace_keyboard-focus\";\n                this.textInput.getElement().setAttribute(\"tabindex\", -1);\n                this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);\n                this.renderer.scroller.setAttribute(\"tabindex\", 0);\n                this.renderer.scroller.setAttribute(\"role\", \"group\");\n                this.renderer.scroller.setAttribute(\"aria-roledescription\", nls(\"editor.scroller.aria-roledescription\", \"editor\"));\n                this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);\n                this.renderer.scroller.setAttribute(\"aria-label\", nls(\"editor.scroller.aria-label\", \"Editor content, press Enter to start editing, press Escape to exit\"));\n                this.renderer.scroller.addEventListener(\"keyup\", focusOnEnterKeyup.bind(this));\n                this.commands.addCommand(blurCommand);\n                this.renderer.$gutter.setAttribute(\"tabindex\", 0);\n                this.renderer.$gutter.setAttribute(\"aria-hidden\", false);\n                this.renderer.$gutter.setAttribute(\"role\", \"group\");\n                this.renderer.$gutter.setAttribute(\"aria-roledescription\", nls(\"editor.gutter.aria-roledescription\", \"editor\"));\n                this.renderer.$gutter.setAttribute(\"aria-label\", nls(\"editor.gutter.aria-label\", \"Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit\"));\n                this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);\n                this.renderer.content.setAttribute(\"aria-hidden\", true);\n                if (!gutterKeyboardHandler)\n                    gutterKeyboardHandler = new GutterKeyboardHandler(this);\n                gutterKeyboardHandler.addListener();\n                this.textInput.setAriaOptions({\n                    setLabel: true\n                });\n            }\n            else {\n                this.renderer.enableKeyboardAccessibility = false;\n                this.textInput.getElement().setAttribute(\"tabindex\", 0);\n                this.textInput.setNumberOfExtraLines(0);\n                this.renderer.scroller.setAttribute(\"tabindex\", -1);\n                this.renderer.scroller.removeAttribute(\"role\");\n                this.renderer.scroller.removeAttribute(\"aria-roledescription\");\n                this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);\n                this.renderer.scroller.removeAttribute(\"aria-label\");\n                this.renderer.scroller.removeEventListener(\"keyup\", focusOnEnterKeyup.bind(this));\n                this.commands.removeCommand(blurCommand);\n                this.renderer.content.removeAttribute(\"aria-hidden\");\n                this.renderer.$gutter.setAttribute(\"tabindex\", -1);\n                this.renderer.$gutter.setAttribute(\"aria-hidden\", true);\n                this.renderer.$gutter.removeAttribute(\"role\");\n                this.renderer.$gutter.removeAttribute(\"aria-roledescription\");\n                this.renderer.$gutter.removeAttribute(\"aria-label\");\n                this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);\n                if (gutterKeyboardHandler)\n                    gutterKeyboardHandler.removeListener();\n            }\n        },\n        initialValue: false\n    },\n    textInputAriaLabel: {\n        set: function (val) { this.$textInputAriaLabel = val; },\n        initialValue: \"\"\n    },\n    enableMobileMenu: {\n        set: function (val) { this.$enableMobileMenu = val; },\n        initialValue: true\n    },\n    customScrollbar: \"renderer\",\n    hScrollBarAlwaysVisible: \"renderer\",\n    vScrollBarAlwaysVisible: \"renderer\",\n    highlightGutterLine: \"renderer\",\n    animatedScroll: \"renderer\",\n    showInvisibles: \"renderer\",\n    showPrintMargin: \"renderer\",\n    printMarginColumn: \"renderer\",\n    printMargin: \"renderer\",\n    fadeFoldWidgets: \"renderer\",\n    showFoldWidgets: \"renderer\",\n    displayIndentGuides: \"renderer\",\n    highlightIndentGuides: \"renderer\",\n    showGutter: \"renderer\",\n    fontSize: \"renderer\",\n    fontFamily: \"renderer\",\n    maxLines: \"renderer\",\n    minLines: \"renderer\",\n    scrollPastEnd: \"renderer\",\n    fixedWidthGutter: \"renderer\",\n    theme: \"renderer\",\n    hasCssTransforms: \"renderer\",\n    maxPixelHeight: \"renderer\",\n    useTextareaForIME: \"renderer\",\n    useResizeObserver: \"renderer\",\n    useSvgGutterIcons: \"renderer\",\n    showFoldedAnnotations: \"renderer\",\n    scrollSpeed: \"$mouseHandler\",\n    dragDelay: \"$mouseHandler\",\n    dragEnabled: \"$mouseHandler\",\n    focusTimeout: \"$mouseHandler\",\n    tooltipFollowsMouse: \"$mouseHandler\",\n    firstLineNumber: \"session\",\n    overwrite: \"session\",\n    newLineMode: \"session\",\n    useWorker: \"session\",\n    useSoftTabs: \"session\",\n    navigateWithinSoftTabs: \"session\",\n    tabSize: \"session\",\n    wrap: \"session\",\n    indentedSoftWrap: \"session\",\n    foldStyle: \"session\",\n    mode: \"session\"\n});\nvar relativeNumberRenderer = {\n    getText: function (/**@type{EditSession}*/ session, /**@type{number}*/ row) {\n        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? \"\\xb7\" : \"\"))) + \"\";\n    },\n    getWidth: function (session, /**@type{number}*/ lastLineNumber, config) {\n        return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;\n    },\n    update: function (e, /**@type{Editor}*/ editor) {\n        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);\n    },\n    attach: function (/**@type{Editor}*/ editor) {\n        editor.renderer.$gutterLayer.$renderer = this;\n        editor.on(\"changeSelection\", this.update);\n        this.update(null, editor);\n    },\n    detach: function (/**@type{Editor}*/ editor) {\n        if (editor.renderer.$gutterLayer.$renderer == this)\n            editor.renderer.$gutterLayer.$renderer = null;\n        editor.off(\"changeSelection\", this.update);\n        this.update(null, editor);\n    }\n};\nexports.Editor = Editor;\n\n});\n\nace.define(\"ace/layer/lines\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar Lines = /** @class */ (function () {\n    function Lines(element, canvasHeight) {\n        this.element = element;\n        this.canvasHeight = canvasHeight || 500000;\n        this.element.style.height = (this.canvasHeight * 2) + \"px\";\n        this.cells = [];\n        this.cellCache = [];\n        this.$offsetCoefficient = 0;\n    }\n    Lines.prototype.moveContainer = function (config) {\n        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);\n    };\n    Lines.prototype.pageChanged = function (oldConfig, newConfig) {\n        return (Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==\n            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight));\n    };\n    Lines.prototype.computeLineTop = function (row, config, session) {\n        var screenTop = config.firstRowScreen * config.lineHeight;\n        var screenPage = Math.floor(screenTop / this.canvasHeight);\n        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;\n        return lineTop - (screenPage * this.canvasHeight);\n    };\n    Lines.prototype.computeLineHeight = function (row, config, session) {\n        return config.lineHeight * session.getRowLineCount(row);\n    };\n    Lines.prototype.getLength = function () {\n        return this.cells.length;\n    };\n    Lines.prototype.get = function (index) {\n        return this.cells[index];\n    };\n    Lines.prototype.shift = function () {\n        this.$cacheCell(this.cells.shift());\n    };\n    Lines.prototype.pop = function () {\n        this.$cacheCell(this.cells.pop());\n    };\n    Lines.prototype.push = function (cell) {\n        if (Array.isArray(cell)) {\n            this.cells.push.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i = 0; i < cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            this.element.appendChild(fragment);\n        }\n        else {\n            this.cells.push(cell);\n            this.element.appendChild(cell.element);\n        }\n    };\n    Lines.prototype.unshift = function (cell) {\n        if (Array.isArray(cell)) {\n            this.cells.unshift.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i = 0; i < cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            if (this.element.firstChild)\n                this.element.insertBefore(fragment, this.element.firstChild);\n            else\n                this.element.appendChild(fragment);\n        }\n        else {\n            this.cells.unshift(cell);\n            this.element.insertAdjacentElement(\"afterbegin\", cell.element);\n        }\n    };\n    Lines.prototype.last = function () {\n        if (this.cells.length)\n            return this.cells[this.cells.length - 1];\n        else\n            return null;\n    };\n    Lines.prototype.$cacheCell = function (cell) {\n        if (!cell)\n            return;\n        cell.element.remove();\n        this.cellCache.push(cell);\n    };\n    Lines.prototype.createCell = function (row, config, session, initElement) {\n        var cell = this.cellCache.pop();\n        if (!cell) {\n            var element = dom.createElement(\"div\");\n            if (initElement)\n                initElement(element);\n            this.element.appendChild(element);\n            cell = {\n                element: element,\n                text: \"\",\n                row: row\n            };\n        }\n        cell.row = row;\n        return cell;\n    };\n    return Lines;\n}());\nexports.Lines = Lines;\n\n});\n\nace.define(\"ace/layer/gutter\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/layer/lines\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Lines = require(\"./lines\").Lines;\nvar nls = require(\"../config\").nls;\nvar Gutter = /** @class */ (function () {\n    function Gutter(parentEl) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_gutter-layer\";\n        parentEl.appendChild(this.element);\n        this.setShowFoldWidgets(this.$showFoldWidgets);\n        this.gutterWidth = 0;\n        this.$annotations = [];\n        this.$updateAnnotations = this.$updateAnnotations.bind(this);\n        this.$lines = new Lines(this.element);\n        this.$lines.$offsetCoefficient = 1;\n    }\n    Gutter.prototype.setSession = function (session) {\n        if (this.session)\n            this.session.off(\"change\", this.$updateAnnotations);\n        this.session = session;\n        if (session)\n            session.on(\"change\", this.$updateAnnotations);\n    };\n    Gutter.prototype.addGutterDecoration = function (row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.addGutterDecoration\");\n        this.session.addGutterDecoration(row, className);\n    };\n    Gutter.prototype.removeGutterDecoration = function (row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.removeGutterDecoration\");\n        this.session.removeGutterDecoration(row, className);\n    };\n    Gutter.prototype.setAnnotations = function (annotations) {\n        this.$annotations = [];\n        for (var i = 0; i < annotations.length; i++) {\n            var annotation = annotations[i];\n            var row = annotation.row;\n            var rowInfo = this.$annotations[row];\n            if (!rowInfo)\n                rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };\n            var annoText = annotation.text;\n            var displayAnnoText = annotation.text;\n            var annoType = annotation.type;\n            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || \"\";\n            displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || \"\";\n            if (rowInfo.text.indexOf(annoText) === -1) {\n                rowInfo.text.push(annoText);\n                rowInfo.type.push(annoType);\n                rowInfo.displayText.push(displayAnnoText);\n            }\n            var className = annotation.className;\n            if (className)\n                rowInfo.className = className;\n            else if (annoType == \"error\")\n                rowInfo.className = \" ace_error\";\n            else if (annoType == \"warning\" && rowInfo.className != \" ace_error\")\n                rowInfo.className = \" ace_warning\";\n            else if (annoType == \"info\" && (!rowInfo.className))\n                rowInfo.className = \" ace_info\";\n        }\n    };\n    Gutter.prototype.$updateAnnotations = function (delta) {\n        if (!this.$annotations.length)\n            return;\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n        }\n        else if (delta.action == 'remove') {\n            this.$annotations.splice(firstRow, len + 1, null);\n        }\n        else {\n            var args = new Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.$annotations.splice.apply(this.$annotations, args);\n        }\n    };\n    Gutter.prototype.update = function (config) {\n        this.config = config;\n        var session = this.session;\n        var firstRow = config.firstRow;\n        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar\n        session.getLength() - 1);\n        this.oldLastRow = lastRow;\n        this.config = config;\n        this.$lines.moveContainer(config);\n        this.$updateCursorRow();\n        var fold = session.getNextFoldLine(firstRow);\n        var foldStart = fold ? fold.start.row : Infinity;\n        var cell = null;\n        var index = -1;\n        var row = firstRow;\n        while (true) {\n            if (row > foldStart) {\n                row = fold.end.row + 1;\n                fold = session.getNextFoldLine(row, fold);\n                foldStart = fold ? fold.start.row : Infinity;\n            }\n            if (row > lastRow) {\n                while (this.$lines.getLength() > index + 1)\n                    this.$lines.pop();\n                break;\n            }\n            cell = this.$lines.get(++index);\n            if (cell) {\n                cell.row = row;\n            }\n            else {\n                cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n                this.$lines.push(cell);\n            }\n            this.$renderCell(cell, config, fold, row);\n            row++;\n        }\n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n    Gutter.prototype.$updateGutterWidth = function (config) {\n        var session = this.session;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var firstLineNumber = session.$firstLineNumber;\n        var lastLineText = this.$lines.last() ? this.$lines.last().text : \"\";\n        if (this.$fixedWidth || session.$useWrapMode)\n            lastLineText = session.getLength() + firstLineNumber - 1;\n        var gutterWidth = gutterRenderer\n            ? gutterRenderer.getWidth(session, lastLineText, config)\n            : lastLineText.toString().length * config.characterWidth;\n        var padding = this.$padding || this.$computePadding();\n        gutterWidth += padding.left + padding.right;\n        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {\n            this.gutterWidth = gutterWidth; (this.element.parentNode).style.width =\n                this.element.style.width = Math.ceil(this.gutterWidth) + \"px\";\n            this._signal(\"changeGutterWidth\", gutterWidth);\n        }\n    };\n    Gutter.prototype.$updateCursorRow = function () {\n        if (!this.$highlightGutterLine)\n            return;\n        var position = this.session.selection.getCursor();\n        if (this.$cursorRow === position.row)\n            return;\n        this.$cursorRow = position.row;\n    };\n    Gutter.prototype.updateLineHighlight = function () {\n        if (!this.$highlightGutterLine)\n            return;\n        var row = this.session.selection.cursor.row;\n        this.$cursorRow = row;\n        if (this.$cursorCell && this.$cursorCell.row == row)\n            return;\n        if (this.$cursorCell)\n            this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n        var cells = this.$lines.cells;\n        this.$cursorCell = null;\n        for (var i = 0; i < cells.length; i++) {\n            var cell = cells[i];\n            if (cell.row >= this.$cursorRow) {\n                if (cell.row > this.$cursorRow) {\n                    var fold = this.session.getFoldLine(this.$cursorRow);\n                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)\n                        cell = cells[i - 1];\n                    else\n                        break;\n                }\n                cell.element.className = \"ace_gutter-active-line \" + cell.element.className;\n                this.$cursorCell = cell;\n                break;\n            }\n        }\n    };\n    Gutter.prototype.scrollLines = function (config) {\n        var oldConfig = this.config;\n        this.config = config;\n        this.$updateCursorRow();\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        this.$lines.moveContainer(config);\n        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar\n        this.session.getLength() - 1);\n        var oldLastRow = this.oldLastRow;\n        this.oldLastRow = lastRow;\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)\n                this.$lines.shift();\n        if (oldLastRow > lastRow)\n            for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)\n                this.$lines.pop();\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n        if (lastRow > oldLastRow) {\n            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));\n        }\n        this.updateLineHighlight();\n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n    Gutter.prototype.$renderLines = function (config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row + 1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n            this.$renderCell(cell, config, foldLine, row);\n            fragment.push(cell);\n            row++;\n        }\n        return fragment;\n    };\n    Gutter.prototype.$renderCell = function (cell, config, fold, row) {\n        var element = cell.element;\n        var session = this.session;\n        var textNode = element.childNodes[0];\n        var foldWidget = element.childNodes[1];\n        var annotationNode = element.childNodes[2];\n        var annotationIconNode = annotationNode.firstChild;\n        var firstLineNumber = session.$firstLineNumber;\n        var breakpoints = session.$breakpoints;\n        var decorations = session.$decorations;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;\n        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;\n        var lineHeight = config.lineHeight + \"px\";\n        var className = this.$useSvgGutterIcons ? \"ace_gutter-cell_svg-icons \" : \"ace_gutter-cell \";\n        var iconClassName = this.$useSvgGutterIcons ? \"ace_icon_svg\" : \"ace_icon\";\n        var rowText = (gutterRenderer\n            ? gutterRenderer.getText(session, row)\n            : row + firstLineNumber).toString();\n        if (this.$highlightGutterLine) {\n            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row)) {\n                className += \"ace_gutter-active-line \";\n                if (this.$cursorCell != cell) {\n                    if (this.$cursorCell)\n                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n                    this.$cursorCell = cell;\n                }\n            }\n        }\n        if (breakpoints[row])\n            className += breakpoints[row];\n        if (decorations[row])\n            className += decorations[row];\n        if (this.$annotations[row] && row !== foldStart)\n            className += this.$annotations[row].className;\n        if (foldWidgets) {\n            var c = foldWidgets[row];\n            if (c == null)\n                c = foldWidgets[row] = session.getFoldWidget(row);\n        }\n        if (c) {\n            var foldClass = \"ace_fold-widget ace_\" + c;\n            var isClosedFold = c == \"start\" && row == foldStart && row < fold.end.row;\n            if (isClosedFold) {\n                foldClass += \" ace_closed\";\n                var foldAnnotationClass = '';\n                var annotationInFold = false;\n                for (var i = row + 1; i <= fold.end.row; i++) {\n                    if (!this.$annotations[i])\n                        continue;\n                    if (this.$annotations[i].className === \" ace_error\") {\n                        annotationInFold = true;\n                        foldAnnotationClass = \" ace_error_fold\";\n                        break;\n                    }\n                    if (this.$annotations[i].className === \" ace_warning\") {\n                        annotationInFold = true;\n                        foldAnnotationClass = \" ace_warning_fold\";\n                        continue;\n                    }\n                }\n                className += foldAnnotationClass;\n            }\n            else\n                foldClass += \" ace_open\";\n            if (foldWidget.className != foldClass)\n                foldWidget.className = foldClass;\n            dom.setStyle(foldWidget.style, \"height\", lineHeight);\n            dom.setStyle(foldWidget.style, \"display\", \"inline-block\");\n            foldWidget.setAttribute(\"role\", \"button\");\n            foldWidget.setAttribute(\"tabindex\", \"-1\");\n            var foldRange = session.getFoldWidgetRange(row);\n            if (foldRange)\n                foldWidget.setAttribute(\"aria-label\", nls(\"gutter.code-folding.range.aria-label\", \"Toggle code folding, rows $0 through $1\", [foldRange.start.row + 1, foldRange.end.row + 1]));\n            else {\n                if (fold)\n                    foldWidget.setAttribute(\"aria-label\", nls(\"gutter.code-folding.closed.aria-label\", \"Toggle code folding, rows $0 through $1\", [fold.start.row + 1, fold.end.row + 1]));\n                else\n                    foldWidget.setAttribute(\"aria-label\", nls(\"gutter.code-folding.open.aria-label\", \"Toggle code folding, row $0\", [row + 1]));\n            }\n            if (isClosedFold) {\n                foldWidget.setAttribute(\"aria-expanded\", \"false\");\n                foldWidget.setAttribute(\"title\", nls(\"gutter.code-folding.closed.title\", \"Unfold code\"));\n            }\n            else {\n                foldWidget.setAttribute(\"aria-expanded\", \"true\");\n                foldWidget.setAttribute(\"title\", nls(\"gutter.code-folding.open.title\", \"Fold code\"));\n            }\n        }\n        else {\n            if (foldWidget) {\n                dom.setStyle(foldWidget.style, \"display\", \"none\");\n                foldWidget.setAttribute(\"tabindex\", \"0\");\n                foldWidget.removeAttribute(\"role\");\n                foldWidget.removeAttribute(\"aria-label\");\n            }\n        }\n        if (annotationInFold && this.$showFoldedAnnotations) {\n            annotationNode.className = \"ace_gutter_annotation\";\n            annotationIconNode.className = iconClassName;\n            annotationIconNode.className += foldAnnotationClass;\n            dom.setStyle(annotationIconNode.style, \"height\", lineHeight);\n            dom.setStyle(annotationNode.style, \"display\", \"block\");\n            dom.setStyle(annotationNode.style, \"height\", lineHeight);\n            var ariaLabel;\n            switch (foldAnnotationClass) {\n                case \" ace_error_fold\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.error\", \"Read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_warning_fold\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.warning\", \"Read annotations row $0\", [rowText]);\n                    break;\n            }\n            annotationNode.setAttribute(\"aria-label\", ariaLabel);\n            annotationNode.setAttribute(\"tabindex\", \"-1\");\n            annotationNode.setAttribute(\"role\", \"button\");\n        }\n        else if (this.$annotations[row]) {\n            annotationNode.className = \"ace_gutter_annotation\";\n            annotationIconNode.className = iconClassName;\n            if (this.$useSvgGutterIcons)\n                annotationIconNode.className += this.$annotations[row].className;\n            else\n                element.classList.add(this.$annotations[row].className.replace(\" \", \"\"));\n            dom.setStyle(annotationIconNode.style, \"height\", lineHeight);\n            dom.setStyle(annotationNode.style, \"display\", \"block\");\n            dom.setStyle(annotationNode.style, \"height\", lineHeight);\n            var ariaLabel;\n            switch (this.$annotations[row].className) {\n                case \" ace_error\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.error\", \"Read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_warning\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.warning\", \"Read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_info\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.info\", \"Read annotations row $0\", [rowText]);\n                    break;\n            }\n            annotationNode.setAttribute(\"aria-label\", ariaLabel);\n            annotationNode.setAttribute(\"tabindex\", \"-1\");\n            annotationNode.setAttribute(\"role\", \"button\");\n        }\n        else {\n            dom.setStyle(annotationNode.style, \"display\", \"none\");\n            annotationNode.removeAttribute(\"aria-label\");\n            annotationNode.removeAttribute(\"role\");\n            annotationNode.setAttribute(\"tabindex\", \"0\");\n        }\n        if (rowText !== textNode.data) {\n            textNode.data = rowText;\n        }\n        if (element.className != className)\n            element.className = className;\n        dom.setStyle(cell.element.style, \"height\", this.$lines.computeLineHeight(row, config, session) + \"px\");\n        dom.setStyle(cell.element.style, \"top\", this.$lines.computeLineTop(row, config, session) + \"px\");\n        cell.text = rowText;\n        if (annotationNode.style.display === \"none\" && foldWidget.style.display === \"none\")\n            cell.element.setAttribute(\"aria-hidden\", true);\n        else\n            cell.element.setAttribute(\"aria-hidden\", false);\n        return cell;\n    };\n    Gutter.prototype.setHighlightGutterLine = function (highlightGutterLine) {\n        this.$highlightGutterLine = highlightGutterLine;\n    };\n    Gutter.prototype.setShowLineNumbers = function (show) {\n        this.$renderer = !show && {\n            getWidth: function () { return 0; },\n            getText: function () { return \"\"; }\n        };\n    };\n    Gutter.prototype.getShowLineNumbers = function () {\n        return this.$showLineNumbers;\n    };\n    Gutter.prototype.setShowFoldWidgets = function (show) {\n        if (show)\n            dom.addCssClass(this.element, \"ace_folding-enabled\");\n        else\n            dom.removeCssClass(this.element, \"ace_folding-enabled\");\n        this.$showFoldWidgets = show;\n        this.$padding = null;\n    };\n    Gutter.prototype.getShowFoldWidgets = function () {\n        return this.$showFoldWidgets;\n    };\n    Gutter.prototype.$computePadding = function () {\n        if (!this.element.firstChild)\n            return { left: 0, right: 0 };\n        var style = dom.computedStyle(/**@type{Element}*/ (this.element.firstChild));\n        this.$padding = {};\n        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)\n            + (parseInt(style.paddingLeft) || 0) + 1;\n        this.$padding.right = (parseInt(style.borderRightWidth) || 0)\n            + (parseInt(style.paddingRight) || 0);\n        return this.$padding;\n    };\n    Gutter.prototype.getRegion = function (point) {\n        var padding = this.$padding || this.$computePadding();\n        var rect = this.element.getBoundingClientRect();\n        if (point.x < padding.left + rect.left)\n            return \"markers\";\n        if (this.$showFoldWidgets && point.x > rect.right - padding.right)\n            return \"foldWidgets\";\n    };\n    return Gutter;\n}());\nGutter.prototype.$fixedWidth = false;\nGutter.prototype.$highlightGutterLine = true;\nGutter.prototype.$renderer = \"\";\nGutter.prototype.$showLineNumbers = true;\nGutter.prototype.$showFoldWidgets = true;\noop.implement(Gutter.prototype, EventEmitter);\nfunction onCreateCell(element) {\n    var textNode = document.createTextNode('');\n    element.appendChild(textNode);\n    var foldWidget = dom.createElement(\"span\");\n    element.appendChild(foldWidget);\n    var annotationNode = dom.createElement(\"span\");\n    element.appendChild(annotationNode);\n    var annotationIconNode = dom.createElement(\"span\");\n    annotationNode.appendChild(annotationIconNode);\n    return element;\n}\nexports.Gutter = Gutter;\n\n});\n\nace.define(\"ace/layer/marker\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar dom = require(\"../lib/dom\");\nvar Marker = /** @class */ (function () {\n    function Marker(parentEl) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_marker-layer\";\n        parentEl.appendChild(this.element);\n    }\n    Marker.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n    };\n    Marker.prototype.setSession = function (session) {\n        this.session = session;\n    };\n    Marker.prototype.setMarkers = function (markers) {\n        this.markers = markers;\n    };\n    Marker.prototype.elt = function (className, css) {\n        var x = this.i != -1 && this.element.childNodes[this.i];\n        if (!x) {\n            x = document.createElement(\"div\");\n            this.element.appendChild(x);\n            this.i = -1;\n        }\n        else {\n            this.i++;\n        }\n        x.style.cssText = css;\n        x.className = className;\n    };\n    Marker.prototype.update = function (config) {\n        if (!config)\n            return;\n        this.config = config;\n        this.i = 0;\n        var html;\n        for (var key in this.markers) {\n            var marker = this.markers[key];\n            if (!marker.range) {\n                marker.update(html, this, this.session, config);\n                continue;\n            }\n            var range = marker.range.clipRows(config.firstRow, config.lastRow);\n            if (range.isEmpty())\n                continue;\n            range = range.toScreenRange(this.session);\n            if (marker.renderer) {\n                var top = this.$getTop(range.start.row, config);\n                var left = this.$padding + range.start.column * config.characterWidth;\n                marker.renderer(html, range, left, top, config);\n            }\n            else if (marker.type == \"fullLine\") {\n                this.drawFullLineMarker(html, range, marker.clazz, config);\n            }\n            else if (marker.type == \"screenLine\") {\n                this.drawScreenLineMarker(html, range, marker.clazz, config);\n            }\n            else if (range.isMultiLine()) {\n                if (marker.type == \"text\")\n                    this.drawTextMarker(html, range, marker.clazz, config);\n                else\n                    this.drawMultiLineMarker(html, range, marker.clazz, config);\n            }\n            else {\n                this.drawSingleLineMarker(html, range, marker.clazz + \" ace_start\" + \" ace_br15\", config);\n            }\n        }\n        if (this.i != -1) {\n            while (this.i < this.element.childElementCount)\n                this.element.removeChild(this.element.lastChild);\n        }\n    };\n    Marker.prototype.$getTop = function (row, layerConfig) {\n        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;\n    };\n    Marker.prototype.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {\n        var session = this.session;\n        var start = range.start.row;\n        var end = range.end.row;\n        var row = start;\n        var prev = 0;\n        var curr = 0;\n        var next = session.getScreenLastRowColumn(row);\n        var lineRange = new Range(row, range.start.column, row, curr);\n        for (; row <= end; row++) {\n            lineRange.start.row = lineRange.end.row = row;\n            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);\n            lineRange.end.column = next;\n            prev = curr;\n            curr = next;\n            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;\n            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? \" ace_start\" : \"\") + \" ace_br\"\n                + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);\n        }\n    };\n    Marker.prototype.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {\n        var padding = this.$padding;\n        var height = config.lineHeight;\n        var top = this.$getTop(range.start.row, config);\n        var left = padding + range.start.column * config.characterWidth;\n        extraStyle = extraStyle || \"\";\n        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {\n            var range1 = range.clone();\n            range1.end.row = range1.start.row;\n            range1.end.column = this.session.getLine(range1.start.row).length;\n            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br1 ace_start\", config, null, extraStyle);\n        }\n        else {\n            this.elt(clazz + \" ace_br1 ace_start\", \"height:\" + height + \"px;\" + \"right:0;\" + \"top:\" + top + \"px;left:\" + left + \"px;\" + (extraStyle || \"\"));\n        }\n        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {\n            var range1 = range.clone();\n            range1.start.row = range1.end.row;\n            range1.start.column = 0;\n            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br12\", config, null, extraStyle);\n        }\n        else {\n            top = this.$getTop(range.end.row, config);\n            var width = range.end.column * config.characterWidth;\n            this.elt(clazz + \" ace_br12\", \"height:\" + height + \"px;\" +\n                \"width:\" + width + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + padding + \"px;\" + (extraStyle || \"\"));\n        }\n        height = (range.end.row - range.start.row - 1) * config.lineHeight;\n        if (height <= 0)\n            return;\n        top = this.$getTop(range.start.row + 1, config);\n        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);\n        this.elt(clazz + (radiusClass ? \" ace_br\" + radiusClass : \"\"), \"height:\" + height + \"px;\" +\n            \"right:0;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:\" + padding + \"px;\" + (extraStyle || \"\"));\n    };\n    Marker.prototype.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        if (this.session.$bidiHandler.isBidiRow(range.start.row))\n            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);\n        var height = config.lineHeight;\n        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;\n        var top = this.$getTop(range.start.row, config);\n        var left = this.$padding + range.start.column * config.characterWidth;\n        this.elt(clazz, \"height:\" + height + \"px;\" +\n            \"width:\" + width + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:\" + left + \"px;\" + (extraStyle || \"\"));\n    };\n    Marker.prototype.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;\n        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);\n        selections.forEach(function (selection) {\n            this.elt(clazz, \"height:\" + height + \"px;\" +\n                \"width:\" + (selection.width + (extraLength || 0)) + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + (padding + selection.left) + \"px;\" + (extraStyle || \"\"));\n        }, this);\n    };\n    Marker.prototype.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        if (range.start.row != range.end.row)\n            height += this.$getTop(range.end.row, config) - top;\n        this.elt(clazz, \"height:\" + height + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:0;right:0;\" + (extraStyle || \"\"));\n    };\n    Marker.prototype.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        this.elt(clazz, \"height:\" + height + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:0;right:0;\" + (extraStyle || \"\"));\n    };\n    return Marker;\n}());\nMarker.prototype.$padding = 0;\nfunction getBorderClass(tl, tr, br, bl) {\n    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);\n}\nexports.Marker = Marker;\n\n});\n\nace.define(\"ace/layer/text_util\",[\"require\",\"exports\",\"module\"], function(require, exports, module){// Tokens for which Ace just uses a simple TextNode and does not add any special className.\nvar textTokens = new Set([\"text\", \"rparen\", \"lparen\"]);\nexports.isTextToken = function (tokenType) {\n    return textTokens.has(tokenType);\n};\n\n});\n\nace.define(\"ace/layer/text\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/layer/lines\",\"ace/lib/event_emitter\",\"ace/config\",\"ace/layer/text_util\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar Lines = require(\"./lines\").Lines;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar nls = require(\"../config\").nls;\nvar isTextToken = require(\"./text_util\").isTextToken;\nvar Text = /** @class */ (function () {\n    function Text(parentEl) {\n        this.dom = dom;\n        this.element = this.dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_text-layer\";\n        parentEl.appendChild(this.element);\n        this.$updateEolChar = this.$updateEolChar.bind(this);\n        this.$lines = new Lines(this.element);\n    }\n    Text.prototype.$updateEolChar = function () {\n        var doc = this.session.doc;\n        var unixMode = doc.getNewLineCharacter() == \"\\n\" && doc.getNewLineMode() != \"windows\";\n        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;\n        if (this.EOL_CHAR != EOL_CHAR) {\n            this.EOL_CHAR = EOL_CHAR;\n            return true;\n        }\n    };\n    Text.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n        this.element.style.margin = \"0 \" + padding + \"px\";\n    };\n    Text.prototype.getLineHeight = function () {\n        return this.$fontMetrics.$characterSize.height || 0;\n    };\n    Text.prototype.getCharacterWidth = function () {\n        return this.$fontMetrics.$characterSize.width || 0;\n    };\n    Text.prototype.$setFontMetrics = function (measure) {\n        this.$fontMetrics = measure;\n        this.$fontMetrics.on(\"changeCharacterSize\", \n        function (e) {\n            this._signal(\"changeCharacterSize\", e);\n        }.bind(this));\n        this.$pollSizeChanges();\n    };\n    Text.prototype.checkForSizeChanges = function () {\n        this.$fontMetrics.checkForSizeChanges();\n    };\n    Text.prototype.$pollSizeChanges = function () {\n        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();\n    };\n    Text.prototype.setSession = function (session) {\n        this.session = session;\n        if (session)\n            this.$computeTabString();\n    };\n    Text.prototype.setShowInvisibles = function (showInvisibles) {\n        if (this.showInvisibles == showInvisibles)\n            return false;\n        this.showInvisibles = showInvisibles;\n        if (typeof showInvisibles == \"string\") {\n            this.showSpaces = /tab/i.test(showInvisibles);\n            this.showTabs = /space/i.test(showInvisibles);\n            this.showEOL = /eol/i.test(showInvisibles);\n        }\n        else {\n            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;\n        }\n        this.$computeTabString();\n        return true;\n    };\n    Text.prototype.setDisplayIndentGuides = function (display) {\n        if (this.displayIndentGuides == display)\n            return false;\n        this.displayIndentGuides = display;\n        this.$computeTabString();\n        return true;\n    };\n    Text.prototype.setHighlightIndentGuides = function (highlight) {\n        if (this.$highlightIndentGuides === highlight)\n            return false;\n        this.$highlightIndentGuides = highlight;\n        return highlight;\n    };\n    Text.prototype.$computeTabString = function () {\n        var tabSize = this.session.getTabSize();\n        this.tabSize = tabSize; var tabStr = this.$tabStrings = [0];\n        for (var i = 1; i < tabSize + 1; i++) {\n            if (this.showTabs) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_tab\";\n                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);\n                tabStr.push(span);\n            }\n            else {\n                tabStr.push(this.dom.createTextNode(lang.stringRepeat(\" \", i), this.element));\n            }\n        }\n        if (this.displayIndentGuides) {\n            this.$indentGuideRe = /\\s\\S| \\t|\\t |\\s$/;\n            var className = \"ace_indent-guide\";\n            var spaceClass = this.showSpaces ? \" ace_invisible ace_invisible_space\" : \"\";\n            var spaceContent = this.showSpaces\n                ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)\n                : lang.stringRepeat(\" \", this.tabSize);\n            var tabClass = this.showTabs ? \" ace_invisible ace_invisible_tab\" : \"\";\n            var tabContent = this.showTabs\n                ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)\n                : spaceContent;\n            var span = this.dom.createElement(\"span\");\n            span.className = className + spaceClass;\n            span.textContent = spaceContent;\n            this.$tabStrings[\" \"] = span;\n            var span = this.dom.createElement(\"span\");\n            span.className = className + tabClass;\n            span.textContent = tabContent;\n            this.$tabStrings[\"\\t\"] = span;\n        }\n    };\n    Text.prototype.updateLines = function (config, firstRow, lastRow) {\n        if (this.config.lastRow != config.lastRow ||\n            this.config.firstRow != config.firstRow) {\n            return this.update(config);\n        }\n        this.config = config;\n        var first = Math.max(firstRow, config.firstRow);\n        var last = Math.min(lastRow, config.lastRow);\n        var lineElements = this.element.childNodes;\n        var lineElementsIdx = 0;\n        for (var row = config.firstRow; row < first; row++) {\n            var foldLine = this.session.getFoldLine(row);\n            if (foldLine) {\n                if (foldLine.containsRow(first)) {\n                    first = foldLine.start.row;\n                    break;\n                }\n                else {\n                    row = foldLine.end.row;\n                }\n            }\n            lineElementsIdx++;\n        }\n        var heightChanged = false;\n        var row = first;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row + 1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > last)\n                break; var lineElement = lineElements[lineElementsIdx++];\n            if (lineElement) {\n                this.dom.removeChildren(lineElement);\n                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);\n                if (heightChanged)\n                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + \"px\";\n                var height = (config.lineHeight * this.session.getRowLength(row)) + \"px\";\n                if (lineElement.style.height != height) {\n                    heightChanged = true;\n                    lineElement.style.height = height;\n                }\n            }\n            row++;\n        }\n        if (heightChanged) {\n            while (lineElementsIdx < this.$lines.cells.length) {\n                var cell = this.$lines.cells[lineElementsIdx++];\n                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + \"px\";\n            }\n        }\n    };\n    Text.prototype.scrollLines = function (config) {\n        var oldConfig = this.config;\n        this.config = config;\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        this.$lines.moveContainer(config);\n        var lastRow = config.lastRow;\n        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n        if (!oldConfig || oldConfig.lastRow < config.firstRow)\n            return this.update(config);\n        if (config.lastRow < oldConfig.firstRow)\n            return this.update(config);\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)\n                this.$lines.shift();\n        if (oldConfig.lastRow > config.lastRow)\n            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)\n                this.$lines.pop();\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n        if (config.lastRow > oldConfig.lastRow) {\n            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));\n        }\n        this.$highlightIndentGuide();\n    };\n    Text.prototype.$renderLinesFragment = function (config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row + 1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n            var line = this.$lines.createCell(row, config, this.session);\n            var lineEl = line.element;\n            this.dom.removeChildren(lineEl);\n            dom.setStyle(lineEl.style, \"height\", this.$lines.computeLineHeight(row, config, this.session) + \"px\");\n            dom.setStyle(lineEl.style, \"top\", this.$lines.computeLineTop(row, config, this.session) + \"px\");\n            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);\n            if (this.$useLineGroups()) {\n                lineEl.className = \"ace_line_group\";\n            }\n            else {\n                lineEl.className = \"ace_line\";\n            }\n            fragment.push(line);\n            row++;\n        }\n        return fragment;\n    };\n    Text.prototype.update = function (config) {\n        this.$lines.moveContainer(config);\n        this.config = config;\n        var firstRow = config.firstRow;\n        var lastRow = config.lastRow;\n        var lines = this.$lines;\n        while (lines.getLength())\n            lines.pop();\n        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));\n    };\n    Text.prototype.$renderToken = function (parent, screenColumn, token, value) {\n        var self = this;\n        var re = /(\\t)|( +)|([\\x00-\\x1f\\x80-\\xa0\\xad\\u1680\\u180E\\u2000-\\u200f\\u2028\\u2029\\u202F\\u205F\\uFEFF\\uFFF9-\\uFFFC\\u2066\\u2067\\u2068\\u202A\\u202B\\u202D\\u202E\\u202C\\u2069]+)|(\\u3000)|([\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3001-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u4DBF\\u4E00-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFAFF\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n        var valueFragment = this.dom.createFragment(this.element);\n        var m;\n        var i = 0;\n        while (m = re.exec(value)) {\n            var tab = m[1];\n            var simpleSpace = m[2];\n            var controlCharacter = m[3];\n            var cjkSpace = m[4];\n            var cjk = m[5];\n            if (!self.showSpaces && simpleSpace)\n                continue;\n            var before = i != m.index ? value.slice(i, m.index) : \"\";\n            i = m.index + m[0].length;\n            if (before) {\n                valueFragment.appendChild(this.dom.createTextNode(before, this.element));\n            }\n            if (tab) {\n                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);\n                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));\n                screenColumn += tabSize - 1;\n            }\n            else if (simpleSpace) {\n                if (self.showSpaces) {\n                    var span = this.dom.createElement(\"span\");\n                    span.className = \"ace_invisible ace_invisible_space\";\n                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);\n                    valueFragment.appendChild(span);\n                }\n                else {\n                    valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));\n                }\n            }\n            else if (controlCharacter) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_space ace_invalid\";\n                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);\n                valueFragment.appendChild(span);\n            }\n            else if (cjkSpace) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = self.showSpaces ? \"ace_cjk ace_invisible ace_invisible_space\" : \"ace_cjk\";\n                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;\n                valueFragment.appendChild(span);\n            }\n            else if (cjk) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = \"ace_cjk\";\n                span.textContent = cjk;\n                valueFragment.appendChild(span);\n            }\n        }\n        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));\n        if (!isTextToken(token.type)) {\n            var classes = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n            var span = this.dom.createElement(\"span\");\n            if (token.type == \"fold\") {\n                span.style.width = (token.value.length * this.config.characterWidth) + \"px\";\n                span.setAttribute(\"title\", nls(\"inline-fold.closed.title\", \"Unfold code\"));\n            }\n            span.className = classes;\n            span.appendChild(valueFragment);\n            parent.appendChild(span);\n        }\n        else {\n            parent.appendChild(valueFragment);\n        }\n        return screenColumn + value.length;\n    };\n    Text.prototype.renderIndentGuide = function (parent, value, max) {\n        var cols = value.search(this.$indentGuideRe);\n        if (cols <= 0 || cols >= max)\n            return value;\n        if (value[0] == \" \") {\n            cols -= cols % this.tabSize;\n            var count = cols / this.tabSize;\n            for (var i = 0; i < count; i++) {\n                parent.appendChild(this.$tabStrings[\" \"].cloneNode(true));\n            }\n            this.$highlightIndentGuide();\n            return value.substr(cols);\n        }\n        else if (value[0] == \"\\t\") {\n            for (var i = 0; i < cols; i++) {\n                parent.appendChild(this.$tabStrings[\"\\t\"].cloneNode(true));\n            }\n            this.$highlightIndentGuide();\n            return value.substr(cols);\n        }\n        this.$highlightIndentGuide();\n        return value;\n    };\n    Text.prototype.$highlightIndentGuide = function () {\n        if (!this.$highlightIndentGuides || !this.displayIndentGuides)\n            return;\n        this.$highlightIndentGuideMarker = {\n            indentLevel: undefined,\n            start: undefined,\n            end: undefined,\n            dir: undefined\n        };\n        var lines = this.session.doc.$lines;\n        if (!lines)\n            return;\n        var cursor = this.session.selection.getCursor();\n        var initialIndent = /^\\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;\n        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);\n        this.$highlightIndentGuideMarker = {\n            indentLevel: elementIndentLevel,\n            start: cursor.row\n        };\n        var bracketHighlight = this.session.$bracketHighlight;\n        if (bracketHighlight) {\n            var ranges = this.session.$bracketHighlight.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                if (cursor.row !== ranges[i].start.row) {\n                    this.$highlightIndentGuideMarker.end = ranges[i].start.row;\n                    if (cursor.row > ranges[i].start.row) {\n                        this.$highlightIndentGuideMarker.dir = -1;\n                    }\n                    else {\n                        this.$highlightIndentGuideMarker.dir = 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if (!this.$highlightIndentGuideMarker.end) {\n            if (lines[cursor.row] !== '' && cursor.column === lines[cursor.row].length) {\n                this.$highlightIndentGuideMarker.dir = 1;\n                for (var i = cursor.row + 1; i < lines.length; i++) {\n                    var line = lines[i];\n                    var currentIndent = /^\\s*/.exec(line)[0].length;\n                    if (line !== '') {\n                        this.$highlightIndentGuideMarker.end = i;\n                        if (currentIndent <= initialIndent)\n                            break;\n                    }\n                }\n            }\n        }\n        this.$renderHighlightIndentGuide();\n    };\n    Text.prototype.$clearActiveIndentGuide = function () {\n        var cells = this.$lines.cells;\n        for (var i = 0; i < cells.length; i++) {\n            var cell = cells[i];\n            var childNodes = cell.element.childNodes;\n            if (childNodes.length > 0) {\n                for (var j = 0; j < childNodes.length; j++) {\n                    if (childNodes[j].classList && childNodes[j].classList.contains(\"ace_indent-guide-active\")) {\n                        childNodes[j].classList.remove(\"ace_indent-guide-active\");\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    Text.prototype.$setIndentGuideActive = function (cell, indentLevel) {\n        var line = this.session.doc.getLine(cell.row);\n        if (line !== \"\") {\n            var childNodes = cell.element.childNodes;\n            if (childNodes) {\n                var node = childNodes[indentLevel - 1];\n                if (node && node.classList && node.classList.contains(\"ace_indent-guide\"))\n                    node.classList.add(\"ace_indent-guide-active\");\n            }\n        }\n    };\n    Text.prototype.$renderHighlightIndentGuide = function () {\n        if (!this.$lines)\n            return;\n        var cells = this.$lines.cells;\n        this.$clearActiveIndentGuide();\n        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;\n        if (indentLevel !== 0) {\n            if (this.$highlightIndentGuideMarker.dir === 1) {\n                for (var i = 0; i < cells.length; i++) {\n                    var cell = cells[i];\n                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start\n                        + 1) {\n                        if (cell.row >= this.$highlightIndentGuideMarker.end)\n                            break;\n                        this.$setIndentGuideActive(cell, indentLevel);\n                    }\n                }\n            }\n            else {\n                for (var i = cells.length - 1; i >= 0; i--) {\n                    var cell = cells[i];\n                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {\n                        if (cell.row <= this.$highlightIndentGuideMarker.end)\n                            break;\n                        this.$setIndentGuideActive(cell, indentLevel);\n                    }\n                }\n            }\n        }\n    };\n    Text.prototype.$createLineElement = function (parent) {\n        var lineEl = this.dom.createElement(\"div\");\n        lineEl.className = \"ace_line\";\n        lineEl.style.height = this.config.lineHeight + \"px\";\n        return lineEl;\n    };\n    Text.prototype.$renderWrappedLine = function (parent, tokens, splits) {\n        var chars = 0;\n        var split = 0;\n        var splitChars = splits[0];\n        var screenColumn = 0;\n        var lineEl = this.$createLineElement();\n        parent.appendChild(lineEl);\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                chars = value.length;\n                value = this.renderIndentGuide(lineEl, value, splitChars);\n                if (!value)\n                    continue;\n                chars -= value.length;\n            }\n            if (chars + value.length < splitChars) {\n                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                chars += value.length;\n            }\n            else {\n                while (chars + value.length >= splitChars) {\n                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));\n                    value = value.substring(splitChars - chars);\n                    chars = splitChars;\n                    lineEl = this.$createLineElement();\n                    parent.appendChild(lineEl);\n                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(\"\\xa0\", splits.indent), this.element));\n                    split++;\n                    screenColumn = 0;\n                    splitChars = splits[split] || Number.MAX_VALUE;\n                }\n                if (value.length != 0) {\n                    chars += value.length;\n                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                }\n            }\n        }\n        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)\n            this.$renderOverflowMessage(lineEl, screenColumn, null, \"\", true);\n    };\n    Text.prototype.$renderSimpleLine = function (parent, tokens) {\n        var screenColumn = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                value = this.renderIndentGuide(parent, value);\n                if (!value)\n                    continue;\n            }\n            if (screenColumn + value.length > this.MAX_LINE_LENGTH)\n                return this.$renderOverflowMessage(parent, screenColumn, token, value);\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        }\n    };\n    Text.prototype.$renderOverflowMessage = function (parent, screenColumn, token, value, hide) {\n        token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));\n        var overflowEl = this.dom.createElement(\"span\");\n        overflowEl.className = \"ace_inline_button ace_keyword ace_toggle_wrap\";\n        overflowEl.textContent = hide ? \"<hide>\" : \"<click to see more...>\";\n        parent.appendChild(overflowEl);\n    };\n    Text.prototype.$renderLine = function (parent, row, foldLine) {\n        if (!foldLine && foldLine != false)\n            foldLine = this.session.getFoldLine(row);\n        if (foldLine)\n            var tokens = this.$getFoldLineTokens(row, foldLine);\n        else\n            var tokens = this.session.getTokens(row);\n        var lastLineEl = parent;\n        if (tokens.length) {\n            var splits = this.session.getRowSplitData(row);\n            if (splits && splits.length) {\n                this.$renderWrappedLine(parent, tokens, splits);\n                var lastLineEl = parent.lastChild;\n            }\n            else {\n                var lastLineEl = parent;\n                if (this.$useLineGroups()) {\n                    lastLineEl = this.$createLineElement();\n                    parent.appendChild(lastLineEl);\n                }\n                this.$renderSimpleLine(lastLineEl, tokens);\n            }\n        }\n        else if (this.$useLineGroups()) {\n            lastLineEl = this.$createLineElement();\n            parent.appendChild(lastLineEl);\n        }\n        if (this.showEOL && lastLineEl) {\n            if (foldLine)\n                row = foldLine.end.row;\n            var invisibleEl = this.dom.createElement(\"span\");\n            invisibleEl.className = \"ace_invisible ace_invisible_eol\";\n            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;\n            lastLineEl.appendChild(invisibleEl);\n        }\n    };\n    Text.prototype.$getFoldLineTokens = function (row, foldLine) {\n        var session = this.session;\n        var renderTokens = [];\n        function addTokens(tokens, from, to) {\n            var idx = 0, col = 0;\n            while ((col + tokens[idx].value.length) < from) {\n                col += tokens[idx].value.length;\n                idx++;\n                if (idx == tokens.length)\n                    return;\n            }\n            if (col != from) {\n                var value = tokens[idx].value.substring(from - col);\n                if (value.length > (to - from))\n                    value = value.substring(0, to - from);\n                renderTokens.push({\n                    type: tokens[idx].type,\n                    value: value\n                });\n                col = from + value.length;\n                idx += 1;\n            }\n            while (col < to && idx < tokens.length) {\n                var value = tokens[idx].value;\n                if (value.length + col > to) {\n                    renderTokens.push({\n                        type: tokens[idx].type,\n                        value: value.substring(0, to - col)\n                    });\n                }\n                else\n                    renderTokens.push(tokens[idx]);\n                col += value.length;\n                idx += 1;\n            }\n        }\n        var tokens = session.getTokens(row);\n        foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {\n            if (placeholder != null) {\n                renderTokens.push({\n                    type: \"fold\",\n                    value: placeholder\n                });\n            }\n            else {\n                if (isNewRow)\n                    tokens = session.getTokens(row);\n                if (tokens.length)\n                    addTokens(tokens, lastColumn, column);\n            }\n        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);\n        return renderTokens;\n    };\n    Text.prototype.$useLineGroups = function () {\n        return this.session.getUseWrapMode();\n    };\n    return Text;\n}());\nText.prototype.EOF_CHAR = \"\\xB6\";\nText.prototype.EOL_CHAR_LF = \"\\xAC\";\nText.prototype.EOL_CHAR_CRLF = \"\\xa4\";\nText.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;\nText.prototype.TAB_CHAR = \"\\u2014\"; //\"\\u21E5\";\nText.prototype.SPACE_CHAR = \"\\xB7\";\nText.prototype.$padding = 0;\nText.prototype.MAX_LINE_LENGTH = 10000;\nText.prototype.showInvisibles = false;\nText.prototype.showSpaces = false;\nText.prototype.showTabs = false;\nText.prototype.showEOL = false;\nText.prototype.displayIndentGuides = true;\nText.prototype.$highlightIndentGuides = true;\nText.prototype.$tabStrings = [];\nText.prototype.destroy = {};\nText.prototype.onChangeTabSize = Text.prototype.$computeTabString;\noop.implement(Text.prototype, EventEmitter);\nexports.Text = Text;\n\n});\n\nace.define(\"ace/layer/cursor\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar Cursor = /** @class */ (function () {\n    function Cursor(parentEl) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_cursor-layer\";\n        parentEl.appendChild(this.element);\n        this.isVisible = false;\n        this.isBlinking = true;\n        this.blinkInterval = 1000;\n        this.smoothBlinking = false;\n        this.cursors = [];\n        this.cursor = this.addCursor();\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.$updateCursors = this.$updateOpacity.bind(this);\n    }\n    Cursor.prototype.$updateOpacity = function (val) {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--;)\n            dom.setStyle(cursors[i].style, \"opacity\", val ? \"\" : \"0\");\n    };\n    Cursor.prototype.$startCssAnimation = function () {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--;)\n            cursors[i].style.animationDuration = this.blinkInterval + \"ms\";\n        this.$isAnimating = true;\n        setTimeout(function () {\n            if (this.$isAnimating) {\n                dom.addCssClass(this.element, \"ace_animate-blinking\");\n            }\n        }.bind(this));\n    };\n    Cursor.prototype.$stopCssAnimation = function () {\n        this.$isAnimating = false;\n        dom.removeCssClass(this.element, \"ace_animate-blinking\");\n    };\n    Cursor.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n    };\n    Cursor.prototype.setSession = function (session) {\n        this.session = session;\n    };\n    Cursor.prototype.setBlinking = function (blinking) {\n        if (blinking != this.isBlinking) {\n            this.isBlinking = blinking;\n            this.restartTimer();\n        }\n    };\n    Cursor.prototype.setBlinkInterval = function (blinkInterval) {\n        if (blinkInterval != this.blinkInterval) {\n            this.blinkInterval = blinkInterval;\n            this.restartTimer();\n        }\n    };\n    Cursor.prototype.setSmoothBlinking = function (smoothBlinking) {\n        if (smoothBlinking != this.smoothBlinking) {\n            this.smoothBlinking = smoothBlinking;\n            dom.setCssClass(this.element, \"ace_smooth-blinking\", smoothBlinking);\n            this.$updateCursors(true);\n            this.restartTimer();\n        }\n    };\n    Cursor.prototype.addCursor = function () {\n        var el = dom.createElement(\"div\");\n        el.className = \"ace_cursor\";\n        this.element.appendChild(el);\n        this.cursors.push(el);\n        return el;\n    };\n    Cursor.prototype.removeCursor = function () {\n        if (this.cursors.length > 1) {\n            var el = this.cursors.pop();\n            el.parentNode.removeChild(el);\n            return el;\n        }\n    };\n    Cursor.prototype.hideCursor = function () {\n        this.isVisible = false;\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n    Cursor.prototype.showCursor = function () {\n        this.isVisible = true;\n        dom.removeCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n    Cursor.prototype.restartTimer = function () {\n        var update = this.$updateCursors;\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n        this.$stopCssAnimation();\n        if (this.smoothBlinking) {\n            this.$isSmoothBlinking = false;\n            dom.removeCssClass(this.element, \"ace_smooth-blinking\");\n        }\n        update(true);\n        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {\n            this.$stopCssAnimation();\n            return;\n        }\n        if (this.smoothBlinking) {\n            this.$isSmoothBlinking = true;\n            setTimeout(function () {\n                if (this.$isSmoothBlinking) {\n                    dom.addCssClass(this.element, \"ace_smooth-blinking\");\n                }\n            }.bind(this));\n        }\n        if (dom.HAS_CSS_ANIMATION) {\n            this.$startCssAnimation();\n        }\n        else {\n            var blink = /**@this{Cursor}*/ function () {\n                this.timeoutId = setTimeout(function () {\n                    update(false);\n                }, 0.6 * this.blinkInterval);\n            }.bind(this);\n            this.intervalId = setInterval(function () {\n                update(true);\n                blink();\n            }, this.blinkInterval);\n            blink();\n        }\n    };\n    Cursor.prototype.getPixelPosition = function (position, onScreen) {\n        if (!this.config || !this.session)\n            return { left: 0, top: 0 };\n        if (!position)\n            position = this.session.selection.getCursor();\n        var pos = this.session.documentToScreenPosition(position);\n        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : pos.column * this.config.characterWidth);\n        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *\n            this.config.lineHeight;\n        return { left: cursorLeft, top: cursorTop };\n    };\n    Cursor.prototype.isCursorInView = function (pixelPos, config) {\n        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;\n    };\n    Cursor.prototype.update = function (config) {\n        this.config = config;\n        var selections = this.session.$selectionMarkers;\n        var i = 0, cursorIndex = 0;\n        if (selections === undefined || selections.length === 0) {\n            selections = [{ cursor: null }];\n        }\n        for (var i = 0, n = selections.length; i < n; i++) {\n            var pixelPos = this.getPixelPosition(selections[i].cursor, true);\n            if ((pixelPos.top > config.height + config.offset ||\n                pixelPos.top < 0) && i > 1) {\n                continue;\n            }\n            var element = this.cursors[cursorIndex++] || this.addCursor();\n            var style = element.style;\n            if (!this.drawCursor) {\n                if (!this.isCursorInView(pixelPos, config)) {\n                    dom.setStyle(style, \"display\", \"none\");\n                }\n                else {\n                    dom.setStyle(style, \"display\", \"block\");\n                    dom.translate(element, pixelPos.left, pixelPos.top);\n                    dom.setStyle(style, \"width\", Math.round(config.characterWidth) + \"px\");\n                    dom.setStyle(style, \"height\", config.lineHeight + \"px\");\n                }\n            }\n            else {\n                this.drawCursor(element, pixelPos, config, selections[i], this.session);\n            }\n        }\n        while (this.cursors.length > cursorIndex)\n            this.removeCursor();\n        var overwrite = this.session.getOverwrite();\n        this.$setOverwrite(overwrite);\n        this.$pixelPos = pixelPos;\n        this.restartTimer();\n    };\n    Cursor.prototype.$setOverwrite = function (overwrite) {\n        if (overwrite != this.overwrite) {\n            this.overwrite = overwrite;\n            if (overwrite)\n                dom.addCssClass(this.element, \"ace_overwrite-cursors\");\n            else\n                dom.removeCssClass(this.element, \"ace_overwrite-cursors\");\n        }\n    };\n    Cursor.prototype.destroy = function () {\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n    };\n    return Cursor;\n}());\nCursor.prototype.$padding = 0;\nCursor.prototype.drawCursor = null;\nexports.Cursor = Cursor;\n\n});\n\nace.define(\"ace/scrollbar\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar MAX_SCROLL_H = 0x8000;\nvar Scrollbar = /** @class */ (function () {\n    function Scrollbar(parent, classSuffix) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_scrollbar ace_scrollbar\" + classSuffix;\n        this.inner = dom.createElement(\"div\");\n        this.inner.className = \"ace_scrollbar-inner\";\n        this.inner.textContent = \"\\xa0\";\n        this.element.appendChild(this.inner);\n        parent.appendChild(this.element);\n        this.setVisible(false);\n        this.skipEvent = false;\n        event.addListener(this.element, \"scroll\", this.onScroll.bind(this));\n        event.addListener(this.element, \"mousedown\", event.preventDefault);\n    }\n    Scrollbar.prototype.setVisible = function (isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n    return Scrollbar;\n}());\noop.implement(Scrollbar.prototype, EventEmitter);\nvar VScrollBar = /** @class */ (function (_super) {\n    __extends(VScrollBar, _super);\n    function VScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-v') || this;\n        _this.scrollTop = 0;\n        _this.scrollHeight = 0;\n        renderer.$scrollbarWidth =\n            _this.width = dom.scrollbarWidth(parent.ownerDocument);\n        _this.inner.style.width =\n            _this.element.style.width = (_this.width || 15) + 5 + \"px\";\n        _this.$minWidth = 0;\n        return _this;\n    }\n    VScrollBar.prototype.onScroll = function () {\n        if (!this.skipEvent) {\n            this.scrollTop = this.element.scrollTop;\n            if (this.coeff != 1) {\n                var h = this.element.clientHeight / this.scrollHeight;\n                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);\n            }\n            this._emit(\"scroll\", { data: this.scrollTop });\n        }\n        this.skipEvent = false;\n    };\n    VScrollBar.prototype.getWidth = function () {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    VScrollBar.prototype.setHeight = function (height) {\n        this.element.style.height = height + \"px\";\n    };\n    VScrollBar.prototype.setScrollHeight = function (height) {\n        this.scrollHeight = height;\n        if (height > MAX_SCROLL_H) {\n            this.coeff = MAX_SCROLL_H / height;\n            height = MAX_SCROLL_H;\n        }\n        else if (this.coeff != 1) {\n            this.coeff = 1;\n        }\n        this.inner.style.height = height + \"px\";\n    };\n    VScrollBar.prototype.setScrollTop = function (scrollTop) {\n        if (this.scrollTop != scrollTop) {\n            this.skipEvent = true;\n            this.scrollTop = scrollTop;\n            this.element.scrollTop = scrollTop * this.coeff;\n        }\n    };\n    return VScrollBar;\n}(Scrollbar));\nVScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;\nvar HScrollBar = /** @class */ (function (_super) {\n    __extends(HScrollBar, _super);\n    function HScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-h') || this;\n        _this.scrollLeft = 0;\n        _this.height = renderer.$scrollbarWidth;\n        _this.inner.style.height =\n            _this.element.style.height = (_this.height || 15) + 5 + \"px\";\n        return _this;\n    }\n    HScrollBar.prototype.onScroll = function () {\n        if (!this.skipEvent) {\n            this.scrollLeft = this.element.scrollLeft;\n            this._emit(\"scroll\", { data: this.scrollLeft });\n        }\n        this.skipEvent = false;\n    };\n    HScrollBar.prototype.getHeight = function () {\n        return this.isVisible ? this.height : 0;\n    };\n    HScrollBar.prototype.setWidth = function (width) {\n        this.element.style.width = width + \"px\";\n    };\n    HScrollBar.prototype.setInnerWidth = function (width) {\n        this.inner.style.width = width + \"px\";\n    };\n    HScrollBar.prototype.setScrollWidth = function (width) {\n        this.inner.style.width = width + \"px\";\n    };\n    HScrollBar.prototype.setScrollLeft = function (scrollLeft) {\n        if (this.scrollLeft != scrollLeft) {\n            this.skipEvent = true;\n            this.scrollLeft = this.element.scrollLeft = scrollLeft;\n        }\n    };\n    return HScrollBar;\n}(Scrollbar));\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n\n});\n\nace.define(\"ace/scrollbar_custom\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\ndom.importCssString(\".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\\n  position: absolute;\\n  background: rgba(128, 128, 128, 0.6);\\n  -moz-box-sizing: border-box;\\n  box-sizing: border-box;\\n  border: 1px solid #bbb;\\n  border-radius: 2px;\\n  z-index: 8;\\n}\\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\\n  position: absolute;\\n  z-index: 6;\\n  background: none;\\n  overflow: hidden!important;\\n}\\n.ace_editor>.ace_sb-v {\\n  z-index: 6;\\n  right: 0;\\n  top: 0;\\n  width: 12px;\\n}\\n.ace_editor>.ace_sb-v div {\\n  z-index: 8;\\n  right: 0;\\n  width: 100%;\\n}\\n.ace_editor>.ace_sb-h {\\n  bottom: 0;\\n  left: 0;\\n  height: 12px;\\n}\\n.ace_editor>.ace_sb-h div {\\n  bottom: 0;\\n  height: 100%;\\n}\\n.ace_editor>.ace_sb_grabbed {\\n  z-index: 8;\\n  background: #000;\\n}\", \"ace_scrollbar.css\", false);\nvar ScrollBar = /** @class */ (function () {\n    function ScrollBar(parent, classSuffix) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_sb\" + classSuffix;\n        this.inner = dom.createElement(\"div\");\n        this.inner.className = \"\";\n        this.element.appendChild(this.inner);\n        this.VScrollWidth = 12;\n        this.HScrollHeight = 12;\n        parent.appendChild(this.element);\n        this.setVisible(false);\n        this.skipEvent = false;\n        event.addMultiMouseDownListener(this.element, [500, 300, 300], this, \"onMouseDown\");\n    }\n    ScrollBar.prototype.setVisible = function (isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n    return ScrollBar;\n}());\noop.implement(ScrollBar.prototype, EventEmitter);\nvar VScrollBar = /** @class */ (function (_super) {\n    __extends(VScrollBar, _super);\n    function VScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-v') || this;\n        _this.scrollTop = 0;\n        _this.scrollHeight = 0;\n        _this.parent = parent;\n        _this.width = _this.VScrollWidth;\n        _this.renderer = renderer;\n        _this.inner.style.width = _this.element.style.width = (_this.width || 15) + \"px\";\n        _this.$minWidth = 0;\n        return _this;\n    }\n    VScrollBar.prototype.onMouseDown = function (eType, e) {\n        if (eType !== \"mousedown\")\n            return;\n        if (event.getButton(e) !== 0 || e.detail === 2) {\n            return;\n        }\n        if (e.target === this.inner) {\n            var self = this;\n            var mousePageY = e.clientY;\n            var onMouseMove = function (e) {\n                mousePageY = e.clientY;\n            };\n            var onMouseUp = function () {\n                clearInterval(timerId);\n            };\n            var startY = e.clientY;\n            var startTop = this.thumbTop;\n            var onScrollInterval = function () {\n                if (mousePageY === undefined)\n                    return;\n                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);\n                if (scrollTop === self.scrollTop)\n                    return;\n                self._emit(\"scroll\", { data: scrollTop });\n            };\n            event.capture(this.inner, onMouseMove, onMouseUp);\n            var timerId = setInterval(onScrollInterval, 20);\n            return event.preventDefault(e);\n        }\n        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;\n        this._emit(\"scroll\", { data: this.scrollTopFromThumbTop(top) });\n        return event.preventDefault(e);\n    };\n    VScrollBar.prototype.getHeight = function () {\n        return this.height;\n    };\n    VScrollBar.prototype.scrollTopFromThumbTop = function (thumbTop) {\n        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);\n        scrollTop = scrollTop >> 0;\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        else if (scrollTop > this.pageHeight - this.viewHeight) {\n            scrollTop = this.pageHeight - this.viewHeight;\n        }\n        return scrollTop;\n    };\n    VScrollBar.prototype.getWidth = function () {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    VScrollBar.prototype.setHeight = function (height) {\n        this.height = Math.max(0, height);\n        this.slideHeight = this.height;\n        this.viewHeight = this.height;\n        this.setScrollHeight(this.pageHeight, true);\n    };\n    VScrollBar.prototype.setScrollHeight = function (height, force) {\n        if (this.pageHeight === height && !force)\n            return;\n        this.pageHeight = height;\n        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;\n        if (this.thumbHeight > this.slideHeight)\n            this.thumbHeight = this.slideHeight;\n        if (this.thumbHeight < 15)\n            this.thumbHeight = 15;\n        this.inner.style.height = this.thumbHeight + \"px\";\n        if (this.scrollTop > (this.pageHeight - this.viewHeight)) {\n            this.scrollTop = (this.pageHeight - this.viewHeight);\n            if (this.scrollTop < 0)\n                this.scrollTop = 0;\n            this._emit(\"scroll\", { data: this.scrollTop });\n        }\n    };\n    VScrollBar.prototype.setScrollTop = function (scrollTop) {\n        this.scrollTop = scrollTop;\n        if (scrollTop < 0)\n            scrollTop = 0;\n        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);\n        this.inner.style.top = this.thumbTop + \"px\";\n    };\n    return VScrollBar;\n}(ScrollBar));\nVScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;\nvar HScrollBar = /** @class */ (function (_super) {\n    __extends(HScrollBar, _super);\n    function HScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-h') || this;\n        _this.scrollLeft = 0;\n        _this.scrollWidth = 0;\n        _this.height = _this.HScrollHeight;\n        _this.inner.style.height = _this.element.style.height = (_this.height || 12) + \"px\";\n        _this.renderer = renderer;\n        return _this;\n    }\n    HScrollBar.prototype.onMouseDown = function (eType, e) {\n        if (eType !== \"mousedown\")\n            return;\n        if (event.getButton(e) !== 0 || e.detail === 2) {\n            return;\n        }\n        if (e.target === this.inner) {\n            var self = this;\n            var mousePageX = e.clientX;\n            var onMouseMove = function (e) {\n                mousePageX = e.clientX;\n            };\n            var onMouseUp = function () {\n                clearInterval(timerId);\n            };\n            var startX = e.clientX;\n            var startLeft = this.thumbLeft;\n            var onScrollInterval = function () {\n                if (mousePageX === undefined)\n                    return;\n                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);\n                if (scrollLeft === self.scrollLeft)\n                    return;\n                self._emit(\"scroll\", { data: scrollLeft });\n            };\n            event.capture(this.inner, onMouseMove, onMouseUp);\n            var timerId = setInterval(onScrollInterval, 20);\n            return event.preventDefault(e);\n        }\n        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;\n        this._emit(\"scroll\", { data: this.scrollLeftFromThumbLeft(left) });\n        return event.preventDefault(e);\n    };\n    HScrollBar.prototype.getHeight = function () {\n        return this.isVisible ? this.height : 0;\n    };\n    HScrollBar.prototype.scrollLeftFromThumbLeft = function (thumbLeft) {\n        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);\n        scrollLeft = scrollLeft >> 0;\n        if (scrollLeft < 0) {\n            scrollLeft = 0;\n        }\n        else if (scrollLeft > this.pageWidth - this.viewWidth) {\n            scrollLeft = this.pageWidth - this.viewWidth;\n        }\n        return scrollLeft;\n    };\n    HScrollBar.prototype.setWidth = function (width) {\n        this.width = Math.max(0, width);\n        this.element.style.width = this.width + \"px\";\n        this.slideWidth = this.width;\n        this.viewWidth = this.width;\n        this.setScrollWidth(this.pageWidth, true);\n    };\n    HScrollBar.prototype.setScrollWidth = function (width, force) {\n        if (this.pageWidth === width && !force)\n            return;\n        this.pageWidth = width;\n        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;\n        if (this.thumbWidth > this.slideWidth)\n            this.thumbWidth = this.slideWidth;\n        if (this.thumbWidth < 15)\n            this.thumbWidth = 15;\n        this.inner.style.width = this.thumbWidth + \"px\";\n        if (this.scrollLeft > (this.pageWidth - this.viewWidth)) {\n            this.scrollLeft = (this.pageWidth - this.viewWidth);\n            if (this.scrollLeft < 0)\n                this.scrollLeft = 0;\n            this._emit(\"scroll\", { data: this.scrollLeft });\n        }\n    };\n    HScrollBar.prototype.setScrollLeft = function (scrollLeft) {\n        this.scrollLeft = scrollLeft;\n        if (scrollLeft < 0)\n            scrollLeft = 0;\n        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);\n        this.inner.style.left = (this.thumbLeft) + \"px\";\n    };\n    return HScrollBar;\n}(ScrollBar));\nHScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n\n});\n\nace.define(\"ace/renderloop\",[\"require\",\"exports\",\"module\",\"ace/lib/event\"], function(require, exports, module){\"use strict\";\nvar event = require(\"./lib/event\");\nvar RenderLoop = /** @class */ (function () {\n    function RenderLoop(onRender, win) {\n        this.onRender = onRender;\n        this.pending = false;\n        this.changes = 0;\n        this.$recursionLimit = 2;\n        this.window = win || window;\n        var _self = this;\n        this._flush = function (ts) {\n            _self.pending = false;\n            var changes = _self.changes;\n            if (changes) {\n                event.blockIdle(100);\n                _self.changes = 0;\n                _self.onRender(changes);\n            }\n            if (_self.changes) {\n                if (_self.$recursionLimit-- < 0)\n                    return;\n                _self.schedule();\n            }\n            else {\n                _self.$recursionLimit = 2;\n            }\n        };\n    }\n    RenderLoop.prototype.schedule = function (change) {\n        this.changes = this.changes | change;\n        if (this.changes && !this.pending) {\n            event.nextFrame(this._flush);\n            this.pending = true;\n        }\n    };\n    RenderLoop.prototype.clear = function (change) {\n        var changes = this.changes;\n        this.changes = 0;\n        return changes;\n    };\n    return RenderLoop;\n}());\nexports.RenderLoop = RenderLoop;\n\n});\n\nace.define(\"ace/layer/font_metrics\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(require, exports, module){var oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar CHAR_COUNT = 512;\nvar USE_OBSERVER = typeof ResizeObserver == \"function\";\nvar L = 200;\nvar FontMetrics = /** @class */ (function () {\n    function FontMetrics(parentEl) {\n        this.el = dom.createElement(\"div\");\n        this.$setMeasureNodeStyles(this.el.style, true);\n        this.$main = dom.createElement(\"div\");\n        this.$setMeasureNodeStyles(this.$main.style);\n        this.$measureNode = dom.createElement(\"div\");\n        this.$setMeasureNodeStyles(this.$measureNode.style);\n        this.el.appendChild(this.$main);\n        this.el.appendChild(this.$measureNode);\n        parentEl.appendChild(this.el);\n        this.$measureNode.textContent = lang.stringRepeat(\"X\", CHAR_COUNT);\n        this.$characterSize = { width: 0, height: 0 };\n        if (USE_OBSERVER)\n            this.$addObserver();\n        else\n            this.checkForSizeChanges();\n    }\n    FontMetrics.prototype.$setMeasureNodeStyles = function (style, isRoot) {\n        style.width = style.height = \"auto\";\n        style.left = style.top = \"0px\";\n        style.visibility = \"hidden\";\n        style.position = \"absolute\";\n        style.whiteSpace = \"pre\";\n        if (useragent.isIE < 8) {\n            style[\"font-family\"] = \"inherit\";\n        }\n        else {\n            style.font = \"inherit\";\n        }\n        style.overflow = isRoot ? \"hidden\" : \"visible\";\n    };\n    FontMetrics.prototype.checkForSizeChanges = function (size) {\n        if (size === undefined)\n            size = this.$measureSizes();\n        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {\n            this.$measureNode.style.fontWeight = \"bold\";\n            var boldSize = this.$measureSizes();\n            this.$measureNode.style.fontWeight = \"\";\n            this.$characterSize = size;\n            this.charSizes = Object.create(null);\n            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;\n            this._emit(\"changeCharacterSize\", { data: size });\n        }\n    };\n    FontMetrics.prototype.$addObserver = function () {\n        var self = this;\n        this.$observer = new window.ResizeObserver(function (e) {\n            self.checkForSizeChanges();\n        });\n        this.$observer.observe(this.$measureNode);\n    };\n    FontMetrics.prototype.$pollSizeChanges = function () {\n        if (this.$pollSizeChangesTimer || this.$observer)\n            return this.$pollSizeChangesTimer;\n        var self = this;\n        return this.$pollSizeChangesTimer = event.onIdle(function cb() {\n            self.checkForSizeChanges();\n            event.onIdle(cb, 500);\n        }, 500);\n    };\n    FontMetrics.prototype.setPolling = function (val) {\n        if (val) {\n            this.$pollSizeChanges();\n        }\n        else if (this.$pollSizeChangesTimer) {\n            clearInterval(this.$pollSizeChangesTimer);\n            this.$pollSizeChangesTimer = 0;\n        }\n    };\n    FontMetrics.prototype.$measureSizes = function (node) {\n        var size = {\n            height: (node || this.$measureNode).clientHeight,\n            width: (node || this.$measureNode).clientWidth / CHAR_COUNT\n        };\n        if (size.width === 0 || size.height === 0)\n            return null;\n        return size;\n    };\n    FontMetrics.prototype.$measureCharWidth = function (ch) {\n        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);\n        var rect = this.$main.getBoundingClientRect();\n        return rect.width / CHAR_COUNT;\n    };\n    FontMetrics.prototype.getCharacterWidth = function (ch) {\n        var w = this.charSizes[ch];\n        if (w === undefined) {\n            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;\n        }\n        return w;\n    };\n    FontMetrics.prototype.destroy = function () {\n        clearInterval(this.$pollSizeChangesTimer);\n        if (this.$observer)\n            this.$observer.disconnect();\n        if (this.el && this.el.parentNode)\n            this.el.parentNode.removeChild(this.el);\n    };\n    FontMetrics.prototype.$getZoom = function (element) {\n        if (!element || !element.parentElement)\n            return 1;\n        return (Number(window.getComputedStyle(element)[\"zoom\"]) || 1) * this.$getZoom(element.parentElement);\n    };\n    FontMetrics.prototype.$initTransformMeasureNodes = function () {\n        var t = function (t, l) {\n            return [\"div\", {\n                    style: \"position: absolute;top:\" + t + \"px;left:\" + l + \"px;\"\n                }];\n        };\n        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);\n    };\n    FontMetrics.prototype.transformCoordinates = function (clientPos, elPos) {\n        if (clientPos) {\n            var zoom = this.$getZoom(this.el);\n            clientPos = mul(1 / zoom, clientPos);\n        }\n        function solve(l1, l2, r) {\n            var det = l1[1] * l2[0] - l1[0] * l2[1];\n            return [\n                (-l2[1] * r[0] + l2[0] * r[1]) / det,\n                (+l1[1] * r[0] - l1[0] * r[1]) / det\n            ];\n        }\n        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }\n        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }\n        function mul(a, b) { return [a * b[0], a * b[1]]; }\n        if (!this.els)\n            this.$initTransformMeasureNodes();\n        function p(el) {\n            var r = el.getBoundingClientRect();\n            return [r.left, r.top];\n        }\n        var a = p(this.els[0]);\n        var b = p(this.els[1]);\n        var c = p(this.els[2]);\n        var d = p(this.els[3]);\n        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));\n        var m1 = mul(1 + h[0], sub(b, a));\n        var m2 = mul(1 + h[1], sub(c, a));\n        if (elPos) {\n            var x = elPos;\n            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;\n            var ut = add(mul(x[0], m1), mul(x[1], m2));\n            return add(mul(1 / k / L, ut), a);\n        }\n        var u = sub(clientPos, a);\n        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);\n        return mul(L, f);\n    };\n    return FontMetrics;\n}());\nFontMetrics.prototype.$characterSize = { width: 0, height: 0 };\noop.implement(FontMetrics.prototype, EventEmitter);\nexports.FontMetrics = FontMetrics;\n\n});\n\nace.define(\"ace/css/editor-css\",[\"require\",\"exports\",\"module\"], function(require, exports, module){/*\nstyles = []\nfor (var i = 1; i < 16; i++) {\n    styles.push(\".ace_br\" + i + \"{\" + (\n        [\"top-left\", \"top-right\", \"bottom-right\", \"bottom-left\"]\n    ).map(function(x, j) {\n        return i & (1<<j) ? \"border-\" + x + \"-radius: 3px;\" : \"\"\n    }).filter(Boolean).join(\" \") + \"}\")\n}\nstyles.join(\"\\\\n\")\n*/\nmodule.exports = \"\\n.ace_br1 {border-top-left-radius    : 3px;}\\n.ace_br2 {border-top-right-radius   : 3px;}\\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\\n.ace_br4 {border-bottom-right-radius: 3px;}\\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\\n.ace_br8 {border-bottom-left-radius : 3px;}\\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\\n\\n\\n.ace_editor {\\n    position: relative;\\n    overflow: hidden;\\n    padding: 0;\\n    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;\\n    direction: ltr;\\n    text-align: left;\\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\n\\n.ace_scroller {\\n    position: absolute;\\n    overflow: hidden;\\n    top: 0;\\n    bottom: 0;\\n    background-color: inherit;\\n    -ms-user-select: none;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    user-select: none;\\n    cursor: text;\\n}\\n\\n.ace_content {\\n    position: absolute;\\n    box-sizing: border-box;\\n    min-width: 100%;\\n    contain: style size layout;\\n    font-variant-ligatures: no-common-ligatures;\\n}\\n\\n.ace_keyboard-focus:focus {\\n    box-shadow: inset 0 0 0 2px #5E9ED6;\\n    outline: none;\\n}\\n\\n.ace_dragging .ace_scroller:before{\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    content: '';\\n    background: rgba(250, 250, 250, 0.01);\\n    z-index: 1000;\\n}\\n.ace_dragging.ace_dark .ace_scroller:before{\\n    background: rgba(0, 0, 0, 0.01);\\n}\\n\\n.ace_gutter {\\n    position: absolute;\\n    overflow : hidden;\\n    width: auto;\\n    top: 0;\\n    bottom: 0;\\n    left: 0;\\n    cursor: default;\\n    z-index: 4;\\n    -ms-user-select: none;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    user-select: none;\\n    contain: style size layout;\\n}\\n\\n.ace_gutter-active-line {\\n    position: absolute;\\n    left: 0;\\n    right: 0;\\n}\\n\\n.ace_scroller.ace_scroll-left:after {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\\n    pointer-events: none;\\n}\\n\\n.ace_gutter-cell, .ace_gutter-cell_svg-icons {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    padding-left: 19px;\\n    padding-right: 6px;\\n    background-repeat: no-repeat;\\n}\\n\\n.ace_gutter-cell_svg-icons .ace_gutter_annotation {\\n    margin-left: -14px;\\n    float: left;\\n}\\n\\n.ace_gutter-cell .ace_gutter_annotation {\\n    margin-left: -19px;\\n    float: left;\\n}\\n\\n.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\\\");\\n    background-repeat: no-repeat;\\n    background-position: 2px center;\\n}\\n\\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\\\");\\n    background-repeat: no-repeat;\\n    background-position: 2px center;\\n}\\n\\n.ace_gutter-cell.ace_info, .ace_icon.ace_info {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\\\");\\n    background-repeat: no-repeat;\\n    background-position: 2px center;\\n}\\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\\\");\\n}\\n\\n.ace_icon_svg.ace_error {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+\\\");\\n    background-color: crimson;\\n}\\n.ace_icon_svg.ace_warning {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==\\\");\\n    background-color: darkorange;\\n}\\n.ace_icon_svg.ace_info {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==\\\");\\n    background-color: royalblue;\\n}\\n\\n.ace_icon_svg.ace_error_fold {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=\\\");\\n    background-color: crimson;\\n}\\n.ace_icon_svg.ace_warning_fold {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=\\\");\\n    background-color: darkorange;\\n}\\n\\n.ace_scrollbar {\\n    contain: strict;\\n    position: absolute;\\n    right: 0;\\n    bottom: 0;\\n    z-index: 6;\\n}\\n\\n.ace_scrollbar-inner {\\n    position: absolute;\\n    cursor: text;\\n    left: 0;\\n    top: 0;\\n}\\n\\n.ace_scrollbar-v{\\n    overflow-x: hidden;\\n    overflow-y: scroll;\\n    top: 0;\\n}\\n\\n.ace_scrollbar-h {\\n    overflow-x: scroll;\\n    overflow-y: hidden;\\n    left: 0;\\n}\\n\\n.ace_print-margin {\\n    position: absolute;\\n    height: 100%;\\n}\\n\\n.ace_text-input {\\n    position: absolute;\\n    z-index: 0;\\n    width: 0.5em;\\n    height: 1em;\\n    opacity: 0;\\n    background: transparent;\\n    -moz-appearance: none;\\n    appearance: none;\\n    border: none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    font: inherit;\\n    padding: 0 1px;\\n    margin: 0 -1px;\\n    contain: strict;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\\n    white-space: pre!important;\\n}\\n.ace_text-input.ace_composition {\\n    background: transparent;\\n    color: inherit;\\n    z-index: 1000;\\n    opacity: 1;\\n}\\n.ace_composition_placeholder { color: transparent }\\n.ace_composition_marker { \\n    border-bottom: 1px solid;\\n    position: absolute;\\n    border-radius: 0;\\n    margin-top: 1px;\\n}\\n\\n[ace_nocontext=true] {\\n    transform: none!important;\\n    filter: none!important;\\n    clip-path: none!important;\\n    mask : none!important;\\n    contain: none!important;\\n    perspective: none!important;\\n    mix-blend-mode: initial!important;\\n    z-index: auto;\\n}\\n\\n.ace_layer {\\n    z-index: 1;\\n    position: absolute;\\n    overflow: hidden;\\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\\n    word-wrap: normal;\\n    white-space: pre;\\n    height: 100%;\\n    width: 100%;\\n    box-sizing: border-box;\\n    /* setting pointer-events: auto; on node under the mouse, which changes\\n        during scroll, will break mouse wheel scrolling in Safari */\\n    pointer-events: none;\\n}\\n\\n.ace_gutter-layer {\\n    position: relative;\\n    width: auto;\\n    text-align: right;\\n    pointer-events: auto;\\n    height: 1000000px;\\n    contain: style size layout;\\n}\\n\\n.ace_text-layer {\\n    font: inherit !important;\\n    position: absolute;\\n    height: 1000000px;\\n    width: 1000000px;\\n    contain: style size layout;\\n}\\n\\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\\n    contain: style size layout;\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n}\\n\\n.ace_hidpi .ace_text-layer,\\n.ace_hidpi .ace_gutter-layer,\\n.ace_hidpi .ace_content,\\n.ace_hidpi .ace_gutter {\\n    contain: strict;\\n}\\n.ace_hidpi .ace_text-layer > .ace_line, \\n.ace_hidpi .ace_text-layer > .ace_line_group {\\n    contain: strict;\\n}\\n\\n.ace_cjk {\\n    display: inline-block;\\n    text-align: center;\\n}\\n\\n.ace_cursor-layer {\\n    z-index: 4;\\n}\\n\\n.ace_cursor {\\n    z-index: 4;\\n    position: absolute;\\n    box-sizing: border-box;\\n    border-left: 2px solid;\\n    /* workaround for smooth cursor repaintng whole screen in chrome */\\n    transform: translatez(0);\\n}\\n\\n.ace_multiselect .ace_cursor {\\n    border-left-width: 1px;\\n}\\n\\n.ace_slim-cursors .ace_cursor {\\n    border-left-width: 1px;\\n}\\n\\n.ace_overwrite-cursors .ace_cursor {\\n    border-left-width: 0;\\n    border-bottom: 1px solid;\\n}\\n\\n.ace_hidden-cursors .ace_cursor {\\n    opacity: 0.2;\\n}\\n\\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\\n    opacity: 0;\\n}\\n\\n.ace_smooth-blinking .ace_cursor {\\n    transition: opacity 0.18s;\\n}\\n\\n.ace_animate-blinking .ace_cursor {\\n    animation-duration: 1000ms;\\n    animation-timing-function: step-end;\\n    animation-name: blink-ace-animate;\\n    animation-iteration-count: infinite;\\n}\\n\\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\\n    animation-duration: 1000ms;\\n    animation-timing-function: ease-in-out;\\n    animation-name: blink-ace-animate-smooth;\\n}\\n    \\n@keyframes blink-ace-animate {\\n    from, to { opacity: 1; }\\n    60% { opacity: 0; }\\n}\\n\\n@keyframes blink-ace-animate-smooth {\\n    from, to { opacity: 1; }\\n    45% { opacity: 1; }\\n    60% { opacity: 0; }\\n    85% { opacity: 0; }\\n}\\n\\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\\n    position: absolute;\\n    z-index: 3;\\n}\\n\\n.ace_marker-layer .ace_selection {\\n    position: absolute;\\n    z-index: 5;\\n}\\n\\n.ace_marker-layer .ace_bracket {\\n    position: absolute;\\n    z-index: 6;\\n}\\n\\n.ace_marker-layer .ace_error_bracket {\\n    position: absolute;\\n    border-bottom: 1px solid #DE5555;\\n    border-radius: 0;\\n}\\n\\n.ace_marker-layer .ace_active-line {\\n    position: absolute;\\n    z-index: 2;\\n}\\n\\n.ace_marker-layer .ace_selected-word {\\n    position: absolute;\\n    z-index: 4;\\n    box-sizing: border-box;\\n}\\n\\n.ace_line .ace_fold {\\n    box-sizing: border-box;\\n\\n    display: inline-block;\\n    height: 11px;\\n    margin-top: -2px;\\n    vertical-align: middle;\\n\\n    background-image:\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\\\");\\n    background-repeat: no-repeat, repeat-x;\\n    background-position: center center, top left;\\n    color: transparent;\\n\\n    border: 1px solid black;\\n    border-radius: 2px;\\n\\n    cursor: pointer;\\n    pointer-events: auto;\\n}\\n\\n.ace_dark .ace_fold {\\n}\\n\\n.ace_fold:hover{\\n    background-image:\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\\\");\\n}\\n\\n.ace_tooltip {\\n    background-color: #f5f5f5;\\n    border: 1px solid gray;\\n    border-radius: 1px;\\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\\n    color: black;\\n    max-width: 100%;\\n    padding: 3px 4px;\\n    position: fixed;\\n    z-index: 999999;\\n    box-sizing: border-box;\\n    cursor: default;\\n    white-space: pre-wrap;\\n    word-wrap: break-word;\\n    line-height: normal;\\n    font-style: normal;\\n    font-weight: normal;\\n    letter-spacing: normal;\\n    pointer-events: none;\\n    overflow: auto;\\n    max-width: min(60em, 66vw);\\n    overscroll-behavior: contain;\\n}\\n.ace_tooltip pre {\\n    white-space: pre-wrap;\\n}\\n\\n.ace_tooltip.ace_dark {\\n    background-color: #636363;\\n    color: #fff;\\n}\\n\\n.ace_tooltip:focus {\\n    outline: 1px solid #5E9ED6;\\n}\\n\\n.ace_icon {\\n    display: inline-block;\\n    width: 18px;\\n    vertical-align: top;\\n}\\n\\n.ace_icon_svg {\\n    display: inline-block;\\n    width: 12px;\\n    vertical-align: top;\\n    -webkit-mask-repeat: no-repeat;\\n    -webkit-mask-size: 12px;\\n    -webkit-mask-position: center;\\n}\\n\\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\\n    padding-right: 13px;\\n}\\n\\n.ace_fold-widget {\\n    box-sizing: border-box;\\n\\n    margin: 0 -12px 0 1px;\\n    display: none;\\n    width: 11px;\\n    vertical-align: top;\\n\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\\\");\\n    background-repeat: no-repeat;\\n    background-position: center;\\n\\n    border-radius: 3px;\\n    \\n    border: 1px solid transparent;\\n    cursor: pointer;\\n}\\n\\n.ace_folding-enabled .ace_fold-widget {\\n    display: inline-block;   \\n}\\n\\n.ace_fold-widget.ace_end {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\\\");\\n}\\n\\n.ace_fold-widget.ace_closed {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\\\");\\n}\\n\\n.ace_fold-widget:hover {\\n    border: 1px solid rgba(0, 0, 0, 0.3);\\n    background-color: rgba(255, 255, 255, 0.2);\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\\n}\\n\\n.ace_fold-widget:active {\\n    border: 1px solid rgba(0, 0, 0, 0.4);\\n    background-color: rgba(0, 0, 0, 0.05);\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\\n}\\n/**\\n * Dark version for fold widgets\\n */\\n.ace_dark .ace_fold-widget {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\\\");\\n}\\n.ace_dark .ace_fold-widget.ace_end {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\\\");\\n}\\n.ace_dark .ace_fold-widget.ace_closed {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\\\");\\n}\\n.ace_dark .ace_fold-widget:hover {\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\n    background-color: rgba(255, 255, 255, 0.1);\\n}\\n.ace_dark .ace_fold-widget:active {\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\n}\\n\\n.ace_inline_button {\\n    border: 1px solid lightgray;\\n    display: inline-block;\\n    margin: -1px 8px;\\n    padding: 0 5px;\\n    pointer-events: auto;\\n    cursor: pointer;\\n}\\n.ace_inline_button:hover {\\n    border-color: gray;\\n    background: rgba(200,200,200,0.2);\\n    display: inline-block;\\n    pointer-events: auto;\\n}\\n\\n.ace_fold-widget.ace_invalid {\\n    background-color: #FFB4B4;\\n    border-color: #DE5555;\\n}\\n\\n.ace_fade-fold-widgets .ace_fold-widget {\\n    transition: opacity 0.4s ease 0.05s;\\n    opacity: 0;\\n}\\n\\n.ace_fade-fold-widgets:hover .ace_fold-widget {\\n    transition: opacity 0.05s ease 0.05s;\\n    opacity:1;\\n}\\n\\n.ace_underline {\\n    text-decoration: underline;\\n}\\n\\n.ace_bold {\\n    font-weight: bold;\\n}\\n\\n.ace_nobold .ace_bold {\\n    font-weight: normal;\\n}\\n\\n.ace_italic {\\n    font-style: italic;\\n}\\n\\n\\n.ace_error-marker {\\n    background-color: rgba(255, 0, 0,0.2);\\n    position: absolute;\\n    z-index: 9;\\n}\\n\\n.ace_highlight-marker {\\n    background-color: rgba(255, 255, 0,0.2);\\n    position: absolute;\\n    z-index: 8;\\n}\\n\\n.ace_mobile-menu {\\n    position: absolute;\\n    line-height: 1.5;\\n    border-radius: 4px;\\n    -ms-user-select: none;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    user-select: none;\\n    background: white;\\n    box-shadow: 1px 3px 2px grey;\\n    border: 1px solid #dcdcdc;\\n    color: black;\\n}\\n.ace_dark > .ace_mobile-menu {\\n    background: #333;\\n    color: #ccc;\\n    box-shadow: 1px 3px 2px grey;\\n    border: 1px solid #444;\\n\\n}\\n.ace_mobile-button {\\n    padding: 2px;\\n    cursor: pointer;\\n    overflow: hidden;\\n}\\n.ace_mobile-button:hover {\\n    background-color: #eee;\\n    opacity:1;\\n}\\n.ace_mobile-button:active {\\n    background-color: #ddd;\\n}\\n\\n.ace_placeholder {\\n    position: relative;\\n    font-family: arial;\\n    transform: scale(0.9);\\n    transform-origin: left;\\n    white-space: pre;\\n    opacity: 0.7;\\n    margin: 0 10px;\\n    z-index: 1;\\n}\\n\\n.ace_ghost_text {\\n    opacity: 0.5;\\n    font-style: italic;\\n}\\n\\n.ace_ghost_text_container > div {\\n    white-space: pre;\\n}\\n\\n.ghost_text_line_wrapped::after {\\n    content: \\\"\\u21A9\\\";\\n    position: absolute;\\n}\\n\\n.ace_lineWidgetContainer.ace_ghost_text {\\n    margin: 0px 4px\\n}\\n\\n.ace_screenreader-only {\\n    position:absolute;\\n    left:-10000px;\\n    top:auto;\\n    width:1px;\\n    height:1px;\\n    overflow:hidden;\\n}\\n\\n.ace_hidden_token {\\n    display: none;\\n}\";\n\n});\n\nace.define(\"ace/layer/decorators\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Decorator = /** @class */ (function () {\n    function Decorator(parent, renderer) {\n        this.canvas = dom.createElement(\"canvas\");\n        this.renderer = renderer;\n        this.pixelRatio = 1;\n        this.maxHeight = renderer.layerConfig.maxHeight;\n        this.lineHeight = renderer.layerConfig.lineHeight;\n        this.canvasHeight = parent.parent.scrollHeight;\n        this.heightRatio = this.canvasHeight / this.maxHeight;\n        this.canvasWidth = parent.width;\n        this.minDecorationHeight = (2 * this.pixelRatio) | 0;\n        this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;\n        this.canvas.width = this.canvasWidth;\n        this.canvas.height = this.canvasHeight;\n        this.canvas.style.top = 0 + \"px\";\n        this.canvas.style.right = 0 + \"px\";\n        this.canvas.style.zIndex = 7 + \"px\";\n        this.canvas.style.position = \"absolute\";\n        this.colors = {};\n        this.colors.dark = {\n            \"error\": \"rgba(255, 18, 18, 1)\",\n            \"warning\": \"rgba(18, 136, 18, 1)\",\n            \"info\": \"rgba(18, 18, 136, 1)\"\n        };\n        this.colors.light = {\n            \"error\": \"rgb(255,51,51)\",\n            \"warning\": \"rgb(32,133,72)\",\n            \"info\": \"rgb(35,68,138)\"\n        };\n        parent.element.appendChild(this.canvas);\n    }\n    Decorator.prototype.$updateDecorators = function (config) {\n        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;\n        if (config) {\n            this.maxHeight = config.maxHeight;\n            this.lineHeight = config.lineHeight;\n            this.canvasHeight = config.height;\n            var allLineHeight = (config.lastRow + 1) * this.lineHeight;\n            if (allLineHeight < this.canvasHeight) {\n                this.heightRatio = 1;\n            }\n            else {\n                this.heightRatio = this.canvasHeight / this.maxHeight;\n            }\n        }\n        var ctx = this.canvas.getContext(\"2d\");\n        function compare(a, b) {\n            if (a.priority < b.priority)\n                return -1;\n            if (a.priority > b.priority)\n                return 1;\n            return 0;\n        }\n        var annotations = this.renderer.session.$annotations;\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (annotations) {\n            var priorities = {\n                \"info\": 1,\n                \"warning\": 2,\n                \"error\": 3\n            };\n            annotations.forEach(function (item) {\n                item.priority = priorities[item.type] || null;\n            });\n            annotations = annotations.sort(compare);\n            var foldData = this.renderer.session.$foldData;\n            for (var i = 0; i < annotations.length; i++) {\n                var row = annotations[i].row;\n                var compensateFold = this.compensateFoldRows(row, foldData);\n                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);\n                var y1 = Math.round(((row - compensateFold) * this.lineHeight * this.heightRatio));\n                var y2 = Math.round((((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio));\n                var height = y2 - y1;\n                if (height < this.minDecorationHeight) {\n                    var yCenter = ((y1 + y2) / 2) | 0;\n                    if (yCenter < this.halfMinDecorationHeight) {\n                        yCenter = this.halfMinDecorationHeight;\n                    }\n                    else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {\n                        yCenter = this.canvasHeight - this.halfMinDecorationHeight;\n                    }\n                    y1 = Math.round(yCenter - this.halfMinDecorationHeight);\n                    y2 = Math.round(yCenter + this.halfMinDecorationHeight);\n                }\n                ctx.fillStyle = colors[annotations[i].type] || null;\n                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);\n            }\n        }\n        var cursor = this.renderer.session.selection.getCursor();\n        if (cursor) {\n            var compensateFold = this.compensateFoldRows(cursor.row, foldData);\n            var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);\n            ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n            ctx.fillRect(0, currentY, this.canvasWidth, 2);\n        }\n    };\n    Decorator.prototype.compensateFoldRows = function (row, foldData) {\n        var compensateFold = 0;\n        if (foldData && foldData.length > 0) {\n            for (var j = 0; j < foldData.length; j++) {\n                if (row > foldData[j].start.row && row < foldData[j].end.row) {\n                    compensateFold += row - foldData[j].start.row;\n                }\n                else if (row >= foldData[j].end.row) {\n                    compensateFold += foldData[j].end.row - foldData[j].start.row;\n                }\n            }\n        }\n        return compensateFold;\n    };\n    return Decorator;\n}());\noop.implement(Decorator.prototype, EventEmitter);\nexports.Decorator = Decorator;\n\n});\n\nace.define(\"ace/virtual_renderer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/config\",\"ace/layer/gutter\",\"ace/layer/marker\",\"ace/layer/text\",\"ace/layer/cursor\",\"ace/scrollbar\",\"ace/scrollbar\",\"ace/scrollbar_custom\",\"ace/scrollbar_custom\",\"ace/renderloop\",\"ace/layer/font_metrics\",\"ace/lib/event_emitter\",\"ace/css/editor-css\",\"ace/layer/decorators\",\"ace/lib/useragent\",\"ace/layer/text_util\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar config = require(\"./config\");\nvar GutterLayer = require(\"./layer/gutter\").Gutter;\nvar MarkerLayer = require(\"./layer/marker\").Marker;\nvar TextLayer = require(\"./layer/text\").Text;\nvar CursorLayer = require(\"./layer/cursor\").Cursor;\nvar HScrollBar = require(\"./scrollbar\").HScrollBar;\nvar VScrollBar = require(\"./scrollbar\").VScrollBar;\nvar HScrollBarCustom = require(\"./scrollbar_custom\").HScrollBar;\nvar VScrollBarCustom = require(\"./scrollbar_custom\").VScrollBar;\nvar RenderLoop = require(\"./renderloop\").RenderLoop;\nvar FontMetrics = require(\"./layer/font_metrics\").FontMetrics;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar editorCss = require(\"./css/editor-css\");\nvar Decorator = require(\"./layer/decorators\").Decorator;\nvar useragent = require(\"./lib/useragent\");\nvar isTextToken = require(\"./layer/text_util\").isTextToken;\ndom.importCssString(editorCss, \"ace_editor.css\", false);\nvar VirtualRenderer = /** @class */ (function () {\n    function VirtualRenderer(container, theme) {\n        var _self = this;\n        this.container = container || dom.createElement(\"div\");\n        dom.addCssClass(this.container, \"ace_editor\");\n        if (dom.HI_DPI)\n            dom.addCssClass(this.container, \"ace_hidpi\");\n        this.setTheme(theme);\n        if (config.get(\"useStrictCSP\") == null)\n            config.set(\"useStrictCSP\", false);\n        this.$gutter = dom.createElement(\"div\");\n        this.$gutter.className = \"ace_gutter\";\n        this.container.appendChild(this.$gutter);\n        this.$gutter.setAttribute(\"aria-hidden\", \"true\");\n        this.scroller = dom.createElement(\"div\");\n        this.scroller.className = \"ace_scroller\";\n        this.container.appendChild(this.scroller);\n        this.content = dom.createElement(\"div\");\n        this.content.className = \"ace_content\";\n        this.scroller.appendChild(this.content);\n        this.$gutterLayer = new GutterLayer(this.$gutter);\n        this.$gutterLayer.on(\"changeGutterWidth\", this.onGutterResize.bind(this));\n        this.$markerBack = new MarkerLayer(this.content);\n        var textLayer = this.$textLayer = new TextLayer(this.content);\n        this.canvas = textLayer.element;\n        this.$markerFront = new MarkerLayer(this.content);\n        this.$cursorLayer = new CursorLayer(this.content);\n        this.$horizScroll = false;\n        this.$vScroll = false;\n        this.scrollBar =\n            this.scrollBarV = new VScrollBar(this.container, this);\n        this.scrollBarH = new HScrollBar(this.container, this);\n        this.scrollBarV.on(\"scroll\", function (e) {\n            if (!_self.$scrollAnimation)\n                _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n        });\n        this.scrollBarH.on(\"scroll\", function (e) {\n            if (!_self.$scrollAnimation)\n                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n        });\n        this.scrollTop = 0;\n        this.scrollLeft = 0;\n        this.cursorPos = {\n            row: 0,\n            column: 0\n        };\n        this.$fontMetrics = new FontMetrics(this.container);\n        this.$textLayer.$setFontMetrics(this.$fontMetrics);\n        this.$textLayer.on(\"changeCharacterSize\", function (e) {\n            _self.updateCharacterSize();\n            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);\n            _self._signal(\"changeCharacterSize\", e);\n        });\n        this.$size = {\n            width: 0,\n            height: 0,\n            scrollerHeight: 0,\n            scrollerWidth: 0,\n            $dirty: true\n        };\n        this.layerConfig = {\n            width: 1,\n            padding: 0,\n            firstRow: 0,\n            firstRowScreen: 0,\n            lastRow: 0,\n            lineHeight: 0,\n            characterWidth: 0,\n            minHeight: 1,\n            maxHeight: 1,\n            offset: 0,\n            height: 1,\n            gutterOffset: 1\n        };\n        this.scrollMargin = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0,\n            v: 0,\n            h: 0\n        };\n        this.margin = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0,\n            v: 0,\n            h: 0\n        };\n        this.$keepTextAreaAtCursor = !useragent.isIOS;\n        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.updateCharacterSize();\n        this.setPadding(4);\n        this.$addResizeObserver();\n        config.resetOptions(this);\n        config._signal(\"renderer\", this);\n    }\n    VirtualRenderer.prototype.updateCharacterSize = function () {\n        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {\n            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;\n            this.setStyle(\"ace_nobold\", !this.$allowBoldFonts);\n        }\n        this.layerConfig.characterWidth =\n            this.characterWidth = this.$textLayer.getCharacterWidth();\n        this.layerConfig.lineHeight =\n            this.lineHeight = this.$textLayer.getLineHeight();\n        this.$updatePrintMargin();\n        dom.setStyle(this.scroller.style, \"line-height\", this.lineHeight + \"px\");\n    };\n    VirtualRenderer.prototype.setSession = function (session) {\n        if (this.session)\n            this.session.doc.off(\"changeNewLineMode\", this.onChangeNewLineMode);\n        this.session = session;\n        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)\n            session.setScrollTop(-this.scrollMargin.top);\n        this.$cursorLayer.setSession(session);\n        this.$markerBack.setSession(session);\n        this.$markerFront.setSession(session);\n        this.$gutterLayer.setSession(session);\n        this.$textLayer.setSession(session);\n        if (!session)\n            return;\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.session.$setFontMetrics(this.$fontMetrics);\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);\n        this.onChangeNewLineMode();\n        this.session.doc.on(\"changeNewLineMode\", this.onChangeNewLineMode);\n    };\n    VirtualRenderer.prototype.updateLines = function (firstRow, lastRow, force) {\n        if (lastRow === undefined)\n            lastRow = Infinity;\n        if (!this.$changedLines) {\n            this.$changedLines = {\n                firstRow: firstRow,\n                lastRow: lastRow\n            };\n        }\n        else {\n            if (this.$changedLines.firstRow > firstRow)\n                this.$changedLines.firstRow = firstRow;\n            if (this.$changedLines.lastRow < lastRow)\n                this.$changedLines.lastRow = lastRow;\n        }\n        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {\n            if (force)\n                this.$changedLines.lastRow = this.layerConfig.lastRow;\n            else\n                return;\n        }\n        if (this.$changedLines.firstRow > this.layerConfig.lastRow)\n            return;\n        this.$loop.schedule(this.CHANGE_LINES);\n    };\n    VirtualRenderer.prototype.onChangeNewLineMode = function () {\n        this.$loop.schedule(this.CHANGE_TEXT);\n        this.$textLayer.$updateEolChar();\n        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);\n    };\n    VirtualRenderer.prototype.onChangeTabSize = function () {\n        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);\n        this.$textLayer.onChangeTabSize();\n    };\n    VirtualRenderer.prototype.updateText = function () {\n        this.$loop.schedule(this.CHANGE_TEXT);\n    };\n    VirtualRenderer.prototype.updateFull = function (force) {\n        if (force)\n            this.$renderChanges(this.CHANGE_FULL, true);\n        else\n            this.$loop.schedule(this.CHANGE_FULL);\n    };\n    VirtualRenderer.prototype.updateFontSize = function () {\n        this.$textLayer.checkForSizeChanges();\n    };\n    VirtualRenderer.prototype.$updateSizeAsync = function () {\n        if (this.$loop.pending)\n            this.$size.$dirty = true;\n        else\n            this.onResize();\n    };\n    VirtualRenderer.prototype.onResize = function (force, gutterWidth, width, height) {\n        if (this.resizing > 2)\n            return;\n        else if (this.resizing > 0)\n            this.resizing++;\n        else\n            this.resizing = force ? 1 : 0;\n        var el = this.container;\n        if (!height)\n            height = el.clientHeight || el.scrollHeight;\n        if (!height && this.$maxLines && this.lineHeight > 1) {\n            if (!el.style.height || el.style.height == \"0px\") {\n                el.style.height = \"1px\";\n                height = el.clientHeight || el.scrollHeight;\n            }\n        }\n        if (!width)\n            width = el.clientWidth || el.scrollWidth;\n        var changes = this.$updateCachedSize(force, gutterWidth, width, height);\n        if (this.$resizeTimer)\n            this.$resizeTimer.cancel();\n        if (!this.$size.scrollerHeight || (!width && !height))\n            return this.resizing = 0;\n        if (force)\n            this.$gutterLayer.$padding = null;\n        if (force)\n            this.$renderChanges(changes | this.$changes, true);\n        else\n            this.$loop.schedule(changes | this.$changes);\n        if (this.resizing)\n            this.resizing = 0;\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        if (this.$customScrollbar) {\n            this.$updateCustomScrollbar(true);\n        }\n    };\n    VirtualRenderer.prototype.$updateCachedSize = function (force, gutterWidth, width, height) {\n        height -= (this.$extraHeight || 0);\n        var changes = 0;\n        var size = this.$size;\n        var oldSize = {\n            width: size.width,\n            height: size.height,\n            scrollerHeight: size.scrollerHeight,\n            scrollerWidth: size.scrollerWidth\n        };\n        if (height && (force || size.height != height)) {\n            size.height = height;\n            changes |= this.CHANGE_SIZE;\n            size.scrollerHeight = size.height;\n            if (this.$horizScroll)\n                size.scrollerHeight -= this.scrollBarH.getHeight();\n            this.scrollBarV.setHeight(size.scrollerHeight);\n            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + \"px\";\n            changes = changes | this.CHANGE_SCROLL;\n        }\n        if (width && (force || size.width != width)) {\n            changes |= this.CHANGE_SIZE;\n            size.width = width;\n            if (gutterWidth == null)\n                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n            this.gutterWidth = gutterWidth;\n            dom.setStyle(this.scrollBarH.element.style, \"left\", gutterWidth + \"px\");\n            dom.setStyle(this.scroller.style, \"left\", gutterWidth + this.margin.left + \"px\");\n            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);\n            dom.setStyle(this.$gutter.style, \"left\", this.margin.left + \"px\");\n            var right = this.scrollBarV.getWidth() + \"px\";\n            dom.setStyle(this.scrollBarH.element.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"bottom\", this.scrollBarH.getHeight());\n            this.scrollBarH.setWidth(size.scrollerWidth);\n            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {\n                changes |= this.CHANGE_FULL;\n            }\n        }\n        size.$dirty = !width || !height;\n        if (changes)\n            this._signal(\"resize\", oldSize);\n        return changes;\n    };\n    VirtualRenderer.prototype.onGutterResize = function (width) {\n        var gutterWidth = this.$showGutter ? width : 0;\n        if (gutterWidth != this.gutterWidth)\n            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);\n        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        }\n        else if (this.$size.$dirty) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        }\n        else {\n            this.$computeLayerConfig();\n        }\n    };\n    VirtualRenderer.prototype.adjustWrapLimit = function () {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth);\n        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);\n    };\n    VirtualRenderer.prototype.setAnimatedScroll = function (shouldAnimate) {\n        this.setOption(\"animatedScroll\", shouldAnimate);\n    };\n    VirtualRenderer.prototype.getAnimatedScroll = function () {\n        return this.$animatedScroll;\n    };\n    VirtualRenderer.prototype.setShowInvisibles = function (showInvisibles) {\n        this.setOption(\"showInvisibles\", showInvisibles);\n        this.session.$bidiHandler.setShowInvisibles(showInvisibles);\n    };\n    VirtualRenderer.prototype.getShowInvisibles = function () {\n        return this.getOption(\"showInvisibles\");\n    };\n    VirtualRenderer.prototype.getDisplayIndentGuides = function () {\n        return this.getOption(\"displayIndentGuides\");\n    };\n    VirtualRenderer.prototype.setDisplayIndentGuides = function (display) {\n        this.setOption(\"displayIndentGuides\", display);\n    };\n    VirtualRenderer.prototype.getHighlightIndentGuides = function () {\n        return this.getOption(\"highlightIndentGuides\");\n    };\n    VirtualRenderer.prototype.setHighlightIndentGuides = function (highlight) {\n        this.setOption(\"highlightIndentGuides\", highlight);\n    };\n    VirtualRenderer.prototype.setShowPrintMargin = function (showPrintMargin) {\n        this.setOption(\"showPrintMargin\", showPrintMargin);\n    };\n    VirtualRenderer.prototype.getShowPrintMargin = function () {\n        return this.getOption(\"showPrintMargin\");\n    };\n    VirtualRenderer.prototype.setPrintMarginColumn = function (printMarginColumn) {\n        this.setOption(\"printMarginColumn\", printMarginColumn);\n    };\n    VirtualRenderer.prototype.getPrintMarginColumn = function () {\n        return this.getOption(\"printMarginColumn\");\n    };\n    VirtualRenderer.prototype.getShowGutter = function () {\n        return this.getOption(\"showGutter\");\n    };\n    VirtualRenderer.prototype.setShowGutter = function (show) {\n        return this.setOption(\"showGutter\", show);\n    };\n    VirtualRenderer.prototype.getFadeFoldWidgets = function () {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    VirtualRenderer.prototype.setFadeFoldWidgets = function (show) {\n        this.setOption(\"fadeFoldWidgets\", show);\n    };\n    VirtualRenderer.prototype.setHighlightGutterLine = function (shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n    VirtualRenderer.prototype.getHighlightGutterLine = function () {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    VirtualRenderer.prototype.$updatePrintMargin = function () {\n        if (!this.$showPrintMargin && !this.$printMarginEl)\n            return;\n        if (!this.$printMarginEl) {\n            var containerEl = dom.createElement(\"div\");\n            containerEl.className = \"ace_layer ace_print-margin-layer\";\n            this.$printMarginEl = dom.createElement(\"div\");\n            this.$printMarginEl.className = \"ace_print-margin\";\n            containerEl.appendChild(this.$printMarginEl);\n            this.content.insertBefore(containerEl, this.content.firstChild);\n        }\n        var style = this.$printMarginEl.style;\n        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + \"px\";\n        style.visibility = this.$showPrintMargin ? \"visible\" : \"hidden\";\n        if (this.session && this.session.$wrap == -1)\n            this.adjustWrapLimit();\n    };\n    VirtualRenderer.prototype.getContainerElement = function () {\n        return this.container;\n    };\n    VirtualRenderer.prototype.getMouseEventTarget = function () {\n        return this.scroller;\n    };\n    VirtualRenderer.prototype.getTextAreaContainer = function () {\n        return this.container;\n    };\n    VirtualRenderer.prototype.$moveTextAreaToCursor = function () {\n        if (this.$isMousePressed)\n            return;\n        var style = this.textarea.style;\n        var composition = this.$composition;\n        if (!this.$keepTextAreaAtCursor && !composition) {\n            dom.translate(this.textarea, -100, 0);\n            return;\n        }\n        var pixelPos = this.$cursorLayer.$pixelPos;\n        if (!pixelPos)\n            return;\n        if (composition && composition.markerRange)\n            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);\n        var config = this.layerConfig;\n        var posTop = pixelPos.top;\n        var posLeft = pixelPos.left;\n        posTop -= config.offset;\n        var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;\n        if (posTop < 0 || posTop > config.height - h) {\n            dom.translate(this.textarea, 0, 0);\n            return;\n        }\n        var w = 1;\n        var maxTop = this.$size.height - h;\n        if (!composition) {\n            posTop += this.lineHeight;\n        }\n        else {\n            if (composition.useTextareaForIME) {\n                var val = this.textarea.value;\n                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);\n            }\n            else {\n                posTop += this.lineHeight + 2;\n            }\n        }\n        posLeft -= this.scrollLeft;\n        if (posLeft > this.$size.scrollerWidth - w)\n            posLeft = this.$size.scrollerWidth - w;\n        posLeft += this.gutterWidth + this.margin.left;\n        dom.setStyle(style, \"height\", h + \"px\");\n        dom.setStyle(style, \"width\", w + \"px\");\n        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));\n    };\n    VirtualRenderer.prototype.getFirstVisibleRow = function () {\n        return this.layerConfig.firstRow;\n    };\n    VirtualRenderer.prototype.getFirstFullyVisibleRow = function () {\n        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);\n    };\n    VirtualRenderer.prototype.getLastFullyVisibleRow = function () {\n        var config = this.layerConfig;\n        var lastRow = config.lastRow;\n        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;\n        if (top - this.session.getScrollTop() > config.height - config.lineHeight)\n            return lastRow - 1;\n        return lastRow;\n    };\n    VirtualRenderer.prototype.getLastVisibleRow = function () {\n        return this.layerConfig.lastRow;\n    };\n    VirtualRenderer.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n        this.$textLayer.setPadding(padding);\n        this.$cursorLayer.setPadding(padding);\n        this.$markerFront.setPadding(padding);\n        this.$markerBack.setPadding(padding);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.$updatePrintMargin();\n    };\n    VirtualRenderer.prototype.setScrollMargin = function (top, bottom, left, right) {\n        var sm = this.scrollMargin;\n        sm.top = top | 0;\n        sm.bottom = bottom | 0;\n        sm.right = right | 0;\n        sm.left = left | 0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        if (sm.top && this.scrollTop <= 0 && this.session)\n            this.session.setScrollTop(-sm.top);\n        this.updateFull();\n    };\n    VirtualRenderer.prototype.setMargin = function (top, bottom, left, right) {\n        var sm = this.margin;\n        sm.top = top | 0;\n        sm.bottom = bottom | 0;\n        sm.right = right | 0;\n        sm.left = left | 0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);\n        this.updateFull();\n    };\n    VirtualRenderer.prototype.getHScrollBarAlwaysVisible = function () {\n        return this.$hScrollBarAlwaysVisible;\n    };\n    VirtualRenderer.prototype.setHScrollBarAlwaysVisible = function (alwaysVisible) {\n        this.setOption(\"hScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    VirtualRenderer.prototype.getVScrollBarAlwaysVisible = function () {\n        return this.$vScrollBarAlwaysVisible;\n    };\n    VirtualRenderer.prototype.setVScrollBarAlwaysVisible = function (alwaysVisible) {\n        this.setOption(\"vScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    VirtualRenderer.prototype.$updateScrollBarV = function () {\n        var scrollHeight = this.layerConfig.maxHeight;\n        var scrollerHeight = this.$size.scrollerHeight;\n        if (!this.$maxLines && this.$scrollPastEnd) {\n            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;\n            if (this.scrollTop > scrollHeight - scrollerHeight) {\n                scrollHeight = this.scrollTop + scrollerHeight;\n                this.scrollBarV.scrollTop = null;\n            }\n        }\n        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);\n        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);\n    };\n    VirtualRenderer.prototype.$updateScrollBarH = function () {\n        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);\n        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);\n    };\n    VirtualRenderer.prototype.freeze = function () {\n        this.$frozen = true;\n    };\n    VirtualRenderer.prototype.unfreeze = function () {\n        this.$frozen = false;\n    };\n    VirtualRenderer.prototype.$renderChanges = function (changes, force) {\n        if (this.$changes) {\n            changes |= this.$changes;\n            this.$changes = 0;\n        }\n        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {\n            this.$changes |= changes;\n            return;\n        }\n        if (this.$size.$dirty) {\n            this.$changes |= changes;\n            return this.onResize(true);\n        }\n        if (!this.lineHeight) {\n            this.$textLayer.checkForSizeChanges();\n        }\n        this._signal(\"beforeRender\", changes);\n        if (this.session && this.session.$bidiHandler)\n            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);\n        var config = this.layerConfig;\n        if (changes & this.CHANGE_FULL ||\n            changes & this.CHANGE_SIZE ||\n            changes & this.CHANGE_TEXT ||\n            changes & this.CHANGE_LINES ||\n            changes & this.CHANGE_SCROLL ||\n            changes & this.CHANGE_H_SCROLL) {\n            changes |= this.$computeLayerConfig() | this.$loop.clear();\n            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {\n                var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;\n                if (st > 0) {\n                    this.scrollTop = st;\n                    changes = changes | this.CHANGE_SCROLL;\n                    changes |= this.$computeLayerConfig() | this.$loop.clear();\n                }\n            }\n            config = this.layerConfig;\n            this.$updateScrollBarV();\n            if (changes & this.CHANGE_H_SCROLL)\n                this.$updateScrollBarH();\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            var width = config.width + 2 * this.$padding + \"px\";\n            var height = config.minHeight + \"px\";\n            dom.setStyle(this.content.style, \"width\", width);\n            dom.setStyle(this.content.style, \"height\", height);\n        }\n        if (changes & this.CHANGE_H_SCROLL) {\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            this.scroller.className = this.scrollLeft <= 0 ? \"ace_scroller \" : \"ace_scroller ace_scroll-left \";\n            if (this.enableKeyboardAccessibility)\n                this.scroller.className += this.keyboardFocusClassName;\n        }\n        if (changes & this.CHANGE_FULL) {\n            this.$changedLines = null;\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\", changes);\n            return;\n        }\n        if (changes & this.CHANGE_SCROLL) {\n            this.$changedLines = null;\n            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)\n                this.$textLayer.update(config);\n            else\n                this.$textLayer.scrollLines(config);\n            if (this.$showGutter) {\n                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)\n                    this.$gutterLayer.update(config);\n                else\n                    this.$gutterLayer.scrollLines(config);\n            }\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\", changes);\n            return;\n        }\n        if (changes & this.CHANGE_TEXT) {\n            this.$changedLines = null;\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        else if (changes & this.CHANGE_LINES) {\n            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        else if (changes & this.CHANGE_CURSOR) {\n            if (this.$highlightGutterLine)\n                this.$gutterLayer.updateLineHighlight(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        if (changes & this.CHANGE_CURSOR) {\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n        }\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {\n            this.$markerFront.update(config);\n        }\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {\n            this.$markerBack.update(config);\n        }\n        this._signal(\"afterRender\", changes);\n    };\n    VirtualRenderer.prototype.$autosize = function () {\n        var height = this.session.getScreenLength() * this.lineHeight;\n        var maxHeight = this.$maxLines * this.lineHeight;\n        var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);\n        if (this.$horizScroll)\n            desiredHeight += this.scrollBarH.getHeight();\n        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)\n            desiredHeight = this.$maxPixelHeight;\n        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;\n        var vScroll = !hideScrollbars && height > maxHeight;\n        if (desiredHeight != this.desiredHeight ||\n            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {\n            if (vScroll != this.$vScroll) {\n                this.$vScroll = vScroll;\n                this.scrollBarV.setVisible(vScroll);\n            }\n            var w = this.container.clientWidth;\n            this.container.style.height = desiredHeight + \"px\";\n            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);\n            this.desiredHeight = desiredHeight;\n            this._signal(\"autosize\");\n        }\n    };\n    VirtualRenderer.prototype.$computeLayerConfig = function () {\n        var session = this.session;\n        var size = this.$size;\n        var hideScrollbars = size.height <= 2 * this.lineHeight;\n        var screenLines = this.session.getScreenLength();\n        var maxHeight = screenLines * this.lineHeight;\n        var longestLine = this.$getLongestLine();\n        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||\n            size.scrollerWidth - longestLine - 2 * this.$padding < 0);\n        var hScrollChanged = this.$horizScroll !== horizScroll;\n        if (hScrollChanged) {\n            this.$horizScroll = horizScroll;\n            this.scrollBarH.setVisible(horizScroll);\n        }\n        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine\n        if (this.$maxLines && this.lineHeight > 1)\n            this.$autosize();\n        var minHeight = size.scrollerHeight + this.lineHeight;\n        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd\n            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd\n            : 0;\n        maxHeight += scrollPastEnd;\n        var sm = this.scrollMargin;\n        this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));\n        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));\n        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||\n            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);\n        var vScrollChanged = vScrollBefore !== vScroll;\n        if (vScrollChanged) {\n            this.$vScroll = vScroll;\n            this.scrollBarV.setVisible(vScroll);\n        }\n        var offset = this.scrollTop % this.lineHeight;\n        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;\n        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));\n        var lastRow = firstRow + lineCount;\n        var firstRowScreen, firstRowHeight;\n        var lineHeight = this.lineHeight;\n        firstRow = session.screenToDocumentRow(firstRow, 0);\n        var foldLine = session.getFoldLine(firstRow);\n        if (foldLine) {\n            firstRow = foldLine.start.row;\n        }\n        firstRowScreen = session.documentToScreenRow(firstRow, 0);\n        firstRowHeight = session.getRowLength(firstRow) * lineHeight;\n        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);\n        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +\n            firstRowHeight;\n        offset = this.scrollTop - firstRowScreen * lineHeight;\n        var changes = 0;\n        if (this.layerConfig.width != longestLine || hScrollChanged)\n            changes = this.CHANGE_H_SCROLL;\n        if (hScrollChanged || vScrollChanged) {\n            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);\n            this._signal(\"scrollbarVisibilityChanged\");\n            if (vScrollChanged)\n                longestLine = this.$getLongestLine();\n        }\n        this.layerConfig = {\n            width: longestLine,\n            padding: this.$padding,\n            firstRow: firstRow,\n            firstRowScreen: firstRowScreen,\n            lastRow: lastRow,\n            lineHeight: lineHeight,\n            characterWidth: this.characterWidth,\n            minHeight: minHeight,\n            maxHeight: maxHeight,\n            offset: offset,\n            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,\n            height: this.$size.scrollerHeight\n        };\n        if (this.session.$bidiHandler)\n            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);\n        return changes;\n    };\n    VirtualRenderer.prototype.$updateLines = function () {\n        if (!this.$changedLines)\n            return;\n        var firstRow = this.$changedLines.firstRow;\n        var lastRow = this.$changedLines.lastRow;\n        this.$changedLines = null;\n        var layerConfig = this.layerConfig;\n        if (firstRow > layerConfig.lastRow + 1) {\n            return;\n        }\n        if (lastRow < layerConfig.firstRow) {\n            return;\n        }\n        if (lastRow === Infinity) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(layerConfig);\n            this.$textLayer.update(layerConfig);\n            return;\n        }\n        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);\n        return true;\n    };\n    VirtualRenderer.prototype.$getLongestLine = function () {\n        var charCount = this.session.getScreenWidth();\n        if (this.showInvisibles && !this.session.$useWrapMode)\n            charCount += 1;\n        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)\n            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;\n        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));\n    };\n    VirtualRenderer.prototype.updateFrontMarkers = function () {\n        this.$markerFront.setMarkers(this.session.getMarkers(true));\n        this.$loop.schedule(this.CHANGE_MARKER_FRONT);\n    };\n    VirtualRenderer.prototype.updateBackMarkers = function () {\n        this.$markerBack.setMarkers(this.session.getMarkers());\n        this.$loop.schedule(this.CHANGE_MARKER_BACK);\n    };\n    VirtualRenderer.prototype.addGutterDecoration = function (row, className) {\n        this.$gutterLayer.addGutterDecoration(row, className);\n    };\n    VirtualRenderer.prototype.removeGutterDecoration = function (row, className) {\n        this.$gutterLayer.removeGutterDecoration(row, className);\n    };\n    VirtualRenderer.prototype.updateBreakpoints = function (rows) {\n        this._rows = rows;\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    VirtualRenderer.prototype.setAnnotations = function (annotations) {\n        this.$gutterLayer.setAnnotations(annotations);\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    VirtualRenderer.prototype.updateCursor = function () {\n        this.$loop.schedule(this.CHANGE_CURSOR);\n    };\n    VirtualRenderer.prototype.hideCursor = function () {\n        this.$cursorLayer.hideCursor();\n    };\n    VirtualRenderer.prototype.showCursor = function () {\n        this.$cursorLayer.showCursor();\n    };\n    VirtualRenderer.prototype.scrollSelectionIntoView = function (anchor, lead, offset) {\n        this.scrollCursorIntoView(anchor, offset);\n        this.scrollCursorIntoView(lead, offset);\n    };\n    VirtualRenderer.prototype.scrollCursorIntoView = function (cursor, offset, $viewMargin) {\n        if (this.$size.scrollerHeight === 0)\n            return;\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var newLeft = pos.left;\n        var newTop = pos.top;\n        var topMargin = $viewMargin && $viewMargin.top || 0;\n        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;\n        if (this.$scrollAnimation) {\n            this.$stopAnimation = true;\n        }\n        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;\n        if (currentTop + topMargin > newTop) {\n            if (offset && currentTop + topMargin > newTop + this.lineHeight)\n                newTop -= offset * this.$size.scrollerHeight;\n            if (newTop === 0)\n                newTop = -this.scrollMargin.top;\n            this.session.setScrollTop(newTop);\n        }\n        else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {\n            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)\n                newTop += offset * this.$size.scrollerHeight;\n            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);\n        }\n        var currentLeft = this.scrollLeft;\n        var twoCharsWidth = 2 * this.layerConfig.characterWidth;\n        if (newLeft - twoCharsWidth < currentLeft) {\n            newLeft -= twoCharsWidth;\n            if (newLeft < this.$padding + twoCharsWidth) {\n                newLeft = -this.scrollMargin.left;\n            }\n            this.session.setScrollLeft(newLeft);\n        }\n        else {\n            newLeft += twoCharsWidth;\n            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {\n                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));\n            }\n            else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {\n                this.session.setScrollLeft(0);\n            }\n        }\n    };\n    VirtualRenderer.prototype.getScrollTop = function () {\n        return this.session.getScrollTop();\n    };\n    VirtualRenderer.prototype.getScrollLeft = function () {\n        return this.session.getScrollLeft();\n    };\n    VirtualRenderer.prototype.getScrollTopRow = function () {\n        return this.scrollTop / this.lineHeight;\n    };\n    VirtualRenderer.prototype.getScrollBottomRow = function () {\n        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);\n    };\n    VirtualRenderer.prototype.scrollToRow = function (row) {\n        this.session.setScrollTop(row * this.lineHeight);\n    };\n    VirtualRenderer.prototype.alignCursor = function (cursor, alignment) {\n        if (typeof cursor == \"number\")\n            cursor = { row: cursor, column: 0 };\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var h = this.$size.scrollerHeight - this.lineHeight;\n        var offset = pos.top - h * (alignment || 0);\n        this.session.setScrollTop(offset);\n        return offset;\n    };\n    VirtualRenderer.prototype.$calcSteps = function (fromValue, toValue) {\n        var i = 0;\n        var l = this.STEPS;\n        var steps = [];\n        var func = function (t, x_min, dx) {\n            return dx * (Math.pow(t - 1, 3) + 1) + x_min;\n        };\n        for (i = 0; i < l; ++i)\n            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));\n        return steps;\n    };\n    VirtualRenderer.prototype.scrollToLine = function (line, center, animate, callback) {\n        var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });\n        var offset = pos.top;\n        if (center)\n            offset -= this.$size.scrollerHeight / 2;\n        var initialScroll = this.scrollTop;\n        this.session.setScrollTop(offset);\n        if (animate !== false)\n            this.animateScrolling(initialScroll, callback);\n    };\n    VirtualRenderer.prototype.animateScrolling = function (fromValue, callback) {\n        var toValue = this.scrollTop;\n        if (!this.$animatedScroll)\n            return;\n        var _self = this;\n        if (fromValue == toValue)\n            return;\n        if (this.$scrollAnimation) {\n            var oldSteps = this.$scrollAnimation.steps;\n            if (oldSteps.length) {\n                fromValue = oldSteps[0];\n                if (fromValue == toValue)\n                    return;\n            }\n        }\n        var steps = _self.$calcSteps(fromValue, toValue);\n        this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };\n        clearInterval(this.$timer);\n        _self.session.setScrollTop(steps.shift());\n        _self.session.$scrollTop = toValue;\n        function endAnimation() {\n            _self.$timer = clearInterval(_self.$timer);\n            _self.$scrollAnimation = null;\n            _self.$stopAnimation = false;\n            callback && callback();\n        }\n        this.$timer = setInterval(function () {\n            if (_self.$stopAnimation) {\n                endAnimation();\n                return;\n            }\n            if (!_self.session)\n                return clearInterval(_self.$timer);\n            if (steps.length) {\n                _self.session.setScrollTop(steps.shift());\n                _self.session.$scrollTop = toValue;\n            }\n            else if (toValue != null) {\n                _self.session.$scrollTop = -1;\n                _self.session.setScrollTop(toValue);\n                toValue = null;\n            }\n            else {\n                endAnimation();\n            }\n        }, 10);\n    };\n    VirtualRenderer.prototype.scrollToY = function (scrollTop) {\n        if (this.scrollTop !== scrollTop) {\n            this.$loop.schedule(this.CHANGE_SCROLL);\n            this.scrollTop = scrollTop;\n        }\n    };\n    VirtualRenderer.prototype.scrollToX = function (scrollLeft) {\n        if (this.scrollLeft !== scrollLeft)\n            this.scrollLeft = scrollLeft;\n        this.$loop.schedule(this.CHANGE_H_SCROLL);\n    };\n    VirtualRenderer.prototype.scrollTo = function (x, y) {\n        this.session.setScrollTop(y);\n        this.session.setScrollLeft(x);\n    };\n    VirtualRenderer.prototype.scrollBy = function (deltaX, deltaY) {\n        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);\n        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);\n    };\n    VirtualRenderer.prototype.isScrollableBy = function (deltaX, deltaY) {\n        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)\n            return true;\n        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight\n            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)\n            return true;\n        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)\n            return true;\n        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth\n            - this.layerConfig.width < -1 + this.scrollMargin.right)\n            return true;\n    };\n    VirtualRenderer.prototype.pixelToScreenCoordinates = function (x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = { top: 0, left: 0 };\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        }\n        else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n        return { row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX: offsetX };\n    };\n    VirtualRenderer.prototype.screenToTextCoordinates = function (x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = { top: 0, left: 0 };\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        }\n        else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);\n    };\n    VirtualRenderer.prototype.textToScreenCoordinates = function (row, column) {\n        var canvasPos = this.scroller.getBoundingClientRect();\n        var pos = this.session.documentToScreenPosition(row, column);\n        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : Math.round(pos.column * this.characterWidth));\n        var y = pos.row * this.lineHeight;\n        return {\n            pageX: canvasPos.left + x - this.scrollLeft,\n            pageY: canvasPos.top + y - this.scrollTop\n        };\n    };\n    VirtualRenderer.prototype.visualizeFocus = function () {\n        dom.addCssClass(this.container, \"ace_focus\");\n    };\n    VirtualRenderer.prototype.visualizeBlur = function () {\n        dom.removeCssClass(this.container, \"ace_focus\");\n    };\n    VirtualRenderer.prototype.showComposition = function (composition) {\n        this.$composition = composition;\n        if (!composition.cssText) {\n            composition.cssText = this.textarea.style.cssText;\n        }\n        if (composition.useTextareaForIME == undefined)\n            composition.useTextareaForIME = this.$useTextareaForIME;\n        if (this.$useTextareaForIME) {\n            dom.addCssClass(this.textarea, \"ace_composition\");\n            this.textarea.style.cssText = \"\";\n            this.$moveTextAreaToCursor();\n            this.$cursorLayer.element.style.display = \"none\";\n        }\n        else {\n            composition.markerId = this.session.addMarker(composition.markerRange, \"ace_composition_marker\", \"text\");\n        }\n    };\n    VirtualRenderer.prototype.setCompositionText = function (text) {\n        var cursor = this.session.selection.cursor;\n        this.addToken(text, \"composition_placeholder\", cursor.row, cursor.column);\n        this.$moveTextAreaToCursor();\n    };\n    VirtualRenderer.prototype.hideComposition = function () {\n        if (!this.$composition)\n            return;\n        if (this.$composition.markerId)\n            this.session.removeMarker(this.$composition.markerId);\n        dom.removeCssClass(this.textarea, \"ace_composition\");\n        this.textarea.style.cssText = this.$composition.cssText;\n        var cursor = this.session.selection.cursor;\n        this.removeExtraToken(cursor.row, cursor.column);\n        this.$composition = null;\n        this.$cursorLayer.element.style.display = \"\";\n    };\n    VirtualRenderer.prototype.setGhostText = function (text, position) {\n        var cursor = this.session.selection.cursor;\n        var insertPosition = position || { row: cursor.row, column: cursor.column };\n        this.removeGhostText();\n        var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);\n        this.addToken(textChunks[0].text, \"ghost_text\", insertPosition.row, insertPosition.column);\n        this.$ghostText = {\n            text: text,\n            position: {\n                row: insertPosition.row,\n                column: insertPosition.column\n            }\n        };\n        var widgetDiv = dom.createElement(\"div\");\n        if (textChunks.length > 1) {\n            var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);\n            var lastLineDiv;\n            textChunks.slice(1).forEach(function (el) {\n                var chunkDiv = dom.createElement(\"div\");\n                var chunkSpan = dom.createElement(\"span\");\n                chunkSpan.className = \"ace_ghost_text\";\n                if (el.wrapped)\n                    chunkDiv.className = \"ghost_text_line_wrapped\";\n                if (el.text.length === 0)\n                    el.text = \" \";\n                chunkSpan.appendChild(dom.createTextNode(el.text));\n                chunkDiv.appendChild(chunkSpan);\n                widgetDiv.appendChild(chunkDiv);\n                lastLineDiv = chunkDiv;\n            });\n            hiddenTokens.forEach(function (token) {\n                var element = dom.createElement(\"span\");\n                if (!isTextToken(token.type))\n                    element.className = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n                element.appendChild(dom.createTextNode(token.value));\n                lastLineDiv.appendChild(element);\n            });\n            this.$ghostTextWidget = {\n                el: widgetDiv,\n                row: insertPosition.row,\n                column: insertPosition.column,\n                className: \"ace_ghost_text_container\"\n            };\n            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);\n            var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);\n            var el = this.container;\n            var height = el.getBoundingClientRect().height;\n            var ghostTextHeight = textChunks.length * this.lineHeight;\n            var fitsY = ghostTextHeight < (height - pixelPosition.top);\n            if (fitsY)\n                return;\n            if (ghostTextHeight < height) {\n                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);\n            }\n            else {\n                this.scrollToRow(insertPosition.row);\n            }\n        }\n    };\n    VirtualRenderer.prototype.$calculateWrappedTextChunks = function (text, position) {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth) - 2;\n        limit = limit <= 0 ? 60 : limit; // this is a hack to prevent the editor from crashing when the window is too small\n        var textLines = text.split(/\\r?\\n/);\n        var textChunks = [];\n        for (var i = 0; i < textLines.length; i++) {\n            var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);\n            var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);\n            if (wrapSplits.length > 0) {\n                var start = 0;\n                wrapSplits.push(textLines[i].length);\n                for (var j = 0; j < wrapSplits.length; j++) {\n                    var textSlice = textLines[i].slice(start, wrapSplits[j]);\n                    textChunks.push({ text: textSlice, wrapped: true });\n                    start = wrapSplits[j];\n                }\n            }\n            else {\n                textChunks.push({ text: textLines[i], wrapped: false });\n            }\n        }\n        return textChunks;\n    };\n    VirtualRenderer.prototype.removeGhostText = function () {\n        if (!this.$ghostText)\n            return;\n        var position = this.$ghostText.position;\n        this.removeExtraToken(position.row, position.column);\n        if (this.$ghostTextWidget) {\n            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);\n            this.$ghostTextWidget = null;\n        }\n        this.$ghostText = null;\n    };\n    VirtualRenderer.prototype.addToken = function (text, type, row, column) {\n        var session = this.session;\n        session.bgTokenizer.lines[row] = null;\n        var newToken = { type: type, value: text };\n        var tokens = session.getTokens(row);\n        if (column == null || !tokens.length) {\n            tokens.push(newToken);\n        }\n        else {\n            var l = 0;\n            for (var i = 0; i < tokens.length; i++) {\n                var token = tokens[i];\n                l += token.value.length;\n                if (column <= l) {\n                    var diff = token.value.length - (l - column);\n                    var before = token.value.slice(0, diff);\n                    var after = token.value.slice(diff);\n                    tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });\n                    break;\n                }\n            }\n        }\n        this.updateLines(row, row);\n    };\n    VirtualRenderer.prototype.hideTokensAfterPosition = function (row, column) {\n        var tokens = this.session.getTokens(row);\n        var l = 0;\n        var hasPassedCursor = false;\n        var hiddenTokens = [];\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            l += token.value.length;\n            if (token.type === \"ghost_text\")\n                continue;\n            if (hasPassedCursor) {\n                hiddenTokens.push({ type: token.type, value: token.value });\n                token.type = \"hidden_token\";\n                continue;\n            }\n            if (l === column) {\n                hasPassedCursor = true;\n            }\n        }\n        this.updateLines(row, row);\n        return hiddenTokens;\n    };\n    VirtualRenderer.prototype.removeExtraToken = function (row, column) {\n        this.session.bgTokenizer.lines[row] = null;\n        this.updateLines(row, row);\n    };\n    VirtualRenderer.prototype.setTheme = function (theme, cb) {\n        var _self = this;\n        this.$themeId = theme;\n        _self._dispatchEvent('themeChange', { theme: theme });\n        if (!theme || typeof theme == \"string\") {\n            var moduleName = theme || this.$options.theme.initialValue;\n            config.loadModule([\"theme\", moduleName], afterLoad);\n        }\n        else {\n            afterLoad(theme);\n        }\n        function afterLoad(module) {\n            if (_self.$themeId != theme)\n                return cb && cb();\n            if (!module || !module.cssClass)\n                throw new Error(\"couldn't load module \" + theme + \" or it didn't call define\");\n            if (module.$id)\n                _self.$themeId = module.$id;\n            dom.importCssString(module.cssText, module.cssClass, _self.container);\n            if (_self.theme)\n                dom.removeCssClass(_self.container, _self.theme.cssClass);\n            var padding = \"padding\" in module ? module.padding\n                : \"padding\" in (_self.theme || {}) ? 4 : _self.$padding;\n            if (_self.$padding && padding != _self.$padding)\n                _self.setPadding(padding);\n            _self.$theme = module.cssClass;\n            _self.theme = module;\n            dom.addCssClass(_self.container, module.cssClass);\n            dom.setCssClass(_self.container, \"ace_dark\", module.isDark);\n            if (_self.$size) {\n                _self.$size.width = 0;\n                _self.$updateSizeAsync();\n            }\n            _self._dispatchEvent('themeLoaded', { theme: module });\n            cb && cb();\n            if (useragent.isSafari && _self.scroller) {\n                _self.scroller.style.background = \"red\";\n                _self.scroller.style.background = \"\";\n            }\n        }\n    };\n    VirtualRenderer.prototype.getTheme = function () {\n        return this.$themeId;\n    };\n    VirtualRenderer.prototype.setStyle = function (style, include) {\n        dom.setCssClass(this.container, style, include !== false);\n    };\n    VirtualRenderer.prototype.unsetStyle = function (style) {\n        dom.removeCssClass(this.container, style);\n    };\n    VirtualRenderer.prototype.setCursorStyle = function (style) {\n        dom.setStyle(this.scroller.style, \"cursor\", style);\n    };\n    VirtualRenderer.prototype.setMouseCursor = function (cursorStyle) {\n        dom.setStyle(this.scroller.style, \"cursor\", cursorStyle);\n    };\n    VirtualRenderer.prototype.attachToShadowRoot = function () {\n        dom.importCssString(editorCss, \"ace_editor.css\", this.container);\n    };\n    VirtualRenderer.prototype.destroy = function () {\n        this.freeze();\n        this.$fontMetrics.destroy();\n        this.$cursorLayer.destroy();\n        this.removeAllListeners();\n        this.container.textContent = \"\";\n        this.setOption(\"useResizeObserver\", false);\n    };\n    VirtualRenderer.prototype.$updateCustomScrollbar = function (val) {\n        var _self = this;\n        this.$horizScroll = this.$vScroll = null;\n        this.scrollBarV.element.remove();\n        this.scrollBarH.element.remove();\n        if (this.$scrollDecorator) {\n            delete this.$scrollDecorator;\n        }\n        if (val === true) {\n            this.scrollBarV = new VScrollBarCustom(this.container, this);\n            this.scrollBarH = new HScrollBarCustom(this.container, this);\n            this.scrollBarV.setHeight(this.$size.scrollerHeight);\n            this.scrollBarH.setWidth(this.$size.scrollerWidth);\n            this.scrollBarV.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n            });\n            this.scrollBarH.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n            });\n            this.$scrollDecorator = new Decorator(this.scrollBarV, this);\n            this.$scrollDecorator.$updateDecorators();\n        }\n        else {\n            this.scrollBarV = new VScrollBar(this.container, this);\n            this.scrollBarH = new HScrollBar(this.container, this);\n            this.scrollBarV.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n            });\n            this.scrollBarH.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n            });\n        }\n    };\n    VirtualRenderer.prototype.$addResizeObserver = function () {\n        if (!window.ResizeObserver || this.$resizeObserver)\n            return;\n        var self = this;\n        this.$resizeTimer = lang.delayedCall(function () {\n            if (!self.destroyed)\n                self.onResize();\n        }, 50);\n        this.$resizeObserver = new window.ResizeObserver(function (e) {\n            var w = e[0].contentRect.width;\n            var h = e[0].contentRect.height;\n            if (Math.abs(self.$size.width - w) > 1\n                || Math.abs(self.$size.height - h) > 1) {\n                self.$resizeTimer.delay();\n            }\n            else {\n                self.$resizeTimer.cancel();\n            }\n        });\n        this.$resizeObserver.observe(this.container);\n    };\n    return VirtualRenderer;\n}());\nVirtualRenderer.prototype.CHANGE_CURSOR = 1;\nVirtualRenderer.prototype.CHANGE_MARKER = 2;\nVirtualRenderer.prototype.CHANGE_GUTTER = 4;\nVirtualRenderer.prototype.CHANGE_SCROLL = 8;\nVirtualRenderer.prototype.CHANGE_LINES = 16;\nVirtualRenderer.prototype.CHANGE_TEXT = 32;\nVirtualRenderer.prototype.CHANGE_SIZE = 64;\nVirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;\nVirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;\nVirtualRenderer.prototype.CHANGE_FULL = 512;\nVirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;\nVirtualRenderer.prototype.$changes = 0;\nVirtualRenderer.prototype.$padding = null;\nVirtualRenderer.prototype.$frozen = false;\nVirtualRenderer.prototype.STEPS = 8;\noop.implement(VirtualRenderer.prototype, EventEmitter);\nconfig.defineOptions(VirtualRenderer.prototype, \"renderer\", {\n    useResizeObserver: {\n        set: function (value) {\n            if (!value && this.$resizeObserver) {\n                this.$resizeObserver.disconnect();\n                this.$resizeTimer.cancel();\n                this.$resizeTimer = this.$resizeObserver = null;\n            }\n            else if (value && !this.$resizeObserver) {\n                this.$addResizeObserver();\n            }\n        }\n    },\n    animatedScroll: { initialValue: false },\n    showInvisibles: {\n        set: function (value) {\n            if (this.$textLayer.setShowInvisibles(value))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: false\n    },\n    showPrintMargin: {\n        set: function () { this.$updatePrintMargin(); },\n        initialValue: true\n    },\n    printMarginColumn: {\n        set: function () { this.$updatePrintMargin(); },\n        initialValue: 80\n    },\n    printMargin: {\n        set: function (val) {\n            if (typeof val == \"number\")\n                this.$printMarginColumn = val;\n            this.$showPrintMargin = !!val;\n            this.$updatePrintMargin();\n        },\n        get: function () {\n            return this.$showPrintMargin && this.$printMarginColumn;\n        }\n    },\n    showGutter: {\n        set: function (show) {\n            this.$gutter.style.display = show ? \"block\" : \"none\";\n            this.$loop.schedule(this.CHANGE_FULL);\n            this.onGutterResize();\n        },\n        initialValue: true\n    },\n    useSvgGutterIcons: {\n        set: function (value) {\n            this.$gutterLayer.$useSvgGutterIcons = value;\n        },\n        initialValue: false\n    },\n    showFoldedAnnotations: {\n        set: function (value) {\n            this.$gutterLayer.$showFoldedAnnotations = value;\n        },\n        initialValue: false\n    },\n    fadeFoldWidgets: {\n        set: function (show) {\n            dom.setCssClass(this.$gutter, \"ace_fade-fold-widgets\", show);\n        },\n        initialValue: false\n    },\n    showFoldWidgets: {\n        set: function (show) {\n            this.$gutterLayer.setShowFoldWidgets(show);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    displayIndentGuides: {\n        set: function (show) {\n            if (this.$textLayer.setDisplayIndentGuides(show))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: true\n    },\n    highlightIndentGuides: {\n        set: function (show) {\n            if (this.$textLayer.setHighlightIndentGuides(show) == true) {\n                this.$textLayer.$highlightIndentGuide();\n            }\n            else {\n                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);\n            }\n        },\n        initialValue: true\n    },\n    highlightGutterLine: {\n        set: function (shouldHighlight) {\n            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    hScrollBarAlwaysVisible: {\n        set: function (val) {\n            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    vScrollBarAlwaysVisible: {\n        set: function (val) {\n            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    fontSize: {\n        set: function (size) {\n            if (typeof size == \"number\")\n                size = size + \"px\";\n            this.container.style.fontSize = size;\n            this.updateFontSize();\n        },\n        initialValue: 12\n    },\n    fontFamily: {\n        set: function (name) {\n            this.container.style.fontFamily = name;\n            this.updateFontSize();\n        }\n    },\n    maxLines: {\n        set: function (val) {\n            this.updateFull();\n        }\n    },\n    minLines: {\n        set: function (val) {\n            if (!(this.$minLines < 0x1ffffffffffff))\n                this.$minLines = 0;\n            this.updateFull();\n        }\n    },\n    maxPixelHeight: {\n        set: function (val) {\n            this.updateFull();\n        },\n        initialValue: 0\n    },\n    scrollPastEnd: {\n        set: function (val) {\n            val = +val || 0;\n            if (this.$scrollPastEnd == val)\n                return;\n            this.$scrollPastEnd = val;\n            this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: 0,\n        handlesSet: true\n    },\n    fixedWidthGutter: {\n        set: function (val) {\n            this.$gutterLayer.$fixedWidth = !!val;\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        }\n    },\n    customScrollbar: {\n        set: function (val) {\n            this.$updateCustomScrollbar(val);\n        },\n        initialValue: false\n    },\n    theme: {\n        set: function (val) { this.setTheme(val); },\n        get: function () { return this.$themeId || this.theme; },\n        initialValue: \"./theme/textmate\",\n        handlesSet: true\n    },\n    hasCssTransforms: {},\n    useTextareaForIME: {\n        initialValue: !useragent.isMobile && !useragent.isIE\n    }\n});\nexports.VirtualRenderer = VirtualRenderer;\n\n});\n\nace.define(\"ace/worker/worker_client\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar net = require(\"../lib/net\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar config = require(\"../config\");\n\nfunction $workerBlob(workerUrl) {\n    var script = \"importScripts('\" + net.qualifyURL(workerUrl) + \"');\";\n    try {\n        return new Blob([script], {\"type\": \"application/javascript\"});\n    } catch (e) { // Backwards-compatibility\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n        var blobBuilder = new BlobBuilder();\n        blobBuilder.append(script);\n        return blobBuilder.getBlob(\"application/javascript\");\n    }\n}\n\nfunction createWorker(workerUrl) {\n    if (typeof Worker == \"undefined\")\n        return { postMessage: function() {}, terminate: function() {} };\n    if (config.get(\"loadWorkerFromBlob\")) {\n        var blob = $workerBlob(workerUrl);\n        var URL = window.URL || window.webkitURL;\n        var blobURL = URL.createObjectURL(blob);\n        return new Worker(blobURL);\n    }\n    return new Worker(workerUrl);\n}\n\nvar WorkerClient = function(worker) {\n    if (!worker.postMessage)\n        worker = this.$createWorkerFromOldConfig.apply(this, arguments);\n\n    this.$worker = worker;\n    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n    this.changeListener = this.changeListener.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n\n    this.callbackId = 1;\n    this.callbacks = {};\n\n    this.$worker.onmessage = this.onMessage;\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {\n        if (require.nameToUrl && !require.toUrl)\n            require.toUrl = require.nameToUrl;\n\n        if (config.get(\"packaged\") || !require.toUrl) {\n            workerUrl = workerUrl || config.moduleUrl(mod, \"worker\");\n        } else {\n            var normalizePath = this.$normalizePath;\n            workerUrl = workerUrl || normalizePath(require.toUrl(\"ace/worker/worker.js\", null, \"_\"));\n\n            var tlns = {};\n            topLevelNamespaces.forEach(function(ns) {\n                tlns[ns] = normalizePath(require.toUrl(ns, null, \"_\").replace(/(\\.js)?(\\?.*)?$/, \"\"));\n            });\n        }\n\n        this.$worker = createWorker(workerUrl);\n        if (importScripts) {\n            this.send(\"importScripts\", importScripts);\n        }\n        this.$worker.postMessage({\n            init : true,\n            tlns : tlns,\n            module : mod,\n            classname : classname\n        });\n        return this.$worker;\n    };\n\n    this.onMessage = function(e) {\n        var msg = e.data;\n        switch (msg.type) {\n            case \"event\":\n                this._signal(msg.name, {data: msg.data});\n                break;\n            case \"call\":\n                var callback = this.callbacks[msg.id];\n                if (callback) {\n                    callback(msg.data);\n                    delete this.callbacks[msg.id];\n                }\n                break;\n            case \"error\":\n                this.reportError(msg.data);\n                break;\n            case \"log\":\n                window.console && console.log && console.log.apply(console, msg.data);\n                break;\n        }\n    };\n    \n    this.reportError = function(err) {\n        window.console && console.error && console.error(err);\n    };\n\n    this.$normalizePath = function(path) {\n        return net.qualifyURL(path);\n    };\n\n    this.terminate = function() {\n        this._signal(\"terminate\", {});\n        this.deltaQueue = null;\n        this.$worker.terminate();\n        this.$worker.onerror = function(e) {\n            e.preventDefault();\n        };\n        this.$worker = null;\n        if (this.$doc)\n            this.$doc.off(\"change\", this.changeListener);\n        this.$doc = null;\n    };\n\n    this.send = function(cmd, args) {\n        this.$worker.postMessage({command: cmd, args: args});\n    };\n\n    this.call = function(cmd, args, callback) {\n        if (callback) {\n            var id = this.callbackId++;\n            this.callbacks[id] = callback;\n            args.push(id);\n        }\n        this.send(cmd, args);\n    };\n\n    this.emit = function(event, data) {\n        try {\n            if (data.data && data.data.err)\n                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};\n                this.$worker && this.$worker.postMessage({event: event, data: {data: data.data}});\n        }\n        catch(ex) {\n            console.error(ex.stack);\n        }\n    };\n\n    this.attachToDocument = function(doc) {\n        if (this.$doc)\n            this.terminate();\n\n        this.$doc = doc;\n        this.call(\"setValue\", [doc.getValue()]);\n        doc.on(\"change\", this.changeListener, true);\n    };\n\n    this.changeListener = function(delta) {\n        if (!this.deltaQueue) {\n            this.deltaQueue = [];\n            setTimeout(this.$sendDeltaQueue, 0);\n        }\n        if (delta.action == \"insert\")\n            this.deltaQueue.push(delta.start, delta.lines);\n        else\n            this.deltaQueue.push(delta.start, delta.end);\n    };\n\n    this.$sendDeltaQueue = function() {\n        var q = this.deltaQueue;\n        if (!q) return;\n        this.deltaQueue = null;\n        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {\n            this.call(\"setValue\", [this.$doc.getValue()]);\n        } else\n            this.emit(\"change\", {data: q});\n    };\n\n}).call(WorkerClient.prototype);\n\n\nvar UIWorkerClient = function(topLevelNamespaces, mod, classname) {\n    var main = null;\n    var emitSync = false;\n    var sender = Object.create(EventEmitter);\n\n    var messageBuffer = [];\n    var workerClient = new WorkerClient({\n        messageBuffer: messageBuffer,\n        terminate: function() {},\n        postMessage: function(e) {\n            messageBuffer.push(e);\n            if (!main) return;\n            if (emitSync)\n                setTimeout(processNext);\n            else\n                processNext();\n        }\n    });\n\n    workerClient.setEmitSync = function(val) { emitSync = val; };\n\n    var processNext = function() {\n        var msg = messageBuffer.shift();\n        if (msg.command)\n            main[msg.command].apply(main, msg.args);\n        else if (msg.event)\n            sender._signal(msg.event, msg.data);\n    };\n\n    sender.postMessage = function(msg) {\n        workerClient.onMessage({data: msg});\n    };\n    sender.callback = function(data, callbackId) {\n        this.postMessage({type: \"call\", id: callbackId, data: data});\n    };\n    sender.emit = function(name, data) {\n        this.postMessage({type: \"event\", name: name, data: data});\n    };\n\n    config.loadModule([\"worker\", mod], function(Main) {\n        main = new Main[classname](sender);\n        while (messageBuffer.length)\n            processNext();\n    });\n\n    return workerClient;\n};\n\nexports.UIWorkerClient = UIWorkerClient;\nexports.WorkerClient = WorkerClient;\nexports.createWorker = createWorker;\n\n\n});\n\nace.define(\"ace/placeholder\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/oop\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar oop = require(\"./lib/oop\");\nvar PlaceHolder = /** @class */ (function () {\n    function PlaceHolder(session, length, pos, others, mainClass, othersClass) {\n        var _self = this;\n        this.length = length;\n        this.session = session;\n        this.doc = session.getDocument();\n        this.mainClass = mainClass;\n        this.othersClass = othersClass;\n        this.$onUpdate = this.onUpdate.bind(this);\n        this.doc.on(\"change\", this.$onUpdate, true);\n        this.$others = others;\n        this.$onCursorChange = function () {\n            setTimeout(function () {\n                _self.onCursorChange();\n            });\n        };\n        this.$pos = pos;\n        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()[\"$undostack\"] || { length: -1 };\n        this.$undoStackDepth = undoStack.length;\n        this.setup();\n        session.selection.on(\"changeCursor\", this.$onCursorChange);\n    }\n    PlaceHolder.prototype.setup = function () {\n        var _self = this;\n        var doc = this.doc;\n        var session = this.session;\n        this.selectionBefore = session.selection.toJSON();\n        if (session.selection.inMultiSelectMode)\n            session.selection.toSingleRange();\n        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);\n        var pos = this.pos;\n        pos.$insertRight = true;\n        pos.detach();\n        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);\n        this.others = [];\n        this.$others.forEach(function (other) {\n            var anchor = doc.createAnchor(other.row, other.column);\n            anchor.$insertRight = true;\n            anchor.detach();\n            _self.others.push(anchor);\n        });\n        session.setUndoSelect(false);\n    };\n    PlaceHolder.prototype.showOtherMarkers = function () {\n        if (this.othersActive)\n            return;\n        var session = this.session;\n        var _self = this;\n        this.othersActive = true;\n        this.others.forEach(function (anchor) {\n            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);\n        });\n    };\n    PlaceHolder.prototype.hideOtherMarkers = function () {\n        if (!this.othersActive)\n            return;\n        this.othersActive = false;\n        for (var i = 0; i < this.others.length; i++) {\n            this.session.removeMarker(this.others[i].markerId);\n        }\n    };\n    PlaceHolder.prototype.onUpdate = function (delta) {\n        if (this.$updating)\n            return this.updateAnchors(delta);\n        var range = delta;\n        if (range.start.row !== range.end.row)\n            return;\n        if (range.start.row !== this.pos.row)\n            return;\n        this.$updating = true;\n        var lengthDiff = delta.action === \"insert\" ? range.end.column - range.start.column : range.start.column - range.end.column;\n        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;\n        var distanceFromStart = range.start.column - this.pos.column;\n        this.updateAnchors(delta);\n        if (inMainRange)\n            this.length += lengthDiff;\n        if (inMainRange && !this.session.$fromUndo) {\n            if (delta.action === 'insert') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };\n                    this.doc.insertMergedLines(newPos, delta.lines);\n                }\n            }\n            else if (delta.action === 'remove') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };\n                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));\n                }\n            }\n        }\n        this.$updating = false;\n        this.updateMarkers();\n    };\n    PlaceHolder.prototype.updateAnchors = function (delta) {\n        this.pos.onChange(delta);\n        for (var i = this.others.length; i--;)\n            this.others[i].onChange(delta);\n        this.updateMarkers();\n    };\n    PlaceHolder.prototype.updateMarkers = function () {\n        if (this.$updating)\n            return;\n        var _self = this;\n        var session = this.session;\n        var updateMarker = function (pos, className) {\n            session.removeMarker(pos.markerId);\n            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);\n        };\n        updateMarker(this.pos, this.mainClass);\n        for (var i = this.others.length; i--;)\n            updateMarker(this.others[i], this.othersClass);\n    };\n    PlaceHolder.prototype.onCursorChange = function (event) {\n        if (this.$updating || !this.session)\n            return;\n        var pos = this.session.selection.getCursor();\n        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {\n            this.showOtherMarkers();\n            this._emit(\"cursorEnter\", event);\n        }\n        else {\n            this.hideOtherMarkers();\n            this._emit(\"cursorLeave\", event);\n        }\n    };\n    PlaceHolder.prototype.detach = function () {\n        this.session.removeMarker(this.pos && this.pos.markerId);\n        this.hideOtherMarkers();\n        this.doc.off(\"change\", this.$onUpdate);\n        this.session.selection.off(\"changeCursor\", this.$onCursorChange);\n        this.session.setUndoSelect(true);\n        this.session = null;\n    };\n    PlaceHolder.prototype.cancel = function () {\n        if (this.$undoStackDepth === -1)\n            return;\n        var undoManager = this.session.getUndoManager();\n        var undosRequired = (undoManager.$undoStack || undoManager[\"$undostack\"]).length - this.$undoStackDepth;\n        for (var i = 0; i < undosRequired; i++) {\n            undoManager.undo(this.session, true);\n        }\n        if (this.selectionBefore)\n            this.session.selection.fromJSON(this.selectionBefore);\n    };\n    return PlaceHolder;\n}());\noop.implement(PlaceHolder.prototype, EventEmitter);\nexports.PlaceHolder = PlaceHolder;\n\n});\n\nace.define(\"ace/mouse/multi_select_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module){var event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nfunction onMouseDown(e) {\n    var ev = e.domEvent;\n    var alt = ev.altKey;\n    var shift = ev.shiftKey;\n    var ctrl = ev.ctrlKey;\n    var accel = e.getAccelKey();\n    var button = e.getButton();\n    if (ctrl && useragent.isMac)\n        button = ev.button;\n    if (e.editor.inMultiSelectMode && button == 2) {\n        e.editor.textInput.onContextMenu(e.domEvent);\n        return;\n    }\n    if (!ctrl && !alt && !accel) {\n        if (button === 0 && e.editor.inMultiSelectMode)\n            e.editor.exitMultiSelectMode();\n        return;\n    }\n    if (button !== 0)\n        return;\n    var editor = e.editor;\n    var selection = editor.selection;\n    var isMultiSelect = editor.inMultiSelectMode;\n    var pos = e.getDocumentPosition();\n    var cursor = selection.getCursor();\n    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));\n    var mouseX = e.x, mouseY = e.y;\n    var onMouseSelection = function (e) {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    var session = editor.session;\n    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n    var screenCursor = screenAnchor;\n    var selectionMode;\n    if (editor.$mouseHandler.$enableJumpToDef) {\n        if (ctrl && alt || accel && alt)\n            selectionMode = shift ? \"block\" : \"add\";\n        else if (alt && editor.$blockSelectEnabled)\n            selectionMode = \"block\";\n    }\n    else {\n        if (accel && !alt) {\n            selectionMode = \"add\";\n            if (!isMultiSelect && shift)\n                return;\n        }\n        else if (alt && editor.$blockSelectEnabled) {\n            selectionMode = \"block\";\n        }\n    }\n    if (selectionMode && useragent.isMac && ev.ctrlKey) {\n        editor.$mouseHandler.cancelContextMenu();\n    }\n    if (selectionMode == \"add\") {\n        if (!isMultiSelect && inSelection)\n            return; // dragging\n        if (!isMultiSelect) {\n            var range = selection.toOrientedRange();\n            editor.addSelectionMarker(range);\n        }\n        var oldRange = selection.rangeList.rangeAtPoint(pos);\n        editor.inVirtualSelectionMode = true;\n        if (shift) {\n            oldRange = null;\n            range = selection.ranges[0] || range;\n            editor.removeSelectionMarker(range);\n        }\n        editor.once(\"mouseup\", function () {\n            var tmpSel = selection.toOrientedRange();\n            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))\n                selection.substractPoint(tmpSel.cursor);\n            else {\n                if (shift) {\n                    selection.substractPoint(range.cursor);\n                }\n                else if (range) {\n                    editor.removeSelectionMarker(range);\n                    selection.addRange(range);\n                }\n                selection.addRange(tmpSel);\n            }\n            editor.inVirtualSelectionMode = false;\n        });\n    }\n    else if (selectionMode == \"block\") {\n        e.stop();\n        editor.inVirtualSelectionMode = true;\n        var initialRange;\n        var rectSel = [];\n        var blockSelect = function () {\n            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);\n            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))\n                return;\n            screenCursor = newCursor;\n            editor.selection.moveToPosition(cursor);\n            editor.renderer.scrollCursorIntoView();\n            editor.removeSelectionMarkers(rectSel);\n            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);\n            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())\n                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();\n            rectSel.forEach(editor.addSelectionMarker, editor);\n            editor.updateSelectionMarkers();\n        };\n        if (isMultiSelect && !accel) {\n            selection.toSingleRange();\n        }\n        else if (!isMultiSelect && accel) {\n            initialRange = selection.toOrientedRange();\n            editor.addSelectionMarker(initialRange);\n        }\n        if (shift)\n            screenAnchor = session.documentToScreenPosition(selection.lead);\n        else\n            selection.moveToPosition(pos);\n        screenCursor = { row: -1, column: -1 };\n        var onMouseSelectionEnd = function (e) {\n            blockSelect();\n            clearInterval(timerId);\n            editor.removeSelectionMarkers(rectSel);\n            if (!rectSel.length)\n                rectSel = [selection.toOrientedRange()];\n            if (initialRange) {\n                editor.removeSelectionMarker(initialRange);\n                selection.toSingleRange(initialRange);\n            }\n            for (var i = 0; i < rectSel.length; i++)\n                selection.addRange(rectSel[i]);\n            editor.inVirtualSelectionMode = false;\n            editor.$mouseHandler.$clickSelection = null;\n        };\n        var onSelectionInterval = blockSelect;\n        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);\n        var timerId = setInterval(function () { onSelectionInterval(); }, 20);\n        return e.preventDefault();\n    }\n}\nexports.onMouseDown = onMouseDown;\n\n});\n\nace.define(\"ace/commands/multi_select_commands\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\"], function(require, exports, module){/**\n * commands to enter multiselect mode\n * @type {import(\"../../ace-internal\").Ace.Command[]}\n */\nexports.defaultCommands = [{\n        name: \"addCursorAbove\",\n        description: \"Add cursor above\",\n        exec: function (editor) { editor.selectMoreLines(-1); },\n        bindKey: { win: \"Ctrl-Alt-Up\", mac: \"Ctrl-Alt-Up\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"addCursorBelow\",\n        description: \"Add cursor below\",\n        exec: function (editor) { editor.selectMoreLines(1); },\n        bindKey: { win: \"Ctrl-Alt-Down\", mac: \"Ctrl-Alt-Down\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"addCursorAboveSkipCurrent\",\n        description: \"Add cursor above (skip current)\",\n        exec: function (editor) { editor.selectMoreLines(-1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Up\", mac: \"Ctrl-Alt-Shift-Up\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"addCursorBelowSkipCurrent\",\n        description: \"Add cursor below (skip current)\",\n        exec: function (editor) { editor.selectMoreLines(1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Down\", mac: \"Ctrl-Alt-Shift-Down\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectMoreBefore\",\n        description: \"Select more before\",\n        exec: function (editor) { editor.selectMore(-1); },\n        bindKey: { win: \"Ctrl-Alt-Left\", mac: \"Ctrl-Alt-Left\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectMoreAfter\",\n        description: \"Select more after\",\n        exec: function (editor) { editor.selectMore(1); },\n        bindKey: { win: \"Ctrl-Alt-Right\", mac: \"Ctrl-Alt-Right\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectNextBefore\",\n        description: \"Select next before\",\n        exec: function (editor) { editor.selectMore(-1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Left\", mac: \"Ctrl-Alt-Shift-Left\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectNextAfter\",\n        description: \"Select next after\",\n        exec: function (editor) { editor.selectMore(1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Right\", mac: \"Ctrl-Alt-Shift-Right\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"toggleSplitSelectionIntoLines\",\n        description: \"Split selection into lines\",\n        exec: function (editor) {\n            if (editor.multiSelect.rangeCount > 1)\n                editor.multiSelect.joinSelections();\n            else\n                editor.multiSelect.splitIntoLines();\n        },\n        bindKey: { win: \"Ctrl-Alt-L\", mac: \"Ctrl-Alt-L\" },\n        readOnly: true\n    }, {\n        name: \"splitSelectionIntoLines\",\n        description: \"Split into lines\",\n        exec: function (editor) { editor.multiSelect.splitIntoLines(); },\n        readOnly: true\n    }, {\n        name: \"alignCursors\",\n        description: \"Align cursors\",\n        exec: function (editor) { editor.alignCursors(); },\n        bindKey: { win: \"Ctrl-Alt-A\", mac: \"Ctrl-Alt-A\" },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"findAll\",\n        description: \"Find all\",\n        exec: function (editor) { editor.findAll(); },\n        bindKey: { win: \"Ctrl-Alt-K\", mac: \"Ctrl-Alt-G\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }];\nexports.multiSelectCommands = [{\n        name: \"singleSelection\",\n        description: \"Single selection\",\n        bindKey: \"esc\",\n        exec: function (editor) { editor.exitMultiSelectMode(); },\n        scrollIntoView: \"cursor\",\n        readOnly: true,\n        isAvailable: function (editor) { return editor && editor.inMultiSelectMode; }\n    }];\nvar HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\nexports.keyboardHandler = new HashHandler(exports.multiSelectCommands);\n\n});\n\nace.define(\"ace/multi_select\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/range\",\"ace/selection\",\"ace/mouse/multi_select_handler\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/commands/multi_select_commands\",\"ace/search\",\"ace/edit_session\",\"ace/editor\",\"ace/config\"], function(require, exports, module){/**\n * @typedef {import(\"./anchor\").Anchor} Anchor\n * @typedef {import(\"../ace-internal\").Ace.Point} Point\n * @typedef {import(\"../ace-internal\").Ace.ScreenCoordinates} ScreenCoordinates\n */\nvar RangeList = require(\"./range_list\").RangeList;\nvar Range = require(\"./range\").Range;\nvar Selection = require(\"./selection\").Selection;\nvar onMouseDown = require(\"./mouse/multi_select_handler\").onMouseDown;\nvar event = require(\"./lib/event\");\nvar lang = require(\"./lib/lang\");\nvar commands = require(\"./commands/multi_select_commands\");\nexports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);\nvar Search = require(\"./search\").Search;\nvar search = new Search();\nfunction find(session, needle, dir) {\n    search.$options.wrap = true;\n    search.$options.needle = needle;\n    search.$options.backwards = dir == -1;\n    return search.find(session);\n}\nvar EditSession = require(\"./edit_session\").EditSession;\n(function () {\n    this.getSelectionMarkers = function () {\n        return this.$selectionMarkers;\n    };\n}).call(EditSession.prototype);\n(function () {\n    this.ranges = null;\n    this.rangeList = null;\n    this.addRange = function (range, $blockChangeEvents) {\n        if (!range)\n            return;\n        if (!this.inMultiSelectMode && this.rangeCount === 0) {\n            var oldRange = this.toOrientedRange();\n            this.rangeList.add(oldRange);\n            this.rangeList.add(range);\n            if (this.rangeList.ranges.length != 2) {\n                this.rangeList.removeAll();\n                return $blockChangeEvents || this.fromOrientedRange(range);\n            }\n            this.rangeList.removeAll();\n            this.rangeList.add(oldRange);\n            this.$onAddRange(oldRange);\n        }\n        if (!range.cursor)\n            range.cursor = range.end;\n        var removed = this.rangeList.add(range);\n        this.$onAddRange(range);\n        if (removed.length)\n            this.$onRemoveRange(removed);\n        if (this.rangeCount > 1 && !this.inMultiSelectMode) {\n            this._signal(\"multiSelect\");\n            this.inMultiSelectMode = true;\n            this.session.$undoSelect = false;\n            this.rangeList.attach(this.session);\n        }\n        return $blockChangeEvents || this.fromOrientedRange(range);\n    };\n    this.toSingleRange = function (range) {\n        range = range || this.ranges[0];\n        var removed = this.rangeList.removeAll();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n        range && this.fromOrientedRange(range);\n    };\n    this.substractPoint = function (pos) {\n        var removed = this.rangeList.substractPoint(pos);\n        if (removed) {\n            this.$onRemoveRange(removed);\n            return removed[0];\n        }\n    };\n    this.mergeOverlappingRanges = function () {\n        var removed = this.rangeList.merge();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n    };\n    this.$onAddRange = function (range) {\n        this.rangeCount = this.rangeList.ranges.length;\n        this.ranges.unshift(range);\n        this._signal(\"addRange\", { range: range });\n    };\n    this.$onRemoveRange = function (removed) {\n        this.rangeCount = this.rangeList.ranges.length;\n        if (this.rangeCount == 1 && this.inMultiSelectMode) {\n            var lastRange = this.rangeList.ranges.pop();\n            removed.push(lastRange);\n            this.rangeCount = 0;\n        }\n        for (var i = removed.length; i--;) {\n            var index = this.ranges.indexOf(removed[i]);\n            this.ranges.splice(index, 1);\n        }\n        this._signal(\"removeRange\", { ranges: removed });\n        if (this.rangeCount === 0 && this.inMultiSelectMode) {\n            this.inMultiSelectMode = false;\n            this._signal(\"singleSelect\");\n            this.session.$undoSelect = true;\n            this.rangeList.detach(this.session);\n        }\n        lastRange = lastRange || this.ranges[0];\n        if (lastRange && !lastRange.isEqual(this.getRange()))\n            this.fromOrientedRange(lastRange);\n    };\n    this.$initRangeList = function () {\n        if (this.rangeList)\n            return;\n        this.rangeList = new RangeList();\n        this.ranges = [];\n        this.rangeCount = 0;\n    };\n    this.getAllRanges = function () {\n        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];\n    };\n    this.splitIntoLines = function () {\n        var ranges = this.ranges.length ? this.ranges : [this.getRange()];\n        var newRanges = [];\n        for (var i = 0; i < ranges.length; i++) {\n            var range = ranges[i];\n            var row = range.start.row;\n            var endRow = range.end.row;\n            if (row === endRow) {\n                newRanges.push(range.clone());\n            }\n            else {\n                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));\n                while (++row < endRow)\n                    newRanges.push(this.getLineRange(row, true));\n                newRanges.push(new Range(endRow, 0, endRow, range.end.column));\n            }\n            if (i == 0 && !this.isBackwards())\n                newRanges = newRanges.reverse();\n        }\n        this.toSingleRange();\n        for (var i = newRanges.length; i--;)\n            this.addRange(newRanges[i]);\n    };\n    this.joinSelections = function () {\n        var ranges = this.rangeList.ranges;\n        var lastRange = ranges[ranges.length - 1];\n        var range = Range.fromPoints(ranges[0].start, lastRange.end);\n        this.toSingleRange();\n        this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n    };\n    this.toggleBlockSelection = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        }\n        else {\n            var cursor = this.session.documentToScreenPosition(this.cursor);\n            var anchor = this.session.documentToScreenPosition(this.anchor);\n            var rectSel = this.rectangularRangeBlock(cursor, anchor);\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {\n        var rectSel = [];\n        var xBackwards = screenCursor.column < screenAnchor.column;\n        if (xBackwards) {\n            var startColumn = screenCursor.column;\n            var endColumn = screenAnchor.column;\n            var startOffsetX = screenCursor.offsetX;\n            var endOffsetX = screenAnchor.offsetX;\n        }\n        else {\n            var startColumn = screenAnchor.column;\n            var endColumn = screenCursor.column;\n            var startOffsetX = screenAnchor.offsetX;\n            var endOffsetX = screenCursor.offsetX;\n        }\n        var yBackwards = screenCursor.row < screenAnchor.row;\n        if (yBackwards) {\n            var startRow = screenCursor.row;\n            var endRow = screenAnchor.row;\n        }\n        else {\n            var startRow = screenAnchor.row;\n            var endRow = screenCursor.row;\n        }\n        if (startColumn < 0)\n            startColumn = 0;\n        if (startRow < 0)\n            startRow = 0;\n        if (startRow == endRow)\n            includeEmptyLines = true;\n        var docEnd;\n        for (var row = startRow; row <= endRow; row++) {\n            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));\n            if (range.isEmpty()) {\n                if (docEnd && isSamePoint(range.end, docEnd))\n                    break;\n                docEnd = range.end;\n            }\n            range.cursor = xBackwards ? range.start : range.end;\n            rectSel.push(range);\n        }\n        if (yBackwards)\n            rectSel.reverse();\n        if (!includeEmptyLines) {\n            var end = rectSel.length - 1;\n            while (rectSel[end].isEmpty() && end > 0)\n                end--;\n            if (end > 0) {\n                var start = 0;\n                while (rectSel[start].isEmpty())\n                    start++;\n            }\n            for (var i = end; i >= start; i--) {\n                if (rectSel[i].isEmpty())\n                    rectSel.splice(i, 1);\n            }\n        }\n        return rectSel;\n    };\n}).call(Selection.prototype);\nvar Editor = require(\"./editor\").Editor;\n(function () {\n    this.updateSelectionMarkers = function () {\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.addSelectionMarker = function (orientedRange) {\n        if (!orientedRange.cursor)\n            orientedRange.cursor = orientedRange.end;\n        var style = this.getSelectionStyle();\n        orientedRange.marker = this.session.addMarker(orientedRange, \"ace_selection\", style);\n        this.session.$selectionMarkers.push(orientedRange);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n        return orientedRange;\n    };\n    this.removeSelectionMarker = function (range) {\n        if (!range.marker)\n            return;\n        this.session.removeMarker(range.marker);\n        var index = this.session.$selectionMarkers.indexOf(range);\n        if (index != -1)\n            this.session.$selectionMarkers.splice(index, 1);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n    };\n    this.removeSelectionMarkers = function (ranges) {\n        var markerList = this.session.$selectionMarkers;\n        for (var i = ranges.length; i--;) {\n            var range = ranges[i];\n            if (!range.marker)\n                continue;\n            this.session.removeMarker(range.marker);\n            var index = markerList.indexOf(range);\n            if (index != -1)\n                markerList.splice(index, 1);\n        }\n        this.session.selectionMarkerCount = markerList.length;\n    };\n    this.$onAddRange = function (e) {\n        this.addSelectionMarker(e.range);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.$onRemoveRange = function (e) {\n        this.removeSelectionMarkers(e.ranges);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.$onMultiSelect = function (e) {\n        if (this.inMultiSelectMode)\n            return;\n        this.inMultiSelectMode = true;\n        this.setStyle(\"ace_multiselect\");\n        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);\n        this.commands.setDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.$onSingleSelect = function (e) {\n        if (this.session.multiSelect.inVirtualMode)\n            return;\n        this.inMultiSelectMode = false;\n        this.unsetStyle(\"ace_multiselect\");\n        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);\n        this.commands.removeDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n        this._emit(\"changeSelection\");\n    };\n    this.$onMultiSelectExec = function (e) {\n        var command = e.command;\n        var editor = e.editor;\n        if (!editor.multiSelect)\n            return;\n        if (!command.multiSelectAction) {\n            var result = command.exec(editor, e.args || {});\n            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());\n            editor.multiSelect.mergeOverlappingRanges();\n        }\n        else if (command.multiSelectAction == \"forEach\") {\n            result = editor.forEachSelection(command, e.args);\n        }\n        else if (command.multiSelectAction == \"forEachLine\") {\n            result = editor.forEachSelection(command, e.args, true);\n        }\n        else if (command.multiSelectAction == \"single\") {\n            editor.exitMultiSelectMode();\n            result = command.exec(editor, e.args || {});\n        }\n        else {\n            result = command.multiSelectAction(editor, e.args || {});\n        }\n        return result;\n    };\n    this.forEachSelection = function (cmd, args, options) {\n        if (this.inVirtualSelectionMode)\n            return;\n        var keepOrder = options && options.keepOrder;\n        var $byLines = options == true || options && options.$byLines;\n        var session = this.session;\n        var selection = this.selection;\n        var rangeList = selection.rangeList;\n        var ranges = (keepOrder ? selection : rangeList).ranges;\n        var result;\n        if (!ranges.length)\n            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n        var reg = selection._eventRegistry;\n        selection._eventRegistry = {};\n        var tmpSel = new Selection(session);\n        this.inVirtualSelectionMode = true;\n        for (var i = ranges.length; i--;) {\n            if ($byLines) {\n                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)\n                    i--;\n            }\n            tmpSel.fromOrientedRange(ranges[i]);\n            tmpSel.index = i;\n            this.selection = session.selection = tmpSel;\n            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n            if (!result && cmdResult !== undefined)\n                result = cmdResult;\n            tmpSel.toOrientedRange(ranges[i]);\n        }\n        tmpSel.detach();\n        this.selection = session.selection = selection;\n        this.inVirtualSelectionMode = false;\n        selection._eventRegistry = reg;\n        selection.mergeOverlappingRanges();\n        if (selection.ranges[0])\n            selection.fromOrientedRange(selection.ranges[0]);\n        var anim = this.renderer.$scrollAnimation;\n        this.onCursorChange();\n        this.onSelectionChange();\n        if (anim && anim.from == anim.to)\n            this.renderer.animateScrolling(anim.from);\n        return result;\n    };\n    this.exitMultiSelectMode = function () {\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n            return;\n        this.multiSelect.toSingleRange();\n    };\n    this.getSelectedText = function () {\n        var text = \"\";\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var ranges = this.multiSelect.rangeList.ranges;\n            var buf = [];\n            for (var i = 0; i < ranges.length; i++) {\n                buf.push(this.session.getTextRange(ranges[i]));\n            }\n            var nl = this.session.getDocument().getNewLineCharacter();\n            text = buf.join(nl);\n            if (text.length == (buf.length - 1) * nl.length)\n                text = \"\";\n        }\n        else if (!this.selection.isEmpty()) {\n            text = this.session.getTextRange(this.getSelectionRange());\n        }\n        return text;\n    };\n    this.$checkMultiselectChange = function (e, anchor) {\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var range = this.multiSelect.ranges[0];\n            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)\n                return;\n            var pos = anchor == this.multiSelect.anchor\n                ? range.cursor == range.start ? range.end : range.start\n                : range.cursor;\n            if (pos.row != anchor.row\n                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)\n                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());\n            else\n                this.multiSelect.mergeOverlappingRanges();\n        }\n    };\n    this.findAll = function (needle, options, additive) {\n        options = options || {};\n        options.needle = needle || options.needle;\n        if (options.needle == undefined) {\n            var range = this.selection.isEmpty()\n                ? this.selection.getWordRange()\n                : this.selection.getRange();\n            options.needle = this.session.getTextRange(range);\n        }\n        this.$search.set(options);\n        var ranges = this.$search.findAll(this.session);\n        if (!ranges.length)\n            return 0;\n        var selection = this.multiSelect;\n        if (!additive)\n            selection.toSingleRange(ranges[0]);\n        for (var i = ranges.length; i--;)\n            selection.addRange(ranges[i], true);\n        if (range && selection.rangeList.rangeAtPoint(range.start))\n            selection.addRange(range, true);\n        return ranges.length;\n    };\n    this.selectMoreLines = function (dir, skip) {\n        var range = this.selection.toOrientedRange();\n        var isBackwards = range.cursor == range.end;\n        var screenLead = this.session.documentToScreenPosition(range.cursor);\n        if (this.selection.$desiredColumn)\n            screenLead.column = this.selection.$desiredColumn;\n        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);\n        if (!range.isEmpty()) {\n            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);\n            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);\n        }\n        else {\n            var anchor = lead;\n        }\n        if (isBackwards) {\n            var newRange = Range.fromPoints(lead, anchor);\n            newRange.cursor = newRange.start;\n        }\n        else {\n            var newRange = Range.fromPoints(anchor, lead);\n            newRange.cursor = newRange.end;\n        }\n        newRange.desiredColumn = screenLead.column;\n        if (!this.selection.inMultiSelectMode) {\n            this.selection.addRange(range);\n        }\n        else {\n            if (skip)\n                var toRemove = range.cursor;\n        }\n        this.selection.addRange(newRange);\n        if (toRemove)\n            this.selection.substractPoint(toRemove);\n    };\n    this.transposeSelections = function (dir) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var all = sel.ranges;\n        for (var i = all.length; i--;) {\n            var range = all[i];\n            if (range.isEmpty()) {\n                var tmp_1 = session.getWordRange(range.start.row, range.start.column);\n                range.start.row = tmp_1.start.row;\n                range.start.column = tmp_1.start.column;\n                range.end.row = tmp_1.end.row;\n                range.end.column = tmp_1.end.column;\n            }\n        }\n        sel.mergeOverlappingRanges();\n        var words = [];\n        for (var i = all.length; i--;) {\n            var range = all[i];\n            words.unshift(session.getTextRange(range));\n        }\n        if (dir < 0)\n            words.unshift(words.pop());\n        else\n            words.push(words.shift());\n        for (var i = all.length; i--;) {\n            var range = all[i];\n            var tmp = range.clone();\n            session.replace(range, words[i]);\n            range.start.row = tmp.start.row;\n            range.start.column = tmp.start.column;\n        }\n        sel.fromOrientedRange(sel.ranges[0]);\n    };\n    this.selectMore = function (dir, skip, stopAtFirst) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var range = sel.toOrientedRange();\n        if (range.isEmpty()) {\n            range = session.getWordRange(range.start.row, range.start.column);\n            range.cursor = dir == -1 ? range.start : range.end;\n            this.multiSelect.addRange(range);\n            if (stopAtFirst)\n                return;\n        }\n        var needle = session.getTextRange(range);\n        var newRange = find(session, needle, dir);\n        if (newRange) {\n            newRange.cursor = dir == -1 ? newRange.start : newRange.end;\n            this.session.unfold(newRange);\n            this.multiSelect.addRange(newRange);\n            this.renderer.scrollCursorIntoView(null, 0.5);\n        }\n        if (skip)\n            this.multiSelect.substractPoint(range.cursor);\n    };\n    this.alignCursors = function () {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var ranges = sel.ranges;\n        var row = -1;\n        var sameRowRanges = ranges.filter(function (r) {\n            if (r.cursor.row == row)\n                return true;\n            row = r.cursor.row;\n        });\n        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {\n            var range = this.selection.getRange();\n            var fr = range.start.row, lr = range.end.row;\n            var guessRange = fr == lr;\n            if (guessRange) {\n                var max = this.session.getLength();\n                var line;\n                do {\n                    line = this.session.getLine(lr);\n                } while (/[=:]/.test(line) && ++lr < max);\n                do {\n                    line = this.session.getLine(fr);\n                } while (/[=:]/.test(line) && --fr > 0);\n                if (fr < 0)\n                    fr = 0;\n                if (lr >= max)\n                    lr = max - 1;\n            }\n            var lines = this.session.removeFullLines(fr, lr);\n            lines = this.$reAlignText(lines, guessRange);\n            this.session.insert({ row: fr, column: 0 }, lines.join(\"\\n\") + \"\\n\");\n            if (!guessRange) {\n                range.start.column = 0;\n                range.end.column = lines[lines.length - 1].length;\n            }\n            this.selection.setRange(range);\n        }\n        else {\n            sameRowRanges.forEach(function (r) {\n                sel.substractPoint(r.cursor);\n            });\n            var maxCol = 0;\n            var minSpace = Infinity;\n            var spaceOffsets = ranges.map(function (r) {\n                var p = r.cursor;\n                var line = session.getLine(p.row);\n                var spaceOffset = line.substr(p.column).search(/\\S/g);\n                if (spaceOffset == -1)\n                    spaceOffset = 0;\n                if (p.column > maxCol)\n                    maxCol = p.column;\n                if (spaceOffset < minSpace)\n                    minSpace = spaceOffset;\n                return spaceOffset;\n            });\n            ranges.forEach(function (r, i) {\n                var p = r.cursor;\n                var l = maxCol - p.column;\n                var d = spaceOffsets[i] - minSpace;\n                if (l > d)\n                    session.insert(p, lang.stringRepeat(\" \", l - d));\n                else\n                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));\n                r.start.column = r.end.column = maxCol;\n                r.start.row = r.end.row = p.row;\n                r.cursor = r.end;\n            });\n            sel.fromOrientedRange(ranges[0]);\n            this.renderer.updateCursor();\n            this.renderer.updateBackMarkers();\n        }\n    };\n    this.$reAlignText = function (lines, forceLeft) {\n        var isLeftAligned = true, isRightAligned = true;\n        var startW, textW, endW;\n        return lines.map(function (line) {\n            var m = line.match(/(\\s*)(.*?)(\\s*)([=:].*)/);\n            if (!m)\n                return [line];\n            if (startW == null) {\n                startW = m[1].length;\n                textW = m[2].length;\n                endW = m[3].length;\n                return m;\n            }\n            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)\n                isRightAligned = false;\n            if (startW != m[1].length)\n                isLeftAligned = false;\n            if (startW > m[1].length)\n                startW = m[1].length;\n            if (textW < m[2].length)\n                textW = m[2].length;\n            if (endW > m[3].length)\n                endW = m[3].length;\n            return m;\n        }).map(forceLeft ? alignLeft :\n            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);\n        function spaces(n) {\n            return lang.stringRepeat(\" \", n);\n        }\n        function alignLeft(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(textW - m[2].length + endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function alignRight(m) {\n            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function unAlign(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n    };\n}).call(Editor.prototype);\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nexports.onSessionChange = function (e) {\n    var session = e.session;\n    if (session && !session.multiSelect) {\n        session.$selectionMarkers = [];\n        session.selection.$initRangeList();\n        session.multiSelect = session.selection;\n    }\n    this.multiSelect = session && session.multiSelect;\n    var oldSession = e.oldSession;\n    if (oldSession) {\n        oldSession.multiSelect.off(\"addRange\", this.$onAddRange);\n        oldSession.multiSelect.off(\"removeRange\", this.$onRemoveRange);\n        oldSession.multiSelect.off(\"multiSelect\", this.$onMultiSelect);\n        oldSession.multiSelect.off(\"singleSelect\", this.$onSingleSelect);\n        oldSession.multiSelect.lead.off(\"change\", this.$checkMultiselectChange);\n        oldSession.multiSelect.anchor.off(\"change\", this.$checkMultiselectChange);\n    }\n    if (session) {\n        session.multiSelect.on(\"addRange\", this.$onAddRange);\n        session.multiSelect.on(\"removeRange\", this.$onRemoveRange);\n        session.multiSelect.on(\"multiSelect\", this.$onMultiSelect);\n        session.multiSelect.on(\"singleSelect\", this.$onSingleSelect);\n        session.multiSelect.lead.on(\"change\", this.$checkMultiselectChange);\n        session.multiSelect.anchor.on(\"change\", this.$checkMultiselectChange);\n    }\n    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {\n        if (session.selection.inMultiSelectMode)\n            this.$onMultiSelect();\n        else\n            this.$onSingleSelect();\n    }\n};\nfunction MultiSelect(editor) {\n    if (editor.$multiselectOnSessionChange)\n        return;\n    editor.$onAddRange = editor.$onAddRange.bind(editor);\n    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);\n    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);\n    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);\n    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);\n    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);\n    editor.$multiselectOnSessionChange(editor);\n    editor.on(\"changeSession\", editor.$multiselectOnSessionChange);\n    editor.on(\"mousedown\", onMouseDown);\n    editor.commands.addCommands(commands.defaultCommands);\n    addAltCursorListeners(editor);\n}\nfunction addAltCursorListeners(editor) {\n    if (!editor.textInput)\n        return;\n    var el = editor.textInput.getElement();\n    var altCursor = false;\n    event.addListener(el, \"keydown\", function (e) {\n        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);\n        if (editor.$blockSelectEnabled && altDown) {\n            if (!altCursor) {\n                editor.renderer.setMouseCursor(\"crosshair\");\n                altCursor = true;\n            }\n        }\n        else if (altCursor) {\n            reset();\n        }\n    }, editor);\n    event.addListener(el, \"keyup\", reset, editor);\n    event.addListener(el, \"blur\", reset, editor);\n    function reset(e) {\n        if (altCursor) {\n            editor.renderer.setMouseCursor(\"\");\n            altCursor = false;\n        }\n    }\n}\nexports.MultiSelect = MultiSelect;\nrequire(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n    enableMultiselect: {\n        set: function (val) {\n            MultiSelect(this);\n            if (val) {\n                this.on(\"mousedown\", onMouseDown);\n            }\n            else {\n                this.off(\"mousedown\", onMouseDown);\n            }\n        },\n        value: true\n    },\n    enableBlockSelect: {\n        set: function (val) {\n            this.$blockSelectEnabled = val;\n        },\n        value: true\n    }\n});\n\n});\n\nace.define(\"ace/mode/folding/fold_mode\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../../range\").Range;\nvar FoldMode = exports.FoldMode = function () { };\n(function () {\n    this.foldingStartMarker = null;\n    this.foldingStopMarker = null;\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (this.foldingStartMarker.test(line))\n            return \"start\";\n        if (foldStyle == \"markbeginend\"\n            && this.foldingStopMarker\n            && this.foldingStopMarker.test(line))\n            return \"end\";\n        return \"\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        return null;\n    };\n    this.indentationBlock = function (session, row, column) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1)\n            return;\n        var startColumn = column || line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        while (++row < maxRow) {\n            var level = session.getLine(row).search(re);\n            if (level == -1)\n                continue;\n            if (level <= startLevel) {\n                var token = session.getTokenAt(row, 0);\n                if (!token || token.type !== \"string\")\n                    break;\n            }\n            endRow = row;\n        }\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.openingBracketBlock = function (session, bracket, row, column, typeRe) {\n        var start = { row: row, column: column + 1 };\n        var end = session.$findClosingBracket(bracket, start, typeRe);\n        if (!end)\n            return;\n        var fw = session.foldWidgets[end.row];\n        if (fw == null)\n            fw = session.getFoldWidget(end.row);\n        if (fw == \"start\" && end.row > start.row) {\n            end.row--;\n            end.column = session.getLine(end.row).length;\n        }\n        return Range.fromPoints(start, end);\n    };\n    this.closingBracketBlock = function (session, bracket, row, column, typeRe) {\n        var end = { row: row, column: column };\n        var start = session.$findOpeningBracket(bracket, end);\n        if (!start)\n            return;\n        start.column++;\n        end.column--;\n        return Range.fromPoints(start, end);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/ext/error_marker\",[\"require\",\"exports\",\"module\",\"ace/line_widgets\",\"ace/lib/dom\",\"ace/range\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar LineWidgets = require(\"../line_widgets\").LineWidgets;\nvar dom = require(\"../lib/dom\");\nvar Range = require(\"../range\").Range;\nvar nls = require(\"../config\").nls;\nfunction binarySearch(array, needle, comparator) {\n    var first = 0;\n    var last = array.length - 1;\n    while (first <= last) {\n        var mid = (first + last) >> 1;\n        var c = comparator(needle, array[mid]);\n        if (c > 0)\n            first = mid + 1;\n        else if (c < 0)\n            last = mid - 1;\n        else\n            return mid;\n    }\n    return -(first + 1);\n}\nfunction findAnnotations(session, row, dir) {\n    var annotations = session.getAnnotations().sort(Range.comparePoints);\n    if (!annotations.length)\n        return;\n    var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);\n    if (i < 0)\n        i = -i - 1;\n    if (i >= annotations.length)\n        i = dir > 0 ? 0 : annotations.length - 1;\n    else if (i === 0 && dir < 0)\n        i = annotations.length - 1;\n    var annotation = annotations[i];\n    if (!annotation || !dir)\n        return;\n    if (annotation.row === row) {\n        do {\n            annotation = annotations[i += dir];\n        } while (annotation && annotation.row === row);\n        if (!annotation)\n            return annotations.slice();\n    }\n    var matched = [];\n    row = annotation.row;\n    do {\n        matched[dir < 0 ? \"unshift\" : \"push\"](annotation);\n        annotation = annotations[i += dir];\n    } while (annotation && annotation.row == row);\n    return matched.length && matched;\n}\nexports.showErrorMarker = function (editor, dir) {\n    var session = editor.session;\n    if (!session.widgetManager) {\n        session.widgetManager = new LineWidgets(session);\n        session.widgetManager.attach(editor);\n    }\n    var pos = editor.getCursorPosition();\n    var row = pos.row;\n    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {\n        return w.type == \"errorMarker\";\n    })[0];\n    if (oldWidget) {\n        oldWidget.destroy();\n    }\n    else {\n        row -= dir;\n    }\n    var annotations = findAnnotations(session, row, dir);\n    var gutterAnno;\n    if (annotations) {\n        var annotation = annotations[0];\n        pos.column = (annotation.pos && typeof annotation.column != \"number\"\n            ? annotation.pos.sc\n            : annotation.column) || 0;\n        pos.row = annotation.row;\n        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];\n    }\n    else if (oldWidget) {\n        return;\n    }\n    else {\n        gutterAnno = {\n            displayText: [nls(\"error-marker.good-state\", \"Looks good!\")],\n            className: \"ace_ok\"\n        };\n    }\n    editor.session.unfold(pos.row);\n    editor.selection.moveToPosition(pos);\n    var w = {\n        row: pos.row,\n        fixedWidth: true,\n        coverGutter: true,\n        el: dom.createElement(\"div\"),\n        type: \"errorMarker\"\n    };\n    var el = w.el.appendChild(dom.createElement(\"div\"));\n    var arrow = w.el.appendChild(dom.createElement(\"div\"));\n    arrow.className = \"error_widget_arrow \" + gutterAnno.className;\n    var left = editor.renderer.$cursorLayer\n        .getPixelPosition(pos).left;\n    arrow.style.left = left + editor.renderer.gutterWidth - 5 + \"px\";\n    w.el.className = \"error_widget_wrapper\";\n    el.className = \"error_widget \" + gutterAnno.className;\n    gutterAnno.displayText.forEach(function (annoTextLine, i) {\n        el.appendChild(dom.createTextNode(annoTextLine));\n        if (i < gutterAnno.displayText.length - 1) {\n            el.appendChild(dom.createElement(\"br\"));\n        }\n    });\n    el.appendChild(dom.createElement(\"div\"));\n    var kb = function (_, hashId, keyString) {\n        if (hashId === 0 && (keyString === \"esc\" || keyString === \"return\")) {\n            w.destroy();\n            return { command: \"null\" };\n        }\n    };\n    w.destroy = function () {\n        if (editor.$mouseHandler.isMousePressed)\n            return;\n        editor.keyBinding.removeKeyboardHandler(kb);\n        session.widgetManager.removeLineWidget(w);\n        editor.off(\"changeSelection\", w.destroy);\n        editor.off(\"changeSession\", w.destroy);\n        editor.off(\"mouseup\", w.destroy);\n        editor.off(\"change\", w.destroy);\n    };\n    editor.keyBinding.addKeyboardHandler(kb);\n    editor.on(\"changeSelection\", w.destroy);\n    editor.on(\"changeSession\", w.destroy);\n    editor.on(\"mouseup\", w.destroy);\n    editor.on(\"change\", w.destroy);\n    editor.session.widgetManager.addLineWidget(w);\n    w.el.onmousedown = editor.focus.bind(editor);\n    editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });\n};\ndom.importCssString(\"\\n    .error_widget_wrapper {\\n        background: inherit;\\n        color: inherit;\\n        border:none\\n    }\\n    .error_widget {\\n        border-top: solid 2px;\\n        border-bottom: solid 2px;\\n        margin: 5px 0;\\n        padding: 10px 40px;\\n        white-space: pre-wrap;\\n    }\\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\\n        border-color: #ff5a5a\\n    }\\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\\n        border-color: #F1D817\\n    }\\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\\n        border-color: #5a5a5a\\n    }\\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\\n        border-color: #5aaa5a\\n    }\\n    .error_widget_arrow {\\n        position: absolute;\\n        border: solid 5px;\\n        border-top-color: transparent!important;\\n        border-right-color: transparent!important;\\n        border-left-color: transparent!important;\\n        top: -5px;\\n    }\\n\", \"error_marker.css\", false);\n\n});\n\nace.define(\"ace/ace\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/range\",\"ace/editor\",\"ace/edit_session\",\"ace/undomanager\",\"ace/virtual_renderer\",\"ace/worker/worker_client\",\"ace/keyboard/hash_handler\",\"ace/placeholder\",\"ace/multi_select\",\"ace/mode/folding/fold_mode\",\"ace/theme/textmate\",\"ace/ext/error_marker\",\"ace/config\",\"ace/loader_build\"], function(require, exports, module){/**\n * The main class required to set up an Ace instance in the browser.\n *\n * @namespace Ace\n **/\n\"use strict\";\nrequire(\"./loader_build\")(exports)\nvar dom = require(\"./lib/dom\");\nvar Range = require(\"./range\").Range;\nvar Editor = require(\"./editor\").Editor;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar Renderer = require(\"./virtual_renderer\").VirtualRenderer;\nrequire(\"./worker/worker_client\");\nrequire(\"./keyboard/hash_handler\");\nrequire(\"./placeholder\");\nrequire(\"./multi_select\");\nrequire(\"./mode/folding/fold_mode\");\nrequire(\"./theme/textmate\");\nrequire(\"./ext/error_marker\");\nexports.config = require(\"./config\");\nexports.edit = function (el, options) {\n    if (typeof el == \"string\") {\n        var _id = el;\n        el = document.getElementById(_id);\n        if (!el)\n            throw new Error(\"ace.edit can't find div #\" + _id);\n    }\n    if (el && el.env && el.env.editor instanceof Editor)\n        return el.env.editor;\n    var value = \"\";\n    if (el && /input|textarea/i.test(el.tagName)) {\n        var oldNode = el;\n        value = oldNode.value;\n        el = dom.createElement(\"pre\");\n        oldNode.parentNode.replaceChild(el, oldNode);\n    }\n    else if (el) {\n        value = el.textContent;\n        el.innerHTML = \"\";\n    }\n    var doc = exports.createEditSession(value);\n    var editor = new Editor(new Renderer(el), doc, options);\n    var env = {\n        document: doc,\n        editor: editor,\n        onResize: editor.resize.bind(editor, null)\n    };\n    if (oldNode)\n        env.textarea = oldNode;\n    editor.on(\"destroy\", function () {\n        env.editor.container.env = null; // prevent memory leak on old ie\n    });\n    editor.container.env = editor.env = env;\n    return editor;\n};\nexports.createEditSession = function (text, mode) {\n    var doc = new EditSession(text, mode);\n    doc.setUndoManager(new UndoManager());\n    return doc;\n};\nexports.Range = Range;\nexports.Editor = Editor;\nexports.EditSession = EditSession;\nexports.UndoManager = UndoManager;\nexports.VirtualRenderer = Renderer;\nexports.version = exports.config.version;\n\n});            (function() {\n                ace.require([\"ace/ace\"], function(a) {\n                    if (a) {\n                        a.config.init(true);\n                        a.define = ace.define;\n                    }\n                    var global = (function () {\n                        return this;\n                    })();\n                    if (!global && typeof window != \"undefined\") global = window; // can happen in strict mode\n                    if (!global && typeof self != \"undefined\") global = self; // can happen in webworker\n                    \n                    if (!global.ace)\n                        global.ace = a;\n                    for (var key in a) if (a.hasOwnProperty(key))\n                        global.ace[key] = a[key];\n                    global.ace[\"default\"] = global.ace;\n                    if ( true && module) {\n                        module.exports = global.ace;\n                    }\n                });\n            })();\n        //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9hY2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9hY2UtYnVpbGRzL3NyYy1ub2NvbmZsaWN0L2FjZS5qcz82ZDRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAsIEFqYXgub3JnIEIuVi5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgQWpheC5vcmcgQi5WLiBub3IgdGhlXG4gKiAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICogICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgQUpBWC5PUkcgQi5WLiBCRSBMSUFCTEUgRk9SIEFOWVxuICogRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAqIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAqIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICogT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKiAqL1xuXG4vKipcbiAqIERlZmluZSBhIG1vZHVsZSBhbG9uZyB3aXRoIGEgcGF5bG9hZFxuICogQHBhcmFtIG1vZHVsZSBhIG5hbWUgZm9yIHRoZSBwYXlsb2FkXG4gKiBAcGFyYW0gcGF5bG9hZCBhIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSBwYXJhbXNcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbnZhciBBQ0VfTkFNRVNQQUNFID0gXCJhY2VcIjtcblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG5pZiAoIWdsb2JhbCAmJiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpIGdsb2JhbCA9IHdpbmRvdzsgLy8gc3RyaWN0IG1vZGVcblxuXG5pZiAoIUFDRV9OQU1FU1BBQ0UgJiYgdHlwZW9mIHJlcXVpcmVqcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm47XG5cblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uKG1vZHVsZSwgZGVwcywgcGF5bG9hZCkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChkZWZpbmUub3JpZ2luYWwpXG4gICAgICAgICAgICBkZWZpbmUub3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZHJvcHBpbmcgbW9kdWxlIGJlY2F1c2UgZGVmaW5lIHdhc25cXCd0IGEgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG4gICAgICAgIHBheWxvYWQgPSBkZXBzO1xuICAgIGlmICghZGVmaW5lLm1vZHVsZXNbbW9kdWxlXSkge1xuICAgICAgICBkZWZpbmUucGF5bG9hZHNbbW9kdWxlXSA9IHBheWxvYWQ7XG4gICAgICAgIGRlZmluZS5tb2R1bGVzW21vZHVsZV0gPSBudWxsO1xuICAgIH1cbn07XG5cbmRlZmluZS5tb2R1bGVzID0ge307XG5kZWZpbmUucGF5bG9hZHMgPSB7fTtcblxuLyoqXG4gKiBHZXQgYXQgZnVuY3Rpb25hbGl0eSBkZWZpbmUoKWVkIHVzaW5nIHRoZSBmdW5jdGlvbiBhYm92ZVxuICovXG52YXIgX3JlcXVpcmUgPSBmdW5jdGlvbihwYXJlbnRJZCwgbW9kdWxlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbG9va3VwKHBhcmVudElkLCBtb2R1bGUpO1xuICAgICAgICBpZiAocGF5bG9hZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1vZHVsZSkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9kdWxlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRlcCA9IGxvb2t1cChwYXJlbnRJZCwgbW9kdWxlW2ldKTtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gdW5kZWZpbmVkICYmIHJlcXVpcmUub3JpZ2luYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZGVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2suYXBwbHkobnVsbCwgcGFyYW1zKSB8fCB0cnVlO1xuICAgIH1cbn07XG5cbnZhciByZXF1aXJlID0gZnVuY3Rpb24obW9kdWxlLCBjYWxsYmFjaykge1xuICAgIHZhciBwYWNrYWdlZE1vZHVsZSA9IF9yZXF1aXJlKFwiXCIsIG1vZHVsZSwgY2FsbGJhY2spO1xuICAgIGlmIChwYWNrYWdlZE1vZHVsZSA9PSB1bmRlZmluZWQgJiYgcmVxdWlyZS5vcmlnaW5hbClcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUub3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcGFja2FnZWRNb2R1bGU7XG59O1xuXG52YXIgbm9ybWFsaXplTW9kdWxlID0gZnVuY3Rpb24ocGFyZW50SWQsIG1vZHVsZU5hbWUpIHtcbiAgICAvLyBub3JtYWxpemUgcGx1Z2luIHJlcXVpcmVzXG4gICAgaWYgKG1vZHVsZU5hbWUuaW5kZXhPZihcIiFcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciBjaHVua3MgPSBtb2R1bGVOYW1lLnNwbGl0KFwiIVwiKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCwgY2h1bmtzWzBdKSArIFwiIVwiICsgbm9ybWFsaXplTW9kdWxlKHBhcmVudElkLCBjaHVua3NbMV0pO1xuICAgIH1cbiAgICAvLyBub3JtYWxpemUgcmVsYXRpdmUgcmVxdWlyZXNcbiAgICBpZiAobW9kdWxlTmFtZS5jaGFyQXQoMCkgPT0gXCIuXCIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwYXJlbnRJZC5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xuICAgICAgICBtb2R1bGVOYW1lID0gYmFzZSArIFwiL1wiICsgbW9kdWxlTmFtZTtcblxuICAgICAgICB3aGlsZShtb2R1bGVOYW1lLmluZGV4T2YoXCIuXCIpICE9PSAtMSAmJiBwcmV2aW91cyAhPSBtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBtb2R1bGVOYW1lO1xuICAgICAgICAgICAgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUucmVwbGFjZSgvXFwvXFwuXFwvLywgXCIvXCIpLnJlcGxhY2UoL1teXFwvXStcXC9cXC5cXC5cXC8vLCBcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9kdWxlTmFtZTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gbG9va3VwIG1vZHVsZU5hbWVzIGFuZCByZXNvbHZlIHRoZW0gYnkgY2FsbGluZyB0aGVcbiAqIGRlZmluaXRpb24gZnVuY3Rpb24gaWYgbmVlZGVkLlxuICovXG52YXIgbG9va3VwID0gZnVuY3Rpb24ocGFyZW50SWQsIG1vZHVsZU5hbWUpIHtcbiAgICBtb2R1bGVOYW1lID0gbm9ybWFsaXplTW9kdWxlKHBhcmVudElkLCBtb2R1bGVOYW1lKTtcblxuICAgIHZhciBtb2R1bGUgPSBkZWZpbmUubW9kdWxlc1ttb2R1bGVOYW1lXTtcbiAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICBtb2R1bGUgPSBkZWZpbmUucGF5bG9hZHNbbW9kdWxlTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgICAgICAgICAgdmFyIG1vZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogbW9kdWxlTmFtZSxcbiAgICAgICAgICAgICAgICB1cmk6ICcnLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgICAgICAgcGFja2FnZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZXEgPSBmdW5jdGlvbihtb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXF1aXJlKG1vZHVsZU5hbWUsIG1vZHVsZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gbW9kdWxlKHJlcSwgZXhwb3J0cywgbW9kKTtcbiAgICAgICAgICAgIGV4cG9ydHMgPSByZXR1cm5WYWx1ZSB8fCBtb2QuZXhwb3J0cztcbiAgICAgICAgICAgIGRlZmluZS5tb2R1bGVzW21vZHVsZU5hbWVdID0gZXhwb3J0cztcbiAgICAgICAgICAgIGRlbGV0ZSBkZWZpbmUucGF5bG9hZHNbbW9kdWxlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlID0gZGVmaW5lLm1vZHVsZXNbbW9kdWxlTmFtZV0gPSBleHBvcnRzIHx8IG1vZHVsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZTtcbn07XG5cbmZ1bmN0aW9uIGV4cG9ydEFjZShucykge1xuICAgIHZhciByb290ID0gZ2xvYmFsO1xuICAgIGlmIChucykge1xuICAgICAgICBpZiAoIWdsb2JhbFtuc10pXG4gICAgICAgICAgICBnbG9iYWxbbnNdID0ge307XG4gICAgICAgIHJvb3QgPSBnbG9iYWxbbnNdO1xuICAgIH1cblxuICAgIGlmICghcm9vdC5kZWZpbmUgfHwgIXJvb3QuZGVmaW5lLnBhY2thZ2VkKSB7XG4gICAgICAgIGRlZmluZS5vcmlnaW5hbCA9IHJvb3QuZGVmaW5lO1xuICAgICAgICByb290LmRlZmluZSA9IGRlZmluZTtcbiAgICAgICAgcm9vdC5kZWZpbmUucGFja2FnZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghcm9vdC5yZXF1aXJlIHx8ICFyb290LnJlcXVpcmUucGFja2FnZWQpIHtcbiAgICAgICAgcmVxdWlyZS5vcmlnaW5hbCA9IHJvb3QucmVxdWlyZTtcbiAgICAgICAgcm9vdC5yZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgcm9vdC5yZXF1aXJlLnBhY2thZ2VkID0gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydEFjZShBQ0VfTkFNRVNQQUNFKTtcblxufSkoKTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZXM2LXNoaW1cIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7ZnVuY3Rpb24gZGVmaW5lUHJvcChvYmosIG5hbWUsIHZhbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cbmlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XG4gICAgZGVmaW5lUHJvcChTdHJpbmcucHJvdG90eXBlLCBcInN0YXJ0c1dpdGhcIiwgZnVuY3Rpb24gKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PT0gcG9zaXRpb247XG4gICAgfSk7XG59XG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgICBkZWZpbmVQcm9wKFN0cmluZy5wcm90b3R5cGUsIFwiZW5kc1dpdGhcIiwgZnVuY3Rpb24gKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN1YmplY3RTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHN1YmplY3RTdHJpbmcubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBzdWJqZWN0U3RyaW5nLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG4gICAgfSk7XG59XG5pZiAoIVN0cmluZy5wcm90b3R5cGUucmVwZWF0KSB7XG4gICAgZGVmaW5lUHJvcChTdHJpbmcucHJvdG90eXBlLCBcInJlcGVhdFwiLCBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoY291bnQgJiAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgICAgICBpZiAoKGNvdW50ID4+PSAxKSlcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5pZiAoIVN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgICBkZWZpbmVQcm9wKFN0cmluZy5wcm90b3R5cGUsIFwiaW5jbHVkZXNcIiwgZnVuY3Rpb24gKHN0ciwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzdHIsIHBvc2l0aW9uKSAhPSAtMTtcbiAgICB9KTtcbn1cbmlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5pZiAoIU9iamVjdC52YWx1ZXMpIHtcbiAgICBPYmplY3QudmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIG9ba107XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgZGVmaW5lUHJvcChBcnJheS5wcm90b3R5cGUsIFwiZmluZFwiLCBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWUgPSB0aGlzW2tdO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICBkZWZpbmVQcm9wKEFycmF5LnByb3RvdHlwZSwgXCJmaW5kSW5kZXhcIiwgZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlID0gdGhpc1trXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCBrVmFsdWUsIGssIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICghQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gICAgZGVmaW5lUHJvcChBcnJheS5wcm90b3R5cGUsIFwiaW5jbHVkZXNcIiwgZnVuY3Rpb24gKGl0ZW0sIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoaXRlbSwgcG9zaXRpb24pICE9IC0xO1xuICAgIH0pO1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsbCkge1xuICAgIGRlZmluZVByb3AoQXJyYXkucHJvdG90eXBlLCBcImZpbGxcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBPID0gdGhpcztcbiAgICAgICAgdmFyIGxlbiA9IE8ubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPj4gMDtcbiAgICAgICAgdmFyIGsgPSByZWxhdGl2ZVN0YXJ0IDwgMFxuICAgICAgICAgICAgPyBNYXRoLm1heChsZW4gKyByZWxhdGl2ZVN0YXJ0LCAwKVxuICAgICAgICAgICAgOiBNYXRoLm1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xuICAgICAgICB2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgcmVsYXRpdmVFbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCA+PiAwO1xuICAgICAgICB2YXIgZmluYWwgPSByZWxhdGl2ZUVuZCA8IDBcbiAgICAgICAgICAgID8gTWF0aC5tYXgobGVuICsgcmVsYXRpdmVFbmQsIDApXG4gICAgICAgICAgICA6IE1hdGgubWluKHJlbGF0aXZlRW5kLCBsZW4pO1xuICAgICAgICB3aGlsZSAoayA8IGZpbmFsKSB7XG4gICAgICAgICAgICBPW2tdID0gdmFsdWU7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE87XG4gICAgfSk7XG59XG5pZiAoIUFycmF5Lm9mKSB7XG4gICAgZGVmaW5lUHJvcChBcnJheSwgXCJvZlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH0pO1xufVxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZml4b2xkYnJvd3NlcnNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXM2LXNoaW1cIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7Ly8gdmltOnNldCB0cz00IHN0cz00IHN3PTQgc3Q6XG5cInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoXCIuL2VzNi1zaGltXCIpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZGVlcF9jb3B5XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe2V4cG9ydHMuZGVlcENvcHkgPSBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIHZhciBjb3B5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29weSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgPSAwOyBrZXkgPCBvYmoubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgY29weVtrZXldID0gZGVlcENvcHkob2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgY29weSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgIGNvcHlba2V5XSA9IGRlZXBDb3B5KG9ialtrZXldKTtcbiAgICByZXR1cm4gY29weTtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9sYW5nXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RlZXBfY29weVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcbn07XG5leHBvcnRzLnN0cmluZ1JldmVyc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbn07XG5leHBvcnRzLnN0cmluZ1JlcGVhdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNvdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgaWYgKGNvdW50ICYgMSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIGlmIChjb3VudCA+Pj0gMSlcbiAgICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHRyaW1CZWdpblJlZ2V4cCA9IC9eXFxzXFxzKi87XG52YXIgdHJpbUVuZFJlZ2V4cCA9IC9cXHNcXHMqJC87XG5leHBvcnRzLnN0cmluZ1RyaW1MZWZ0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKTtcbn07XG5leHBvcnRzLnN0cmluZ1RyaW1SaWdodCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xufTtcbmV4cG9ydHMuY29weU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcbmV4cG9ydHMuY29weUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGNvcHkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXJyYXlbaV0gJiYgdHlwZW9mIGFycmF5W2ldID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBjb3B5W2ldID0gdGhpcy5jb3B5T2JqZWN0KGFycmF5W2ldKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29weVtpXSA9IGFycmF5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG5leHBvcnRzLmRlZXBDb3B5ID0gcmVxdWlyZShcIi4vZGVlcF9jb3B5XCIpLmRlZXBDb3B5O1xuZXhwb3J0cy5hcnJheVRvTWFwID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBbYXJyW2ldXSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59O1xuZXhwb3J0cy5jcmVhdGVNYXAgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpIGluIHByb3BzKSB7XG4gICAgICAgIG1hcFtpXSA9IHByb3BzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufTtcbmV4cG9ydHMuYXJyYXlSZW1vdmUgPSBmdW5jdGlvbiAoYXJyYXksIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBhcnJheVtpXSkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMuZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKis/XiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xufTtcbmV4cG9ydHMuZXNjYXBlSFRNTCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gKFwiXCIgKyBzdHIpLnJlcGxhY2UoLyYvZywgXCImIzM4O1wiKS5yZXBsYWNlKC9cIi9nLCBcIiYjMzQ7XCIpLnJlcGxhY2UoLycvZywgXCImIzM5O1wiKS5yZXBsYWNlKC88L2csIFwiJiM2MDtcIik7XG59O1xuZXhwb3J0cy5nZXRNYXRjaE9mZnNldHMgPSBmdW5jdGlvbiAoc3RyaW5nLCByZWdFeHApIHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHN0cmluZy5yZXBsYWNlKHJlZ0V4cCwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdHIubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaGVzO1xufTtcbmV4cG9ydHMuZGVmZXJyZWRDYWxsID0gZnVuY3Rpb24gKGZjbikge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIGZjbigpO1xuICAgIH07XG4gICAgdmFyIGRlZmVycmVkID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgICAgZGVmZXJyZWQuY2FuY2VsKCk7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCB8fCAwKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH07XG4gICAgZGVmZXJyZWQuc2NoZWR1bGUgPSBkZWZlcnJlZDtcbiAgICBkZWZlcnJlZC5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBmY24oKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH07XG4gICAgZGVmZXJyZWQuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9O1xuICAgIGRlZmVycmVkLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgIH07XG4gICAgcmV0dXJuIGRlZmVycmVkO1xufTtcbmV4cG9ydHMuZGVsYXllZENhbGwgPSBmdW5jdGlvbiAoZmNuLCBkZWZhdWx0VGltZW91dCkge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIGZjbigpO1xuICAgIH07XG4gICAgdmFyIF9zZWxmID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRpbWVyID09IG51bGwpXG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgZGVmYXVsdFRpbWVvdXQpO1xuICAgIH07XG4gICAgX3NlbGYuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgZGVmYXVsdFRpbWVvdXQpO1xuICAgIH07XG4gICAgX3NlbGYuc2NoZWR1bGUgPSBfc2VsZjtcbiAgICBfc2VsZi5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBmY24oKTtcbiAgICB9O1xuICAgIF9zZWxmLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgIH07XG4gICAgX3NlbGYuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgfTtcbiAgICByZXR1cm4gX3NlbGY7XG59O1xuZXhwb3J0cy5zdXBwb3J0c0xvb2tiZWhpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cCgnKD88PS4pJyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0cy5za2lwRW1wdHlNYXRjaCA9IGZ1bmN0aW9uIChsaW5lLCBsYXN0LCBzdXBwb3J0c1VuaWNvZGVGbGFnKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzVW5pY29kZUZsYWcgJiYgbGluZS5jb2RlUG9pbnRBdChsYXN0KSA+IDB4ZmZmZiA/IDIgOiAxO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL3VzZXJhZ2VudFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuT1MgPSB7XG4gICAgTElOVVg6IFwiTElOVVhcIixcbiAgICBNQUM6IFwiTUFDXCIsXG4gICAgV0lORE9XUzogXCJXSU5ET1dTXCJcbn07XG5leHBvcnRzLmdldE9TID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBvcnRzLmlzTWFjKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9TLk1BQztcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwb3J0cy5pc0xpbnV4KSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9TLkxJTlVYO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT1MuV0lORE9XUztcbiAgICB9XG59O1xudmFyIF9uYXZpZ2F0b3IgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgPyBuYXZpZ2F0b3IgOiB7fTtcbnZhciBvcyA9ICgvbWFjfHdpbnxsaW51eC9pLmV4ZWMoX25hdmlnYXRvci5wbGF0Zm9ybSkgfHwgW1wib3RoZXJcIl0pWzBdLnRvTG93ZXJDYXNlKCk7XG52YXIgdWEgPSBfbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xudmFyIGFwcE5hbWUgPSBfbmF2aWdhdG9yLmFwcE5hbWUgfHwgXCJcIjtcbmV4cG9ydHMuaXNXaW4gPSAob3MgPT0gXCJ3aW5cIik7XG5leHBvcnRzLmlzTWFjID0gKG9zID09IFwibWFjXCIpO1xuZXhwb3J0cy5pc0xpbnV4ID0gKG9zID09IFwibGludXhcIik7XG5leHBvcnRzLmlzSUUgPVxuICAgIChhcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIgfHwgYXBwTmFtZS5pbmRleE9mKFwiTVNBcHBIb3N0XCIpID49IDApXG4gICAgICAgID8gcGFyc2VGbG9hdCgodWEubWF0Y2goLyg/Ok1TSUUgfFRyaWRlbnRcXC9bMC05XStbXFwuMC05XSs7LipydjopKFswLTldK1tcXC4wLTldKykvKSB8fCBbXSlbMV0pXG4gICAgICAgIDogcGFyc2VGbG9hdCgodWEubWF0Y2goLyg/OlRyaWRlbnRcXC9bMC05XStbXFwuMC05XSs7LipydjopKFswLTldK1tcXC4wLTldKykvKSB8fCBbXSlbMV0pOyAvLyBmb3IgaWVcbmV4cG9ydHMuaXNPbGRJRSA9IGV4cG9ydHMuaXNJRSAmJiBleHBvcnRzLmlzSUUgPCA5O1xuZXhwb3J0cy5pc0dlY2tvID0gZXhwb3J0cy5pc01vemlsbGEgPSB1YS5tYXRjaCgvIEdlY2tvXFwvXFxkKy8pO1xuZXhwb3J0cy5pc09wZXJhID0gdHlwZW9mIG9wZXJhID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvd1tcIm9wZXJhXCJdKSA9PSBcIltvYmplY3QgT3BlcmFdXCI7XG5leHBvcnRzLmlzV2ViS2l0ID0gcGFyc2VGbG9hdCh1YS5zcGxpdChcIldlYktpdC9cIilbMV0pIHx8IHVuZGVmaW5lZDtcbmV4cG9ydHMuaXNDaHJvbWUgPSBwYXJzZUZsb2F0KHVhLnNwbGl0KFwiIENocm9tZS9cIilbMV0pIHx8IHVuZGVmaW5lZDtcbmV4cG9ydHMuaXNTYWZhcmkgPSBwYXJzZUZsb2F0KHVhLnNwbGl0KFwiIFNhZmFyaS9cIilbMV0pICYmICFleHBvcnRzLmlzQ2hyb21lIHx8IHVuZGVmaW5lZDtcbmV4cG9ydHMuaXNFZGdlID0gcGFyc2VGbG9hdCh1YS5zcGxpdChcIiBFZGdlL1wiKVsxXSkgfHwgdW5kZWZpbmVkO1xuZXhwb3J0cy5pc0FJUiA9IHVhLmluZGV4T2YoXCJBZG9iZUFJUlwiKSA+PSAwO1xuZXhwb3J0cy5pc0FuZHJvaWQgPSB1YS5pbmRleE9mKFwiQW5kcm9pZFwiKSA+PSAwO1xuZXhwb3J0cy5pc0Nocm9tZU9TID0gdWEuaW5kZXhPZihcIiBDck9TIFwiKSA+PSAwO1xuZXhwb3J0cy5pc0lPUyA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVhKSAmJiAhd2luZG93W1wiTVNTdHJlYW1cIl07XG5pZiAoZXhwb3J0cy5pc0lPUylcbiAgICBleHBvcnRzLmlzTWFjID0gdHJ1ZTtcbmV4cG9ydHMuaXNNb2JpbGUgPSBleHBvcnRzLmlzSU9TIHx8IGV4cG9ydHMuaXNBbmRyb2lkO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZG9tXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi91c2VyYWdlbnRcIik7XG52YXIgWEhUTUxfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbmV4cG9ydHMuYnVpbGREb20gPSBmdW5jdGlvbiBidWlsZERvbShhcnIsIHBhcmVudCwgcmVmcykge1xuICAgIGlmICh0eXBlb2YgYXJyID09IFwic3RyaW5nXCIgJiYgYXJyKSB7XG4gICAgICAgIHZhciB0eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhcnIpO1xuICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHR4dCk7XG4gICAgICAgIHJldHVybiB0eHQ7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGlmIChhcnIgJiYgYXJyLmFwcGVuZENoaWxkICYmIHBhcmVudClcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChhcnIpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyclswXSAhPSBcInN0cmluZ1wiIHx8ICFhcnJbMF0pIHtcbiAgICAgICAgdmFyIGVscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gYnVpbGREb20oYXJyW2ldLCBwYXJlbnQsIHJlZnMpO1xuICAgICAgICAgICAgY2ggJiYgZWxzLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHM7XG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYXJyWzBdKTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyclsxXTtcbiAgICB2YXIgY2hpbGRJbmRleCA9IDE7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSlcbiAgICAgICAgY2hpbGRJbmRleCA9IDI7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkSW5kZXg7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1aWxkRG9tKGFycltpXSwgZWwsIHJlZnMpO1xuICAgIGlmIChjaGlsZEluZGV4ID09IDIpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbnNbbl07XG4gICAgICAgICAgICBpZiAobiA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLmpvaW4oXCIgXCIpIDogdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PSBcImZ1bmN0aW9uXCIgfHwgbiA9PSBcInZhbHVlXCIgfHwgblswXSA9PSBcIiRcIikge1xuICAgICAgICAgICAgICAgIGVsW25dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobiA9PT0gXCJyZWZcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWZzKVxuICAgICAgICAgICAgICAgICAgICByZWZzW3ZhbF0gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG4gPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShuLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmVudClcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG59O1xuZXhwb3J0cy5nZXREb2N1bWVudEhlYWQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgaWYgKCFkb2MpXG4gICAgICAgIGRvYyA9IGRvY3VtZW50O1xuICAgIHJldHVybiBkb2MuaGVhZCB8fCBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG59O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZywgbnMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TID9cbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zIHx8IFhIVE1MX05TLCB0YWcpIDpcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xufTtcbmV4cG9ydHMucmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbn07XG5leHBvcnRzLmNyZWF0ZVRleHROb2RlID0gZnVuY3Rpb24gKHRleHRDb250ZW50LCBlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHRDb250ZW50KTtcbn07XG5leHBvcnRzLmNyZWF0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xuICAgIHJldHVybiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufTtcbmV4cG9ydHMuaGFzQ3NzQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgICB2YXIgY2xhc3NlcyA9IChlbC5jbGFzc05hbWUgKyBcIlwiKS5zcGxpdCgvXFxzKy9nKTtcbiAgICByZXR1cm4gY2xhc3Nlcy5pbmRleE9mKG5hbWUpICE9PSAtMTtcbn07XG5leHBvcnRzLmFkZENzc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgaWYgKCFleHBvcnRzLmhhc0Nzc0NsYXNzKGVsLCBuYW1lKSkge1xuICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBuYW1lO1xuICAgIH1cbn07XG5leHBvcnRzLnJlbW92ZUNzc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoL1xccysvZyk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbn07XG5leHBvcnRzLnRvZ2dsZUNzc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoL1xccysvZyksIGFkZCA9IHRydWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFkZCA9IGZhbHNlO1xuICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGlmIChhZGQpXG4gICAgICAgIGNsYXNzZXMucHVzaChuYW1lKTtcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgIHJldHVybiBhZGQ7XG59O1xuZXhwb3J0cy5zZXRDc3NDbGFzcyA9IGZ1bmN0aW9uIChub2RlLCBjbGFzc05hbWUsIGluY2x1ZGUpIHtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICBleHBvcnRzLmFkZENzc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleHBvcnRzLnJlbW92ZUNzc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgfVxufTtcbmV4cG9ydHMuaGFzQ3NzU3RyaW5nID0gZnVuY3Rpb24gKGlkLCBkb2MpIHtcbiAgICB2YXIgaW5kZXggPSAwLCBzaGVldHM7XG4gICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgIGlmICgoc2hlZXRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVwiKSkpIHtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc2hlZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNoZWV0c1tpbmRleCsrXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnJlbW92ZUVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGlkLCBkb2MpIHtcbiAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgaWYgKGRvYy5nZXRFbGVtZW50QnlJZChpZCkpIHtcbiAgICAgICAgZG9jLmdldEVsZW1lbnRCeUlkKGlkKS5yZW1vdmUoKTtcbiAgICB9XG59O1xudmFyIHN0cmljdENTUDtcbnZhciBjc3NDYWNoZSA9IFtdO1xuZXhwb3J0cy51c2VTdHJpY3RDU1AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBzdHJpY3RDU1AgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT0gZmFsc2UpXG4gICAgICAgIGluc2VydFBlbmRpbmdTdHlsZXMoKTtcbiAgICBlbHNlIGlmICghY3NzQ2FjaGUpXG4gICAgICAgIGNzc0NhY2hlID0gW107XG59O1xuZnVuY3Rpb24gaW5zZXJ0UGVuZGluZ1N0eWxlcygpIHtcbiAgICB2YXIgY2FjaGUgPSBjc3NDYWNoZTtcbiAgICBjc3NDYWNoZSA9IG51bGw7XG4gICAgY2FjaGUgJiYgY2FjaGUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpbXBvcnRDc3NTdHJpbmcoaXRlbVswXSwgaXRlbVsxXSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbXBvcnRDc3NTdHJpbmcoY3NzVGV4dCwgaWQsIHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChjc3NDYWNoZSkge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpbnNlcnRQZW5kaW5nU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNzc0NhY2hlLnB1c2goW2Nzc1RleHQsIGlkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmljdENTUClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBjb250YWluZXIgPSB0YXJnZXQ7XG4gICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5nZXRSb290Tm9kZSkge1xuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lciA9IHRhcmdldC5nZXRSb290Tm9kZSgpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCBjb250YWluZXIgPT0gdGFyZ2V0KVxuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBkb2MgPSBjb250YWluZXIub3duZXJEb2N1bWVudCB8fCBjb250YWluZXI7XG4gICAgaWYgKGlkICYmIGV4cG9ydHMuaGFzQ3NzU3RyaW5nKGlkLCBjb250YWluZXIpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaWQpXG4gICAgICAgIGNzc1RleHQgKz0gXCJcXG4vKiMgc291cmNlVVJMPWFjZS9jc3MvXCIgKyBpZCArIFwiICovXCI7XG4gICAgdmFyIHN0eWxlID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgICBpZiAoaWQpXG4gICAgICAgIHN0eWxlLmlkID0gaWQ7XG4gICAgaWYgKGNvbnRhaW5lciA9PSBkb2MpXG4gICAgICAgIGNvbnRhaW5lciA9IGV4cG9ydHMuZ2V0RG9jdW1lbnRIZWFkKGRvYyk7XG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZShzdHlsZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xufVxuZXhwb3J0cy5pbXBvcnRDc3NTdHJpbmcgPSBpbXBvcnRDc3NTdHJpbmc7XG5leHBvcnRzLmltcG9ydENzc1N0eWxzaGVldCA9IGZ1bmN0aW9uICh1cmksIGRvYykge1xuICAgIGV4cG9ydHMuYnVpbGREb20oW1wibGlua1wiLCB7IHJlbDogXCJzdHlsZXNoZWV0XCIsIGhyZWY6IHVyaSB9XSwgZXhwb3J0cy5nZXREb2N1bWVudEhlYWQoZG9jKSk7XG59O1xuZXhwb3J0cy5zY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICB2YXIgaW5uZXIgPSBleHBvcnRzLmNyZWF0ZUVsZW1lbnQoXCJhY2VfaW5uZXJcIik7XG4gICAgaW5uZXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICBpbm5lci5zdHlsZS5taW5XaWR0aCA9IFwiMHB4XCI7XG4gICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xuICAgIGlubmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdmFyIG91dGVyID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50KFwiYWNlX291dGVyXCIpO1xuICAgIHZhciBzdHlsZSA9IG91dGVyLnN0eWxlO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHN0eWxlLmxlZnQgPSBcIi0xMDAwMHB4XCI7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHN0eWxlLndpZHRoID0gXCIyMDBweFwiO1xuICAgIHN0eWxlLm1pbldpZHRoID0gXCIwcHhcIjtcbiAgICBzdHlsZS5oZWlnaHQgPSBcIjE1MHB4XCI7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgdmFyIGJvZHkgPSAoZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQpIHx8IChkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIGlmICghYm9keSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG4gICAgdmFyIG5vU2Nyb2xsYmFyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSBcInNjcm9sbFwiO1xuICAgIHZhciB3aXRoU2Nyb2xsYmFyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgaWYgKG5vU2Nyb2xsYmFyID09PSB3aXRoU2Nyb2xsYmFyKSB7XG4gICAgICAgIHdpdGhTY3JvbGxiYXIgPSBvdXRlci5jbGllbnRXaWR0aDtcbiAgICB9XG4gICAgYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG4gICAgcmV0dXJuIG5vU2Nyb2xsYmFyIC0gd2l0aFNjcm9sbGJhcjtcbn07XG5leHBvcnRzLmNvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGUpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgXCJcIikgfHwge307XG59O1xuZXhwb3J0cy5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmIChzdHlsZXNbcHJvcGVydHldICE9PSB2YWx1ZSkge1xuICAgICAgICBzdHlsZXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydHMuSEFTX0NTU19BTklNQVRJT04gPSBmYWxzZTtcbmV4cG9ydHMuSEFTX0NTU19UUkFOU0ZPUk1TID0gZmFsc2U7XG5leHBvcnRzLkhJX0RQSSA9IHVzZXJhZ2VudC5pc1dpblxuICAgID8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAxLjVcbiAgICA6IHRydWU7XG5pZiAodXNlcmFnZW50LmlzQ2hyb21lT1MpXG4gICAgZXhwb3J0cy5ISV9EUEkgPSBmYWxzZTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBpZiAoZXhwb3J0cy5ISV9EUEkgJiYgZGl2LnN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBleHBvcnRzLkhBU19DU1NfVFJBTlNGT1JNUyA9IHRydWU7XG4gICAgaWYgKCF1c2VyYWdlbnQuaXNFZGdlICYmIHR5cGVvZiBkaXYuc3R5bGUuYW5pbWF0aW9uTmFtZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgZXhwb3J0cy5IQVNfQ1NTX0FOSU1BVElPTiA9IHRydWU7XG4gICAgZGl2ID0gbnVsbDtcbn1cbmlmIChleHBvcnRzLkhBU19DU1NfVFJBTlNGT1JNUykge1xuICAgIGV4cG9ydHMudHJhbnNsYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHR4LCB0eSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgTWF0aC5yb3VuZCh0eCkgKyBcInB4LCBcIiArIE1hdGgucm91bmQodHkpICsgXCJweClcIjtcbiAgICB9O1xufVxuZWxzZSB7XG4gICAgZXhwb3J0cy50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHgsIHR5KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gTWF0aC5yb3VuZCh0eSkgKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IE1hdGgucm91bmQodHgpICsgXCJweFwiO1xuICAgIH07XG59XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9uZXRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpey8qXG4gKiBiYXNlZCBvbiBjb2RlIGZyb206XG4gKlxuICogQGxpY2Vuc2UgUmVxdWlyZUpTIHRleHQgMC4yNS4wIENvcHlyaWdodCAoYykgMjAxMC0yMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcyBmb3IgZGV0YWlsc1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi9kb21cIik7XG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKG51bGwpO1xufTtcbmV4cG9ydHMubG9hZFNjcmlwdCA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaykge1xuICAgIHZhciBoZWFkID0gZG9tLmdldERvY3VtZW50SGVhZCgpO1xuICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgcy5zcmMgPSBwYXRoO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQocyk7XG4gICAgcy5vbmxvYWQgPSBzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChfLCBpc0Fib3J0KSB7XG4gICAgICAgIGlmIChpc0Fib3J0IHx8ICFzLnJlYWR5U3RhdGUgfHwgcy5yZWFkeVN0YXRlID09IFwibG9hZGVkXCIgfHwgcy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgcyA9IHMub25sb2FkID0gcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpc0Fib3J0KVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMucXVhbGlmeVVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGEuaHJlZjtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9vb3BcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiAob2JqLCBtaXhpbikge1xuICAgIGZvciAodmFyIGtleSBpbiBtaXhpbikge1xuICAgICAgICBvYmpba2V5XSA9IG1peGluW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuZXhwb3J0cy5pbXBsZW1lbnQgPSBmdW5jdGlvbiAocHJvdG8sIG1peGluKSB7XG4gICAgZXhwb3J0cy5taXhpbihwcm90bywgbWl4aW4pO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXZlbnRFbWl0dGVyID0ge307XG52YXIgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkgeyB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7IH07XG52YXIgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH07XG5FdmVudEVtaXR0ZXIuX2VtaXQgPVxuICAgIEV2ZW50RW1pdHRlci5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGUpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRSZWdpc3RyeSB8fCAodGhpcy5fZXZlbnRSZWdpc3RyeSA9IHt9KTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJzIHx8ICh0aGlzLl9kZWZhdWx0SGFuZGxlcnMgPSB7fSk7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gfHwgW107XG4gICAgICAgIHZhciBkZWZhdWx0SGFuZGxlciA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycy5sZW5ndGggJiYgIWRlZmF1bHRIYW5kbGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICAgICAgICAgIGUgPSB7fTtcbiAgICAgICAgaWYgKCFlLnR5cGUpXG4gICAgICAgICAgICBlLnR5cGUgPSBldmVudE5hbWU7XG4gICAgICAgIGlmICghZS5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbiA9IHN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgaWYgKCFlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXShlLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdEhhbmRsZXIgJiYgIWUuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0SGFuZGxlcihlLCB0aGlzKTtcbiAgICB9O1xuRXZlbnRFbWl0dGVyLl9zaWduYWwgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9ICh0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9KVtldmVudE5hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICByZXR1cm47XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGxpc3RlbmVyc1tpXShlLCB0aGlzKTtcbn07XG5FdmVudEVtaXR0ZXIub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICB0aGlzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gbmV3Q2FsbGJhY2soKSB7XG4gICAgICAgIF9zZWxmLm9mZihldmVudE5hbWUsIG5ld0NhbGxiYWNrKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuRXZlbnRFbWl0dGVyLnNldERlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnM7XG4gICAgaWYgKCFoYW5kbGVycylcbiAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnMgPSB7IF9kaXNhYmxlZF86IHt9IH07XG4gICAgaWYgKGhhbmRsZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIG9sZCA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIHZhciBkaXNhYmxlZCA9IGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFkaXNhYmxlZClcbiAgICAgICAgICAgIGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXSA9IGRpc2FibGVkID0gW107XG4gICAgICAgIGRpc2FibGVkLnB1c2gob2xkKTtcbiAgICAgICAgdmFyIGkgPSBkaXNhYmxlZC5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpXG4gICAgICAgICAgICBkaXNhYmxlZC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBjYWxsYmFjaztcbn07XG5FdmVudEVtaXR0ZXIucmVtb3ZlRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2RlZmF1bHRIYW5kbGVycztcbiAgICBpZiAoIWhhbmRsZXJzKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGRpc2FibGVkID0gaGFuZGxlcnMuX2Rpc2FibGVkX1tldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyc1tldmVudE5hbWVdID09IGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEhhbmRsZXIoZXZlbnROYW1lLCBkaXNhYmxlZC5wb3AoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHZhciBpID0gZGlzYWJsZWQuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgZGlzYWJsZWQuc3BsaWNlKGksIDEpO1xuICAgIH1cbn07XG5FdmVudEVtaXR0ZXIub24gPVxuICAgIEV2ZW50RW1pdHRlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGNhcHR1cmluZykge1xuICAgICAgICB0aGlzLl9ldmVudFJlZ2lzdHJ5ID0gdGhpcy5fZXZlbnRSZWdpc3RyeSB8fCB7fTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSA9PSAtMSlcbiAgICAgICAgICAgIGxpc3RlbmVyc1tjYXB0dXJpbmcgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiXShjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9O1xuRXZlbnRFbWl0dGVyLm9mZiA9XG4gICAgRXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyID1cbiAgICAgICAgRXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRSZWdpc3RyeSA9IHRoaXMuX2V2ZW50UmVnaXN0cnkgfHwge307XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbkV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgaWYgKCFldmVudE5hbWUpXG4gICAgICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50UmVnaXN0cnkpXG4gICAgICAgIHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5fZGVmYXVsdEhhbmRsZXJzKVxuICAgICAgICB0aGlzLl9kZWZhdWx0SGFuZGxlcnNbZXZlbnROYW1lXSA9IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL3JlcG9ydF9lcnJvclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtleHBvcnRzLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gcmVwb3J0RXJyb3IobXNnLCBkYXRhKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobXNnKTtcbiAgICBlW1wiZGF0YVwiXSA9IGRhdGE7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlID09IFwib2JqZWN0XCIgJiYgY29uc29sZS5lcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZGVmYXVsdF9lbmdsaXNoX21lc3NhZ2VzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe3ZhciBkZWZhdWx0RW5nbGlzaE1lc3NhZ2VzID0ge1xuICAgIFwiYXV0b2NvbXBsZXRlLnBvcHVwLmFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwiQXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXCIsXG4gICAgXCJhdXRvY29tcGxldGUucG9wdXAuYXJpYS1sYWJlbFwiOiBcIkF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uc1wiLFxuICAgIFwiYXV0b2NvbXBsZXRlLnBvcHVwLml0ZW0uYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJpdGVtXCIsXG4gICAgXCJhdXRvY29tcGxldGUubG9hZGluZ1wiOiBcIkxvYWRpbmcuLi5cIixcbiAgICBcImVkaXRvci5zY3JvbGxlci5hcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImVkaXRvclwiLFxuICAgIFwiZWRpdG9yLnNjcm9sbGVyLmFyaWEtbGFiZWxcIjogXCJFZGl0b3IgY29udGVudCwgcHJlc3MgRW50ZXIgdG8gc3RhcnQgZWRpdGluZywgcHJlc3MgRXNjYXBlIHRvIGV4aXRcIixcbiAgICBcImVkaXRvci5ndXR0ZXIuYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJlZGl0b3JcIixcbiAgICBcImVkaXRvci5ndXR0ZXIuYXJpYS1sYWJlbFwiOiBcIkVkaXRvciBndXR0ZXIsIHByZXNzIEVudGVyIHRvIGludGVyYWN0IHdpdGggY29udHJvbHMgdXNpbmcgYXJyb3cga2V5cywgcHJlc3MgRXNjYXBlIHRvIGV4aXRcIixcbiAgICBcImVycm9yLW1hcmtlci5nb29kLXN0YXRlXCI6IFwiTG9va3MgZ29vZCFcIixcbiAgICBcInByb21wdC5yZWNlbnRseS11c2VkXCI6IFwiUmVjZW50bHkgdXNlZFwiLFxuICAgIFwicHJvbXB0Lm90aGVyLWNvbW1hbmRzXCI6IFwiT3RoZXIgY29tbWFuZHNcIixcbiAgICBcInByb21wdC5uby1tYXRjaGluZy1jb21tYW5kc1wiOiBcIk5vIG1hdGNoaW5nIGNvbW1hbmRzXCIsXG4gICAgXCJzZWFyY2gtYm94LmZpbmQucGxhY2Vob2xkZXJcIjogXCJTZWFyY2ggZm9yXCIsXG4gICAgXCJzZWFyY2gtYm94LmZpbmQtYWxsLnRleHRcIjogXCJBbGxcIixcbiAgICBcInNlYXJjaC1ib3gucmVwbGFjZS5wbGFjZWhvbGRlclwiOiBcIlJlcGxhY2Ugd2l0aFwiLFxuICAgIFwic2VhcmNoLWJveC5yZXBsYWNlLW5leHQudGV4dFwiOiBcIlJlcGxhY2VcIixcbiAgICBcInNlYXJjaC1ib3gucmVwbGFjZS1hbGwudGV4dFwiOiBcIkFsbFwiLFxuICAgIFwic2VhcmNoLWJveC50b2dnbGUtcmVwbGFjZS50aXRsZVwiOiBcIlRvZ2dsZSBSZXBsYWNlIG1vZGVcIixcbiAgICBcInNlYXJjaC1ib3gudG9nZ2xlLXJlZ2V4cC50aXRsZVwiOiBcIlJlZ0V4cCBTZWFyY2hcIixcbiAgICBcInNlYXJjaC1ib3gudG9nZ2xlLWNhc2UudGl0bGVcIjogXCJDYXNlU2Vuc2l0aXZlIFNlYXJjaFwiLFxuICAgIFwic2VhcmNoLWJveC50b2dnbGUtd2hvbGUtd29yZC50aXRsZVwiOiBcIldob2xlIFdvcmQgU2VhcmNoXCIsXG4gICAgXCJzZWFyY2gtYm94LnRvZ2dsZS1pbi1zZWxlY3Rpb24udGl0bGVcIjogXCJTZWFyY2ggSW4gU2VsZWN0aW9uXCIsXG4gICAgXCJzZWFyY2gtYm94LnNlYXJjaC1jb3VudGVyXCI6IFwiJDAgb2YgJDFcIixcbiAgICBcInRleHQtaW5wdXQuYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJlZGl0b3JcIixcbiAgICBcInRleHQtaW5wdXQuYXJpYS1sYWJlbFwiOiBcIkN1cnNvciBhdCByb3cgJDBcIixcbiAgICBcImd1dHRlci5jb2RlLWZvbGRpbmcucmFuZ2UuYXJpYS1sYWJlbFwiOiBcIlRvZ2dsZSBjb2RlIGZvbGRpbmcsIHJvd3MgJDAgdGhyb3VnaCAkMVwiLFxuICAgIFwiZ3V0dGVyLmNvZGUtZm9sZGluZy5jbG9zZWQuYXJpYS1sYWJlbFwiOiBcIlRvZ2dsZSBjb2RlIGZvbGRpbmcsIHJvd3MgJDAgdGhyb3VnaCAkMVwiLFxuICAgIFwiZ3V0dGVyLmNvZGUtZm9sZGluZy5vcGVuLmFyaWEtbGFiZWxcIjogXCJUb2dnbGUgY29kZSBmb2xkaW5nLCByb3cgJDBcIixcbiAgICBcImd1dHRlci5jb2RlLWZvbGRpbmcuY2xvc2VkLnRpdGxlXCI6IFwiVW5mb2xkIGNvZGVcIixcbiAgICBcImd1dHRlci5jb2RlLWZvbGRpbmcub3Blbi50aXRsZVwiOiBcIkZvbGQgY29kZVwiLFxuICAgIFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC5lcnJvclwiOiBcIkVycm9yLCByZWFkIGFubm90YXRpb25zIHJvdyAkMFwiLFxuICAgIFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC53YXJuaW5nXCI6IFwiV2FybmluZywgcmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIixcbiAgICBcImd1dHRlci5hbm5vdGF0aW9uLmFyaWEtbGFiZWwuaW5mb1wiOiBcIkluZm8sIHJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsXG4gICAgXCJpbmxpbmUtZm9sZC5jbG9zZWQudGl0bGVcIjogXCJVbmZvbGQgY29kZVwiLFxuICAgIFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC5lcnJvci5zaW5ndWxhclwiOiBcImVycm9yXCIsXG4gICAgXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmVycm9yLnBsdXJhbFwiOiBcImVycm9yc1wiLFxuICAgIFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC53YXJuaW5nLnNpbmd1bGFyXCI6IFwid2FybmluZ1wiLFxuICAgIFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC53YXJuaW5nLnBsdXJhbFwiOiBcIndhcm5pbmdzXCIsXG4gICAgXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmluZm8uc2luZ3VsYXJcIjogXCJpbmZvcm1hdGlvbiBtZXNzYWdlXCIsXG4gICAgXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmluZm8ucGx1cmFsXCI6IFwiaW5mb3JtYXRpb24gbWVzc2FnZXNcIlxufTtcbmV4cG9ydHMuZGVmYXVsdEVuZ2xpc2hNZXNzYWdlcyA9IGRlZmF1bHRFbmdsaXNoTWVzc2FnZXM7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9hcHBfY29uZmlnXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvbGliL3JlcG9ydF9lcnJvclwiLFwiYWNlL2xpYi9kZWZhdWx0X2VuZ2xpc2hfbWVzc2FnZXNcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJubyB1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vb29wXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIHJlcG9ydEVycm9yID0gcmVxdWlyZShcIi4vcmVwb3J0X2Vycm9yXCIpLnJlcG9ydEVycm9yO1xudmFyIGRlZmF1bHRFbmdsaXNoTWVzc2FnZXMgPSByZXF1aXJlKFwiLi9kZWZhdWx0X2VuZ2xpc2hfbWVzc2FnZXNcIikuZGVmYXVsdEVuZ2xpc2hNZXNzYWdlcztcbnZhciBvcHRpb25zUHJvdmlkZXIgPSB7XG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdExpc3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0TGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbihrZXksIG9wdExpc3Rba2V5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbk5hbWVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25OYW1lcykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9uTmFtZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhb3B0aW9uc1trZXldLmhpZGRlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbk5hbWVzKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb3B0aW9uTmFtZXM7XG4gICAgICAgICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuZ2V0T3B0aW9uKGtleSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgc2V0T3B0aW9uOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXNbXCIkXCIgKyBuYW1lXSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBvcHQgPSB0aGlzLiRvcHRpb25zW25hbWVdO1xuICAgICAgICBpZiAoIW9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIHdhcm4oJ21pc3NwZWxsZWQgb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LmZvcndhcmRUbylcbiAgICAgICAgICAgIHJldHVybiB0aGlzW29wdC5mb3J3YXJkVG9dICYmIHRoaXNbb3B0LmZvcndhcmRUb10uc2V0T3B0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHQuaGFuZGxlc1NldClcbiAgICAgICAgICAgIHRoaXNbXCIkXCIgKyBuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAob3B0ICYmIG9wdC5zZXQpXG4gICAgICAgICAgICBvcHQuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgb3B0ID0gdGhpcy4kb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKCFvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiB3YXJuKCdtaXNzcGVsbGVkIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC5mb3J3YXJkVG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tvcHQuZm9yd2FyZFRvXSAmJiB0aGlzW29wdC5mb3J3YXJkVG9dLmdldE9wdGlvbihuYW1lKTtcbiAgICAgICAgcmV0dXJuIG9wdCAmJiBvcHQuZ2V0ID8gb3B0LmdldC5jYWxsKHRoaXMpIDogdGhpc1tcIiRcIiArIG5hbWVdO1xuICAgIH1cbn07XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pXG4gICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xufVxudmFyIG1lc3NhZ2VzO1xudmFyIG5sc1BsYWNlaG9sZGVycztcbnZhciBBcHBDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwQ29uZmlnKCkge1xuICAgICAgICB0aGlzLiRkZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgICAgICBtZXNzYWdlcyA9IGRlZmF1bHRFbmdsaXNoTWVzc2FnZXM7XG4gICAgICAgIG5sc1BsYWNlaG9sZGVycyA9IFwiZG9sbGFyU2lnbnNcIjtcbiAgICB9XG4gICAgQXBwQ29uZmlnLnByb3RvdHlwZS5kZWZpbmVPcHRpb25zID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9iai4kb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMuJGRlZmF1bHRPcHRpb25zW3BhdGhdID0gb2JqLiRvcHRpb25zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgb3B0ID0geyBmb3J3YXJkVG86IG9wdCB9O1xuICAgICAgICAgICAgb3B0Lm5hbWUgfHwgKG9wdC5uYW1lID0ga2V5KTtcbiAgICAgICAgICAgIG9iai4kb3B0aW9uc1tvcHQubmFtZV0gPSBvcHQ7XG4gICAgICAgICAgICBpZiAoXCJpbml0aWFsVmFsdWVcIiBpbiBvcHQpXG4gICAgICAgICAgICAgICAgb2JqW1wiJFwiICsgb3B0Lm5hbWVdID0gb3B0LmluaXRpYWxWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9vcC5pbXBsZW1lbnQob2JqLCBvcHRpb25zUHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFwcENvbmZpZy5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmouJG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IG9iai4kb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBvcHQpXG4gICAgICAgICAgICAgICAgb2JqLnNldE9wdGlvbihrZXksIG9wdC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXBwQ29uZmlnLnByb3RvdHlwZS5zZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAocGF0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBmb3IgKHBhdGggaW4gdGhpcy4kZGVmYXVsdE9wdGlvbnMpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGRlZmF1bHRPcHRpb25zW3BhdGhdW25hbWVdKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICghdGhpcy4kZGVmYXVsdE9wdGlvbnNbcGF0aF1bbmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy4kZGVmYXVsdE9wdGlvbnNbcGF0aF0gfHwgKHRoaXMuJGRlZmF1bHRPcHRpb25zW3BhdGhdID0ge30pO1xuICAgICAgICBpZiAob3B0c1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKG9wdHMuZm9yd2FyZFRvKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdFZhbHVlKG9wdHMuZm9yd2FyZFRvLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3B0c1tuYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcHBDb25maWcucHJvdG90eXBlLnNldERlZmF1bHRWYWx1ZXMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9uSGFzaCkge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25IYXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdFZhbHVlKHBhdGgsIGtleSwgb3B0aW9uSGFzaFtrZXldKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBBcHBDb25maWcucHJvdG90eXBlLnNldE1lc3NhZ2VzID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gdmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGxhY2Vob2xkZXJzKSB7XG4gICAgICAgICAgICBubHNQbGFjZWhvbGRlcnMgPSBvcHRpb25zLnBsYWNlaG9sZGVycztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXBwQ29uZmlnLnByb3RvdHlwZS5ubHMgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0U3RyaW5nLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlc1trZXldKSB7XG4gICAgICAgICAgICB3YXJuKFwiTm8gbWVzc2FnZSBmb3VuZCBmb3IgdGhlIGtleSAnXCIgKyBrZXkgKyBcIicgaW4gdGhlIHByb3ZpZGVkIG1lc3NhZ2VzLCB0cnlpbmcgdG8gZmluZCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZGVmYXVsdCBzdHJpbmcgJ1wiICsgZGVmYXVsdFN0cmluZyArIFwiJy5cIik7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2VzW2RlZmF1bHRTdHJpbmddKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIk5vIG1lc3NhZ2UgZm91bmQgZm9yIHRoZSBkZWZhdWx0IHN0cmluZyAnXCIgKyBkZWZhdWx0U3RyaW5nICsgXCInIGluIHRoZSBwcm92aWRlZCBtZXNzYWdlcy4gRmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IEVuZ2xpc2ggbWVzc2FnZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zbGF0ZWQgPSBtZXNzYWdlc1trZXldIHx8IG1lc3NhZ2VzW2RlZmF1bHRTdHJpbmddIHx8IGRlZmF1bHRTdHJpbmc7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChubHNQbGFjZWhvbGRlcnMgPT09IFwiZG9sbGFyU2lnbnNcIikge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGVkLnJlcGxhY2UoL1xcJChcXCR8W1xcZF0rKS9nLCBmdW5jdGlvbiAoXywgZG9sbGFyTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbGxhck1hdGNoID09IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zW2RvbGxhck1hdGNoXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChubHNQbGFjZWhvbGRlcnMgPT09IFwiY3VybHlCcmFja2V0c1wiKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZWQucmVwbGFjZSgvXFx7KFteXFx9XSspXFx9L2csIGZ1bmN0aW9uIChfLCBjdXJseUJyYWNrZXRNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zW2N1cmx5QnJhY2tldE1hdGNoXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICB9O1xuICAgIHJldHVybiBBcHBDb25maWc7XG59KCkpO1xuQXBwQ29uZmlnLnByb3RvdHlwZS53YXJuID0gd2FybjtcbkFwcENvbmZpZy5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcbm9vcC5pbXBsZW1lbnQoQXBwQ29uZmlnLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuQXBwQ29uZmlnID0gQXBwQ29uZmlnO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS90aGVtZS90ZXh0bWF0ZS1jc3NcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7bW9kdWxlLmV4cG9ydHMgPSBcIi5hY2UtdG0gLmFjZV9ndXR0ZXIge1xcbiAgYmFja2dyb3VuZDogI2YwZjBmMDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfcHJpbnQtbWFyZ2luIHtcXG4gIHdpZHRoOiAxcHg7XFxuICBiYWNrZ3JvdW5kOiAjZThlOGU4O1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfZm9sZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM2QjcyRTY7XFxufVxcblxcbi5hY2UtdG0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmFjZS10bSAuYWNlX2N1cnNvciB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcbiAgICAgICAgXFxuLmFjZS10bSAuYWNlX2ludmlzaWJsZSB7XFxuICBjb2xvcjogcmdiKDE5MSwgMTkxLCAxOTEpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2Vfc3RvcmFnZSxcXG4uYWNlLXRtIC5hY2Vfa2V5d29yZCB7XFxuICBjb2xvcjogYmx1ZTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50IHtcXG4gIGNvbG9yOiByZ2IoMTk3LCA2LCAxMSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9jb25zdGFudC5hY2VfYnVpbGRpbiB7XFxuICBjb2xvcjogcmdiKDg4LCA3MiwgMjQ2KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9sYW5ndWFnZSB7XFxuICBjb2xvcjogcmdiKDg4LCA5MiwgMjQ2KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9saWJyYXJ5IHtcXG4gIGNvbG9yOiByZ2IoNiwgMTUwLCAxNCk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9pbnZhbGlkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAwLCAwLCAwLjEpO1xcbiAgY29sb3I6IHJlZDtcXG59XFxuXFxuLmFjZS10bSAuYWNlX3N1cHBvcnQuYWNlX2Z1bmN0aW9uIHtcXG4gIGNvbG9yOiByZ2IoNjAsIDc2LCAxMTQpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfY29uc3RhbnQge1xcbiAgY29sb3I6IHJnYig2LCAxNTAsIDE0KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX3N1cHBvcnQuYWNlX3R5cGUsXFxuLmFjZS10bSAuYWNlX3N1cHBvcnQuYWNlX2NsYXNzIHtcXG4gIGNvbG9yOiByZ2IoMTA5LCAxMjEsIDIyMik7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9rZXl3b3JkLmFjZV9vcGVyYXRvciB7XFxuICBjb2xvcjogcmdiKDEwNCwgMTE4LCAxMzUpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2Vfc3RyaW5nIHtcXG4gIGNvbG9yOiByZ2IoMywgMTA2LCA3KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2NvbW1lbnQge1xcbiAgY29sb3I6IHJnYig3NiwgMTM2LCAxMDcpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29tbWVudC5hY2VfZG9jIHtcXG4gIGNvbG9yOiByZ2IoMCwgMTAyLCAyNTUpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29tbWVudC5hY2VfZG9jLmFjZV90YWcge1xcbiAgY29sb3I6IHJnYigxMjgsIDE1OSwgMTkxKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9udW1lcmljIHtcXG4gIGNvbG9yOiByZ2IoMCwgMCwgMjA1KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX3ZhcmlhYmxlIHtcXG4gIGNvbG9yOiByZ2IoNDksIDEzMiwgMTQ5KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX3htbC1wZSB7XFxuICBjb2xvcjogcmdiKDEwNCwgMTA0LCA5MSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9lbnRpdHkuYWNlX25hbWUuYWNlX2Z1bmN0aW9uIHtcXG4gIGNvbG9yOiAjMDAwMEEyO1xcbn1cXG5cXG5cXG4uYWNlLXRtIC5hY2VfaGVhZGluZyB7XFxuICBjb2xvcjogcmdiKDEyLCA3LCAyNTUpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfbGlzdCB7XFxuICBjb2xvcjpyZ2IoMTg1LCA2LCAxNDQpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfbWV0YS5hY2VfdGFnIHtcXG4gIGNvbG9yOnJnYigwLCAyMiwgMTQyKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX3N0cmluZy5hY2VfcmVnZXgge1xcbiAgY29sb3I6IHJnYigyNTUsIDAsIDApXFxufVxcblxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zZWxlY3Rpb24ge1xcbiAgYmFja2dyb3VuZDogcmdiKDE4MSwgMjEzLCAyNTUpO1xcbn1cXG4uYWNlLXRtLmFjZV9tdWx0aXNlbGVjdCAuYWNlX3NlbGVjdGlvbi5hY2Vfc3RhcnQge1xcbiAgYm94LXNoYWRvdzogMCAwIDNweCAwcHggd2hpdGU7XFxufVxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGVwIHtcXG4gIGJhY2tncm91bmQ6IHJnYigyNTIsIDI1NSwgMCk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGFjayB7XFxuICBiYWNrZ3JvdW5kOiByZ2IoMTY0LCAyMjksIDEwMSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9icmFja2V0IHtcXG4gIG1hcmdpbjogLTFweCAwIDAgLTFweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNyk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9ndXR0ZXItYWN0aXZlLWxpbmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yIDogI2RjZGNkYztcXG59XFxuXFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX3NlbGVjdGVkLXdvcmQge1xcbiAgYmFja2dyb3VuZDogcmdiKDI1MCwgMjUwLCAyNTUpO1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiKDIwMCwgMjAwLCAyNTApO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfaW5kZW50LWd1aWRlIHtcXG4gIGJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFDQ0FZQUFBQ1pnYlluQUFBQUUwbEVRVlFJbVdQNC8vLy9mNGJMbHkvL0J3QW1WZ2QxL3cxMS9nQUFBQUJKUlU1RXJrSmdnZz09XFxcIikgcmlnaHQgcmVwZWF0LXk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9pbmRlbnQtZ3VpZGUtYWN0aXZlIHtcXG4gIGJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFDQ0FZQUFBQ1pnYlluQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQVpTVVJCVkhqYVl2ai8vLzkvaGl2S3l2OEJBQUFBLy84REFDTHFCaGJ2aysvZUFBQUFBRWxGVGtTdVFtQ0NcXFwiKSByaWdodCByZXBlYXQteTtcXG59XFxuXCI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3RoZW1lL3RleHRtYXRlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvdGhlbWUvdGV4dG1hdGUtY3NzXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNEYXJrID0gZmFsc2U7XG5leHBvcnRzLmNzc0NsYXNzID0gXCJhY2UtdG1cIjtcbmV4cG9ydHMuY3NzVGV4dCA9IHJlcXVpcmUoXCIuL3RleHRtYXRlLWNzc1wiKTtcbmV4cG9ydHMuJGlkID0gXCJhY2UvdGhlbWUvdGV4dG1hdGVcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbmRvbS5pbXBvcnRDc3NTdHJpbmcoZXhwb3J0cy5jc3NUZXh0LCBleHBvcnRzLmNzc0NsYXNzLCBmYWxzZSk7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2NvbmZpZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGliL25ldFwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvYXBwX2NvbmZpZ1wiLFwiYWNlL3RoZW1lL3RleHRtYXRlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1wibm8gdXNlIHN0cmljdFwiO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBuZXQgPSByZXF1aXJlKFwiLi9saWIvbmV0XCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgQXBwQ29uZmlnID0gcmVxdWlyZShcIi4vbGliL2FwcF9jb25maWdcIikuQXBwQ29uZmlnO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEFwcENvbmZpZygpO1xudmFyIG9wdGlvbnMgPSB7XG4gICAgcGFja2FnZWQ6IGZhbHNlLFxuICAgIHdvcmtlclBhdGg6IG51bGwsXG4gICAgbW9kZVBhdGg6IG51bGwsXG4gICAgdGhlbWVQYXRoOiBudWxsLFxuICAgIGJhc2VQYXRoOiBcIlwiLFxuICAgIHN1ZmZpeDogXCIuanNcIixcbiAgICAkbW9kdWxlVXJsczoge30sXG4gICAgbG9hZFdvcmtlckZyb21CbG9iOiB0cnVlLFxuICAgIHNoYXJlZFBvcHVwczogZmFsc2UsXG4gICAgdXNlU3RyaWN0Q1NQOiBudWxsXG59O1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29uZmlnIGtleTogXCIgKyBrZXkpO1xuICAgIHJldHVybiBvcHRpb25zW2tleV07XG59O1xuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgaWYgKHRoaXMuc2V0RGVmYXVsdFZhbHVlKFwiXCIsIGtleSwgdmFsdWUpID09IGZhbHNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbmZpZyBrZXk6IFwiICsga2V5KTtcbiAgICBpZiAoa2V5ID09IFwidXNlU3RyaWN0Q1NQXCIpXG4gICAgICAgIGRvbS51c2VTdHJpY3RDU1AodmFsdWUpO1xufTtcbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsYW5nLmNvcHlPYmplY3Qob3B0aW9ucyk7XG59O1xuZXhwb3J0cy4kbW9kZXMgPSB7fTtcbmV4cG9ydHMubW9kdWxlVXJsID0gZnVuY3Rpb24gKG5hbWUsIGNvbXBvbmVudCkge1xuICAgIGlmIChvcHRpb25zLiRtb2R1bGVVcmxzW25hbWVdKVxuICAgICAgICByZXR1cm4gb3B0aW9ucy4kbW9kdWxlVXJsc1tuYW1lXTtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICBjb21wb25lbnQgPSBjb21wb25lbnQgfHwgcGFydHNbcGFydHMubGVuZ3RoIC0gMl0gfHwgXCJcIjtcbiAgICB2YXIgc2VwID0gY29tcG9uZW50ID09IFwic25pcHBldHNcIiA/IFwiL1wiIDogXCItXCI7XG4gICAgdmFyIGJhc2UgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoY29tcG9uZW50ID09IFwid29ya2VyXCIgJiYgc2VwID09IFwiLVwiKSB7XG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBjb21wb25lbnQgKyBcIltcXFxcLV9dfFtcXFxcLV9dXCIgKyBjb21wb25lbnQgKyBcIiRcIiwgXCJnXCIpO1xuICAgICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKHJlLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCghYmFzZSB8fCBiYXNlID09IGNvbXBvbmVudCkgJiYgcGFydHMubGVuZ3RoID4gMSlcbiAgICAgICAgYmFzZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdO1xuICAgIHZhciBwYXRoID0gb3B0aW9uc1tjb21wb25lbnQgKyBcIlBhdGhcIl07XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICBwYXRoID0gb3B0aW9ucy5iYXNlUGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VwID09IFwiL1wiKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IHNlcCA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChwYXRoICYmIHBhdGguc2xpY2UoLTEpICE9IFwiL1wiKVxuICAgICAgICBwYXRoICs9IFwiL1wiO1xuICAgIHJldHVybiBwYXRoICsgY29tcG9uZW50ICsgc2VwICsgYmFzZSArIHRoaXMuZ2V0KFwic3VmZml4XCIpO1xufTtcbmV4cG9ydHMuc2V0TW9kdWxlVXJsID0gZnVuY3Rpb24gKG5hbWUsIHN1YnN0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuJG1vZHVsZVVybHNbbmFtZV0gPSBzdWJzdDtcbn07XG52YXIgbG9hZGVyID0gZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGNiKSB7XG4gICAgaWYgKG1vZHVsZU5hbWUgPT09IFwiYWNlL3RoZW1lL3RleHRtYXRlXCIgfHwgbW9kdWxlTmFtZSA9PT0gXCIuL3RoZW1lL3RleHRtYXRlXCIpXG4gICAgICAgIHJldHVybiBjYihudWxsLCByZXF1aXJlKFwiLi90aGVtZS90ZXh0bWF0ZVwiKSk7XG4gICAgaWYgKGN1c3RvbUxvYWRlcilcbiAgICAgICAgcmV0dXJuIGN1c3RvbUxvYWRlcihtb2R1bGVOYW1lLCBjYik7XG4gICAgY29uc29sZS5lcnJvcihcImxvYWRlciBpcyBub3QgY29uZmlndXJlZFwiKTtcbn07XG52YXIgY3VzdG9tTG9hZGVyO1xuZXhwb3J0cy5zZXRMb2FkZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBjdXN0b21Mb2FkZXIgPSBjYjtcbn07XG5leHBvcnRzLmR5bmFtaWNNb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydHMuJGxvYWRpbmcgPSB7fTtcbmV4cG9ydHMuJGxvYWRlZCA9IHt9O1xuZXhwb3J0cy5sb2FkTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvbkxvYWQpIHtcbiAgICB2YXIgbG9hZGVkTW9kdWxlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1vZHVsZUlkKSkge1xuICAgICAgICB2YXIgbW9kdWxlVHlwZSA9IG1vZHVsZUlkWzBdO1xuICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IG1vZHVsZUlkWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlSWQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IG1vZHVsZUlkO1xuICAgIH1cbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZSAmJiAhZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSlcbiAgICAgICAgICAgIHJldHVybiBvbkxvYWQgJiYgb25Mb2FkKG1vZHVsZSk7XG4gICAgICAgIGlmICghZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSlcbiAgICAgICAgICAgIGV4cG9ydHMuJGxvYWRpbmdbbW9kdWxlTmFtZV0gPSBbXTtcbiAgICAgICAgZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXS5wdXNoKG9uTG9hZCk7XG4gICAgICAgIGlmIChleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhZnRlckxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2FkZXIobW9kdWxlTmFtZSwgZnVuY3Rpb24gKGVyciwgbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy4kbG9hZGVkW21vZHVsZU5hbWVdID0gbW9kdWxlO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuX2VtaXQoXCJsb2FkLm1vZHVsZVwiLCB7IG5hbWU6IG1vZHVsZU5hbWUsIG1vZHVsZTogbW9kdWxlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuJGxvYWRpbmdbbW9kdWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChtb2R1bGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghZXhwb3J0cy5nZXQoXCJwYWNrYWdlZFwiKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlckxvYWQoKTtcbiAgICAgICAgbmV0LmxvYWRTY3JpcHQoZXhwb3J0cy5tb2R1bGVVcmwobW9kdWxlTmFtZSwgbW9kdWxlVHlwZSksIGFmdGVyTG9hZCk7XG4gICAgICAgIHJlcG9ydEVycm9ySWZQYXRoSXNOb3RDb25maWd1cmVkKCk7XG4gICAgfTtcbiAgICBpZiAoZXhwb3J0cy5keW5hbWljTW9kdWxlc1ttb2R1bGVOYW1lXSkge1xuICAgICAgICBleHBvcnRzLmR5bmFtaWNNb2R1bGVzW21vZHVsZU5hbWVdKCkudGhlbihmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBsb2FkKG1vZHVsZS5kZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvYWQobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9hZGVkTW9kdWxlID0gdGhpcy4kcmVxdWlyZShtb2R1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIGxvYWQobG9hZGVkTW9kdWxlIHx8IGV4cG9ydHMuJGxvYWRlZFttb2R1bGVOYW1lXSk7XG4gICAgfVxufTtcbmV4cG9ydHMuJHJlcXVpcmUgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlW1wicmVxdWlyZVwiXSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHJlcSA9IFwicmVxdWlyZVwiO1xuICAgICAgICByZXR1cm4gbW9kdWxlW3JlcV0obW9kdWxlTmFtZSk7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0TW9kdWxlTG9hZGVyID0gZnVuY3Rpb24gKG1vZHVsZU5hbWUsIG9uTG9hZCkge1xuICAgIGV4cG9ydHMuZHluYW1pY01vZHVsZXNbbW9kdWxlTmFtZV0gPSBvbkxvYWQ7XG59O1xudmFyIHJlcG9ydEVycm9ySWZQYXRoSXNOb3RDb25maWd1cmVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghb3B0aW9ucy5iYXNlUGF0aCAmJiAhb3B0aW9ucy53b3JrZXJQYXRoXG4gICAgICAgICYmICFvcHRpb25zLm1vZGVQYXRoICYmICFvcHRpb25zLnRoZW1lUGF0aFxuICAgICAgICAmJiAhT2JqZWN0LmtleXMob3B0aW9ucy4kbW9kdWxlVXJscykubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5mZXIgcGF0aCB0byBhY2UgZnJvbSBzY3JpcHQgc3JjLFwiLCBcInVzZSBhY2UuY29uZmlnLnNldCgnYmFzZVBhdGgnLCAncGF0aCcpIHRvIGVuYWJsZSBkeW5hbWljIGxvYWRpbmcgb2YgbW9kZXMgYW5kIHRoZW1lc1wiLCBcIm9yIHdpdGggd2VicGFjayB1c2UgYWNlL3dlYnBhY2stcmVzb2x2ZXJcIik7XG4gICAgICAgIHJlcG9ydEVycm9ySWZQYXRoSXNOb3RDb25maWd1cmVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjEuMzUuNFwiO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sb2FkZXJfYnVpbGRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZml4b2xkYnJvd3NlcnNcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuL2xpYi9maXhvbGRicm93c2Vyc1wiKTtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5jb25maWcuc2V0TG9hZGVyKGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGNiKSB7XG4gICAgcmVxdWlyZShbbW9kdWxlTmFtZV0sIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICBjYihudWxsLCBtb2R1bGUpO1xuICAgIH0pO1xufSk7XG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMgfHwgdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYWNlKSB7XG4gICAgY29uZmlnLmluaXQgPSBpbml0O1xuICAgIGNvbmZpZy4kcmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgYWNlLnJlcXVpcmUgPSByZXF1aXJlO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgYWNlLmRlZmluZSA9IGRlZmluZTtcbn07XG5pbml0KHRydWUpO2Z1bmN0aW9uIGluaXQocGFja2FnZWQpIHtcblxuICAgIGlmICghZ2xvYmFsIHx8ICFnbG9iYWwuZG9jdW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBjb25maWcuc2V0KFwicGFja2FnZWRcIiwgcGFja2FnZWQgfHwgcmVxdWlyZS5wYWNrYWdlZCB8fCBtb2R1bGUucGFja2FnZWQgfHwgKGdsb2JhbC5kZWZpbmUgJiYgZGVmaW5lLnBhY2thZ2VkKSk7XG5cbiAgICB2YXIgc2NyaXB0T3B0aW9ucyA9IHt9O1xuICAgIHZhciBzY3JpcHRVcmwgPSBcIlwiO1xuICAgIHZhciBjdXJyZW50U2NyaXB0ID0gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgfHwgZG9jdW1lbnQuX2N1cnJlbnRTY3JpcHQgKTsgLy8gbmF0aXZlIG9yIHBvbHlmaWxsXG4gICAgdmFyIGN1cnJlbnREb2N1bWVudCA9IGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgIFxuICAgIGlmIChjdXJyZW50U2NyaXB0ICYmIGN1cnJlbnRTY3JpcHQuc3JjKSB7XG4gICAgICAgIHNjcmlwdFVybCA9IGN1cnJlbnRTY3JpcHQuc3JjLnNwbGl0KC9bPyNdLylbMF0uc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKSB8fCBcIlwiO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc2NyaXB0cyA9IGN1cnJlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8c2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcblxuICAgICAgICB2YXIgc3JjID0gc2NyaXB0LnNyYyB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXNyYylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc2NyaXB0LmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGo9MCwgbD1hdHRyaWJ1dGVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZS5pbmRleE9mKFwiZGF0YS1hY2UtXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0T3B0aW9uc1tkZUh5cGhlbmF0ZShhdHRyLm5hbWUucmVwbGFjZSgvXmRhdGEtYWNlLS8sIFwiXCIpKV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSBzcmMubWF0Y2goL14oLiopXFwvYWNlKFtcXC0uXVxcdyspP1xcLmpzKFxcP3wkKS8pO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICAgIHNjcmlwdFVybCA9IG1bMV07XG4gICAgfVxuXG4gICAgaWYgKHNjcmlwdFVybCkge1xuICAgICAgICBzY3JpcHRPcHRpb25zLmJhc2UgPSBzY3JpcHRPcHRpb25zLmJhc2UgfHwgc2NyaXB0VXJsO1xuICAgICAgICBzY3JpcHRPcHRpb25zLnBhY2thZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY3JpcHRPcHRpb25zLmJhc2VQYXRoID0gc2NyaXB0T3B0aW9ucy5iYXNlO1xuICAgIHNjcmlwdE9wdGlvbnMud29ya2VyUGF0aCA9IHNjcmlwdE9wdGlvbnMud29ya2VyUGF0aCB8fCBzY3JpcHRPcHRpb25zLmJhc2U7XG4gICAgc2NyaXB0T3B0aW9ucy5tb2RlUGF0aCA9IHNjcmlwdE9wdGlvbnMubW9kZVBhdGggfHwgc2NyaXB0T3B0aW9ucy5iYXNlO1xuICAgIHNjcmlwdE9wdGlvbnMudGhlbWVQYXRoID0gc2NyaXB0T3B0aW9ucy50aGVtZVBhdGggfHwgc2NyaXB0T3B0aW9ucy5iYXNlO1xuICAgIGRlbGV0ZSBzY3JpcHRPcHRpb25zLmJhc2U7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc2NyaXB0T3B0aW9ucylcbiAgICAgICAgaWYgKHR5cGVvZiBzY3JpcHRPcHRpb25zW2tleV0gIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICBjb25maWcuc2V0KGtleSwgc2NyaXB0T3B0aW9uc1trZXldKTtcbn1cblxuZnVuY3Rpb24gZGVIeXBoZW5hdGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG0sIG0xKSB7IHJldHVybiBtMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn1cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3JhbmdlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgZW5kUm93LCBlbmRDb2x1bW4pIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgIHJvdzogc3RhcnRSb3csXG4gICAgICAgICAgICBjb2x1bW46IHN0YXJ0Q29sdW1uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kID0ge1xuICAgICAgICAgICAgcm93OiBlbmRSb3csXG4gICAgICAgICAgICBjb2x1bW46IGVuZENvbHVtblxuICAgICAgICB9O1xuICAgIH1cbiAgICBSYW5nZS5wcm90b3R5cGUuaXNFcXVhbCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJlxuICAgICAgICAgICAgdGhpcy5lbmQucm93ID09PSByYW5nZS5lbmQucm93ICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9PT0gcmFuZ2Uuc3RhcnQuY29sdW1uICYmXG4gICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPT09IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXCJSYW5nZTogW1wiICsgdGhpcy5zdGFydC5yb3cgKyBcIi9cIiArIHRoaXMuc3RhcnQuY29sdW1uICtcbiAgICAgICAgICAgIFwiXSAtPiBbXCIgKyB0aGlzLmVuZC5yb3cgKyBcIi9cIiArIHRoaXMuZW5kLmNvbHVtbiArIFwiXVwiKTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKSA9PSAwO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBhcmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgY21wLCBlbmQgPSByYW5nZS5lbmQsIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShlbmQucm93LCBlbmQuY29sdW1uKTtcbiAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLmNvbXBhcmUoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLmNvbXBhcmUoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wYXJlUG9pbnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHAucm93LCBwLmNvbHVtbik7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29udGFpbnNSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlUG9pbnQocmFuZ2Uuc3RhcnQpID09IDAgJiYgdGhpcy5jb21wYXJlUG9pbnQocmFuZ2UuZW5kKSA9PSAwO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGNtcCA9IHRoaXMuY29tcGFyZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIChjbXAgPT0gLTEgfHwgY21wID09IDAgfHwgY21wID09IDEpO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmlzRW5kID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5yb3cgPT0gcm93ICYmIHRoaXMuZW5kLmNvbHVtbiA9PSBjb2x1bW47XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaXNTdGFydCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5yb3cgPT0gcm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09IGNvbHVtbjtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5zZXRTdGFydCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAodHlwZW9mIHJvdyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9IHJvdy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnJvdyA9IHJvdy5yb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnJvdyA9IHJvdztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuc2V0RW5kID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygcm93ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kLmNvbHVtbiA9IHJvdy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLmVuZC5yb3cgPSByb3cucm93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmQucm93ID0gcm93O1xuICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaW5zaWRlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKHJvdywgY29sdW1uKSB8fCB0aGlzLmlzU3RhcnQocm93LCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmluc2lkZVN0YXJ0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKHJvdywgY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5pbnNpZGVFbmQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFydChyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aUxpbmUoKSkge1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gdGhpcy5zdGFydC5yb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uIDwgdGhpcy5zdGFydC5jb2x1bW4gPyAtMSA6IChjb2x1bW4gPiB0aGlzLmVuZC5jb2x1bW4gPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdyA8IHRoaXMuc3RhcnQucm93KVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAocm93ID4gdGhpcy5lbmQucm93KVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA9PT0gcm93KVxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA+PSB0aGlzLnN0YXJ0LmNvbHVtbiA/IDAgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuZW5kLnJvdyA9PT0gcm93KVxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA8PSB0aGlzLmVuZC5jb2x1bW4gPyAwIDogMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcGFyZVN0YXJ0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBhcmVFbmQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kLnJvdyA9PSByb3cgJiYgdGhpcy5lbmQuY29sdW1uID09IGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBhcmVJbnNpZGUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kLnJvdyA9PSByb3cgJiYgdGhpcy5lbmQuY29sdW1uID09IGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFydC5yb3cgPT0gcm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09IGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShyb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jbGlwUm93cyA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICBpZiAodGhpcy5lbmQucm93ID4gbGFzdFJvdylcbiAgICAgICAgICAgIHZhciBlbmQgPSB7IHJvdzogbGFzdFJvdyArIDEsIGNvbHVtbjogMCB9O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmVuZC5yb3cgPCBmaXJzdFJvdylcbiAgICAgICAgICAgIHZhciBlbmQgPSB7IHJvdzogZmlyc3RSb3csIGNvbHVtbjogMCB9O1xuICAgICAgICBpZiAodGhpcy5zdGFydC5yb3cgPiBsYXN0Um93KVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0geyByb3c6IGxhc3RSb3cgKyAxLCBjb2x1bW46IDAgfTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFydC5yb3cgPCBmaXJzdFJvdylcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHsgcm93OiBmaXJzdFJvdywgY29sdW1uOiAwIH07XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0IHx8IHRoaXMuc3RhcnQsIGVuZCB8fCB0aGlzLmVuZCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBjbXAgPSB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuICAgICAgICBpZiAoY21wID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAoY21wID09IC0xKVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0geyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIGVuZCA9IHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH07XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0IHx8IHRoaXMuc3RhcnQsIGVuZCB8fCB0aGlzLmVuZCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0LnJvdyA9PT0gdGhpcy5lbmQucm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09PSB0aGlzLmVuZC5jb2x1bW4pO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmlzTXVsdGlMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnQucm93ICE9PSB0aGlzLmVuZC5yb3cpO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29sbGFwc2VSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lbmQuY29sdW1uID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQucm93LCAwLCBNYXRoLm1heCh0aGlzLnN0YXJ0LnJvdywgdGhpcy5lbmQucm93IC0gMSksIDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQucm93LCAwLCB0aGlzLmVuZC5yb3csIDApO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLnRvU2NyZWVuUmFuZ2UgPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB2YXIgc2NyZWVuUG9zU3RhcnQgPSBzZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbih0aGlzLnN0YXJ0KTtcbiAgICAgICAgdmFyIHNjcmVlblBvc0VuZCA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzY3JlZW5Qb3NTdGFydC5yb3csIHNjcmVlblBvc1N0YXJ0LmNvbHVtbiwgc2NyZWVuUG9zRW5kLnJvdywgc2NyZWVuUG9zRW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuc3RhcnQucm93ICs9IHJvdztcbiAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gKz0gY29sdW1uO1xuICAgICAgICB0aGlzLmVuZC5yb3cgKz0gcm93O1xuICAgICAgICB0aGlzLmVuZC5jb2x1bW4gKz0gY29sdW1uO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlO1xufSgpKTtcblJhbmdlLmZyb21Qb2ludHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQucm93LCBzdGFydC5jb2x1bW4sIGVuZC5yb3csIGVuZC5jb2x1bW4pO1xufTtcblJhbmdlLmNvbXBhcmVQb2ludHMgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyAtIHAyLnJvdyB8fCBwMS5jb2x1bW4gLSBwMi5jb2x1bW47XG59O1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIva2V5c1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vb29wXCIpO1xudmFyIEtleXMgPSB7XG4gICAgTU9ESUZJRVJfS0VZUzoge1xuICAgICAgICAxNjogJ1NoaWZ0JywgMTc6ICdDdHJsJywgMTg6ICdBbHQnLCAyMjQ6ICdNZXRhJyxcbiAgICAgICAgOTE6ICdNZXRhTGVmdCcsIDkyOiAnTWV0YVJpZ2h0JywgOTM6ICdDb250ZXh0TWVudSdcbiAgICB9LFxuICAgIEtFWV9NT0RTOiB7XG4gICAgICAgIFwiY3RybFwiOiAxLCBcImFsdFwiOiAyLCBcIm9wdGlvblwiOiAyLCBcInNoaWZ0XCI6IDQsXG4gICAgICAgIFwic3VwZXJcIjogOCwgXCJtZXRhXCI6IDgsIFwiY29tbWFuZFwiOiA4LCBcImNtZFwiOiA4LFxuICAgICAgICBcImNvbnRyb2xcIjogMVxuICAgIH0sXG4gICAgRlVOQ1RJT05fS0VZUzoge1xuICAgICAgICA4OiBcIkJhY2tzcGFjZVwiLFxuICAgICAgICA5OiBcIlRhYlwiLFxuICAgICAgICAxMzogXCJSZXR1cm5cIixcbiAgICAgICAgMTk6IFwiUGF1c2VcIixcbiAgICAgICAgMjc6IFwiRXNjXCIsXG4gICAgICAgIDMyOiBcIlNwYWNlXCIsXG4gICAgICAgIDMzOiBcIlBhZ2VVcFwiLFxuICAgICAgICAzNDogXCJQYWdlRG93blwiLFxuICAgICAgICAzNTogXCJFbmRcIixcbiAgICAgICAgMzY6IFwiSG9tZVwiLFxuICAgICAgICAzNzogXCJMZWZ0XCIsXG4gICAgICAgIDM4OiBcIlVwXCIsXG4gICAgICAgIDM5OiBcIlJpZ2h0XCIsXG4gICAgICAgIDQwOiBcIkRvd25cIixcbiAgICAgICAgNDQ6IFwiUHJpbnRcIixcbiAgICAgICAgNDU6IFwiSW5zZXJ0XCIsXG4gICAgICAgIDQ2OiBcIkRlbGV0ZVwiLFxuICAgICAgICAnLTEzJzogXCJOdW1wYWRFbnRlclwiLFxuICAgICAgICAxNDQ6IFwiTnVtbG9ja1wiLFxuICAgICAgICAxNDU6IFwiU2Nyb2xsbG9ja1wiXG4gICAgfSxcbiAgICBQUklOVEFCTEVfS0VZUzoge1xuICAgICAgICAzMjogJyAnLCA1OTogJzsnLCA2MTogJz0nLCAxMDc6ICcrJywgMTA5OiAnLScsIDExMDogJy4nLFxuICAgICAgICAxODY6ICc7JywgMTg3OiAnPScsIDE4ODogJywnLCAxODk6ICctJywgMTkwOiAnLicsIDE5MTogJy8nLCAxOTI6ICdgJyxcbiAgICAgICAgMjE5OiAnWycsIDIyMDogJ1xcXFwnLCAyMjE6ICddJywgMjIyOiBcIidcIiwgMTExOiAnLycsIDEwNjogJyonXG4gICAgfVxufTtcbnZhciBjb2RlVG9LZXlDb2RlID0ge1xuICAgIENvbW1hbmQ6IDIyNCxcbiAgICBCYWNrc3BhY2U6IDgsXG4gICAgVGFiOiA5LFxuICAgIFJldHVybjogMTMsXG4gICAgRW50ZXI6IDEzLFxuICAgIFBhdXNlOiAxOSxcbiAgICBFc2NhcGU6IDI3LFxuICAgIFBhZ2VVcDogMzMsXG4gICAgUGFnZURvd246IDM0LFxuICAgIEVuZDogMzUsXG4gICAgSG9tZTogMzYsXG4gICAgSW5zZXJ0OiA0NSxcbiAgICBEZWxldGU6IDQ2LFxuICAgIEFycm93TGVmdDogMzcsXG4gICAgQXJyb3dVcDogMzgsXG4gICAgQXJyb3dSaWdodDogMzksXG4gICAgQXJyb3dEb3duOiA0MCxcbiAgICBCYWNrcXVvdGU6IDE5MixcbiAgICBNaW51czogMTg5LFxuICAgIEVxdWFsOiAxODcsXG4gICAgQnJhY2tldExlZnQ6IDIxOSxcbiAgICBCYWNrc2xhc2g6IDIyMCxcbiAgICBCcmFja2V0UmlnaHQ6IDIyMSxcbiAgICBTZW1pY29sb246IDE4NixcbiAgICBRdW90ZTogMjIyLFxuICAgIENvbW1hOiAxODgsXG4gICAgUGVyaW9kOiAxOTAsXG4gICAgU2xhc2g6IDE5MSxcbiAgICBTcGFjZTogMzIsXG4gICAgTnVtcGFkQWRkOiAxMDcsXG4gICAgTnVtcGFkRGVjaW1hbDogMTEwLFxuICAgIE51bXBhZFN1YnRyYWN0OiAxMDksXG4gICAgTnVtcGFkRGl2aWRlOiAxMTEsXG4gICAgTnVtcGFkTXVsdGlwbHk6IDEwNlxufTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGNvZGVUb0tleUNvZGVbXCJEaWdpdFwiICsgaV0gPSA0OCArIGk7XG4gICAgY29kZVRvS2V5Q29kZVtcIk51bXBhZFwiICsgaV0gPSA5NiArIGk7XG4gICAgS2V5cy5QUklOVEFCTEVfS0VZU1s0OCArIGldID0gXCJcIiArIGk7XG4gICAgS2V5cy5GVU5DVElPTl9LRVlTWzk2ICsgaV0gPSBcIk51bXBhZFwiICsgaTtcbn1cbmZvciAodmFyIGkgPSA2NTsgaSA8IDkxOyBpKyspIHtcbiAgICB2YXIgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpO1xuICAgIGNvZGVUb0tleUNvZGVbXCJLZXlcIiArIGNoci50b1VwcGVyQ2FzZSgpXSA9IGk7XG4gICAgS2V5cy5QUklOVEFCTEVfS0VZU1tpXSA9IGNocjtcbn1cbmZvciAodmFyIGkgPSAxOyBpIDwgMTM7IGkrKykge1xuICAgIGNvZGVUb0tleUNvZGVbXCJGXCIgKyBpXSA9IDExMSArIGk7XG4gICAgS2V5cy5GVU5DVElPTl9LRVlTWzExMSArIGldID0gXCJGXCIgKyBpO1xufVxudmFyIG1vZGlmaWVycyA9IHtcbiAgICBTaGlmdDogMTYsXG4gICAgQ29udHJvbDogMTcsXG4gICAgQWx0OiAxOCxcbiAgICBNZXRhOiAyMjRcbn07XG5mb3IgKHZhciBtb2QgaW4gbW9kaWZpZXJzKSB7XG4gICAgY29kZVRvS2V5Q29kZVttb2RdID0gY29kZVRvS2V5Q29kZVttb2QgKyBcIkxlZnRcIl1cbiAgICAgICAgPSBjb2RlVG9LZXlDb2RlW21vZCArIFwiUmlnaHRcIl0gPSBtb2RpZmllcnNbbW9kXTtcbn1cbmV4cG9ydHMuJGNvZGVUb0tleUNvZGUgPSBjb2RlVG9LZXlDb2RlO1xuS2V5cy5QUklOVEFCTEVfS0VZU1sxNzNdID0gJy0nO1xuZm9yICh2YXIgaiBpbiBLZXlzLkZVTkNUSU9OX0tFWVMpIHtcbiAgICB2YXIgbmFtZSA9IEtleXMuRlVOQ1RJT05fS0VZU1tqXS50b0xvd2VyQ2FzZSgpO1xuICAgIEtleXNbbmFtZV0gPSBwYXJzZUludChqLCAxMCk7XG59XG5mb3IgKHZhciBqIGluIEtleXMuUFJJTlRBQkxFX0tFWVMpIHtcbiAgICB2YXIgbmFtZSA9IEtleXMuUFJJTlRBQkxFX0tFWVNbal0udG9Mb3dlckNhc2UoKTtcbiAgICBLZXlzW25hbWVdID0gcGFyc2VJbnQoaiwgMTApO1xufVxub29wLm1peGluKEtleXMsIEtleXMuTU9ESUZJRVJfS0VZUyk7XG5vb3AubWl4aW4oS2V5cywgS2V5cy5QUklOVEFCTEVfS0VZUyk7XG5vb3AubWl4aW4oS2V5cywgS2V5cy5GVU5DVElPTl9LRVlTKTtcbktleXMuZW50ZXIgPSBLZXlzW1wicmV0dXJuXCJdO1xuS2V5cy5lc2NhcGUgPSBLZXlzLmVzYztcbktleXMuZGVsID0gS2V5c1tcImRlbGV0ZVwiXTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZHMgPSBbXCJjbWRcIiwgXCJjdHJsXCIsIFwiYWx0XCIsIFwic2hpZnRcIl07XG4gICAgZm9yICh2YXIgaSA9IE1hdGgucG93KDIsIG1vZHMubGVuZ3RoKTsgaS0tOykge1xuICAgICAgICBLZXlzLktFWV9NT0RTW2ldID0gbW9kcy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBpICYgS2V5cy5LRVlfTU9EU1t4XTtcbiAgICAgICAgfSkuam9pbihcIi1cIikgKyBcIi1cIjtcbiAgICB9XG59KSgpO1xuS2V5cy5LRVlfTU9EU1swXSA9IFwiXCI7XG5LZXlzLktFWV9NT0RTWy0xXSA9IFwiaW5wdXQtXCI7XG5vb3AubWl4aW4oZXhwb3J0cywgS2V5cyk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzO1xuZXhwb3J0cy5rZXlDb2RlVG9TdHJpbmcgPSBmdW5jdGlvbiAoa2V5Q29kZSkge1xuICAgIHZhciBrZXlTdHJpbmcgPSBLZXlzW2tleUNvZGVdO1xuICAgIGlmICh0eXBlb2Yga2V5U3RyaW5nICE9IFwic3RyaW5nXCIpXG4gICAgICAgIGtleVN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5Q29kZSk7XG4gICAgcmV0dXJuIGtleVN0cmluZy50b0xvd2VyQ2FzZSgpO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2V2ZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2tleXNcIixcImFjZS9saWIvdXNlcmFnZW50XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiOyB2YXIga2V5cyA9IHJlcXVpcmUoXCIuL2tleXNcIik7XG52YXIgdXNlcmFnZW50ID0gcmVxdWlyZShcIi4vdXNlcmFnZW50XCIpO1xudmFyIHByZXNzZWRLZXlzID0gbnVsbDtcbnZhciB0cyA9IDA7XG52YXIgYWN0aXZlTGlzdGVuZXJPcHRpb25zO1xuZnVuY3Rpb24gZGV0ZWN0TGlzdGVuZXJPcHRpb25zU3VwcG9ydCgpIHtcbiAgICBhY3RpdmVMaXN0ZW5lck9wdGlvbnMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIGZ1bmN0aW9uICgpIHsgfSwge1xuICAgICAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlTGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJPcHRpb25zKCkge1xuICAgIGlmIChhY3RpdmVMaXN0ZW5lck9wdGlvbnMgPT0gdW5kZWZpbmVkKVxuICAgICAgICBkZXRlY3RMaXN0ZW5lck9wdGlvbnNTdXBwb3J0KCk7XG4gICAgcmV0dXJuIGFjdGl2ZUxpc3RlbmVyT3B0aW9ucztcbn1cbmZ1bmN0aW9uIEV2ZW50TGlzdGVuZXIoZWxlbSwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xufVxuRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVMaXN0ZW5lcih0aGlzLmVsZW0sIHRoaXMudHlwZSwgdGhpcy5jYWxsYmFjayk7XG4gICAgdGhpcy5lbGVtID0gdGhpcy50eXBlID0gdGhpcy5jYWxsYmFjayA9IHVuZGVmaW5lZDtcbn07XG52YXIgYWRkTGlzdGVuZXIgPSBleHBvcnRzLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGNhbGxiYWNrLCAvKipAdHlwZXthbnk/fSovIGRlc3Ryb3llcikge1xuICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgZ2V0TGlzdGVuZXJPcHRpb25zKCkpO1xuICAgIGlmIChkZXN0cm95ZXIpXG4gICAgICAgIGRlc3Ryb3llci4kdG9EZXN0cm95LnB1c2gobmV3IEV2ZW50TGlzdGVuZXIoZWxlbSwgdHlwZSwgY2FsbGJhY2spKTtcbn07XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBnZXRMaXN0ZW5lck9wdGlvbnMoKSk7XG59O1xuZXhwb3J0cy5zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGV4cG9ydHMuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIGV4cG9ydHMucHJldmVudERlZmF1bHQoZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbn07XG5leHBvcnRzLmdldEJ1dHRvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudHlwZSA9PSBcImRibGNsaWNrXCIpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmIChlLnR5cGUgPT0gXCJjb250ZXh0bWVudVwiIHx8ICh1c2VyYWdlbnQuaXNNYWMgJiYgKGUuY3RybEtleSAmJiAhZS5hbHRLZXkgJiYgIWUuc2hpZnRLZXkpKSlcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgcmV0dXJuIGUuYnV0dG9uO1xufTtcbmV4cG9ydHMuY2FwdHVyZSA9IGZ1bmN0aW9uIChlbCwgZXZlbnRIYW5kbGVyLCByZWxlYXNlQ2FwdHVyZUhhbmRsZXIpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IGVsICYmIGVsLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyICYmIGV2ZW50SGFuZGxlcihlKTtcbiAgICAgICAgcmVsZWFzZUNhcHR1cmVIYW5kbGVyICYmIHJlbGVhc2VDYXB0dXJlSGFuZGxlcihlKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKG93bmVyRG9jdW1lbnQsIFwiZHJhZ3N0YXJ0XCIsIG9uTW91c2VVcCk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKG93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGV2ZW50SGFuZGxlcik7XG4gICAgYWRkTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgYWRkTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJkcmFnc3RhcnRcIiwgb25Nb3VzZVVwKTtcbiAgICByZXR1cm4gb25Nb3VzZVVwO1xufTtcbmV4cG9ydHMuYWRkTW91c2VXaGVlbExpc3RlbmVyID0gZnVuY3Rpb24gKGVsLCBjYWxsYmFjaywgZGVzdHJveWVyKSB7XG4gICAgYWRkTGlzdGVuZXIoZWwsIFwid2hlZWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IDAuMTU7XG4gICAgICAgIHZhciBkZWx0YVggPSBlLmRlbHRhWCB8fCAwO1xuICAgICAgICB2YXIgZGVsdGFZID0gZS5kZWx0YVkgfHwgMDtcbiAgICAgICAgc3dpdGNoIChlLmRlbHRhTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBlLkRPTV9ERUxUQV9QSVhFTDpcbiAgICAgICAgICAgICAgICBlLndoZWVsWCA9IGRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IGRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZS5ET01fREVMVEFfTElORTpcbiAgICAgICAgICAgICAgICB2YXIgbGluZVBpeGVscyA9IDE1O1xuICAgICAgICAgICAgICAgIGUud2hlZWxYID0gZGVsdGFYICogbGluZVBpeGVscztcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IGRlbHRhWSAqIGxpbmVQaXhlbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGUuRE9NX0RFTFRBX1BBR0U6XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VQaXhlbHMgPSAxNTA7XG4gICAgICAgICAgICAgICAgZS53aGVlbFggPSBkZWx0YVggKiBwYWdlUGl4ZWxzO1xuICAgICAgICAgICAgICAgIGUud2hlZWxZID0gZGVsdGFZICogcGFnZVBpeGVscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9LCBkZXN0cm95ZXIpO1xufTtcbmV4cG9ydHMuYWRkTXVsdGlNb3VzZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50cywgdGltZW91dHMsIGV2ZW50SGFuZGxlciwgY2FsbGJhY2tOYW1lLCBkZXN0cm95ZXIpIHtcbiAgICB2YXIgY2xpY2tzID0gMDtcbiAgICB2YXIgc3RhcnRYLCBzdGFydFksIHRpbWVyO1xuICAgIHZhciBldmVudE5hbWVzID0ge1xuICAgICAgICAyOiBcImRibGNsaWNrXCIsXG4gICAgICAgIDM6IFwidHJpcGxlY2xpY2tcIixcbiAgICAgICAgNDogXCJxdWFkY2xpY2tcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gb25Nb3VzZWRvd24oZSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5nZXRCdXR0b24oZSkgIT09IDApIHtcbiAgICAgICAgICAgIGNsaWNrcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5kZXRhaWwgPiAxKSB7XG4gICAgICAgICAgICBjbGlja3MrKztcbiAgICAgICAgICAgIGlmIChjbGlja3MgPiA0KVxuICAgICAgICAgICAgICAgIGNsaWNrcyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGlja3MgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSkge1xuICAgICAgICAgICAgdmFyIGlzTmV3Q2xpY2sgPSBNYXRoLmFicyhlLmNsaWVudFggLSBzdGFydFgpID4gNSB8fCBNYXRoLmFicyhlLmNsaWVudFkgLSBzdGFydFkpID4gNTtcbiAgICAgICAgICAgIGlmICghdGltZXIgfHwgaXNOZXdDbGljaylcbiAgICAgICAgICAgICAgICBjbGlja3MgPSAxO1xuICAgICAgICAgICAgaWYgKHRpbWVyKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aW1lciA9IG51bGw7IH0sIHRpbWVvdXRzW2NsaWNrcyAtIDFdIHx8IDYwMCk7XG4gICAgICAgICAgICBpZiAoY2xpY2tzID09IDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydFggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUuX2NsaWNrcyA9IGNsaWNrcztcbiAgICAgICAgZXZlbnRIYW5kbGVyW2NhbGxiYWNrTmFtZV0oXCJtb3VzZWRvd25cIiwgZSk7XG4gICAgICAgIGlmIChjbGlja3MgPiA0KVxuICAgICAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgZWxzZSBpZiAoY2xpY2tzID4gMSlcbiAgICAgICAgICAgIHJldHVybiBldmVudEhhbmRsZXJbY2FsbGJhY2tOYW1lXShldmVudE5hbWVzW2NsaWNrc10sIGUpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWwsIFwibW91c2Vkb3duXCIsIG9uTW91c2Vkb3duLCBkZXN0cm95ZXIpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGdldE1vZGlmaWVySGFzaChlKSB7XG4gICAgcmV0dXJuIDAgfCAoZS5jdHJsS2V5ID8gMSA6IDApIHwgKGUuYWx0S2V5ID8gMiA6IDApIHwgKGUuc2hpZnRLZXkgPyA0IDogMCkgfCAoZS5tZXRhS2V5ID8gOCA6IDApO1xufVxuZXhwb3J0cy5nZXRNb2RpZmllclN0cmluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGtleXMuS0VZX01PRFNbZ2V0TW9kaWZpZXJIYXNoKGUpXTtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb21tYW5kS2V5cyhjYWxsYmFjaywgZSwga2V5Q29kZSkge1xuICAgIHZhciBoYXNoSWQgPSBnZXRNb2RpZmllckhhc2goZSk7XG4gICAgaWYgKCFrZXlDb2RlICYmIGUuY29kZSkge1xuICAgICAgICBrZXlDb2RlID0ga2V5cy4kY29kZVRvS2V5Q29kZVtlLmNvZGVdIHx8IGtleUNvZGU7XG4gICAgfVxuICAgIGlmICghdXNlcmFnZW50LmlzTWFjICYmIHByZXNzZWRLZXlzKSB7XG4gICAgICAgIGlmIChlLmdldE1vZGlmaWVyU3RhdGUgJiYgKGUuZ2V0TW9kaWZpZXJTdGF0ZShcIk9TXCIpIHx8IGUuZ2V0TW9kaWZpZXJTdGF0ZShcIldpblwiKSkpXG4gICAgICAgICAgICBoYXNoSWQgfD0gODtcbiAgICAgICAgaWYgKHByZXNzZWRLZXlzLmFsdEdyKSB7XG4gICAgICAgICAgICBpZiAoKDMgJiBoYXNoSWQpICE9IDMpXG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuYWx0R3IgPSAwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTggfHwga2V5Q29kZSA9PT0gMTcpIHtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGUubG9jYXRpb247XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTcgJiYgbG9jYXRpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlc3NlZEtleXNba2V5Q29kZV0gPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgdHMgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IDE4ICYmIGhhc2hJZCA9PT0gMyAmJiBsb2NhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGUudGltZVN0YW1wIC0gdHM7XG4gICAgICAgICAgICAgICAgaWYgKGR0IDwgNTApXG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmFsdEdyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5Q29kZSBpbiBrZXlzLk1PRElGSUVSX0tFWVMpIHtcbiAgICAgICAga2V5Q29kZSA9IC0xO1xuICAgIH1cbiAgICBpZiAoIWhhc2hJZCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgICBpZiAoZS5sb2NhdGlvbiA9PT0gMykge1xuICAgICAgICAgICAgY2FsbGJhY2soZSwgaGFzaElkLCAta2V5Q29kZSk7XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlcmFnZW50LmlzQ2hyb21lT1MgJiYgaGFzaElkICYgOCkge1xuICAgICAgICBjYWxsYmFjayhlLCBoYXNoSWQsIGtleUNvZGUpO1xuICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoYXNoSWQgJj0gfjg7XG4gICAgfVxuICAgIGlmICghaGFzaElkICYmICEoa2V5Q29kZSBpbiBrZXlzLkZVTkNUSU9OX0tFWVMpICYmICEoa2V5Q29kZSBpbiBrZXlzLlBSSU5UQUJMRV9LRVlTKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjayhlLCBoYXNoSWQsIGtleUNvZGUpO1xufVxuZXhwb3J0cy5hZGRDb21tYW5kS2V5TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWwsIGNhbGxiYWNrLCBkZXN0cm95ZXIpIHtcbiAgICB2YXIgbGFzdERlZmF1bHRQcmV2ZW50ZWQgPSBudWxsO1xuICAgIGFkZExpc3RlbmVyKGVsLCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcHJlc3NlZEtleXNbZS5rZXlDb2RlXSA9IChwcmVzc2VkS2V5c1tlLmtleUNvZGVdIHx8IDApICsgMTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5vcm1hbGl6ZUNvbW1hbmRLZXlzKGNhbGxiYWNrLCBlLCBlLmtleUNvZGUpO1xuICAgICAgICBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IGUuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBkZXN0cm95ZXIpO1xuICAgIGFkZExpc3RlbmVyKGVsLCBcImtleXByZXNzXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChsYXN0RGVmYXVsdFByZXZlbnRlZCAmJiAoZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgICAgICAgZXhwb3J0cy5zdG9wRXZlbnQoZSk7XG4gICAgICAgICAgICBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCBkZXN0cm95ZXIpO1xuICAgIGFkZExpc3RlbmVyKGVsLCBcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHByZXNzZWRLZXlzW2Uua2V5Q29kZV0gPSBudWxsO1xuICAgIH0sIGRlc3Ryb3llcik7XG4gICAgaWYgKCFwcmVzc2VkS2V5cykge1xuICAgICAgICByZXNldFByZXNzZWRLZXlzKCk7XG4gICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgXCJmb2N1c1wiLCByZXNldFByZXNzZWRLZXlzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcmVzZXRQcmVzc2VkS2V5cygpIHtcbiAgICBwcmVzc2VkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5pZiAodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiAhdXNlcmFnZW50LmlzT2xkSUUpIHtcbiAgICB2YXIgcG9zdE1lc3NhZ2VJZCA9IDE7XG4gICAgZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgd2luKSB7XG4gICAgICAgIHdpbiA9IHdpbiB8fCB3aW5kb3c7XG4gICAgICAgIHZhciBtZXNzYWdlTmFtZSA9IFwiemVyby10aW1lb3V0LW1lc3NhZ2UtXCIgKyAocG9zdE1lc3NhZ2VJZCsrKTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmRhdGEgPT0gbWVzc2FnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcih3aW4sIFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkTGlzdGVuZXIod2luLCBcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICB3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZU5hbWUsIFwiKlwiKTtcbiAgICB9O1xufVxuZXhwb3J0cy4kaWRsZUJsb2NrZWQgPSBmYWxzZTtcbmV4cG9ydHMub25JZGxlID0gZnVuY3Rpb24gKGNiLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKCFleHBvcnRzLiRpZGxlQmxvY2tlZCkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMTAwKTtcbiAgICAgICAgfVxuICAgIH0sIHRpbWVvdXQpO1xufTtcbmV4cG9ydHMuJGlkbGVCbG9ja0lkID0gbnVsbDtcbmV4cG9ydHMuYmxvY2tJZGxlID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgaWYgKGV4cG9ydHMuJGlkbGVCbG9ja0lkKVxuICAgICAgICBjbGVhclRpbWVvdXQoZXhwb3J0cy4kaWRsZUJsb2NrSWQpO1xuICAgIGV4cG9ydHMuJGlkbGVCbG9ja2VkID0gdHJ1ZTtcbiAgICBleHBvcnRzLiRpZGxlQmxvY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLiRpZGxlQmxvY2tlZCA9IGZhbHNlO1xuICAgIH0sIGRlbGF5IHx8IDEwMCk7XG59O1xuZXhwb3J0cy5uZXh0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB8fCB3aW5kb3dbXCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl1cbiAgICB8fCB3aW5kb3dbXCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl1cbiAgICB8fCB3aW5kb3dbXCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZVwiXVxuICAgIHx8IHdpbmRvd1tcIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl0pO1xuaWYgKGV4cG9ydHMubmV4dEZyYW1lKVxuICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZXhwb3J0cy5uZXh0RnJhbWUuYmluZCh3aW5kb3cpO1xuZWxzZVxuICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE3KTtcbiAgICB9O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jbGlwYm9hcmRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgJGNhbmNlbFQ7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBsaW5lTW9kZTogZmFsc2UsXG4gICAgcGFzdGVDYW5jZWxsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRjYW5jZWxUICYmICRjYW5jZWxUID4gRGF0ZS5ub3coKSAtIDUwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAkY2FuY2VsVCA9IGZhbHNlO1xuICAgIH0sXG4gICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRjYW5jZWxUID0gRGF0ZS5ub3coKTtcbiAgICB9XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9jb25maWdcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvY2xpcGJvYXJkXCIsXCJhY2UvbGliL2tleXNcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIG5scyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIikubmxzO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgY2xpcGJvYXJkID0gcmVxdWlyZShcIi4uL2NsaXBib2FyZFwiKTtcbnZhciBCUk9LRU5fU0VUREFUQSA9IHVzZXJhZ2VudC5pc0Nocm9tZSA8IDE4O1xudmFyIFVTRV9JRV9NSU1FX1RZUEUgPSB1c2VyYWdlbnQuaXNJRTtcbnZhciBIQVNfRk9DVVNfQVJHUyA9IHVzZXJhZ2VudC5pc0Nocm9tZSA+IDYzO1xudmFyIE1BWF9MSU5FX0xFTkdUSCA9IDQwMDtcbnZhciBLRVlTID0gcmVxdWlyZShcIi4uL2xpYi9rZXlzXCIpO1xudmFyIE1PRFMgPSBLRVlTLktFWV9NT0RTO1xudmFyIGlzSU9TID0gdXNlcmFnZW50LmlzSU9TO1xudmFyIHZhbHVlUmVzZXRSZWdleCA9IGlzSU9TID8gL1xccy8gOiAvXFxuLztcbnZhciBpc01vYmlsZSA9IHVzZXJhZ2VudC5pc01vYmlsZTtcbnZhciBUZXh0SW5wdXQ7XG5UZXh0SW5wdXQgPSBmdW5jdGlvbiAocGFyZW50Tm9kZSwgaG9zdCkge1xuICAgIHZhciB0ZXh0ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICB0ZXh0LmNsYXNzTmFtZSA9IFwiYWNlX3RleHQtaW5wdXRcIjtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsIFwib2ZmXCIpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCBcImZhbHNlXCIpO1xuICAgIHRleHQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHQsIHBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgdmFyIGNvcGllZCA9IGZhbHNlO1xuICAgIHZhciBwYXN0ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5Db21wb3NpdGlvbiA9IGZhbHNlO1xuICAgIHZhciBzZW5kaW5nVGV4dCA9IGZhbHNlO1xuICAgIHZhciB0ZW1wU3R5bGUgPSAnJztcbiAgICBpZiAoIWlzTW9iaWxlKVxuICAgICAgICB0ZXh0LnN0eWxlLmZvbnRTaXplID0gXCIxcHhcIjtcbiAgICB2YXIgY29tbWFuZE1vZGUgPSBmYWxzZTtcbiAgICB2YXIgaWdub3JlRm9jdXNFdmVudHMgPSBmYWxzZTtcbiAgICB2YXIgbGFzdFZhbHVlID0gXCJcIjtcbiAgICB2YXIgbGFzdFNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICB2YXIgbGFzdFNlbGVjdGlvbkVuZCA9IDA7XG4gICAgdmFyIGxhc3RSZXN0b3JlRW5kID0gMDtcbiAgICB2YXIgcm93U3RhcnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICB2YXIgcm93RW5kID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgdmFyIG51bWJlck9mRXh0cmFMaW5lcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGlzRm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRleHQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICB0aGlzLnNldE51bWJlck9mRXh0cmFMaW5lcyA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgcm93U3RhcnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgcm93RW5kID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICBudW1iZXJPZkV4dHJhTGluZXMgPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG51bWJlck9mRXh0cmFMaW5lcyA9IG51bWJlcjtcbiAgICB9O1xuICAgIHRoaXMuc2V0QXJpYU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hY3RpdmVEZXNjZW5kYW50KSB7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWF1dG9jb21wbGV0ZVwiLCBvcHRpb25zLmlubGluZSA/IFwiYm90aFwiIDogXCJsaXN0XCIpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgb3B0aW9ucy5hY3RpdmVEZXNjZW5kYW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWF1dG9jb21wbGV0ZVwiLCBcImJvdGhcIik7XG4gICAgICAgICAgICB0ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yb2xlKSB7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgb3B0aW9ucy5yb2xlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZXRMYWJlbCkge1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBubHMoXCJ0ZXh0LWlucHV0LmFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIFwiZWRpdG9yXCIpKTtcbiAgICAgICAgICAgIHZhciBhcmlhbExhYmVsID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChob3N0LiR0ZXh0SW5wdXRBcmlhTGFiZWwpIHtcbiAgICAgICAgICAgICAgICBhcmlhbExhYmVsICs9IFwiXCIuY29uY2F0KGhvc3QuJHRleHRJbnB1dEFyaWFMYWJlbCwgXCIsIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3N0LnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gaG9zdC5zZXNzaW9uLnNlbGVjdGlvbi5jdXJzb3Iucm93O1xuICAgICAgICAgICAgICAgIGFyaWFsTGFiZWwgKz0gbmxzKFwidGV4dC1pbnB1dC5hcmlhLWxhYmVsXCIsIFwiQ3Vyc29yIGF0IHJvdyAkMFwiLCBbcm93ICsgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGFyaWFsTGFiZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNldEFyaWFPcHRpb25zKHsgcm9sZTogXCJ0ZXh0Ym94XCIgfSk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJibHVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpZ25vcmVGb2N1c0V2ZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaG9zdC5vbkJsdXIoZSk7XG4gICAgICAgIGlzRm9jdXNlZCA9IGZhbHNlO1xuICAgIH0sIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGlnbm9yZUZvY3VzRXZlbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodXNlcmFnZW50LmlzRWRnZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50Lmhhc0ZvY3VzKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBob3N0Lm9uRm9jdXMoZSk7XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNFZGdlKVxuICAgICAgICAgICAgc2V0VGltZW91dChyZXNldFNlbGVjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgfSwgaG9zdCk7XG4gICAgdGhpcy4kZm9jdXNTY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEFyaWFPcHRpb25zKHtcbiAgICAgICAgICAgIHNldExhYmVsOiBob3N0LnJlbmRlcmVyLmVuYWJsZUtleWJvYXJkQWNjZXNzaWJpbGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRlbXBTdHlsZSB8fCBIQVNfRk9DVVNfQVJHUyB8fCB0aGlzLiRmb2N1c1Njcm9sbCA9PSBcImJyb3dzZXJcIilcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHRvcCA9IHRleHQuc3R5bGUudG9wO1xuICAgICAgICB0ZXh0LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICB0ZXh0LnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaXNUcmFuc2Zvcm1lZCA9IHRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICE9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgICAgIGlmIChpc1RyYW5zZm9ybWVkKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRleHQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHdoaWxlICh0ICYmIHQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwiYWNlX25vY29udGV4dFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0LnBhcmVudEVsZW1lbnQgJiYgdC5nZXRSb290Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQuZ2V0Um9vdE5vZGUoKVtcImhvc3RcIl07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0ID0gdC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRleHQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgYW5jZXN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBwLnJlbW92ZUF0dHJpYnV0ZShcImFjZV9ub2NvbnRleHRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRleHQuc3R5bGUucG9zaXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRleHQuc3R5bGUudG9wID09IFwiMHB4XCIpXG4gICAgICAgICAgICAgICAgdGV4dC5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgdGhpcy5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXh0LmJsdXIoKTtcbiAgICB9O1xuICAgIHRoaXMuaXNGb2N1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNGb2N1c2VkO1xuICAgIH07XG4gICAgaG9zdC5vbihcImJlZm9yZUVuZE9wZXJhdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJPcCA9IGhvc3QuY3VyT3A7XG4gICAgICAgIHZhciBjb21tYW5kTmFtZSA9IGN1ck9wICYmIGN1ck9wLmNvbW1hbmQgJiYgY3VyT3AuY29tbWFuZC5uYW1lO1xuICAgICAgICBpZiAoY29tbWFuZE5hbWUgPT0gXCJpbnNlcnRzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGlzVXNlckFjdGlvbiA9IGNvbW1hbmROYW1lICYmIChjdXJPcC5kb2NDaGFuZ2VkIHx8IGN1ck9wLnNlbGVjdGlvbkNoYW5nZWQpO1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbiAmJiBpc1VzZXJBY3Rpb24pIHtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHRleHQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgb25Db21wb3NpdGlvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgfSk7XG4gICAgdmFyIHBvc2l0aW9uVG9TZWxlY3Rpb24gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGNvbHVtbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gcm93IC0gcm93U3RhcnQgJiYgaSA8IDIgKiBudW1iZXJPZkV4dHJhTGluZXMgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiArPSBob3N0LnNlc3Npb24uZ2V0TGluZShyb3cgLSBpKS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfTtcbiAgICB2YXIgcmVzZXRTZWxlY3Rpb24gPSBpc0lPU1xuICAgICAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFpc0ZvY3VzZWQgfHwgKGNvcGllZCAmJiAhdmFsdWUpIHx8IHNlbmRpbmdUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gXCJcXG4gYWJcIiArIHZhbHVlICsgXCJjZGUgZmdcXG5cIjtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPSB0ZXh0LnZhbHVlKVxuICAgICAgICAgICAgICAgIHRleHQudmFsdWUgPSBsYXN0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IDQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gNCArICh2YWx1ZS5sZW5ndGggfHwgKGhvc3Quc2VsZWN0aW9uLmlzRW1wdHkoKSA/IDAgOiAxKSk7XG4gICAgICAgICAgICBpZiAobGFzdFNlbGVjdGlvblN0YXJ0ICE9IHNlbGVjdGlvblN0YXJ0IHx8IGxhc3RTZWxlY3Rpb25FbmQgIT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uIHx8IHNlbmRpbmdUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghaXNGb2N1c2VkICYmICFhZnRlckNvbnRleHRNZW51KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGluQ29tcG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGhvc3Quc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBob3N0LnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gc2VsZWN0aW9uLmN1cnNvci5yb3c7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA9PT0gcm93RW5kICsgMSkge1xuICAgICAgICAgICAgICAgICAgICByb3dTdGFydCA9IHJvd0VuZCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHJvd0VuZCA9IHJvd1N0YXJ0ICsgMiAqIG51bWJlck9mRXh0cmFMaW5lcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93ID09PSByb3dTdGFydCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93RW5kID0gcm93U3RhcnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICByb3dTdGFydCA9IHJvd0VuZCAtIDIgKiBudW1iZXJPZkV4dHJhTGluZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdyA8IHJvd1N0YXJ0IC0gMSB8fCByb3cgPiByb3dFbmQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1N0YXJ0ID0gcm93ID4gbnVtYmVyT2ZFeHRyYUxpbmVzID8gcm93IC0gbnVtYmVyT2ZFeHRyYUxpbmVzIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcm93RW5kID0gcm93ID4gbnVtYmVyT2ZFeHRyYUxpbmVzID8gcm93ICsgbnVtYmVyT2ZFeHRyYUxpbmVzIDogMiAqIG51bWJlck9mRXh0cmFMaW5lcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJvd1N0YXJ0OyBpIDw9IHJvd0VuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaG9zdC5zZXNzaW9uLmdldExpbmUoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBwb3NpdGlvblRvU2VsZWN0aW9uKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBwb3NpdGlvblRvU2VsZWN0aW9uKHJhbmdlLmVuZC5yb3csIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPCByb3dTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkxpbmUgPSBob3N0LnNlc3Npb24uZ2V0TGluZShyb3dTdGFydCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHJhbmdlLnN0YXJ0LnJvdyA8IHJvd1N0YXJ0IC0gMSA/IDAgOiBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kICs9IHByZXZMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBwcmV2TGluZSArIFwiXFxuXCIgKyBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5lbmQucm93ID4gcm93RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IGhvc3Quc2Vzc2lvbi5nZXRMaW5lKHJvd0VuZCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSByYW5nZS5lbmQucm93ID4gcm93RW5kICsgMSA/IG5leHRMaW5lLmxlbmd0aCA6IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lICsgXCJcXG5cIiArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01vYmlsZSAmJiByb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBcIlxcblwiICsgbGluZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPCBNQVhfTElORV9MRU5HVEggJiYgc2VsZWN0aW9uRW5kIDwgTUFYX0xJTkVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBNQVhfTElORV9MRU5HVEgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gbGluZSArIFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9IGxhc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnZhbHVlID0gbGFzdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25TdGFydCA9IGxhc3RTZWxlY3Rpb25FbmQgPSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFmdGVyQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgICAgICBsYXN0U2VsZWN0aW9uU3RhcnQgPSB0ZXh0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25FbmQgPSB0ZXh0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0U2VsZWN0aW9uRW5kICE9IHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICAgIHx8IGxhc3RTZWxlY3Rpb25TdGFydCAhPSBzZWxlY3Rpb25TdGFydFxuICAgICAgICAgICAgICAgIHx8IHRleHQuc2VsZWN0aW9uRW5kICE9IGxhc3RTZWxlY3Rpb25FbmQgLy8gb24gaWUgZWRnZSBzZWxlY3Rpb25FbmQgY2hhbmdlcyBzaWxlbnRseSBhZnRlciB0aGUgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0aW9uRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbkNvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgdGhpcy5yZXNldFNlbGVjdGlvbiA9IHJlc2V0U2VsZWN0aW9uO1xuICAgIGlmIChpc0ZvY3VzZWQpXG4gICAgICAgIGhvc3Qub25Gb2N1cygpO1xuICAgIHZhciBpc0FsbFNlbGVjdGVkID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGV4dC5zZWxlY3Rpb25FbmQgPj0gbGFzdFZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgJiYgdGV4dC52YWx1ZSA9PT0gbGFzdFZhbHVlICYmIGxhc3RWYWx1ZVxuICAgICAgICAgICAgJiYgdGV4dC5zZWxlY3Rpb25FbmQgIT09IGxhc3RTZWxlY3Rpb25FbmQ7XG4gICAgfTtcbiAgICB2YXIgb25TZWxlY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGNvcGllZCkge1xuICAgICAgICAgICAgY29waWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBbGxTZWxlY3RlZCh0ZXh0KSkge1xuICAgICAgICAgICAgaG9zdC5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb2JpbGUgJiYgdGV4dC5zZWxlY3Rpb25TdGFydCAhPSBsYXN0U2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbnB1dEhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMuc2V0SW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGNiKSB7IGlucHV0SGFuZGxlciA9IGNiOyB9O1xuICAgIHRoaXMuZ2V0SW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXRIYW5kbGVyOyB9O1xuICAgIHZhciBhZnRlckNvbnRleHRNZW51ID0gZmFsc2U7XG4gICAgdmFyIHNlbmRUZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBmcm9tSW5wdXQpIHtcbiAgICAgICAgaWYgKGFmdGVyQ29udGV4dE1lbnUpXG4gICAgICAgICAgICBhZnRlckNvbnRleHRNZW51ID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXN0ZWQpIHtcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgaG9zdC5vblBhc3RlKHZhbHVlKTtcbiAgICAgICAgICAgIHBhc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0ZXh0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IHRleHQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgdmFyIGV4dGVuZExlZnQgPSBsYXN0U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB2YXIgZXh0ZW5kUmlnaHQgPSBsYXN0VmFsdWUubGVuZ3RoIC0gbGFzdFNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIHJlc3RvcmVTdGFydCA9IHZhbHVlLmxlbmd0aCAtIHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIHJlc3RvcmVFbmQgPSB2YWx1ZS5sZW5ndGggLSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ZW5kTGVmdCA+IDAgJiYgbGFzdFZhbHVlW2ldID09IHZhbHVlW2ldKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGV4dGVuZExlZnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc2VydGVkID0gaW5zZXJ0ZWQuc2xpY2UoaSk7XG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChleHRlbmRSaWdodCA+IDAgJiYgbGFzdFZhbHVlLmxlbmd0aCAtIGkgPiBsYXN0U2VsZWN0aW9uU3RhcnQgLSAxICYmIGxhc3RWYWx1ZVtsYXN0VmFsdWUubGVuZ3RoIC0gaV0gPT0gdmFsdWVbdmFsdWUubGVuZ3RoIC0gaV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZXh0ZW5kUmlnaHQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3RvcmVTdGFydCAtPSBpIC0gMTtcbiAgICAgICAgICAgIHJlc3RvcmVFbmQgLT0gaSAtIDE7XG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBpbnNlcnRlZC5sZW5ndGggLSBpICsgMTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHRlbmRMZWZ0ID0gLWVuZEluZGV4O1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc2VydGVkID0gaW5zZXJ0ZWQuc2xpY2UoMCwgZW5kSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFmcm9tSW5wdXQgJiYgIWluc2VydGVkICYmICFyZXN0b3JlU3RhcnQgJiYgIWV4dGVuZExlZnQgJiYgIWV4dGVuZFJpZ2h0ICYmICFyZXN0b3JlRW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgc2VuZGluZ1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHNob3VsZFJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodXNlcmFnZW50LmlzQW5kcm9pZCAmJiBpbnNlcnRlZCA9PSBcIi4gXCIpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IFwiICBcIjtcbiAgICAgICAgICAgICAgICBzaG91bGRSZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIWV4dGVuZExlZnQgJiYgIWV4dGVuZFJpZ2h0ICYmICFyZXN0b3JlU3RhcnQgJiYgIXJlc3RvcmVFbmQgfHwgY29tbWFuZE1vZGUpIHtcbiAgICAgICAgICAgICAgICBob3N0Lm9uVGV4dElucHV0KGluc2VydGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvc3Qub25UZXh0SW5wdXQoaW5zZXJ0ZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGVmdDogZXh0ZW5kTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kUmlnaHQ6IGV4dGVuZFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByZXN0b3JlU3RhcnQ6IHJlc3RvcmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZUVuZDogcmVzdG9yZUVuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZGluZ1RleHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgbGFzdFJlc3RvcmVFbmQgPSByZXN0b3JlRW5kO1xuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFJlc2V0ID8gXCJcXG5cIiA6IGluc2VydGVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25JbnB1dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpbkNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIG9uQ29tcG9zaXRpb25VcGRhdGUoKTtcbiAgICAgICAgaWYgKGUgJiYgZS5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3QuZXhlY0NvbW1hbmQoXCJ1bmRvXCIpO1xuICAgICAgICAgICAgaWYgKGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9zdC5leGVjQ29tbWFuZChcInJlZG9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSB0ZXh0LnZhbHVlO1xuICAgICAgICB2YXIgaW5zZXJ0ZWQgPSBzZW5kVGV4dChkYXRhLCB0cnVlKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gTUFYX0xJTkVfTEVOR1RIICsgMTAwXG4gICAgICAgICAgICB8fCB2YWx1ZVJlc2V0UmVnZXgudGVzdChpbnNlcnRlZClcbiAgICAgICAgICAgIHx8IGlzTW9iaWxlICYmIGxhc3RTZWxlY3Rpb25TdGFydCA8IDEgJiYgbGFzdFNlbGVjdGlvblN0YXJ0ID09IGxhc3RTZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVDbGlwYm9hcmREYXRhID0gZnVuY3Rpb24gKGUsIGRhdGEsIGZvcmNlSUVNaW1lKSB7XG4gICAgICAgIHZhciBjbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhIHx8IHdpbmRvd1tcImNsaXBib2FyZERhdGFcIl07XG4gICAgICAgIGlmICghY2xpcGJvYXJkRGF0YSB8fCBCUk9LRU5fU0VUREFUQSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1pbWUgPSBVU0VfSUVfTUlNRV9UWVBFIHx8IGZvcmNlSUVNaW1lID8gXCJUZXh0XCIgOiBcInRleHQvcGxhaW5cIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaXBib2FyZERhdGEuc2V0RGF0YShtaW1lLCBkYXRhKSAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpcGJvYXJkRGF0YS5nZXREYXRhKG1pbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlSUVNaW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVDbGlwYm9hcmREYXRhKGUsIGRhdGEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZG9Db3B5ID0gZnVuY3Rpb24gKGUsIGlzQ3V0KSB7XG4gICAgICAgIHZhciBkYXRhID0gaG9zdC5nZXRDb3B5VGV4dCgpO1xuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGlmIChoYW5kbGVDbGlwYm9hcmREYXRhKGUsIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgICAgICAgICByZXNldFNlbGVjdGlvbihkYXRhKTtcbiAgICAgICAgICAgICAgICBjb3BpZWQgPSBkYXRhO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3BpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0N1dCA/IGhvc3Qub25DdXQoKSA6IGhvc3Qub25Db3B5KCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcGllZCA9IHRydWU7XG4gICAgICAgICAgICB0ZXh0LnZhbHVlID0gZGF0YTtcbiAgICAgICAgICAgIHRleHQuc2VsZWN0KCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb3BpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlzQ3V0ID8gaG9zdC5vbkN1dCgpIDogaG9zdC5vbkNvcHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25DdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkb0NvcHkoZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgb25Db3B5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZG9Db3B5KGUsIGZhbHNlKTtcbiAgICB9O1xuICAgIHZhciBvblBhc3RlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBoYW5kbGVDbGlwYm9hcmREYXRhKGUpO1xuICAgICAgICBpZiAoY2xpcGJvYXJkLnBhc3RlQ2FuY2VsbGVkKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICBob3N0Lm9uUGFzdGUoZGF0YSwgZSk7XG4gICAgICAgICAgICBpZiAodXNlcmFnZW50LmlzSUUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNldFNlbGVjdGlvbik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgcGFzdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXZlbnQuYWRkQ29tbWFuZEtleUxpc3RlbmVyKHRleHQsIGZ1bmN0aW9uIChlLCBoYXNoSWQsIGtleUNvZGUpIHtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBob3N0Lm9uQ29tbWFuZEtleShlLCBoYXNoSWQsIGtleUNvZGUpO1xuICAgIH0sIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwic2VsZWN0XCIsIG9uU2VsZWN0LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImlucHV0XCIsIG9uSW5wdXQsIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiY3V0XCIsIG9uQ3V0LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvcHlcIiwgb25Db3B5LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcInBhc3RlXCIsIG9uUGFzdGUsIGhvc3QpO1xuICAgIGlmICghKCdvbmN1dCcgaW4gdGV4dCkgfHwgISgnb25jb3B5JyBpbiB0ZXh0KSB8fCAhKCdvbnBhc3RlJyBpbiB0ZXh0KSkge1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihwYXJlbnROb2RlLCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICgodXNlcmFnZW50LmlzTWFjICYmICFlLm1ldGFLZXkpIHx8ICFlLmN0cmxLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDY3OlxuICAgICAgICAgICAgICAgICAgICBvbkNvcHkoZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODY6XG4gICAgICAgICAgICAgICAgICAgIG9uUGFzdGUoZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODg6XG4gICAgICAgICAgICAgICAgICAgIG9uQ3V0KGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaG9zdCk7XG4gICAgfVxuICAgIHZhciBvbkNvbXBvc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbiB8fCAhaG9zdC5vbkNvbXBvc2l0aW9uU3RhcnQgfHwgaG9zdC4kcmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluQ29tcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGNvbW1hbmRNb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZS5kYXRhKVxuICAgICAgICAgICAgaW5Db21wb3NpdGlvbi51c2VUZXh0YXJlYUZvcklNRSA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KG9uQ29tcG9zaXRpb25VcGRhdGUsIDApO1xuICAgICAgICBob3N0Ll9zaWduYWwoXCJjb21wb3NpdGlvblN0YXJ0XCIpO1xuICAgICAgICBob3N0Lm9uKFwibW91c2Vkb3duXCIsIGNhbmNlbENvbXBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHJhbmdlID0gaG9zdC5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICByYW5nZS5lbmQucm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICBpbkNvbXBvc2l0aW9uLm1hcmtlclJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGluQ29tcG9zaXRpb24uc2VsZWN0aW9uU3RhcnQgPSBsYXN0U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGhvc3Qub25Db21wb3NpdGlvblN0YXJ0KGluQ29tcG9zaXRpb24pO1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbi51c2VUZXh0YXJlYUZvcklNRSkge1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdGV4dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkVuZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGV4dC5tc0dldElucHV0Q29udGV4dClcbiAgICAgICAgICAgICAgICBpbkNvbXBvc2l0aW9uLmNvbnRleHQgPSB0ZXh0Lm1zR2V0SW5wdXRDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAodGV4dC5nZXRJbnB1dENvbnRleHQpXG4gICAgICAgICAgICAgICAgaW5Db21wb3NpdGlvbi5jb250ZXh0ID0gdGV4dC5nZXRJbnB1dENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uQ29tcG9zaXRpb25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaW5Db21wb3NpdGlvbiB8fCAhaG9zdC5vbkNvbXBvc2l0aW9uVXBkYXRlIHx8IGhvc3QuJHJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY29tbWFuZE1vZGUpXG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsQ29tcG9zaXRpb24oKTtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUpIHtcbiAgICAgICAgICAgIGhvc3Qub25Db21wb3NpdGlvblVwZGF0ZSh0ZXh0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGV4dC52YWx1ZTtcbiAgICAgICAgICAgIHNlbmRUZXh0KGRhdGEpO1xuICAgICAgICAgICAgaWYgKGluQ29tcG9zaXRpb24ubWFya2VyUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Db21wb3NpdGlvbi5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluQ29tcG9zaXRpb24ubWFya2VyUmFuZ2Uuc3RhcnQuY29sdW1uID0gaW5Db21wb3NpdGlvbi5zZWxlY3Rpb25TdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBpbkNvbXBvc2l0aW9uLmNvbnRleHQuY29tcG9zaXRpb25TdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5Db21wb3NpdGlvbi5tYXJrZXJSYW5nZS5lbmQuY29sdW1uID0gaW5Db21wb3NpdGlvbi5tYXJrZXJSYW5nZS5zdGFydC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgKyBsYXN0U2VsZWN0aW9uRW5kIC0gaW5Db21wb3NpdGlvbi5zZWxlY3Rpb25TdGFydCArIGxhc3RSZXN0b3JlRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25Db21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghaG9zdC5vbkNvbXBvc2l0aW9uRW5kIHx8IGhvc3QuJHJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbkNvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGhvc3Qub25Db21wb3NpdGlvbkVuZCgpO1xuICAgICAgICBob3N0Lm9mZihcIm1vdXNlZG93blwiLCBjYW5jZWxDb21wb3NpdGlvbik7XG4gICAgICAgIGlmIChlKVxuICAgICAgICAgICAgb25JbnB1dCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY2FuY2VsQ29tcG9zaXRpb24oKSB7XG4gICAgICAgIGlnbm9yZUZvY3VzRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgdGV4dC5ibHVyKCk7XG4gICAgICAgIHRleHQuZm9jdXMoKTtcbiAgICAgICAgaWdub3JlRm9jdXNFdmVudHMgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN5bmNDb21wb3NpdGlvbiA9IGxhbmcuZGVsYXllZENhbGwob25Db21wb3NpdGlvblVwZGF0ZSwgNTApLnNjaGVkdWxlLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgZnVuY3Rpb24gb25LZXl1cChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcgJiYgdGV4dC52YWx1ZS5sZW5ndGggPCB0ZXh0LnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoIWluQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gdGV4dC52YWx1ZTtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25TdGFydCA9IGxhc3RTZWxlY3Rpb25FbmQgPSAtMTtcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3luY0NvbXBvc2l0aW9uKCk7XG4gICAgfVxuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQsIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiY29tcG9zaXRpb251cGRhdGVcIiwgb25Db21wb3NpdGlvblVwZGF0ZSwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJrZXl1cFwiLCBvbktleXVwLCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImtleWRvd25cIiwgc3luY0NvbXBvc2l0aW9uLCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvbXBvc2l0aW9uZW5kXCIsIG9uQ29tcG9zaXRpb25FbmQsIGhvc3QpO1xuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICB0aGlzLnNldENvbW1hbmRNb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbW1hbmRNb2RlID0gdmFsdWU7XG4gICAgICAgIHRleHQucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuc2V0UmVhZE9ubHkgPSBmdW5jdGlvbiAocmVhZE9ubHkpIHtcbiAgICAgICAgaWYgKCFjb21tYW5kTW9kZSlcbiAgICAgICAgICAgIHRleHQucmVhZE9ubHkgPSByZWFkT25seTtcbiAgICB9O1xuICAgIHRoaXMuc2V0Q29weVdpdGhFbXB0eVNlbGVjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIH07XG4gICAgdGhpcy5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgYWZ0ZXJDb250ZXh0TWVudSA9IHRydWU7XG4gICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGhvc3QuX2VtaXQoXCJuYXRpdmVjb250ZXh0bWVudVwiLCB7IHRhcmdldDogaG9zdCwgZG9tRXZlbnQ6IGUgfSk7XG4gICAgICAgIHRoaXMubW92ZVRvTW91c2UoZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVUb01vdXNlID0gZnVuY3Rpb24gKGUsIGJyaW5nVG9Gcm9udCkge1xuICAgICAgICBpZiAoIXRlbXBTdHlsZSlcbiAgICAgICAgICAgIHRlbXBTdHlsZSA9IHRleHQuc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgdGV4dC5zdHlsZS5jc3NUZXh0ID0gKGJyaW5nVG9Gcm9udCA/IFwiei1pbmRleDoxMDAwMDA7XCIgOiBcIlwiKVxuICAgICAgICAgICAgKyAodXNlcmFnZW50LmlzSUUgPyBcIm9wYWNpdHk6MC4xO1wiIDogXCJcIilcbiAgICAgICAgICAgICsgXCJ0ZXh0LWluZGVudDogLVwiICsgKGxhc3RTZWxlY3Rpb25TdGFydCArIGxhc3RTZWxlY3Rpb25FbmQpICogaG9zdC5yZW5kZXJlci5jaGFyYWN0ZXJXaWR0aCAqIDAuNSArIFwicHg7XCI7XG4gICAgICAgIHZhciByZWN0ID0gaG9zdC5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvbS5jb21wdXRlZFN0eWxlKGhvc3QuY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHRvcCA9IHJlY3QudG9wICsgKHBhcnNlSW50KHN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwKTtcbiAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyAocGFyc2VJbnQocmVjdC5ib3JkZXJMZWZ0V2lkdGgpIHx8IDApO1xuICAgICAgICB2YXIgbWF4VG9wID0gcmVjdC5ib3R0b20gLSB0b3AgLSB0ZXh0LmNsaWVudEhlaWdodCAtIDI7XG4gICAgICAgIHZhciBtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRvbS50cmFuc2xhdGUodGV4dCwgZS5jbGllbnRYIC0gbGVmdCAtIDIsIE1hdGgubWluKGUuY2xpZW50WSAtIHRvcCAtIDIsIG1heFRvcCkpO1xuICAgICAgICB9O1xuICAgICAgICBtb3ZlKGUpO1xuICAgICAgICBpZiAoZS50eXBlICE9IFwibW91c2Vkb3duXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhvc3QucmVuZGVyZXIuJGlzTW91c2VQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dCk7XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNXaW4pXG4gICAgICAgICAgICBldmVudC5jYXB0dXJlKGhvc3QuY29udGFpbmVyLCBtb3ZlLCBvbkNvbnRleHRNZW51Q2xvc2UpO1xuICAgIH07XG4gICAgdGhpcy5vbkNvbnRleHRNZW51Q2xvc2UgPSBvbkNvbnRleHRNZW51Q2xvc2U7XG4gICAgdmFyIGNsb3NlVGltZW91dDtcbiAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51Q2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQpO1xuICAgICAgICBjbG9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0ZW1wU3R5bGUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0LnN0eWxlLmNzc1RleHQgPSB0ZW1wU3R5bGU7XG4gICAgICAgICAgICAgICAgdGVtcFN0eWxlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3N0LnJlbmRlcmVyLiRpc01vdXNlUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhvc3QucmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yKVxuICAgICAgICAgICAgICAgIGhvc3QucmVuZGVyZXIuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICB2YXIgb25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhvc3QudGV4dElucHV0Lm9uQ29udGV4dE1lbnUoZSk7XG4gICAgICAgIG9uQ29udGV4dE1lbnVDbG9zZSgpO1xuICAgIH07XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJtb3VzZXVwXCIsIG9uQ29udGV4dE1lbnUsIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25Db250ZXh0TWVudUNsb3NlKCk7XG4gICAgfSwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoaG9zdC5yZW5kZXJlci5zY3JvbGxlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUsIGhvc3QpO1xuICAgIGlmIChpc0lPUylcbiAgICAgICAgYWRkSW9zU2VsZWN0aW9uSGFuZGxlcihwYXJlbnROb2RlLCBob3N0LCB0ZXh0KTtcbiAgICBmdW5jdGlvbiBhZGRJb3NTZWxlY3Rpb25IYW5kbGVyKHBhcmVudE5vZGUsIGhvc3QsIHRleHQpIHtcbiAgICAgICAgdmFyIHR5cGluZ1Jlc2V0VGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciB0eXBpbmcgPSBmYWxzZTtcbiAgICAgICAgdGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHR5cGluZ1Jlc2V0VGltZW91dClcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHlwaW5nUmVzZXRUaW1lb3V0KTtcbiAgICAgICAgICAgIHR5cGluZyA9IHRydWU7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdHlwaW5nUmVzZXRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHlwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgdmFyIGRldGVjdEFycm93S2V5cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwaW5nIHx8IGluQ29tcG9zaXRpb24gfHwgaG9zdC4kbW91c2VIYW5kbGVyLmlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChjb3BpZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0ZXh0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IHRleHQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgdmFyIGtleSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSAwO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLnVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uU3RhcnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGtleSA9IEtFWVMuaG9tZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbkVuZCA+IGxhc3RTZWxlY3Rpb25FbmQgJiYgbGFzdFZhbHVlW3NlbGVjdGlvbkVuZF0gPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGtleSA9IEtFWVMuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uU3RhcnQgPCBsYXN0U2VsZWN0aW9uU3RhcnQgJiYgbGFzdFZhbHVlW3NlbGVjdGlvblN0YXJ0IC0gMV0gPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLmxlZnQ7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBNT0RTLm9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvblN0YXJ0IDwgbGFzdFNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgICAgICAgfHwgKHNlbGVjdGlvblN0YXJ0ID09IGxhc3RTZWxlY3Rpb25TdGFydFxuICAgICAgICAgICAgICAgICAgICAmJiBsYXN0U2VsZWN0aW9uRW5kICE9IGxhc3RTZWxlY3Rpb25TdGFydFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxlY3Rpb25TdGFydCA9PSBzZWxlY3Rpb25FbmQpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gS0VZUy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uRW5kID4gbGFzdFNlbGVjdGlvbkVuZCAmJiBsYXN0VmFsdWUuc2xpY2UoMCwgc2VsZWN0aW9uRW5kKS5zcGxpdChcIlxcblwiKS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gS0VZUy5kb3duO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uRW5kID4gbGFzdFNlbGVjdGlvbkVuZCAmJiBsYXN0VmFsdWVbc2VsZWN0aW9uRW5kIC0gMV0gPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLnJpZ2h0O1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gTU9EUy5vcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25FbmQgPiBsYXN0U2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfHwgKHNlbGVjdGlvbkVuZCA9PSBsYXN0U2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgICAgICYmIGxhc3RTZWxlY3Rpb25FbmQgIT0gbGFzdFNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGVjdGlvblN0YXJ0ID09IHNlbGVjdGlvbkVuZCkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpXG4gICAgICAgICAgICAgICAgbW9kaWZpZXIgfD0gTU9EUy5zaGlmdDtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaG9zdC5vbkNvbW1hbmRLZXkoe30sIG1vZGlmaWVyLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIGhvc3QuY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gS0VZUy5rZXlDb2RlVG9TdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBob3N0LmNvbW1hbmRzLmZpbmRLZXlDb21tYW5kKG1vZGlmaWVyLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3QuZXhlY0NvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgcmVzZXRTZWxlY3Rpb24oXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgZGV0ZWN0QXJyb3dLZXlzKTtcbiAgICAgICAgaG9zdC5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCBkZXRlY3RBcnJvd0tleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGV4dC5wYXJlbnRFbGVtZW50KVxuICAgICAgICAgICAgdGV4dC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRleHQpO1xuICAgIH07XG59O1xuZXhwb3J0cy5UZXh0SW5wdXQgPSBUZXh0SW5wdXQ7XG5leHBvcnRzLiRzZXRVc2VyQWdlbnRGb3JUZXN0cyA9IGZ1bmN0aW9uIChfaXNNb2JpbGUsIF9pc0lPUykge1xuICAgIGlzTW9iaWxlID0gX2lzTW9iaWxlO1xuICAgIGlzSU9TID0gX2lzSU9TO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvZGVmYXVsdF9oYW5kbGVyc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXNlcmFnZW50ID0gcmVxdWlyZShcIi4uL2xpYi91c2VyYWdlbnRcIik7XG52YXIgRFJBR19PRkZTRVQgPSAwOyAvLyBwaXhlbHNcbnZhciBTQ1JPTExfQ09PTERPV05fVCA9IDU1MDsgLy8gbWlsbGlzZWNvbmRzXG52YXIgRGVmYXVsdEhhbmRsZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRIYW5kbGVycyhtb3VzZUhhbmRsZXIpIHtcbiAgICAgICAgbW91c2VIYW5kbGVyLiRjbGlja1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBlZGl0b3IgPSBtb3VzZUhhbmRsZXIuZWRpdG9yO1xuICAgICAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93bi5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgICAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJkYmxjbGlja1wiLCB0aGlzLm9uRG91YmxlQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICAgICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwidHJpcGxlY2xpY2tcIiwgdGhpcy5vblRyaXBsZUNsaWNrLmJpbmQobW91c2VIYW5kbGVyKSk7XG4gICAgICAgIGVkaXRvci5zZXREZWZhdWx0SGFuZGxlcihcInF1YWRjbGlja1wiLCB0aGlzLm9uUXVhZENsaWNrLmJpbmQobW91c2VIYW5kbGVyKSk7XG4gICAgICAgIGVkaXRvci5zZXREZWZhdWx0SGFuZGxlcihcIm1vdXNld2hlZWxcIiwgdGhpcy5vbk1vdXNlV2hlZWwuYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICAgICAgdmFyIGV4cG9ydHMgPSBbXCJzZWxlY3RcIiwgXCJzdGFydFNlbGVjdFwiLCBcInNlbGVjdEVuZFwiLCBcInNlbGVjdEFsbEVuZFwiLCBcInNlbGVjdEJ5V29yZHNFbmRcIixcbiAgICAgICAgICAgIFwic2VsZWN0QnlMaW5lc0VuZFwiLCBcImRyYWdXYWl0XCIsIFwiZHJhZ1dhaXRFbmRcIiwgXCJmb2N1c1dhaXRcIl07XG4gICAgICAgIGV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgbW91c2VIYW5kbGVyW3hdID0gdGhpc1t4XTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIG1vdXNlSGFuZGxlcltcInNlbGVjdEJ5TGluZXNcIl0gPSB0aGlzLmV4dGVuZFNlbGVjdGlvbkJ5LmJpbmQobW91c2VIYW5kbGVyLCBcImdldExpbmVSYW5nZVwiKTtcbiAgICAgICAgbW91c2VIYW5kbGVyW1wic2VsZWN0QnlXb3Jkc1wiXSA9IHRoaXMuZXh0ZW5kU2VsZWN0aW9uQnkuYmluZChtb3VzZUhhbmRsZXIsIFwiZ2V0V29yZFJhbmdlXCIpO1xuICAgIH1cbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBpblNlbGVjdGlvbiA9IGV2LmluU2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQgPSBldjtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgYnV0dG9uID0gZXYuZ2V0QnV0dG9uKCk7XG4gICAgICAgIGlmIChidXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVtcHR5ID0gc2VsZWN0aW9uUmFuZ2UuaXNFbXB0eSgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkVtcHR5IHx8IGJ1dHRvbiA9PSAxKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgIGlmIChidXR0b24gPT0gMikge1xuICAgICAgICAgICAgICAgIGVkaXRvci50ZXh0SW5wdXQub25Db250ZXh0TWVudShldi5kb21FdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyYWdlbnQuaXNNb3ppbGxhKVxuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChpblNlbGVjdGlvbiAmJiAhZWRpdG9yLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRmb2N1c1RpbWVvdXQgJiYgIXRoaXMuJGNsaWNrU2VsZWN0aW9uICYmICFlZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKFwiZm9jdXNXYWl0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZU1vdXNlKGV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZXYpO1xuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0KHBvcywgZXYuZG9tRXZlbnQuX2NsaWNrcyA+IDEpO1xuICAgICAgICByZXR1cm4gZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuc3RhcnRTZWxlY3QgPSBmdW5jdGlvbiAocG9zLCB3YWl0Rm9yQ2xpY2tTZWxlY3Rpb24pIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBpZiAoIXRoaXMubW91c2Vkb3duRXZlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1vdXNlZG93bkV2ZW50LmdldFNoaWZ0S2V5KCkpXG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgZWxzZSBpZiAoIXdhaXRGb3JDbGlja1NlbGVjdGlvbilcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgaWYgKCF3YWl0Rm9yQ2xpY2tTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgICAgICBlZGl0b3Iuc2V0U3R5bGUoXCJhY2Vfc2VsZWN0aW5nXCIpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwic2VsZWN0XCIpO1xuICAgIH07XG4gICAgRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmNob3IsIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLnJlbmRlcmVyLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgaWYgKHRoaXMuJGNsaWNrU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY21wID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uY29tcGFyZVBvaW50KGN1cnNvcik7XG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcmllbnRlZFJhbmdlID0gY2FsY1JhbmdlT3JpZW50YXRpb24odGhpcy4kY2xpY2tTZWxlY3Rpb24sIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gb3JpZW50ZWRSYW5nZS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gb3JpZW50ZWRSYW5nZS5hbmNob3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFNlbGVjdGlvbkFuY2hvcihhbmNob3Iucm93LCBhbmNob3IuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFRvUG9zaXRpb24oY3Vyc29yKTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLmV4dGVuZFNlbGVjdGlvbkJ5ID0gZnVuY3Rpb24gKHVuaXROYW1lKSB7XG4gICAgICAgIHZhciBhbmNob3IsIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLnJlbmRlcmVyLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvblt1bml0TmFtZV0oY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIGlmICh0aGlzLiRjbGlja1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGNtcFN0YXJ0ID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uY29tcGFyZVBvaW50KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBjbXBFbmQgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5jb21wYXJlUG9pbnQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChjbXBTdGFydCA9PSAtMSAmJiBjbXBFbmQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRoaXMuJGNsaWNrU2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kLnJvdyAhPSBjdXJzb3Iucm93IHx8IHJhbmdlLmVuZC5jb2x1bW4gIT0gY3Vyc29yLmNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXBFbmQgPT0gMSAmJiBjbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyAhPSBjdXJzb3Iucm93IHx8IHJhbmdlLnN0YXJ0LmNvbHVtbiAhPSBjdXJzb3IuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXBTdGFydCA9PSAtMSAmJiBjbXBFbmQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcmllbnRlZFJhbmdlID0gY2FsY1JhbmdlT3JpZW50YXRpb24odGhpcy4kY2xpY2tTZWxlY3Rpb24sIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gb3JpZW50ZWRSYW5nZS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gb3JpZW50ZWRSYW5nZS5hbmNob3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFNlbGVjdGlvbkFuY2hvcihhbmNob3Iucm93LCBhbmNob3IuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFRvUG9zaXRpb24oY3Vyc29yKTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLnNlbGVjdEJ5TGluZXNFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZGl0b3IudW5zZXRTdHlsZShcImFjZV9zZWxlY3RpbmdcIik7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLmZvY3VzV2FpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKHRoaXMubW91c2Vkb3duRXZlbnQueCwgdGhpcy5tb3VzZWRvd25FdmVudC55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gRFJBR19PRkZTRVQgfHwgdGltZSAtIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA+IHRoaXMuJGZvY3VzVGltZW91dClcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTZWxlY3QodGhpcy5tb3VzZWRvd25FdmVudC5nZXREb2N1bWVudFBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHJhbmdlID0gc2Vzc2lvbi5nZXRCcmFja2V0UmFuZ2UocG9zKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uLS07XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShcInNlbGVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRXb3JkUmFuZ2UocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKFwic2VsZWN0QnlXb3Jkc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbiA9IHJhbmdlO1xuICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH07XG4gICAgRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5vblRyaXBsZUNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInNlbGVjdEJ5TGluZXNcIik7XG4gICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UuaXNNdWx0aUxpbmUoKSAmJiByYW5nZS5jb250YWlucyhwb3Mucm93LCBwb3MuY29sdW1uKSkge1xuICAgICAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24uZW5kID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRMaW5lUmFuZ2UocmFuZ2UuZW5kLnJvdykuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShwb3Mucm93KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH07XG4gICAgRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5vblF1YWRDbGljayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGVkaXRvci5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInNlbGVjdEFsbFwiKTtcbiAgICB9O1xuICAgIERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUub25Nb3VzZVdoZWVsID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldi5nZXRBY2NlbEtleSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXYuZ2V0U2hpZnRLZXkoKSAmJiBldi53aGVlbFkgJiYgIWV2LndoZWVsWCkge1xuICAgICAgICAgICAgZXYud2hlZWxYID0gZXYud2hlZWxZO1xuICAgICAgICAgICAgZXYud2hlZWxZID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGlmICghdGhpcy4kbGFzdFNjcm9sbClcbiAgICAgICAgICAgIHRoaXMuJGxhc3RTY3JvbGwgPSB7IHQ6IDAsIHZ4OiAwLCB2eTogMCwgYWxsb3dlZDogMCB9O1xuICAgICAgICB2YXIgcHJldlNjcm9sbCA9IHRoaXMuJGxhc3RTY3JvbGw7XG4gICAgICAgIHZhciB0ID0gZXYuZG9tRXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2YXIgZHQgPSB0IC0gcHJldlNjcm9sbC50O1xuICAgICAgICB2YXIgdnggPSBkdCA/IGV2LndoZWVsWCAvIGR0IDogcHJldlNjcm9sbC52eDtcbiAgICAgICAgdmFyIHZ5ID0gZHQgPyBldi53aGVlbFkgLyBkdCA6IHByZXZTY3JvbGwudnk7XG4gICAgICAgIGlmIChkdCA8IFNDUk9MTF9DT09MRE9XTl9UKSB7XG4gICAgICAgICAgICB2eCA9ICh2eCArIHByZXZTY3JvbGwudngpIC8gMjtcbiAgICAgICAgICAgIHZ5ID0gKHZ5ICsgcHJldlNjcm9sbC52eSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBNYXRoLmFicyh2eCAvIHZ5KTtcbiAgICAgICAgdmFyIGNhblNjcm9sbCA9IGZhbHNlO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID49IDEgJiYgZWRpdG9yLnJlbmRlcmVyLmlzU2Nyb2xsYWJsZUJ5KGV2LndoZWVsWCAqIGV2LnNwZWVkLCAwKSlcbiAgICAgICAgICAgIGNhblNjcm9sbCA9IHRydWU7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPD0gMSAmJiBlZGl0b3IucmVuZGVyZXIuaXNTY3JvbGxhYmxlQnkoMCwgZXYud2hlZWxZICogZXYuc3BlZWQpKVxuICAgICAgICAgICAgY2FuU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhblNjcm9sbCkge1xuICAgICAgICAgICAgcHJldlNjcm9sbC5hbGxvd2VkID0gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IC0gcHJldlNjcm9sbC5hbGxvd2VkIDwgU0NST0xMX0NPT0xET1dOX1QpIHtcbiAgICAgICAgICAgIHZhciBpc1Nsb3dlciA9IE1hdGguYWJzKHZ4KSA8PSAxLjUgKiBNYXRoLmFicyhwcmV2U2Nyb2xsLnZ4KVxuICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKHZ5KSA8PSAxLjUgKiBNYXRoLmFicyhwcmV2U2Nyb2xsLnZ5KTtcbiAgICAgICAgICAgIGlmIChpc1Nsb3dlcikge1xuICAgICAgICAgICAgICAgIGNhblNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldlNjcm9sbC5hbGxvd2VkID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZTY3JvbGwuYWxsb3dlZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldlNjcm9sbC50ID0gdDtcbiAgICAgICAgcHJldlNjcm9sbC52eCA9IHZ4O1xuICAgICAgICBwcmV2U2Nyb2xsLnZ5ID0gdnk7XG4gICAgICAgIGlmIChjYW5TY3JvbGwpIHtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxCeShldi53aGVlbFggKiBldi5zcGVlZCwgZXYud2hlZWxZICogZXYuc3BlZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGV2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRIYW5kbGVycztcbn0oKSk7XG5EZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLnNlbGVjdEVuZCA9IERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuc2VsZWN0QnlMaW5lc0VuZDtcbkRlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuc2VsZWN0QWxsRW5kID0gRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zZWxlY3RCeUxpbmVzRW5kO1xuRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zZWxlY3RCeVdvcmRzRW5kID0gRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zZWxlY3RCeUxpbmVzRW5kO1xuZXhwb3J0cy5EZWZhdWx0SGFuZGxlcnMgPSBEZWZhdWx0SGFuZGxlcnM7XG5mdW5jdGlvbiBjYWxjRGlzdGFuY2UoYXgsIGF5LCBieCwgYnkpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGJ4IC0gYXgsIDIpICsgTWF0aC5wb3coYnkgLSBheSwgMikpO1xufVxuZnVuY3Rpb24gY2FsY1JhbmdlT3JpZW50YXRpb24ocmFuZ2UsIGN1cnNvcikge1xuICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdylcbiAgICAgICAgdmFyIGNtcCA9IDIgKiBjdXJzb3IuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uIC0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICBlbHNlIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdyAtIDEgJiYgIXJhbmdlLnN0YXJ0LmNvbHVtbiAmJiAhcmFuZ2UuZW5kLmNvbHVtbilcbiAgICAgICAgdmFyIGNtcCA9IGN1cnNvci5jb2x1bW4gLSA0O1xuICAgIGVsc2VcbiAgICAgICAgdmFyIGNtcCA9IDIgKiBjdXJzb3Iucm93IC0gcmFuZ2Uuc3RhcnQucm93IC0gcmFuZ2UuZW5kLnJvdztcbiAgICBpZiAoY21wIDwgMClcbiAgICAgICAgcmV0dXJuIHsgY3Vyc29yOiByYW5nZS5zdGFydCwgYW5jaG9yOiByYW5nZS5lbmQgfTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB7IGN1cnNvcjogcmFuZ2UuZW5kLCBhbmNob3I6IHJhbmdlLnN0YXJ0IH07XG59XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9zY3JvbGxcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7ZXhwb3J0cy5wcmV2ZW50UGFyZW50U2Nyb2xsID0gZnVuY3Rpb24gcHJldmVudFBhcmVudFNjcm9sbChldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIHZhciBjb250ZW50T3ZlcmZsb3dzID0gdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCFjb250ZW50T3ZlcmZsb3dzKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdG9vbHRpcFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9yYW5nZVwiLFwiYWNlL2xpYi9zY3JvbGxcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRcIik7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBwcmV2ZW50UGFyZW50U2Nyb2xsID0gcmVxdWlyZShcIi4vbGliL3Njcm9sbFwiKS5wcmV2ZW50UGFyZW50U2Nyb2xsO1xudmFyIENMQVNTTkFNRSA9IFwiYWNlX3Rvb2x0aXBcIjtcbnZhciBUb29sdGlwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvb2x0aXAocGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgfVxuICAgIFRvb2x0aXAucHJvdG90eXBlLiRpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY2xhc3NOYW1lID0gQ0xBU1NOQU1FO1xuICAgICAgICB0aGlzLiRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy4kcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQ7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudCB8fCB0aGlzLiRpbml0KCk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuc2V0SHRtbCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuc2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5nZXRFbGVtZW50KCksIGNsYXNzTmFtZSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmNsYXNzTmFtZSA9IENMQVNTTkFNRSArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGVtZS5pc0RhcmsgPyBcImFjZV9kYXJrIFwiIDogXCJcIikgKyAodGhlbWUuY3NzQ2xhc3MgfHwgXCJcIik7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHRleHQsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRleHQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICAgICAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5jbGFzc05hbWUgPSBDTEFTU05BTUU7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoKS5vZmZzZXRIZWlnaHQ7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudCgpLm9mZnNldFdpZHRoO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQgJiYgdGhpcy4kZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb29sdGlwO1xufSgpKTtcbnZhciBQb3B1cE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9wdXBNYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLnBvcHVwcyA9IFtdO1xuICAgIH1cbiAgICBQb3B1cE1hbmFnZXIucHJvdG90eXBlLmFkZFBvcHVwID0gZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICAgIHRoaXMucG9wdXBzLnB1c2gocG9wdXApO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvcHVwcygpO1xuICAgIH07XG4gICAgUG9wdXBNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVQb3B1cCA9IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBvcHVwcy5pbmRleE9mKHBvcHVwKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9wdXBzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUG9wdXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdGhpcy5wb3B1cHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7IH0pO1xuICAgICAgICB2YXIgdmlzaWJsZXBvcHVwcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLnBvcHVwcyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9wdXAgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkRGlzcGxheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdmlzaWJsZXBvcHVwc18xID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXModmlzaWJsZXBvcHVwcykpLCB2aXNpYmxlcG9wdXBzXzFfMSA9IHZpc2libGVwb3B1cHNfMS5uZXh0KCk7ICF2aXNpYmxlcG9wdXBzXzFfMS5kb25lOyB2aXNpYmxlcG9wdXBzXzFfMSA9IHZpc2libGVwb3B1cHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUG9wdXAgPSB2aXNpYmxlcG9wdXBzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvUG9wdXBzT3ZlcmxhcCh2aXNpYmxlUG9wdXAsIHBvcHVwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZERpc3BsYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2libGVwb3B1cHNfMV8xICYmICF2aXNpYmxlcG9wdXBzXzFfMS5kb25lICYmIChfYiA9IHZpc2libGVwb3B1cHNfMS5yZXR1cm4pKSBfYi5jYWxsKHZpc2libGVwb3B1cHNfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlcG9wdXBzLnB1c2gocG9wdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wdXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3B1cE1hbmFnZXIucHJvdG90eXBlLmRvUG9wdXBzT3ZlcmxhcCA9IGZ1bmN0aW9uIChwb3B1cEEsIHBvcHVwQikge1xuICAgICAgICB2YXIgcmVjdEEgPSBwb3B1cEEuZ2V0RWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcmVjdEIgPSBwb3B1cEIuZ2V0RWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gKHJlY3RBLmxlZnQgPCByZWN0Qi5yaWdodCAmJiByZWN0QS5yaWdodCA+IHJlY3RCLmxlZnQgJiYgcmVjdEEudG9wIDwgcmVjdEIuYm90dG9tICYmIHJlY3RBLmJvdHRvbVxuICAgICAgICAgICAgPiByZWN0Qi50b3ApO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVwTWFuYWdlcjtcbn0oKSk7XG52YXIgcG9wdXBNYW5hZ2VyID0gbmV3IFBvcHVwTWFuYWdlcigpO1xuZXhwb3J0cy5wb3B1cE1hbmFnZXIgPSBwb3B1cE1hbmFnZXI7XG5leHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xudmFyIEhvdmVyVG9vbHRpcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG92ZXJUb29sdGlwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvdmVyVG9vbHRpcChwYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlID09PSB2b2lkIDApIHsgcGFyZW50Tm9kZSA9IGRvY3VtZW50LmJvZHk7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50Tm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMubGFzdFQgPSAwO1xuICAgICAgICBfdGhpcy5pZGxlVGltZSA9IDM1MDtcbiAgICAgICAgX3RoaXMubGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5vbk1vdXNlT3V0ID0gX3RoaXMub25Nb3VzZU91dC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25Nb3VzZU1vdmUgPSBfdGhpcy5vbk1vdXNlTW92ZS5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMud2FpdEZvckhvdmVyID0gX3RoaXMud2FpdEZvckhvdmVyLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5oaWRlID0gX3RoaXMuaGlkZS5iaW5kKF90aGlzKTtcbiAgICAgICAgdmFyIGVsID0gX3RoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgICBlbC5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmUtd3JhcFwiO1xuICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBfdGhpcy5vbk1vdXNlT3V0KTtcbiAgICAgICAgZWwudGFiSW5kZXggPSAtMTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFlbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfS5iaW5kKF90aGlzKSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBwcmV2ZW50UGFyZW50U2Nyb2xsKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLmFkZFRvRWRpdG9yID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBlZGl0b3Iub24oXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNlZG93blwiLCB0aGlzLmhpZGUpO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuZ2V0TW91c2VFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xuICAgIH07XG4gICAgSG92ZXJUb29sdGlwLnByb3RvdHlwZS5yZW1vdmVGcm9tRWRpdG9yID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBlZGl0b3Iub2ZmKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwibW91c2Vkb3duXCIsIHRoaXMuaGlkZSk7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci5nZXRNb3VzZUV2ZW50VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMub25Nb3VzZU91dCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSG92ZXJUb29sdGlwLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlLCBlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBlO1xuICAgICAgICB0aGlzLmxhc3RUID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGlzTW91c2VQcmVzc2VkID0gZWRpdG9yLiRtb3VzZUhhbmRsZXIuaXNNb3VzZVByZXNzZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMubGFzdEV2ZW50ICYmIHRoaXMubGFzdEV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZVxuICAgICAgICAgICAgICAgIHx8ICF0aGlzLnJhbmdlLmNvbnRhaW5zKHBvcy5yb3csIHBvcy5jb2x1bW4pXG4gICAgICAgICAgICAgICAgfHwgaXNNb3VzZVByZXNzZWRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmlzT3V0c2lkZU9mVGV4dCh0aGlzLmxhc3RFdmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lb3V0IHx8IGlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IGU7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy53YWl0Rm9ySG92ZXIsIHRoaXMuaWRsZVRpbWUpO1xuICAgIH07XG4gICAgSG92ZXJUb29sdGlwLnByb3RvdHlwZS53YWl0Rm9ySG92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdmFyIGR0ID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFQ7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lIC0gZHQgPiAxMCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLndhaXRGb3JIb3ZlciwgdGhpcy5pZGxlVGltZSAtIGR0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5sYXN0RXZlbnQgJiYgIXRoaXMuaXNPdXRzaWRlT2ZUZXh0KHRoaXMubGFzdEV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy4kZ2F0aGVyRGF0YSh0aGlzLmxhc3RFdmVudCwgdGhpcy5sYXN0RXZlbnQuZWRpdG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSG92ZXJUb29sdGlwLnByb3RvdHlwZS5pc091dHNpZGVPZlRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgICAgIHZhciBkb2NQb3MgPSBlLmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxpbmUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKGRvY1Bvcy5yb3cpO1xuICAgICAgICBpZiAoZG9jUG9zLmNvbHVtbiA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNjcmVlblBvcyA9IGVkaXRvci5yZW5kZXJlci5waXhlbFRvU2NyZWVuQ29vcmRpbmF0ZXMoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgICAgdmFyIGNsaXBwZWRQb3MgPSBlZGl0b3Iuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oZG9jUG9zLnJvdywgZG9jUG9zLmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY2xpcHBlZFBvcy5jb2x1bW4gIT0gc2NyZWVuUG9zLmNvbHVtblxuICAgICAgICAgICAgICAgIHx8IGNsaXBwZWRQb3Mucm93ICE9IHNjcmVlblBvcy5yb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLnNldERhdGFQcm92aWRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRnYXRoZXJEYXRhID0gdmFsdWU7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLnNob3dGb3JSYW5nZSA9IGZ1bmN0aW9uIChlZGl0b3IsIHJhbmdlLCBkb21Ob2RlLCBzdGFydGluZ0V2ZW50KSB7XG4gICAgICAgIHZhciBNQVJHSU4gPSAxMDtcbiAgICAgICAgaWYgKHN0YXJ0aW5nRXZlbnQgJiYgc3RhcnRpbmdFdmVudCAhPSB0aGlzLmxhc3RFdmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5nZXRFbGVtZW50KCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByZW5kZXJlciA9IGVkaXRvci5yZW5kZXJlcjtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcG9wdXBNYW5hZ2VyLmFkZFBvcHVwKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kcmVnaXN0ZXJDbG9zZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaGVtZShyZW5kZXJlci50aGVtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZE1hcmtlcihyYW5nZSwgZWRpdG9yLnNlc3Npb24pO1xuICAgICAgICB0aGlzLnJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcmVuZGVyZXIudGV4dFRvU2NyZWVuQ29vcmRpbmF0ZXMocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICB2YXIgcmVjdCA9IHJlbmRlcmVyLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAocG9zaXRpb24ucGFnZVggPCByZWN0LmxlZnQpXG4gICAgICAgICAgICBwb3NpdGlvbi5wYWdlWCA9IHJlY3QubGVmdDtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvbU5vZGUpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLm1heEhlaWdodCA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIHNwYWNlQmVsb3cgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3NpdGlvbi5wYWdlWSAtIHJlbmRlcmVyLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBpc0Fib3ZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLnBhZ2VZIC0gbGFiZWxIZWlnaHQgPCAwICYmIHBvc2l0aW9uLnBhZ2VZIDwgc3BhY2VCZWxvdykge1xuICAgICAgICAgICAgaXNBYm92ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWF4SGVpZ2h0ID0gKGlzQWJvdmUgPyBwb3NpdGlvbi5wYWdlWSA6IHNwYWNlQmVsb3cpIC0gTUFSR0lOICsgXCJweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IGlzQWJvdmUgPyBcIlwiIDogcG9zaXRpb24ucGFnZVkgKyByZW5kZXJlci5saW5lSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmJvdHRvbSA9IGlzQWJvdmUgPyB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3NpdGlvbi5wYWdlWSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IE1hdGgubWluKHBvc2l0aW9uLnBhZ2VYLCB3aW5kb3cuaW5uZXJXaWR0aCAtIGxhYmVsV2lkdGggLSBNQVJHSU4pICsgXCJweFwiO1xuICAgIH07XG4gICAgSG92ZXJUb29sdGlwLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAocmFuZ2UsIHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJTZXNzaW9uLnJlbW92ZU1hcmtlcih0aGlzLm1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kbWFya2VyU2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMubWFya2VyID0gc2Vzc2lvbiAmJiBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXCJhY2VfaGlnaGxpZ2h0LW1hcmtlclwiLCBcInRleHRcIik7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmdldEVsZW1lbnQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgJiYgKGUudHlwZSAhPSBcImtleWRvd25cIiB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiB0aGlzLiRlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWRkTWFya2VyKG51bGwpO1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuJHJlbW92ZUNsb3NlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcG9wdXBNYW5hZ2VyLnJlbW92ZVBvcHVwKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLiRyZWdpc3RlckNsb3NlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oaWRlLCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLmhpZGUsIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhpZGUsIHRydWUpO1xuICAgIH07XG4gICAgSG92ZXJUb29sdGlwLnByb3RvdHlwZS4kcmVtb3ZlQ2xvc2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhpZGUsIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuaGlkZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGlkZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLm9uTW91c2VPdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWUucmVsYXRlZFRhcmdldCB8fCB0aGlzLmdldEVsZW1lbnQoKS5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZSAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFlLnJlbGF0ZWRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWNlX2NvbnRlbnRcIikpXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBIb3ZlclRvb2x0aXA7XG59KFRvb2x0aXApKTtcbmV4cG9ydHMuSG92ZXJUb29sdGlwID0gSG92ZXJUb29sdGlwO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9kZWZhdWx0X2d1dHRlcl9oYW5kbGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL3Rvb2x0aXBcIixcImFjZS9jb25maWdcIixcImFjZS9saWIvbGFuZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIFRvb2x0aXAgPSByZXF1aXJlKFwiLi4vdG9vbHRpcFwiKS5Ub29sdGlwO1xudmFyIG5scyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIikubmxzO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG5mdW5jdGlvbiBHdXR0ZXJIYW5kbGVyKG1vdXNlSGFuZGxlcikge1xuICAgIHZhciBlZGl0b3IgPSBtb3VzZUhhbmRsZXIuZWRpdG9yO1xuICAgIHZhciBndXR0ZXIgPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyO1xuICAgIHZhciB0b29sdGlwID0gbmV3IEd1dHRlclRvb2x0aXAoZWRpdG9yKTtcbiAgICBtb3VzZUhhbmRsZXIuZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwiZ3V0dGVybW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZWRpdG9yLmlzRm9jdXNlZCgpIHx8IGUuZ2V0QnV0dG9uKCkgIT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGd1dHRlclJlZ2lvbiA9IGd1dHRlci5nZXRSZWdpb24oZSk7XG4gICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXCJmb2xkV2lkZ2V0c1wiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcm93ID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlc3Npb24uc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZS5nZXRTaGlmdEtleSgpKVxuICAgICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdFRvKHJvdywgMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGUuZG9tRXZlbnQuZGV0YWlsID09IDIpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShyb3cpO1xuICAgICAgICB9XG4gICAgICAgIG1vdXNlSGFuZGxlci5zZXRTdGF0ZShcInNlbGVjdEJ5TGluZXNcIik7XG4gICAgICAgIG1vdXNlSGFuZGxlci5jYXB0dXJlTW91c2UoZSk7XG4gICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgdmFyIHRvb2x0aXBUaW1lb3V0LCBtb3VzZUV2ZW50O1xuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgICAgICB2YXIgcm93ID0gbW91c2VFdmVudC5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICB2YXIgbWF4Um93ID0gZWRpdG9yLnNlc3Npb24uZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChyb3cgPT0gbWF4Um93KSB7XG4gICAgICAgICAgICB2YXIgc2NyZWVuUm93ID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcygwLCBtb3VzZUV2ZW50LnkpLnJvdztcbiAgICAgICAgICAgIHZhciBwb3MgPSBtb3VzZUV2ZW50LiRwb3M7XG4gICAgICAgICAgICBpZiAoc2NyZWVuUm93ID4gZWRpdG9yLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhwb3Mucm93LCBwb3MuY29sdW1uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwLnNob3dUb29sdGlwKHJvdyk7XG4gICAgICAgIGlmICghdG9vbHRpcC5pc09wZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNld2hlZWxcIiwgaGlkZVRvb2x0aXApO1xuICAgICAgICBpZiAobW91c2VIYW5kbGVyLiR0b29sdGlwRm9sbG93c01vdXNlKSB7XG4gICAgICAgICAgICBtb3ZlVG9vbHRpcChtb3VzZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBndXR0ZXJSb3cgPSBtb3VzZUV2ZW50LmdldEd1dHRlclJvdygpO1xuICAgICAgICAgICAgdmFyIGd1dHRlckNlbGwgPSBndXR0ZXIuJGxpbmVzLmdldChndXR0ZXJSb3cpO1xuICAgICAgICAgICAgaWYgKGd1dHRlckNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3V0dGVyRWxlbWVudCA9IGd1dHRlckNlbGwuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmFjZV9ndXR0ZXJfYW5ub3RhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGd1dHRlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdG9vbHRpcC5nZXRFbGVtZW50KCkuc3R5bGU7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IHJlY3QucmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gcmVjdC5ib3R0b20gKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3ZlVG9vbHRpcChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBUaW1lb3V0KVxuICAgICAgICAgICAgdG9vbHRpcFRpbWVvdXQgPSBjbGVhclRpbWVvdXQodG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICBpZiAodG9vbHRpcC5pc09wZW4pIHtcbiAgICAgICAgICAgIHRvb2x0aXAuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIGVkaXRvci5vZmYoXCJtb3VzZXdoZWVsXCIsIGhpZGVUb29sdGlwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlVG9vbHRpcChlKSB7XG4gICAgICAgIHRvb2x0aXAuc2V0UG9zaXRpb24oZS54LCBlLnkpO1xuICAgIH1cbiAgICBtb3VzZUhhbmRsZXIuZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwiZ3V0dGVybW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLmRvbUV2ZW50LnRhcmdldCB8fCBlLmRvbUV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgIGlmIChkb20uaGFzQ3NzQ2xhc3ModGFyZ2V0LCBcImFjZV9mb2xkLXdpZGdldFwiKSlcbiAgICAgICAgICAgIHJldHVybiBoaWRlVG9vbHRpcCgpO1xuICAgICAgICBpZiAodG9vbHRpcC5pc09wZW4gJiYgbW91c2VIYW5kbGVyLiR0b29sdGlwRm9sbG93c01vdXNlKVxuICAgICAgICAgICAgbW92ZVRvb2x0aXAoZSk7XG4gICAgICAgIG1vdXNlRXZlbnQgPSBlO1xuICAgICAgICBpZiAodG9vbHRpcFRpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0b29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobW91c2VFdmVudCAmJiAhbW91c2VIYW5kbGVyLmlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH0pO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyLCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIG1vdXNlRXZlbnQgPSBudWxsO1xuICAgICAgICBpZiAoIXRvb2x0aXAuaXNPcGVuIHx8IHRvb2x0aXBUaW1lb3V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH0sIGVkaXRvcik7XG4gICAgZWRpdG9yLm9uKFwiY2hhbmdlU2Vzc2lvblwiLCBoaWRlVG9vbHRpcCk7XG4gICAgZWRpdG9yLm9uKFwiaW5wdXRcIiwgaGlkZVRvb2x0aXApO1xufVxuZXhwb3J0cy5HdXR0ZXJIYW5kbGVyID0gR3V0dGVySGFuZGxlcjtcbnZhciBHdXR0ZXJUb29sdGlwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHdXR0ZXJUb29sdGlwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEd1dHRlclRvb2x0aXAoZWRpdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVkaXRvci5jb250YWluZXIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHdXR0ZXJUb29sdGlwLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICB4ICs9IDE1O1xuICAgICAgICB5ICs9IDE1O1xuICAgICAgICBpZiAoeCArIHdpZHRoID4gd2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIHggLT0gKHggKyB3aWR0aCkgLSB3aW5kb3dXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSArIGhlaWdodCA+IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgeSAtPSAyMCArIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRQb3NpdGlvbi5jYWxsKHRoaXMsIHgsIHkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEd1dHRlclRvb2x0aXAsIFwiYW5ub3RhdGlvbkxhYmVsc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBzaW5ndWxhcjogbmxzKFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC5lcnJvci5zaW5ndWxhclwiLCBcImVycm9yXCIpLFxuICAgICAgICAgICAgICAgICAgICBwbHVyYWw6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuZXJyb3IucGx1cmFsXCIsIFwiZXJyb3JzXCIpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmd1bGFyOiBubHMoXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLndhcm5pbmcuc2luZ3VsYXJcIiwgXCJ3YXJuaW5nXCIpLFxuICAgICAgICAgICAgICAgICAgICBwbHVyYWw6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwud2FybmluZy5wbHVyYWxcIiwgXCJ3YXJuaW5nc1wiKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBzaW5ndWxhcjogbmxzKFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC5pbmZvLnNpbmd1bGFyXCIsIFwiaW5mb3JtYXRpb24gbWVzc2FnZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsOiBubHMoXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmluZm8ucGx1cmFsXCIsIFwiaW5mb3JtYXRpb24gbWVzc2FnZXNcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGd1dHRlciA9IHRoaXMuZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllcjtcbiAgICAgICAgdmFyIGFubm90YXRpb25zSW5Sb3cgPSBndXR0ZXIuJGFubm90YXRpb25zW3Jvd107XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbnNJblJvdylcbiAgICAgICAgICAgIGFubm90YXRpb24gPSB7IGRpc3BsYXlUZXh0OiBBcnJheS5mcm9tKGFubm90YXRpb25zSW5Sb3cuZGlzcGxheVRleHQpLCB0eXBlOiBBcnJheS5mcm9tKGFubm90YXRpb25zSW5Sb3cudHlwZSkgfTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IHsgZGlzcGxheVRleHQ6IFtdLCB0eXBlOiBbXSB9O1xuICAgICAgICB2YXIgZm9sZCA9IGd1dHRlci5zZXNzaW9uLmdldEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIGlmIChmb2xkICYmIGd1dHRlci4kc2hvd0ZvbGRlZEFubm90YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnNJbkZvbGQgPSB7IGVycm9yOiBbXSwgd2FybmluZzogW10sIGluZm86IFtdIH07XG4gICAgICAgICAgICB2YXIgbW9zdFNldmVyZUFubm90YXRpb25JbkZvbGRUeXBlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJvdyArIDE7IGkgPD0gZm9sZC5lbmQucm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWd1dHRlci4kYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3V0dGVyLiRhbm5vdGF0aW9uc1tpXS50ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uVHlwZSA9IGd1dHRlci4kYW5ub3RhdGlvbnNbaV0udHlwZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnNJbkZvbGRbYW5ub3RhdGlvblR5cGVdLnB1c2goZ3V0dGVyLiRhbm5vdGF0aW9uc1tpXS50ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25UeXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RTZXZlcmVBbm5vdGF0aW9uSW5Gb2xkVHlwZSA9IFwiZXJyb3JfZm9sZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25UeXBlID09PSBcIndhcm5pbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9zdFNldmVyZUFubm90YXRpb25JbkZvbGRUeXBlID0gXCJ3YXJuaW5nX2ZvbGRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vc3RTZXZlcmVBbm5vdGF0aW9uSW5Gb2xkVHlwZSA9PT0gXCJlcnJvcl9mb2xkXCIgfHwgbW9zdFNldmVyZUFubm90YXRpb25JbkZvbGRUeXBlID09PSBcIndhcm5pbmdfZm9sZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bW1hcnlGb2xkZWRBbm5vdGF0aW9ucyA9IFwiXCIuY29uY2F0KEd1dHRlclRvb2x0aXAuYW5ub3RhdGlvbnNUb1N1bW1hcnlTdHJpbmcoYW5ub3RhdGlvbnNJbkZvbGQpLCBcIiBpbiBmb2xkZWQgY29kZS5cIik7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5kaXNwbGF5VGV4dC5wdXNoKHN1bW1hcnlGb2xkZWRBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi50eXBlLnB1c2gobW9zdFNldmVyZUFubm90YXRpb25JbkZvbGRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbi5kaXNwbGF5VGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9uTWVzc2FnZXMgPSB7IGVycm9yOiBbXSwgd2FybmluZzogW10sIGluZm86IFtdIH07XG4gICAgICAgIHZhciBpY29uQ2xhc3NOYW1lID0gZ3V0dGVyLiR1c2VTdmdHdXR0ZXJJY29ucyA/IFwiYWNlX2ljb25fc3ZnXCIgOiBcImFjZV9pY29uXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbi5kaXNwbGF5VGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmVFbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgdmFyIGljb25FbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgKF9hID0gaWNvbkVsZW1lbnQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIFtcImFjZV9cIi5jb25jYXQoYW5ub3RhdGlvbi50eXBlW2ldKSwgaWNvbkNsYXNzTmFtZV0pO1xuICAgICAgICAgICAgaWNvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlwiLmNvbmNhdChHdXR0ZXJUb29sdGlwLmFubm90YXRpb25MYWJlbHNbYW5ub3RhdGlvbi50eXBlW2ldLnJlcGxhY2UoXCJfZm9sZFwiLCBcIlwiKV0uc2luZ3VsYXIpKTtcbiAgICAgICAgICAgIGljb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgICAgICAgICBpY29uRWxlbWVudC5hcHBlbmRDaGlsZChkb20uY3JlYXRlVGV4dE5vZGUoXCIgXCIpKTtcbiAgICAgICAgICAgIGxpbmVFbGVtZW50LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgICAgIGxpbmVFbGVtZW50LmFwcGVuZENoaWxkKGRvbS5jcmVhdGVUZXh0Tm9kZShhbm5vdGF0aW9uLmRpc3BsYXlUZXh0W2ldKSk7XG4gICAgICAgICAgICBsaW5lRWxlbWVudC5hcHBlbmRDaGlsZChkb20uY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgICAgICAgIGFubm90YXRpb25NZXNzYWdlc1thbm5vdGF0aW9uLnR5cGVbaV0ucmVwbGFjZShcIl9mb2xkXCIsIFwiXCIpXS5wdXNoKGxpbmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9vbHRpcEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgICAgZG9tLnJlbW92ZUNoaWxkcmVuKHRvb2x0aXBFbGVtZW50KTtcbiAgICAgICAgYW5ub3RhdGlvbk1lc3NhZ2VzLmVycm9yLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiB0b29sdGlwRWxlbWVudC5hcHBlbmRDaGlsZChlbCk7IH0pO1xuICAgICAgICBhbm5vdGF0aW9uTWVzc2FnZXMud2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gdG9vbHRpcEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpOyB9KTtcbiAgICAgICAgYW5ub3RhdGlvbk1lc3NhZ2VzLmluZm8uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRvb2x0aXBFbGVtZW50LmFwcGVuZENoaWxkKGVsKTsgfSk7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXRUaGVtZSh0aGlzLmVkaXRvci5yZW5kZXJlci50aGVtZSk7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZShcImFjZV9ndXR0ZXItdG9vbHRpcFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuX3NpZ25hbChcInNob3dHdXR0ZXJUb29sdGlwXCIsIHRoaXMpO1xuICAgIH07XG4gICAgR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1saXZlXCIpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuX3NpZ25hbChcImhpZGVHdXR0ZXJUb29sdGlwXCIsIHRoaXMpO1xuICAgIH07XG4gICAgR3V0dGVyVG9vbHRpcC5hbm5vdGF0aW9uc1RvU3VtbWFyeVN0cmluZyA9IGZ1bmN0aW9uIChhbm5vdGF0aW9ucykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIHN1bW1hcnkgPSBbXTtcbiAgICAgICAgdmFyIGFubm90YXRpb25UeXBlcyA9IFsnZXJyb3InLCAnd2FybmluZycsICdpbmZvJ107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhbm5vdGF0aW9uVHlwZXNfMSA9IF9fdmFsdWVzKGFubm90YXRpb25UeXBlcyksIGFubm90YXRpb25UeXBlc18xXzEgPSBhbm5vdGF0aW9uVHlwZXNfMS5uZXh0KCk7ICFhbm5vdGF0aW9uVHlwZXNfMV8xLmRvbmU7IGFubm90YXRpb25UeXBlc18xXzEgPSBhbm5vdGF0aW9uVHlwZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uVHlwZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghYW5ub3RhdGlvbnNbYW5ub3RhdGlvblR5cGVdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gYW5ub3RhdGlvbnNbYW5ub3RhdGlvblR5cGVdLmxlbmd0aCA9PT0gMSA/IEd1dHRlclRvb2x0aXAuYW5ub3RhdGlvbkxhYmVsc1thbm5vdGF0aW9uVHlwZV0uc2luZ3VsYXIgOiBHdXR0ZXJUb29sdGlwLmFubm90YXRpb25MYWJlbHNbYW5ub3RhdGlvblR5cGVdLnBsdXJhbDtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5LnB1c2goXCJcIi5jb25jYXQoYW5ub3RhdGlvbnNbYW5ub3RhdGlvblR5cGVdLmxlbmd0aCwgXCIgXCIpLmNvbmNhdChsYWJlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvblR5cGVzXzFfMSAmJiAhYW5ub3RhdGlvblR5cGVzXzFfMS5kb25lICYmIChfYSA9IGFubm90YXRpb25UeXBlc18xLnJldHVybikpIF9hLmNhbGwoYW5ub3RhdGlvblR5cGVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1tYXJ5LmpvaW4oXCIsIFwiKTtcbiAgICB9O1xuICAgIHJldHVybiBHdXR0ZXJUb29sdGlwO1xufShUb29sdGlwKSk7XG5leHBvcnRzLkd1dHRlclRvb2x0aXAgPSBHdXR0ZXJUb29sdGlwO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9tb3VzZV9ldmVudFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIE1vdXNlRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW91c2VFdmVudChkb21FdmVudCwgZWRpdG9yKSB7IHRoaXMuc3BlZWQ7IHRoaXMud2hlZWxYOyB0aGlzLndoZWVsWTtcbiAgICAgICAgdGhpcy5kb21FdmVudCA9IGRvbUV2ZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy54ID0gdGhpcy5jbGllbnRYID0gZG9tRXZlbnQuY2xpZW50WDtcbiAgICAgICAgdGhpcy55ID0gdGhpcy5jbGllbnRZID0gZG9tRXZlbnQuY2xpZW50WTtcbiAgICAgICAgdGhpcy4kcG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy4kaW5TZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgTW91c2VFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24odGhpcy5kb21FdmVudCk7XG4gICAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCh0aGlzLmRvbUV2ZW50KTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLmdldERvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLiRwb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcG9zO1xuICAgICAgICB0aGlzLiRwb3MgPSB0aGlzLmVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyh0aGlzLmNsaWVudFgsIHRoaXMuY2xpZW50WSk7XG4gICAgICAgIHJldHVybiB0aGlzLiRwb3M7XG4gICAgfTtcbiAgICBNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXRHdXR0ZXJSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb2N1bWVudFJvdyA9IHRoaXMuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcbiAgICAgICAgdmFyIHNjcmVlblJvdyA9IHRoaXMuZWRpdG9yLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhkb2N1bWVudFJvdywgMCk7XG4gICAgICAgIHZhciBzY3JlZW5Ub3BSb3cgPSB0aGlzLmVkaXRvci5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Sb3codGhpcy5lZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLiRsaW5lcy5nZXQoMCkucm93LCAwKTtcbiAgICAgICAgcmV0dXJuIHNjcmVlblJvdyAtIHNjcmVlblRvcFJvdztcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLmluU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kaW5TZWxlY3Rpb24gIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5TZWxlY3Rpb247XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25SYW5nZS5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLiRpblNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuJGluU2VsZWN0aW9uID0gc2VsZWN0aW9uUmFuZ2UuY29udGFpbnMocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJGluU2VsZWN0aW9uO1xuICAgIH07XG4gICAgTW91c2VFdmVudC5wcm90b3R5cGUuZ2V0QnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuZ2V0QnV0dG9uKHRoaXMuZG9tRXZlbnQpO1xuICAgIH07XG4gICAgTW91c2VFdmVudC5wcm90b3R5cGUuZ2V0U2hpZnRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUV2ZW50LnNoaWZ0S2V5O1xuICAgIH07XG4gICAgTW91c2VFdmVudC5wcm90b3R5cGUuZ2V0QWNjZWxLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1c2VyYWdlbnQuaXNNYWMgPyB0aGlzLmRvbUV2ZW50Lm1ldGFLZXkgOiB0aGlzLmRvbUV2ZW50LmN0cmxLZXk7XG4gICAgfTtcbiAgICByZXR1cm4gTW91c2VFdmVudDtcbn0oKSk7XG5leHBvcnRzLk1vdXNlRXZlbnQgPSBNb3VzZUV2ZW50O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9kcmFnZHJvcF9oYW5kbGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIEFVVE9TQ1JPTExfREVMQVkgPSAyMDA7XG52YXIgU0NST0xMX0NVUlNPUl9ERUxBWSA9IDIwMDtcbnZhciBTQ1JPTExfQ1VSU09SX0hZU1RFUkVTSVMgPSA1O1xuZnVuY3Rpb24gRHJhZ2Ryb3BIYW5kbGVyKG1vdXNlSGFuZGxlcikge1xuICAgIHZhciBlZGl0b3IgPSBtb3VzZUhhbmRsZXIuZWRpdG9yO1xuICAgIHZhciBkcmFnSW1hZ2UgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkcmFnSW1hZ2Uuc3R5bGUuY3NzVGV4dCA9IFwidG9wOi0xMDBweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjIxNDc0ODM2NDc7b3BhY2l0eTowLjVcIjtcbiAgICBkcmFnSW1hZ2UudGV4dENvbnRlbnQgPSBcIlxceGEwXCI7XG4gICAgdmFyIGV4cG9ydHMgPSBbXCJkcmFnV2FpdFwiLCBcImRyYWdXYWl0RW5kXCIsIFwic3RhcnREcmFnXCIsIFwiZHJhZ1JlYWR5RW5kXCIsIFwib25Nb3VzZURyYWdcIl07XG4gICAgZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIG1vdXNlSGFuZGxlclt4XSA9IHRoaXNbeF07XG4gICAgfSwgdGhpcyk7XG4gICAgZWRpdG9yLm9uKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZURvd24uYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICB2YXIgbW91c2VUYXJnZXQgPSBlZGl0b3IuY29udGFpbmVyO1xuICAgIHZhciBkcmFnU2VsZWN0aW9uTWFya2VyLCB4LCB5O1xuICAgIHZhciB0aW1lcklkLCByYW5nZTtcbiAgICB2YXIgZHJhZ0N1cnNvciwgY291bnRlciA9IDA7XG4gICAgdmFyIGRyYWdPcGVyYXRpb247XG4gICAgdmFyIGlzSW50ZXJuYWw7XG4gICAgdmFyIGF1dG9TY3JvbGxTdGFydFRpbWU7XG4gICAgdmFyIGN1cnNvck1vdmVkVGltZTtcbiAgICB2YXIgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQ7XG4gICAgdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbERyYWcgfHwgIW1vdXNlVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdGFydFNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FwdHVyZU1vdXNlKGUpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBlZGl0b3IuZ2V0UmVhZE9ubHkoKSA/IFwiY29weVwiIDogXCJjb3B5TW92ZVwiO1xuICAgICAgICBlZGl0b3IuY29udGFpbmVyLmFwcGVuZENoaWxkKGRyYWdJbWFnZSk7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnSW1hZ2UsIDAsIDApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIucmVtb3ZlQ2hpbGQoZHJhZ0ltYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGVkaXRvci5zZXNzaW9uLmdldFRleHRSYW5nZSgpKTtcbiAgICAgICAgaXNJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJkcmFnXCIpO1xuICAgIH07XG4gICAgdGhpcy5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBtb3VzZVRhcmdldC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgaXNJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKG51bGwpO1xuICAgICAgICBpZiAoIWVkaXRvci5nZXRSZWFkT25seSgpKSB7XG4gICAgICAgICAgICB2YXIgZHJvcEVmZmVjdCA9IGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q7XG4gICAgICAgICAgICBpZiAoIWRyYWdPcGVyYXRpb24gJiYgZHJvcEVmZmVjdCA9PSBcIm1vdmVcIilcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICAgICAgZWRpdG9yLiRyZXNldEN1cnNvclN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3IudW5zZXRTdHlsZShcImFjZV9kcmFnZ2luZ1wiKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyZXIuc2V0Q3Vyc29yU3R5bGUoXCJcIik7XG4gICAgfTtcbiAgICB0aGlzLm9uRHJhZ0VudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGVkaXRvci5nZXRSZWFkT25seSgpIHx8ICFjYW5BY2NlcHQoZS5kYXRhVHJhbnNmZXIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB4ID0gZS5jbGllbnRYO1xuICAgICAgICB5ID0gZS5jbGllbnRZO1xuICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb25NYXJrZXIpXG4gICAgICAgICAgICBhZGREcmFnTWFya2VyKCk7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGRyYWdPcGVyYXRpb24gPSBnZXREcm9wRWZmZWN0KGUpO1xuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uRHJhZ092ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZWRpdG9yLmdldFJlYWRPbmx5KCkgfHwgIWNhbkFjY2VwdChlLmRhdGFUcmFuc2ZlcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHggPSBlLmNsaWVudFg7XG4gICAgICAgIHkgPSBlLmNsaWVudFk7XG4gICAgICAgIGlmICghZHJhZ1NlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgICAgYWRkRHJhZ01hcmtlcigpO1xuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlTW92ZVRpbWVyICE9PSBudWxsKVxuICAgICAgICAgICAgb25Nb3VzZU1vdmVUaW1lciA9IG51bGw7XG4gICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBkcmFnT3BlcmF0aW9uID0gZ2V0RHJvcEVmZmVjdChlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgIH07XG4gICAgdGhpcy5vbkRyYWdMZWF2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgaWYgKGNvdW50ZXIgPD0gMCAmJiBkcmFnU2VsZWN0aW9uTWFya2VyKSB7XG4gICAgICAgICAgICBjbGVhckRyYWdNYXJrZXIoKTtcbiAgICAgICAgICAgIGRyYWdPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uRHJvcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZHJhZ0N1cnNvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICBpZiAoaXNJbnRlcm5hbCkge1xuICAgICAgICAgICAgc3dpdGNoIChkcmFnT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbnRhaW5zKGRyYWdDdXJzb3Iucm93LCBkcmFnQ3Vyc29yLmNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkcmFnQ3Vyc29yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZHJhZ0N1cnNvclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZWRpdG9yLm1vdmVUZXh0KHJhbmdlLCBkcmFnQ3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29weVwiOlxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGVkaXRvci5tb3ZlVGV4dChyYW5nZSwgZHJhZ0N1cnNvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRyb3BEYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ1RleHQnKTtcbiAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkcmFnQ3Vyc29yLFxuICAgICAgICAgICAgICAgIGVuZDogZWRpdG9yLnNlc3Npb24uaW5zZXJ0KGRyYWdDdXJzb3IsIGRyb3BEYXRhKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgZHJhZ09wZXJhdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJEcmFnTWFya2VyKCk7XG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICB9O1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcImRyYWdzdGFydFwiLCB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQobW91c2VIYW5kbGVyKSwgZWRpdG9yKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJkcmFnZW5kXCIsIHRoaXMub25EcmFnRW5kLmJpbmQobW91c2VIYW5kbGVyKSwgZWRpdG9yKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJkcmFnZW50ZXJcIiwgdGhpcy5vbkRyYWdFbnRlci5iaW5kKG1vdXNlSGFuZGxlciksIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiZHJhZ292ZXJcIiwgdGhpcy5vbkRyYWdPdmVyLmJpbmQobW91c2VIYW5kbGVyKSwgZWRpdG9yKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJkcmFnbGVhdmVcIiwgdGhpcy5vbkRyYWdMZWF2ZS5iaW5kKG1vdXNlSGFuZGxlciksIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiZHJvcFwiLCB0aGlzLm9uRHJvcC5iaW5kKG1vdXNlSGFuZGxlciksIGVkaXRvcik7XG4gICAgZnVuY3Rpb24gc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoY3Vyc29yLCBwcmV2Q3Vyc29yKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgdk1vdmVtZW50ID0gIXByZXZDdXJzb3IgfHwgY3Vyc29yLnJvdyAhPSBwcmV2Q3Vyc29yLnJvdztcbiAgICAgICAgdmFyIGhNb3ZlbWVudCA9ICFwcmV2Q3Vyc29yIHx8IGN1cnNvci5jb2x1bW4gIT0gcHJldkN1cnNvci5jb2x1bW47XG4gICAgICAgIGlmICghY3Vyc29yTW92ZWRUaW1lIHx8IHZNb3ZlbWVudCB8fCBoTW92ZW1lbnQpIHtcbiAgICAgICAgICAgIGVkaXRvci5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICAgICAgY3Vyc29yTW92ZWRUaW1lID0gbm93O1xuICAgICAgICAgICAgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZShjdXJzb3JQb2ludE9uQ2FyZXRNb3ZlZC54LCBjdXJzb3JQb2ludE9uQ2FyZXRNb3ZlZC55LCB4LCB5KTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IFNDUk9MTF9DVVJTT1JfSFlTVEVSRVNJUykge1xuICAgICAgICAgICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub3cgLSBjdXJzb3JNb3ZlZFRpbWUgPj0gU0NST0xMX0NVUlNPUl9ERUxBWSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXV0b1Njcm9sbChjdXJzb3IsIHByZXZDdXJzb3IpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZWRpdG9yLnJlbmRlcmVyLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBjaGFyYWN0ZXJXaWR0aCA9IGVkaXRvci5yZW5kZXJlci5sYXllckNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGVkaXRvclJlY3QgPSBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXRzID0ge1xuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHggLSBlZGl0b3JSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGVkaXRvclJlY3QucmlnaHQgLSB4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgIHRvcDogeSAtIGVkaXRvclJlY3QudG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogZWRpdG9yUmVjdC5ib3R0b20gLSB5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZWFyZXN0WE9mZnNldCA9IE1hdGgubWluKG9mZnNldHMueC5sZWZ0LCBvZmZzZXRzLngucmlnaHQpO1xuICAgICAgICB2YXIgbmVhcmVzdFlPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXRzLnkudG9wLCBvZmZzZXRzLnkuYm90dG9tKTtcbiAgICAgICAgdmFyIHNjcm9sbEN1cnNvciA9IHsgcm93OiBjdXJzb3Iucm93LCBjb2x1bW46IGN1cnNvci5jb2x1bW4gfTtcbiAgICAgICAgaWYgKG5lYXJlc3RYT2Zmc2V0IC8gY2hhcmFjdGVyV2lkdGggPD0gMikge1xuICAgICAgICAgICAgc2Nyb2xsQ3Vyc29yLmNvbHVtbiArPSAob2Zmc2V0cy54LmxlZnQgPCBvZmZzZXRzLngucmlnaHQgPyAtMyA6ICsyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVhcmVzdFlPZmZzZXQgLyBsaW5lSGVpZ2h0IDw9IDEpIHtcbiAgICAgICAgICAgIHNjcm9sbEN1cnNvci5yb3cgKz0gKG9mZnNldHMueS50b3AgPCBvZmZzZXRzLnkuYm90dG9tID8gLTEgOiArMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZTY3JvbGwgPSBjdXJzb3Iucm93ICE9IHNjcm9sbEN1cnNvci5yb3c7XG4gICAgICAgIHZhciBoU2Nyb2xsID0gY3Vyc29yLmNvbHVtbiAhPSBzY3JvbGxDdXJzb3IuY29sdW1uO1xuICAgICAgICB2YXIgdk1vdmVtZW50ID0gIXByZXZDdXJzb3IgfHwgY3Vyc29yLnJvdyAhPSBwcmV2Q3Vyc29yLnJvdztcbiAgICAgICAgaWYgKHZTY3JvbGwgfHwgKGhTY3JvbGwgJiYgIXZNb3ZlbWVudCkpIHtcbiAgICAgICAgICAgIGlmICghYXV0b1Njcm9sbFN0YXJ0VGltZSlcbiAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsU3RhcnRUaW1lID0gbm93O1xuICAgICAgICAgICAgZWxzZSBpZiAobm93IC0gYXV0b1Njcm9sbFN0YXJ0VGltZSA+PSBBVVRPU0NST0xMX0RFTEFZKVxuICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhzY3JvbGxDdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXV0b1Njcm9sbFN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25EcmFnSW50ZXJ2YWwoKSB7XG4gICAgICAgIHZhciBwcmV2Q3Vyc29yID0gZHJhZ0N1cnNvcjtcbiAgICAgICAgZHJhZ0N1cnNvciA9IGVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyh4LCB5KTtcbiAgICAgICAgc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoZHJhZ0N1cnNvciwgcHJldkN1cnNvcik7XG4gICAgICAgIGF1dG9TY3JvbGwoZHJhZ0N1cnNvciwgcHJldkN1cnNvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZERyYWdNYXJrZXIoKSB7XG4gICAgICAgIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcbiAgICAgICAgZHJhZ1NlbGVjdGlvbk1hcmtlciA9IGVkaXRvci5zZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXCJhY2Vfc2VsZWN0aW9uXCIsIGVkaXRvci5nZXRTZWxlY3Rpb25TdHlsZSgpKTtcbiAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNGb2N1c2VkKCkpXG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyLnNldEJsaW5raW5nKGZhbHNlKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgb25EcmFnSW50ZXJ2YWwoKTtcbiAgICAgICAgdGltZXJJZCA9IHNldEludGVydmFsKG9uRHJhZ0ludGVydmFsLCAyMCk7XG4gICAgICAgIGNvdW50ZXIgPSAwO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckRyYWdNYXJrZXIoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgIGVkaXRvci5zZXNzaW9uLnJlbW92ZU1hcmtlcihkcmFnU2VsZWN0aW9uTWFya2VyKTtcbiAgICAgICAgZHJhZ1NlbGVjdGlvbk1hcmtlciA9IG51bGw7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoZWRpdG9yLmlzRm9jdXNlZCgpICYmICFpc0ludGVybmFsKVxuICAgICAgICAgICAgZWRpdG9yLiRyZXNldEN1cnNvclN0eWxlKCk7XG4gICAgICAgIHJhbmdlID0gbnVsbDtcbiAgICAgICAgZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgICAgIGNvdW50ZXIgPSAwO1xuICAgICAgICBhdXRvU2Nyb2xsU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgY3Vyc29yTW92ZWRUaW1lID0gbnVsbDtcbiAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG4gICAgdmFyIG9uTW91c2VNb3ZlVGltZXIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge1xuICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uTW91c2VNb3ZlVGltZXIgIT0gbnVsbCAmJiBkcmFnU2VsZWN0aW9uTWFya2VyKVxuICAgICAgICAgICAgICAgICAgICBjbGVhckRyYWdNYXJrZXIoKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5BY2NlcHQoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHZhciB0eXBlcyA9IGRhdGFUcmFuc2Zlci50eXBlcztcbiAgICAgICAgcmV0dXJuICF0eXBlcyB8fCBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKHR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT0gJ3RleHQvcGxhaW4nIHx8IHR5cGUgPT0gJ1RleHQnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RHJvcEVmZmVjdChlKSB7XG4gICAgICAgIHZhciBjb3B5QWxsb3dlZCA9IFsnY29weScsICdjb3B5bW92ZScsICdhbGwnLCAndW5pbml0aWFsaXplZCddO1xuICAgICAgICB2YXIgbW92ZUFsbG93ZWQgPSBbJ21vdmUnLCAnY29weW1vdmUnLCAnbGlua21vdmUnLCAnYWxsJywgJ3VuaW5pdGlhbGl6ZWQnXTtcbiAgICAgICAgdmFyIGNvcHlNb2RpZmllclN0YXRlID0gdXNlcmFnZW50LmlzTWFjID8gZS5hbHRLZXkgOiBlLmN0cmxLZXk7XG4gICAgICAgIHZhciBlZmZlY3RBbGxvd2VkID0gXCJ1bmluaXRpYWxpemVkXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlZmZlY3RBbGxvd2VkID0gZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgdmFyIGRyb3BFZmZlY3QgPSBcIm5vbmVcIjtcbiAgICAgICAgaWYgKGNvcHlNb2RpZmllclN0YXRlICYmIGNvcHlBbGxvd2VkLmluZGV4T2YoZWZmZWN0QWxsb3dlZCkgPj0gMClcbiAgICAgICAgICAgIGRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgICAgZWxzZSBpZiAobW92ZUFsbG93ZWQuaW5kZXhPZihlZmZlY3RBbGxvd2VkKSA+PSAwKVxuICAgICAgICAgICAgZHJvcEVmZmVjdCA9IFwibW92ZVwiO1xuICAgICAgICBlbHNlIGlmIChjb3B5QWxsb3dlZC5pbmRleE9mKGVmZmVjdEFsbG93ZWQpID49IDApXG4gICAgICAgICAgICBkcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgIHJldHVybiBkcm9wRWZmZWN0O1xuICAgIH1cbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kcmFnV2FpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gRGF0ZS5ub3coKSAtIHRoaXMubW91c2Vkb3duRXZlbnQudGltZTtcbiAgICAgICAgaWYgKGludGVydmFsID4gdGhpcy5lZGl0b3IuZ2V0RHJhZ0RlbGF5KCkpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZygpO1xuICAgIH07XG4gICAgdGhpcy5kcmFnV2FpdEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZWRpdG9yLmNvbnRhaW5lcjtcbiAgICAgICAgdGFyZ2V0LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0KHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpKTtcbiAgICAgICAgdGhpcy5zZWxlY3RFbmQoKTtcbiAgICB9O1xuICAgIHRoaXMuZHJhZ1JlYWR5RW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IuJHJlc2V0Q3Vyc29yU3R5bGUoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IudW5zZXRTdHlsZShcImFjZV9kcmFnZ2luZ1wiKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyZXIuc2V0Q3Vyc29yU3R5bGUoXCJcIik7XG4gICAgICAgIHRoaXMuZHJhZ1dhaXRFbmQoKTtcbiAgICB9O1xuICAgIHRoaXMuc3RhcnREcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbERyYWcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZWRpdG9yLmNvbnRhaW5lcjtcbiAgICAgICAgdGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXIuc2V0QmxpbmtpbmcoZmFsc2UpO1xuICAgICAgICBlZGl0b3Iuc2V0U3R5bGUoXCJhY2VfZHJhZ2dpbmdcIik7XG4gICAgICAgIHZhciBjdXJzb3JTdHlsZSA9IHVzZXJhZ2VudC5pc1dpbiA/IFwiZGVmYXVsdFwiIDogXCJtb3ZlXCI7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJkcmFnUmVhZHlcIik7XG4gICAgfTtcbiAgICB0aGlzLm9uTW91c2VEcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZWRpdG9yLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0lFICYmIHRoaXMuc3RhdGUgPT0gXCJkcmFnUmVhZHlcIikge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKHRoaXMubW91c2Vkb3duRXZlbnQueCwgdGhpcy5tb3VzZWRvd25FdmVudC55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAzKVxuICAgICAgICAgICAgICAgIHRhcmdldC5kcmFnRHJvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImRyYWdXYWl0XCIpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZSh0aGlzLm1vdXNlZG93bkV2ZW50LngsIHRoaXMubW91c2Vkb3duRXZlbnQueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0KHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy4kZHJhZ0VuYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQgPSBlO1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBpblNlbGVjdGlvbiA9IGUuaW5TZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGUuZ2V0QnV0dG9uKCk7XG4gICAgICAgIHZhciBjbGlja0NvdW50ID0gZS5kb21FdmVudC5kZXRhaWwgfHwgMTtcbiAgICAgICAgaWYgKGNsaWNrQ291bnQgPT09IDEgJiYgYnV0dG9uID09PSAwICYmIGluU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZS5lZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGUgJiYgKGUuZ2V0QWNjZWxLZXkoKSB8fCBlLmdldFNoaWZ0S2V5KCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLmRvbUV2ZW50LnRhcmdldCB8fCBlLmRvbUV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoXCJ1bnNlbGVjdGFibGVcIiBpbiBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC51bnNlbGVjdGFibGUgPSBcIm9uXCI7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmdldERyYWdEZWxheSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJhZ2VudC5pc1dlYktpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VUYXJnZXQgPSBlZGl0b3IuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKFwiZHJhZ1dhaXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZSwgdGhpcy5vbk1vdXNlRHJhZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGUuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufSkuY2FsbChEcmFnZHJvcEhhbmRsZXIucHJvdG90eXBlKTtcbmZ1bmN0aW9uIGNhbGNEaXN0YW5jZShheCwgYXksIGJ4LCBieSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYnggLSBheCwgMikgKyBNYXRoLnBvdyhieSAtIGF5LCAyKSk7XG59XG5leHBvcnRzLkRyYWdkcm9wSGFuZGxlciA9IERyYWdkcm9wSGFuZGxlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvdG91Y2hfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL21vdXNlL21vdXNlX2V2ZW50XCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vbW91c2VfZXZlbnRcIikuTW91c2VFdmVudDtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG5leHBvcnRzLmFkZFRvdWNoTGlzdGVuZXJzID0gZnVuY3Rpb24gKGVsLCBlZGl0b3IpIHtcbiAgICB2YXIgbW9kZSA9IFwic2Nyb2xsXCI7XG4gICAgdmFyIHN0YXJ0WDtcbiAgICB2YXIgc3RhcnRZO1xuICAgIHZhciB0b3VjaFN0YXJ0VDtcbiAgICB2YXIgbGFzdFQ7XG4gICAgdmFyIGxvbmdUb3VjaFRpbWVyO1xuICAgIHZhciBhbmltYXRpb25UaW1lcjtcbiAgICB2YXIgYW5pbWF0aW9uU3RlcHMgPSAwO1xuICAgIHZhciBwb3M7XG4gICAgdmFyIGNsaWNrQ291bnQgPSAwO1xuICAgIHZhciB2WCA9IDA7XG4gICAgdmFyIHZZID0gMDtcbiAgICB2YXIgcHJlc3NlZDtcbiAgICB2YXIgY29udGV4dE1lbnU7XG4gICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dE1lbnUoKSB7XG4gICAgICAgIHZhciBjbGlwYm9hcmQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkO1xuICAgICAgICB2YXIgaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHZhciB1cGRhdGVNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gZWRpdG9yLmdldENvcHlUZXh0KCk7XG4gICAgICAgICAgICB2YXIgaGFzVW5kbyA9IGVkaXRvci5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuaGFzVW5kbygpO1xuICAgICAgICAgICAgY29udGV4dE1lbnUucmVwbGFjZUNoaWxkKGRvbS5idWlsZERvbShpc09wZW4gPyBbXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgIXNlbGVjdGVkICYmIGNhbkV4ZWN1dGVDb21tYW5kKFwic2VsZWN0YWxsXCIpICYmIFtcInNwYW5cIiwgeyBjbGFzczogXCJhY2VfbW9iaWxlLWJ1dHRvblwiLCBhY3Rpb246IFwic2VsZWN0YWxsXCIgfSwgXCJTZWxlY3QgQWxsXCJdLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkICYmIGNhbkV4ZWN1dGVDb21tYW5kKFwiY29weVwiKSAmJiBbXCJzcGFuXCIsIHsgY2xhc3M6IFwiYWNlX21vYmlsZS1idXR0b25cIiwgYWN0aW9uOiBcImNvcHlcIiB9LCBcIkNvcHlcIl0sXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgJiYgY2FuRXhlY3V0ZUNvbW1hbmQoXCJjdXRcIikgJiYgW1wic3BhblwiLCB7IGNsYXNzOiBcImFjZV9tb2JpbGUtYnV0dG9uXCIsIGFjdGlvbjogXCJjdXRcIiB9LCBcIkN1dFwiXSxcbiAgICAgICAgICAgICAgICBjbGlwYm9hcmQgJiYgY2FuRXhlY3V0ZUNvbW1hbmQoXCJwYXN0ZVwiKSAmJiBbXCJzcGFuXCIsIHsgY2xhc3M6IFwiYWNlX21vYmlsZS1idXR0b25cIiwgYWN0aW9uOiBcInBhc3RlXCIgfSwgXCJQYXN0ZVwiXSxcbiAgICAgICAgICAgICAgICBoYXNVbmRvICYmIGNhbkV4ZWN1dGVDb21tYW5kKFwidW5kb1wiKSAmJiBbXCJzcGFuXCIsIHsgY2xhc3M6IFwiYWNlX21vYmlsZS1idXR0b25cIiwgYWN0aW9uOiBcInVuZG9cIiB9LCBcIlVuZG9cIl0sXG4gICAgICAgICAgICAgICAgY2FuRXhlY3V0ZUNvbW1hbmQoXCJmaW5kXCIpICYmIFtcInNwYW5cIiwgeyBjbGFzczogXCJhY2VfbW9iaWxlLWJ1dHRvblwiLCBhY3Rpb246IFwiZmluZFwiIH0sIFwiRmluZFwiXSxcbiAgICAgICAgICAgICAgICBjYW5FeGVjdXRlQ29tbWFuZChcIm9wZW5Db21tYW5kUGFsZXR0ZVwiKSAmJiBbXCJzcGFuXCIsIHsgY2xhc3M6IFwiYWNlX21vYmlsZS1idXR0b25cIiwgYWN0aW9uOiBcIm9wZW5Db21tYW5kUGFsZXR0ZVwiIH0sIFwiUGFsZXR0ZVwiXVxuICAgICAgICAgICAgXSA6IFtcInNwYW5cIl0pLCBjb250ZXh0TWVudS5maXJzdENoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNhbkV4ZWN1dGVDb21tYW5kID0gZnVuY3Rpb24gKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBjbWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuY2FuRXhlY3V0ZShjbWQsIGVkaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGVDbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBcIm1vcmVcIiB8fCAhaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgaXNPcGVuID0gIWlzT3BlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlTWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBcInBhc3RlXCIpIHtcbiAgICAgICAgICAgICAgICBjbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChhY3Rpb24sIHRleHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBcImN1dFwiIHx8IGFjdGlvbiA9PSBcImNvcHlcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcGJvYXJkKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcGJvYXJkLndyaXRlVGV4dChlZGl0b3IuZ2V0Q29weVRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0TWVudS5maXJzdENoaWxkLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiAhPSBcIm9wZW5Db21tYW5kUGFsZXR0ZVwiKVxuICAgICAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBjb250ZXh0TWVudSA9IGRvbS5idWlsZERvbShbXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJhY2VfbW9iaWxlLW1lbnVcIixcbiAgICAgICAgICAgICAgICBvbnRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBcIm1lbnVcIjtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IudGV4dElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbnRvdWNoZW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNsaWNrKGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25jbGljazogaGFuZGxlQ2xpY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXCJzcGFuXCJdLFxuICAgICAgICAgICAgW1wic3BhblwiLCB7IGNsYXNzOiBcImFjZV9tb2JpbGUtYnV0dG9uXCIsIGFjdGlvbjogXCJtb3JlXCIgfSwgXCIuLi5cIl1cbiAgICAgICAgXSwgZWRpdG9yLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3dDb250ZXh0TWVudSgpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuZ2V0T3B0aW9uKFwiZW5hYmxlTW9iaWxlTWVudVwiKSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICAgICAgaGlkZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZXh0TWVudSlcbiAgICAgICAgICAgIGNyZWF0ZUNvbnRleHRNZW51KCk7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3Iuc2VsZWN0aW9uLmN1cnNvcjtcbiAgICAgICAgdmFyIHBhZ2VQb3MgPSBlZGl0b3IucmVuZGVyZXIudGV4dFRvU2NyZWVuQ29vcmRpbmF0ZXMoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gZWRpdG9yLnJlbmRlcmVyLnRleHRUb1NjcmVlbkNvb3JkaW5hdGVzKDAsIDApLnBhZ2VYO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGVkaXRvci5yZW5kZXJlci5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgcmVjdCA9IGVkaXRvci5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnRleHRNZW51LnN0eWxlLnRvcCA9IHBhZ2VQb3MucGFnZVkgLSByZWN0LnRvcCAtIDMgKyBcInB4XCI7XG4gICAgICAgIGlmIChwYWdlUG9zLnBhZ2VYIC0gcmVjdC5sZWZ0IDwgcmVjdC53aWR0aCAtIDcwKSB7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnRleHRNZW51LnN0eWxlLnJpZ2h0ID0gXCIxMHB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5zdHlsZS5sZWZ0ID0gbGVmdE9mZnNldCArIHNjcm9sbExlZnQgLSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dE1lbnUuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIGNvbnRleHRNZW51LmZpcnN0Q2hpbGQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBlZGl0b3Iub24oXCJpbnB1dFwiLCBoaWRlQ29udGV4dE1lbnUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlQ29udGV4dE1lbnUoZSkge1xuICAgICAgICBpZiAoY29udGV4dE1lbnUpXG4gICAgICAgICAgICBjb250ZXh0TWVudS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGVkaXRvci5vZmYoXCJpbnB1dFwiLCBoaWRlQ29udGV4dE1lbnUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVMb25nVGFwKCkge1xuICAgICAgICBsb25nVG91Y2hUaW1lciA9IG51bGw7XG4gICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hUaW1lcik7XG4gICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIGluU2VsZWN0aW9uID0gcmFuZ2UuY29udGFpbnMocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkgfHwgIWluU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlID0gXCJ3YWl0XCI7XG4gICAgICAgIHNob3dDb250ZXh0TWVudSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb1NlbGVjdGlvbk1vZGUoKSB7XG4gICAgICAgIGxvbmdUb3VjaFRpbWVyID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxvbmdUb3VjaFRpbWVyKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBjbGlja0NvdW50ID49IDJcbiAgICAgICAgICAgID8gZWRpdG9yLnNlbGVjdGlvbi5nZXRMaW5lUmFuZ2UocG9zLnJvdylcbiAgICAgICAgICAgIDogZWRpdG9yLnNlc3Npb24uZ2V0QnJhY2tldFJhbmdlKHBvcyk7XG4gICAgICAgIGlmIChyYW5nZSAmJiAhcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0V29yZCgpO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgPSBcIndhaXRcIjtcbiAgICB9XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFwcmVzc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSBlZGl0b3IudGV4dElucHV0LmdldEVsZW1lbnQoKTtcbiAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcbiAgICB9LCBlZGl0b3IpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKGVsLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIGlmIChsb25nVG91Y2hUaW1lciB8fCB0b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hUaW1lcik7XG4gICAgICAgICAgICBsb25nVG91Y2hUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB0b3VjaFN0YXJ0VCA9IC0xO1xuICAgICAgICAgICAgbW9kZSA9IFwiem9vbVwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXNzZWQgPSBlZGl0b3IuJG1vdXNlSGFuZGxlci5pc01vdXNlUHJlc3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBoID0gZWRpdG9yLnJlbmRlcmVyLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciB3ID0gZWRpdG9yLnJlbmRlcmVyLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciB0ID0gZS50aW1lU3RhbXA7XG4gICAgICAgIGxhc3RUID0gdDtcbiAgICAgICAgdmFyIHRvdWNoT2JqID0gdG91Y2hlc1swXTtcbiAgICAgICAgdmFyIHggPSB0b3VjaE9iai5jbGllbnRYO1xuICAgICAgICB2YXIgeSA9IHRvdWNoT2JqLmNsaWVudFk7XG4gICAgICAgIGlmIChNYXRoLmFicyhzdGFydFggLSB4KSArIE1hdGguYWJzKHN0YXJ0WSAtIHkpID4gaClcbiAgICAgICAgICAgIHRvdWNoU3RhcnRUID0gLTE7XG4gICAgICAgIHN0YXJ0WCA9IGUuY2xpZW50WCA9IHg7XG4gICAgICAgIHN0YXJ0WSA9IGUuY2xpZW50WSA9IHk7XG4gICAgICAgIHZYID0gdlkgPSAwO1xuICAgICAgICB2YXIgZXYgPSBuZXcgTW91c2VFdmVudChlLCBlZGl0b3IpO1xuICAgICAgICBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0IC0gdG91Y2hTdGFydFQgPCA1MDAgJiYgdG91Y2hlcy5sZW5ndGggPT0gMSAmJiAhYW5pbWF0aW9uU3RlcHMpIHtcbiAgICAgICAgICAgIGNsaWNrQ291bnQrKztcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuYnV0dG9uID0gMDtcbiAgICAgICAgICAgIHN3aXRjaFRvU2VsZWN0aW9uTW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLnNlbGVjdGlvbi5jdXJzb3I7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkgPyBjdXJzb3IgOiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgIHZhciBjdXJzb3JQb3MgPSBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oY3Vyc29yLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBhbmNob3JQb3MgPSBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oYW5jaG9yLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIG9mZnNldFRvcCA9IGVkaXRvci5yZW5kZXJlci5sYXllckNvbmZpZy5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGVkaXRvci5yZW5kZXJlci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdmFyIHdlaWdodGVkRGlzdGFuY2UgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHggPSB4IC8gdztcbiAgICAgICAgICAgICAgICB5ID0geSAvIGggLSAwLjc1O1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlLmNsaWVudFggPCByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgICAgICBtb2RlID0gXCJ6b29tXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpZmYxID0gd2VpZ2h0ZWREaXN0YW5jZShlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjdXJzb3JQb3MubGVmdCArIG9mZnNldExlZnQsIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY3Vyc29yUG9zLnRvcCArIG9mZnNldFRvcCk7XG4gICAgICAgICAgICB2YXIgZGlmZjIgPSB3ZWlnaHRlZERpc3RhbmNlKGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGFuY2hvclBvcy5sZWZ0ICsgb2Zmc2V0TGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBhbmNob3JQb3MudG9wICsgb2Zmc2V0VG9wKTtcbiAgICAgICAgICAgIGlmIChkaWZmMSA8IDMuNSAmJiBkaWZmMiA8IDMuNSlcbiAgICAgICAgICAgICAgICBtb2RlID0gZGlmZjEgPiBkaWZmMiA/IFwiY3Vyc29yXCIgOiBcImFuY2hvclwiO1xuICAgICAgICAgICAgaWYgKGRpZmYyIDwgMy41KVxuICAgICAgICAgICAgICAgIG1vZGUgPSBcImFuY2hvclwiO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGlmZjEgPCAzLjUpXG4gICAgICAgICAgICAgICAgbW9kZSA9IFwiY3Vyc29yXCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbW9kZSA9IFwic2Nyb2xsXCI7XG4gICAgICAgICAgICBsb25nVG91Y2hUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlTG9uZ1RhcCwgNDUwKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaFN0YXJ0VCA9IHQ7XG4gICAgfSwgZWRpdG9yKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihlbCwgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBwcmVzc2VkID0gZWRpdG9yLiRtb3VzZUhhbmRsZXIuaXNNb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVyKVxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhbmltYXRpb25UaW1lcik7XG4gICAgICAgIGlmIChtb2RlID09IFwiem9vbVwiKSB7XG4gICAgICAgICAgICBtb2RlID0gXCJcIjtcbiAgICAgICAgICAgIGFuaW1hdGlvblN0ZXBzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb25nVG91Y2hUaW1lcikge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgYW5pbWF0aW9uU3RlcHMgPSAwO1xuICAgICAgICAgICAgc2hvd0NvbnRleHRNZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgICAgICBoaWRlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNob3dDb250ZXh0TWVudSgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hUaW1lcik7XG4gICAgICAgIGxvbmdUb3VjaFRpbWVyID0gbnVsbDtcbiAgICB9LCBlZGl0b3IpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKGVsLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAobG9uZ1RvdWNoVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hUaW1lcik7XG4gICAgICAgICAgICBsb25nVG91Y2hUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA+IDEgfHwgbW9kZSA9PSBcInpvb21cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHRvdWNoT2JqID0gdG91Y2hlc1swXTtcbiAgICAgICAgdmFyIHdoZWVsWCA9IHN0YXJ0WCAtIHRvdWNoT2JqLmNsaWVudFg7XG4gICAgICAgIHZhciB3aGVlbFkgPSBzdGFydFkgLSB0b3VjaE9iai5jbGllbnRZO1xuICAgICAgICBpZiAobW9kZSA9PSBcIndhaXRcIikge1xuICAgICAgICAgICAgaWYgKHdoZWVsWCAqIHdoZWVsWCArIHdoZWVsWSAqIHdoZWVsWSA+IDQpXG4gICAgICAgICAgICAgICAgbW9kZSA9IFwiY3Vyc29yXCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFggPSB0b3VjaE9iai5jbGllbnRYO1xuICAgICAgICBzdGFydFkgPSB0b3VjaE9iai5jbGllbnRZO1xuICAgICAgICBlLmNsaWVudFggPSB0b3VjaE9iai5jbGllbnRYO1xuICAgICAgICBlLmNsaWVudFkgPSB0b3VjaE9iai5jbGllbnRZO1xuICAgICAgICB2YXIgdCA9IGUudGltZVN0YW1wO1xuICAgICAgICB2YXIgZHQgPSB0IC0gbGFzdFQ7XG4gICAgICAgIGxhc3RUID0gdDtcbiAgICAgICAgaWYgKG1vZGUgPT0gXCJzY3JvbGxcIikge1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudChlLCBlZGl0b3IpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5zcGVlZCA9IDE7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LndoZWVsWCA9IHdoZWVsWDtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQud2hlZWxZID0gd2hlZWxZO1xuICAgICAgICAgICAgaWYgKDEwICogTWF0aC5hYnMod2hlZWxYKSA8IE1hdGguYWJzKHdoZWVsWSkpXG4gICAgICAgICAgICAgICAgd2hlZWxYID0gMDtcbiAgICAgICAgICAgIGlmICgxMCAqIE1hdGguYWJzKHdoZWVsWSkgPCBNYXRoLmFicyh3aGVlbFgpKVxuICAgICAgICAgICAgICAgIHdoZWVsWSA9IDA7XG4gICAgICAgICAgICBpZiAoZHQgIT0gMCkge1xuICAgICAgICAgICAgICAgIHZYID0gd2hlZWxYIC8gZHQ7XG4gICAgICAgICAgICAgICAgdlkgPSB3aGVlbFkgLyBkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5fZW1pdChcIm1vdXNld2hlZWxcIiwgbW91c2VFdmVudCk7XG4gICAgICAgICAgICBpZiAoIW1vdXNlRXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgdlggPSB2WSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBuZXcgTW91c2VFdmVudChlLCBlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09IFwiY3Vyc29yXCIpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcImFuY2hvclwiKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uQW5jaG9yKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KHBvcyk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LCBlZGl0b3IpO1xuICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgIGFuaW1hdGlvblN0ZXBzICs9IDYwO1xuICAgICAgICBhbmltYXRpb25UaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25TdGVwcy0tIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFuaW1hdGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModlgpIDwgMC4wMSlcbiAgICAgICAgICAgICAgICB2WCA9IDA7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModlkpIDwgMC4wMSlcbiAgICAgICAgICAgICAgICB2WSA9IDA7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uU3RlcHMgPCAyMClcbiAgICAgICAgICAgICAgICB2WCA9IDAuOSAqIHZYO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblN0ZXBzIDwgMjApXG4gICAgICAgICAgICAgICAgdlkgPSAwLjkgKiB2WTtcbiAgICAgICAgICAgIHZhciBvbGRTY3JvbGxUb3AgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxCeSgxMCAqIHZYLCAxMCAqIHZZKTtcbiAgICAgICAgICAgIGlmIChvbGRTY3JvbGxUb3AgPT0gZWRpdG9yLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkpXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uU3RlcHMgPSAwO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvbW91c2VfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIixcImFjZS9tb3VzZS9kZWZhdWx0X2hhbmRsZXJzXCIsXCJhY2UvbW91c2UvZGVmYXVsdF9ndXR0ZXJfaGFuZGxlclwiLFwiYWNlL21vdXNlL21vdXNlX2V2ZW50XCIsXCJhY2UvbW91c2UvZHJhZ2Ryb3BfaGFuZGxlclwiLFwiYWNlL21vdXNlL3RvdWNoX2hhbmRsZXJcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIERlZmF1bHRIYW5kbGVycyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRfaGFuZGxlcnNcIikuRGVmYXVsdEhhbmRsZXJzO1xudmFyIERlZmF1bHRHdXR0ZXJIYW5kbGVyID0gcmVxdWlyZShcIi4vZGVmYXVsdF9ndXR0ZXJfaGFuZGxlclwiKS5HdXR0ZXJIYW5kbGVyO1xudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9tb3VzZV9ldmVudFwiKS5Nb3VzZUV2ZW50O1xudmFyIERyYWdkcm9wSGFuZGxlciA9IHJlcXVpcmUoXCIuL2RyYWdkcm9wX2hhbmRsZXJcIikuRHJhZ2Ryb3BIYW5kbGVyO1xudmFyIGFkZFRvdWNoTGlzdGVuZXJzID0gcmVxdWlyZShcIi4vdG91Y2hfaGFuZGxlclwiKS5hZGRUb3VjaExpc3RlbmVycztcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xudmFyIE1vdXNlSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb3VzZUhhbmRsZXIoZWRpdG9yKSB7IHRoaXMuJGRyYWdEZWxheTsgdGhpcy4kZHJhZ0VuYWJsZWQ7IHRoaXMuJG1vdXNlTW92ZWQ7IHRoaXMubW91c2VFdmVudDsgdGhpcy4kZm9jdXNUaW1lb3V0O1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgbmV3IERlZmF1bHRIYW5kbGVycyh0aGlzKTtcbiAgICAgICAgbmV3IERlZmF1bHRHdXR0ZXJIYW5kbGVyKHRoaXMpO1xuICAgICAgICBuZXcgRHJhZ2Ryb3BIYW5kbGVyKHRoaXMpO1xuICAgICAgICB2YXIgZm9jdXNFZGl0b3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd0JsdXJyZWQgPSAhZG9jdW1lbnQuaGFzRm9jdXMgfHwgIWRvY3VtZW50Lmhhc0ZvY3VzKClcbiAgICAgICAgICAgICAgICB8fCAhZWRpdG9yLmlzRm9jdXNlZCgpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gKGVkaXRvci50ZXh0SW5wdXQgJiYgZWRpdG9yLnRleHRJbnB1dC5nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgaWYgKHdpbmRvd0JsdXJyZWQpXG4gICAgICAgICAgICAgICAgd2luZG93LmZvY3VzKCk7XG4gICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yLmlzRm9jdXNlZCgpKVxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbW91c2VUYXJnZXQgPSBlZGl0b3IucmVuZGVyZXIuZ2V0TW91c2VFdmVudFRhcmdldCgpO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJjbGlja1wiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFwiY2xpY2tcIiksIGVkaXRvcik7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcywgXCJtb3VzZW1vdmVcIiksIGVkaXRvcik7XG4gICAgICAgIGV2ZW50LmFkZE11bHRpTW91c2VEb3duTGlzdGVuZXIoW1xuICAgICAgICAgICAgbW91c2VUYXJnZXQsXG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFyViAmJiBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFyVi5pbm5lcixcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJIICYmIGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJILmlubmVyLFxuICAgICAgICAgICAgZWRpdG9yLnRleHRJbnB1dCAmJiBlZGl0b3IudGV4dElucHV0LmdldEVsZW1lbnQoKVxuICAgICAgICBdLmZpbHRlcihCb29sZWFuKSwgWzQwMCwgMzAwLCAyNTBdLCB0aGlzLCBcIm9uTW91c2VFdmVudFwiLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRNb3VzZVdoZWVsTGlzdGVuZXIoZWRpdG9yLmNvbnRhaW5lciwgdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzLCBcIm1vdXNld2hlZWxcIiksIGVkaXRvcik7XG4gICAgICAgIGFkZFRvdWNoTGlzdGVuZXJzKGVkaXRvci5jb250YWluZXIsIGVkaXRvcik7XG4gICAgICAgIHZhciBndXR0ZXJFbCA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImd1dHRlcm1vdXNlZG93blwiKSwgZWRpdG9yKTtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZ3V0dGVyRWwsIFwiY2xpY2tcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImd1dHRlcmNsaWNrXCIpLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJkYmxjbGlja1wiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFwiZ3V0dGVyZGJsY2xpY2tcIiksIGVkaXRvcik7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKGd1dHRlckVsLCBcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFwiZ3V0dGVybW91c2Vtb3ZlXCIpLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJtb3VzZWRvd25cIiwgZm9jdXNFZGl0b3IsIGVkaXRvcik7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKGd1dHRlckVsLCBcIm1vdXNlZG93blwiLCBmb2N1c0VkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0lFICYmIGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJWKSB7XG4gICAgICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFyVi5lbGVtZW50LCBcIm1vdXNlZG93blwiLCBmb2N1c0VkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJILmVsZW1lbnQsIFwibW91c2Vkb3duXCIsIGZvY3VzRWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF9zZWxmLnN0YXRlIHx8IF9zZWxmLiRkcmFnRGVsYXkgfHwgIV9zZWxmLiRkcmFnRW5hYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gZWRpdG9yLnJlbmRlcmVyLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzKGUueCwgZS55KTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5zZXNzaW9uLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gZWRpdG9yLnJlbmRlcmVyO1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5pc0VtcHR5KCkgJiYgcmFuZ2UuaW5zaWRlU3RhcnQoY2hhcmFjdGVyLnJvdywgY2hhcmFjdGVyLmNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcImRlZmF1bHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgLy9AdHMtZXhwZWN0LWVycm9yIFRPRE86IHNlZW1zIG1pc3R5cGluZyAtIHNob3VsZCBiZSBib29sZWFuXG4gICAgICAgIGVkaXRvcik7XG4gICAgfVxuICAgIE1vdXNlSGFuZGxlci5wcm90b3R5cGUub25Nb3VzZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5zZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVkaXRvci5fZW1pdChuYW1lLCBuZXcgTW91c2VFdmVudChlLCB0aGlzLmVkaXRvcikpO1xuICAgIH07XG4gICAgTW91c2VIYW5kbGVyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChuYW1lLCBlKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmVkaXRvci5fZXZlbnRSZWdpc3RyeSAmJiB0aGlzLmVkaXRvci5fZXZlbnRSZWdpc3RyeS5tb3VzZW1vdmU7XG4gICAgICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVkaXRvci5fZW1pdChuYW1lLCBuZXcgTW91c2VFdmVudChlLCB0aGlzLmVkaXRvcikpO1xuICAgIH07XG4gICAgTW91c2VIYW5kbGVyLnByb3RvdHlwZS5vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbiAobmFtZSwgZSkge1xuICAgICAgICB2YXIgbW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KGUsIHRoaXMuZWRpdG9yKTtcbiAgICAgICAgbW91c2VFdmVudC5zcGVlZCA9IHRoaXMuJHNjcm9sbFNwZWVkICogMjtcbiAgICAgICAgbW91c2VFdmVudC53aGVlbFggPSBlLndoZWVsWDtcbiAgICAgICAgbW91c2VFdmVudC53aGVlbFkgPSBlLndoZWVsWTtcbiAgICAgICAgdGhpcy5lZGl0b3IuX2VtaXQobmFtZSwgbW91c2VFdmVudCk7XG4gICAgfTtcbiAgICBNb3VzZUhhbmRsZXIucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9O1xuICAgIE1vdXNlSGFuZGxlci5wcm90b3R5cGUuY2FwdHVyZU1vdXNlID0gZnVuY3Rpb24gKGV2LCBtb3VzZU1vdmVIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMueCA9IGV2Lng7XG4gICAgICAgIHRoaXMueSA9IGV2Lnk7XG4gICAgICAgIHRoaXMuaXNNb3VzZVByZXNzZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZWRpdG9yLnJlbmRlcmVyO1xuICAgICAgICByZW5kZXJlci4kaXNNb3VzZVByZXNzZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHVzZXJhZ2VudC5pc1dlYktpdCAmJiAhZS53aGljaCAmJiBzZWxmLnJlbGVhc2VNb3VzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgICAgIHNlbGYueCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIHNlbGYueSA9IGUuY2xpZW50WTtcbiAgICAgICAgICAgIG1vdXNlTW92ZUhhbmRsZXIgJiYgbW91c2VNb3ZlSGFuZGxlcihlKTtcbiAgICAgICAgICAgIHNlbGYubW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KGUsIHNlbGYuZWRpdG9yKTtcbiAgICAgICAgICAgIHNlbGYuJG1vdXNlTW92ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DYXB0dXJlRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGVkaXRvci5vZmYoXCJiZWZvcmVFbmRPcGVyYXRpb25cIiwgb25PcGVyYXRpb25FbmQpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2Vzc2lvbilcbiAgICAgICAgICAgICAgICBvbkNhcHR1cmVJbnRlcnZhbCgpO1xuICAgICAgICAgICAgc2VsZltzZWxmLnN0YXRlICsgXCJFbmRcIl0gJiYgc2VsZltzZWxmLnN0YXRlICsgXCJFbmRcIl0oZSk7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJcIjtcbiAgICAgICAgICAgIHNlbGYuaXNNb3VzZVByZXNzZWQgPSByZW5kZXJlci4kaXNNb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IpXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgICAgICAgICBzZWxmLiRvbkNhcHR1cmVNb3VzZU1vdmUgPSBzZWxmLnJlbGVhc2VNb3VzZSA9IG51bGw7XG4gICAgICAgICAgICBlICYmIHNlbGYub25Nb3VzZUV2ZW50KFwibW91c2V1cFwiLCBlKTtcbiAgICAgICAgICAgIGVkaXRvci5lbmRPcGVyYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2FwdHVyZUludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZltzZWxmLnN0YXRlXSAmJiBzZWxmW3NlbGYuc3RhdGVdKCk7XG4gICAgICAgICAgICBzZWxmLiRtb3VzZU1vdmVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNPbGRJRSAmJiBldi5kb21FdmVudC50eXBlID09IFwiZGJsY2xpY2tcIikge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBvbkNhcHR1cmVFbmQoZXYpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb25PcGVyYXRpb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnJlbGVhc2VNb3VzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmN1ck9wLmNvbW1hbmQubmFtZSAmJiBlZGl0b3IuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHNlbGZbc2VsZi5zdGF0ZSArIFwiRW5kXCJdICYmIHNlbGZbc2VsZi5zdGF0ZSArIFwiRW5kXCJdKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKFwiYmVmb3JlRW5kT3BlcmF0aW9uXCIsIG9uT3BlcmF0aW9uRW5kKTtcbiAgICAgICAgZWRpdG9yLnN0YXJ0T3BlcmF0aW9uKHsgY29tbWFuZDogeyBuYW1lOiBcIm1vdXNlXCIgfSB9KTtcbiAgICAgICAgc2VsZi4kb25DYXB0dXJlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmU7XG4gICAgICAgIHNlbGYucmVsZWFzZU1vdXNlID0gZXZlbnQuY2FwdHVyZSh0aGlzLmVkaXRvci5jb250YWluZXIsIG9uTW91c2VNb3ZlLCBvbkNhcHR1cmVFbmQpO1xuICAgICAgICB2YXIgdGltZXJJZCA9IHNldEludGVydmFsKG9uQ2FwdHVyZUludGVydmFsLCAyMCk7XG4gICAgfTtcbiAgICBNb3VzZUhhbmRsZXIucHJvdG90eXBlLmNhbmNlbENvbnRleHRNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLmRvbUV2ZW50ICYmIGUuZG9tRXZlbnQudHlwZSAhPSBcImNvbnRleHRtZW51XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwibmF0aXZlY29udGV4dG1lbnVcIiwgc3RvcCk7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLmRvbUV2ZW50KVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BFdmVudChlLmRvbUV2ZW50KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICBzZXRUaW1lb3V0KHN0b3AsIDEwKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJuYXRpdmVjb250ZXh0bWVudVwiLCBzdG9wKTtcbiAgICB9O1xuICAgIE1vdXNlSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZU1vdXNlKVxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlTW91c2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBNb3VzZUhhbmRsZXI7XG59KCkpO1xuTW91c2VIYW5kbGVyLnByb3RvdHlwZS5yZWxlYXNlTW91c2UgPSBudWxsO1xuY29uZmlnLmRlZmluZU9wdGlvbnMoTW91c2VIYW5kbGVyLnByb3RvdHlwZSwgXCJtb3VzZUhhbmRsZXJcIiwge1xuICAgIHNjcm9sbFNwZWVkOiB7IGluaXRpYWxWYWx1ZTogMiB9LFxuICAgIGRyYWdEZWxheTogeyBpbml0aWFsVmFsdWU6ICh1c2VyYWdlbnQuaXNNYWMgPyAxNTAgOiAwKSB9LFxuICAgIGRyYWdFbmFibGVkOiB7IGluaXRpYWxWYWx1ZTogdHJ1ZSB9LFxuICAgIGZvY3VzVGltZW91dDogeyBpbml0aWFsVmFsdWU6IDAgfSxcbiAgICB0b29sdGlwRm9sbG93c01vdXNlOiB7IGluaXRpYWxWYWx1ZTogdHJ1ZSB9XG59KTtcbmV4cG9ydHMuTW91c2VIYW5kbGVyID0gTW91c2VIYW5kbGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9mb2xkX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIEZvbGRIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvbGRIYW5kbGVyKGVkaXRvcikge1xuICAgICAgICBlZGl0b3Iub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgICAgICAgICAgdmFyIGZvbGQgPSBzZXNzaW9uLmdldEZvbGRBdChwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbiwgMSk7XG4gICAgICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgICAgIGlmIChlLmdldEFjY2VsS2V5KCkpXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlRm9sZChmb2xkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZXhwYW5kRm9sZChmb2xkKTtcbiAgICAgICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLmRvbUV2ZW50ICYmIGUuZG9tRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiBkb20uaGFzQ3NzQ2xhc3ModGFyZ2V0LCBcImFjZV9pbmxpbmVfYnV0dG9uXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5oYXNDc3NDbGFzcyh0YXJnZXQsIFwiYWNlX3RvZ2dsZV93cmFwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uc2V0T3B0aW9uKFwid3JhcFwiLCAhc2Vzc2lvbi5nZXRVc2VXcmFwTW9kZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKFwiZ3V0dGVyY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBndXR0ZXJSZWdpb24gPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLmdldFJlZ2lvbihlKTtcbiAgICAgICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXCJmb2xkV2lkZ2V0c1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcbiAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLmZvbGRXaWRnZXRzICYmIHNlc3Npb24uZm9sZFdpZGdldHNbcm93XSlcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ub25Gb2xkV2lkZ2V0Q2xpY2socm93LCBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvci5pc0ZvY3VzZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oXCJndXR0ZXJkYmxjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGd1dHRlclJlZ2lvbiA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuZ2V0UmVnaW9uKGUpO1xuICAgICAgICAgICAgaWYgKGd1dHRlclJlZ2lvbiA9PSBcImZvbGRXaWRnZXRzXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uID0gZWRpdG9yLnNlc3Npb247XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXNzaW9uLmdldFBhcmVudEZvbGRSYW5nZURhdGEocm93LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBkYXRhLnJhbmdlIHx8IGRhdGEuZmlyc3RSYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZCA9IHNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgc2Vzc2lvbi5nZXRMaW5lKHJvdykubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlRm9sZChmb2xkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoeyByb3c6IHJhbmdlLnN0YXJ0LnJvdywgY29sdW1uOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEZvbGRIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuRm9sZEhhbmRsZXIgPSBGb2xkSGFuZGxlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uva2V5Ym9hcmQva2V5YmluZGluZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9rZXlzXCIsXCJhY2UvbGliL2V2ZW50XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGtleVV0aWwgPSByZXF1aXJlKFwiLi4vbGliL2tleXNcIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIEtleUJpbmRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS2V5QmluZGluZyhlZGl0b3IpIHtcbiAgICAgICAgdGhpcy4kZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLiRkYXRhID0geyBlZGl0b3I6IGVkaXRvciB9O1xuICAgICAgICB0aGlzLiRoYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLnNldERlZmF1bHRIYW5kbGVyKGVkaXRvci5jb21tYW5kcyk7XG4gICAgfVxuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLnNldERlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24gKGtiKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKHRoaXMuJGRlZmF1bHRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy4kZGVmYXVsdEhhbmRsZXIgPSBrYjtcbiAgICAgICAgdGhpcy5hZGRLZXlib2FyZEhhbmRsZXIoa2IsIDApO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUuc2V0S2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24gKGtiKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy4kaGFuZGxlcnM7XG4gICAgICAgIGlmIChoW2gubGVuZ3RoIC0gMV0gPT0ga2IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHdoaWxlIChoW2gubGVuZ3RoIC0gMV0gJiYgaFtoLmxlbmd0aCAtIDFdICE9IHRoaXMuJGRlZmF1bHRIYW5kbGVyKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVLZXlib2FyZEhhbmRsZXIoaFtoLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdGhpcy5hZGRLZXlib2FyZEhhbmRsZXIoa2IsIDEpO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUuYWRkS2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24gKGtiLCBwb3MpIHtcbiAgICAgICAgaWYgKCFrYilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBrYiA9PSBcImZ1bmN0aW9uXCIgJiYgIWtiLmhhbmRsZUtleWJvYXJkKVxuICAgICAgICAgICAga2IuaGFuZGxlS2V5Ym9hcmQgPSBrYjtcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRoYW5kbGVycy5pbmRleE9mKGtiKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpXG4gICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlmIChwb3MgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy4kaGFuZGxlcnMucHVzaChrYik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJGhhbmRsZXJzLnNwbGljZShwb3MsIDAsIGtiKTtcbiAgICAgICAgaWYgKGkgPT0gLTEgJiYga2IuYXR0YWNoKVxuICAgICAgICAgICAga2IuYXR0YWNoKHRoaXMuJGVkaXRvcik7XG4gICAgfTtcbiAgICBLZXlCaW5kaW5nLnByb3RvdHlwZS5yZW1vdmVLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbiAoa2IpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRoYW5kbGVycy5pbmRleE9mKGtiKTtcbiAgICAgICAgaWYgKGkgPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuJGhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAga2IuZGV0YWNoICYmIGtiLmRldGFjaCh0aGlzLiRlZGl0b3IpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLmdldEtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGhhbmRsZXJzW3RoaXMuJGhhbmRsZXJzLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUuZ2V0U3RhdHVzVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLiRkYXRhO1xuICAgICAgICB2YXIgZWRpdG9yID0gZGF0YS5lZGl0b3I7XG4gICAgICAgIHJldHVybiB0aGlzLiRoYW5kbGVycy5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoLmdldFN0YXR1c1RleHQgJiYgaC5nZXRTdGF0dXNUZXh0KGVkaXRvciwgZGF0YSkgfHwgXCJcIjtcbiAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUuJGNhbGxLZXlib2FyZEhhbmRsZXJzID0gZnVuY3Rpb24gKGhhc2hJZCwga2V5U3RyaW5nLCBrZXlDb2RlLCBlKSB7XG4gICAgICAgIHZhciB0b0V4ZWN1dGU7XG4gICAgICAgIHZhciBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IHRoaXMuJGVkaXRvci5jb21tYW5kcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuJGhhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdG9FeGVjdXRlID0gdGhpcy4kaGFuZGxlcnNbaV0uaGFuZGxlS2V5Ym9hcmQoXG4gICAgICAgICAgICB0aGlzLiRkYXRhLCBoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSwgZSk7XG4gICAgICAgICAgICBpZiAoIXRvRXhlY3V0ZSB8fCAhdG9FeGVjdXRlLmNvbW1hbmQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9FeGVjdXRlLmNvbW1hbmQgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBjb21tYW5kcy5leGVjKHRvRXhlY3V0ZS5jb21tYW5kLCB0aGlzLiRlZGl0b3IsIHRvRXhlY3V0ZS5hcmdzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWNjZXNzICYmIGUgJiYgaGFzaElkICE9IC0xICYmXG4gICAgICAgICAgICAgICAgdG9FeGVjdXRlW1wicGFzc0V2ZW50XCJdICE9IHRydWUgJiYgdG9FeGVjdXRlLmNvbW1hbmRbXCJwYXNzRXZlbnRcIl0gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BFdmVudChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWNjZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VjY2VzcyAmJiBoYXNoSWQgPT0gLTEpIHtcbiAgICAgICAgICAgIHRvRXhlY3V0ZSA9IHsgY29tbWFuZDogXCJpbnNlcnRzdHJpbmdcIiB9O1xuICAgICAgICAgICAgc3VjY2VzcyA9IGNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRzdHJpbmdcIiwgdGhpcy4kZWRpdG9yLCBrZXlTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzICYmIHRoaXMuJGVkaXRvci5fc2lnbmFsKVxuICAgICAgICAgICAgdGhpcy4kZWRpdG9yLl9zaWduYWwoXCJrZXlib2FyZEFjdGl2aXR5XCIsIHRvRXhlY3V0ZSk7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUub25Db21tYW5kS2V5ID0gZnVuY3Rpb24gKGUsIGhhc2hJZCwga2V5Q29kZSkge1xuICAgICAgICB2YXIga2V5U3RyaW5nID0ga2V5VXRpbC5rZXlDb2RlVG9TdHJpbmcoa2V5Q29kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLiRjYWxsS2V5Ym9hcmRIYW5kbGVycyhoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSwgZSk7XG4gICAgfTtcbiAgICBLZXlCaW5kaW5nLnByb3RvdHlwZS5vblRleHRJbnB1dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjYWxsS2V5Ym9hcmRIYW5kbGVycygtMSwgdGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5QmluZGluZztcbn0oKSk7XG5leHBvcnRzLktleUJpbmRpbmcgPSBLZXlCaW5kaW5nO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvYmlkaXV0aWxcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJhYmljQWxlZkJldEludGVydmFsc0JlZ2luZSA9IFsnXFx1MDYyMScsICdcXHUwNjQxJ107XG52YXIgQXJhYmljQWxlZkJldEludGVydmFsc0VuZCA9IFsnXFx1MDYzQScsICdcXHUwNjRhJ107XG52YXIgZGlyID0gMCwgaGlMZXZlbCA9IDA7XG52YXIgbGFzdEFyYWJpYyA9IGZhbHNlLCBoYXNVQkFUX0FMID0gZmFsc2UsIGhhc1VCQVRfQiA9IGZhbHNlLCBoYXNVQkFUX1MgPSBmYWxzZSwgaGFzQmxvY2tTZXAgPSBmYWxzZSwgaGFzU2VnU2VwID0gZmFsc2U7XG52YXIgaW1wVGFiX0xUUiA9IFsgWzAsIDMsIDAsIDEsIDAsIDAsIDBdLCBbMCwgMywgMCwgMSwgMiwgMiwgMF0sIFswLCAzLCAwLCAweDExLCAyLCAwLCAxXSwgWzAsIDMsIDUsIDUsIDQsIDEsIDBdLCBbMCwgMywgMHgxNSwgMHgxNSwgNCwgMCwgMV0sIFswLCAzLCA1LCA1LCA0LCAyLCAwXVxuXTtcbnZhciBpbXBUYWJfUlRMID0gWyBbMiwgMCwgMSwgMSwgMCwgMSwgMF0sIFsyLCAwLCAxLCAxLCAwLCAyLCAwXSwgWzIsIDAsIDIsIDEsIDMsIDIsIDBdLCBbMiwgMCwgMiwgMHgyMSwgMywgMSwgMV1cbl07XG52YXIgTFRSID0gMCwgUlRMID0gMTtcbnZhciBMID0gMDtcbnZhciBSID0gMTtcbnZhciBFTiA9IDI7XG52YXIgQU4gPSAzO1xudmFyIE9OID0gNDtcbnZhciBCID0gNTtcbnZhciBTID0gNjtcbnZhciBBTCA9IDc7XG52YXIgV1MgPSA4O1xudmFyIENTID0gOTtcbnZhciBFUyA9IDEwO1xudmFyIEVUID0gMTE7XG52YXIgTlNNID0gMTI7XG52YXIgTFJFID0gMTM7XG52YXIgUkxFID0gMTQ7XG52YXIgUERGID0gMTU7XG52YXIgTFJPID0gMTY7XG52YXIgUkxPID0gMTc7XG52YXIgQk4gPSAxODtcbnZhciBVbmljb2RlVEJMMDAgPSBbXG4gICAgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgUywgQiwgUywgV1MsIEIsIEJOLCBCTixcbiAgICBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCLCBCLCBCLCBTLFxuICAgIFdTLCBPTiwgT04sIEVULCBFVCwgRVQsIE9OLCBPTiwgT04sIE9OLCBPTiwgRVMsIENTLCBFUywgQ1MsIENTLFxuICAgIEVOLCBFTiwgRU4sIEVOLCBFTiwgRU4sIEVOLCBFTiwgRU4sIEVOLCBDUywgT04sIE9OLCBPTiwgT04sIE9OLFxuICAgIE9OLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLFxuICAgIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIE9OLCBPTiwgT04sIE9OLCBPTixcbiAgICBPTiwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCxcbiAgICBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBPTiwgT04sIE9OLCBPTiwgQk4sXG4gICAgQk4sIEJOLCBCTiwgQk4sIEJOLCBCLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTixcbiAgICBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTixcbiAgICBDUywgT04sIEVULCBFVCwgRVQsIEVULCBPTiwgT04sIE9OLCBPTiwgTCwgT04sIE9OLCBCTiwgT04sIE9OLFxuICAgIEVULCBFVCwgRU4sIEVOLCBPTiwgTCwgT04sIE9OLCBPTiwgRU4sIEwsIE9OLCBPTiwgT04sIE9OLCBPTlxuXTtcbnZhciBVbmljb2RlVEJMMjAgPSBbXG4gICAgV1MsIFdTLCBXUywgV1MsIFdTLCBXUywgV1MsIFdTLCBXUywgV1MsIFdTLCBCTiwgQk4sIEJOLCBMLCBSLFxuICAgIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLFxuICAgIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgV1MsIEIsIExSRSwgUkxFLCBQREYsIExSTywgUkxPLCBDUyxcbiAgICBFVCwgRVQsIEVULCBFVCwgRVQsIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTixcbiAgICBPTiwgT04sIE9OLCBPTiwgQ1MsIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTixcbiAgICBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBXU1xuXTtcbmZ1bmN0aW9uIF9jb21wdXRlTGV2ZWxzKGNoYXJzLCBsZXZlbHMsIGxlbiwgY2hhclR5cGVzKSB7XG4gICAgdmFyIGltcFRhYiA9IGRpciA/IGltcFRhYl9SVEwgOiBpbXBUYWJfTFRSLCBwcmV2U3RhdGUgPSBudWxsLCBuZXdDbGFzcyA9IG51bGwsIG5ld0xldmVsID0gbnVsbCwgbmV3U3RhdGUgPSAwLCBhY3Rpb24gPSBudWxsLCBjb25kID0gbnVsbCwgY29uZFBvcyA9IC0xLCBpID0gbnVsbCwgaXggPSBudWxsLCBjbGFzc2VzID0gW107XG4gICAgaWYgKCFjaGFyVHlwZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgY2hhclR5cGVzID0gW107IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hhclR5cGVzW2ldID0gX2dldENoYXJhY3RlclR5cGUoY2hhcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpTGV2ZWwgPSBkaXI7XG4gICAgbGFzdEFyYWJpYyA9IGZhbHNlO1xuICAgIGhhc1VCQVRfQUwgPSBmYWxzZTtcbiAgICBoYXNVQkFUX0IgPSBmYWxzZTtcbiAgICBoYXNVQkFUX1MgPSBmYWxzZTtcbiAgICBmb3IgKGl4ID0gMDsgaXggPCBsZW47IGl4KyspIHtcbiAgICAgICAgcHJldlN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGNsYXNzZXNbaXhdID0gbmV3Q2xhc3MgPSBfZ2V0Q2hhckNsYXNzKGNoYXJzLCBjaGFyVHlwZXMsIGNsYXNzZXMsIGl4KTtcbiAgICAgICAgbmV3U3RhdGUgPSBpbXBUYWJbcHJldlN0YXRlXVtuZXdDbGFzc107XG4gICAgICAgIGFjdGlvbiA9IG5ld1N0YXRlICYgMHhGMDtcbiAgICAgICAgbmV3U3RhdGUgJj0gMHgwRjtcbiAgICAgICAgbGV2ZWxzW2l4XSA9IG5ld0xldmVsID0gaW1wVGFiW25ld1N0YXRlXVs1XTtcbiAgICAgICAgaWYgKGFjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMHgxMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvbmRQb3M7IGkgPCBpeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsc1tpXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmRQb3MgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmRQb3MgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25kID0gaW1wVGFiW25ld1N0YXRlXVs2XTtcbiAgICAgICAgaWYgKGNvbmQpIHtcbiAgICAgICAgICAgIGlmIChjb25kUG9zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uZFBvcyA9IGl4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmRQb3MgPiAtMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvbmRQb3M7IGkgPCBpeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsc1tpXSA9IG5ld0xldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25kUG9zID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJUeXBlc1tpeF0gPT0gQikge1xuICAgICAgICAgICAgbGV2ZWxzW2l4XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaGlMZXZlbCB8PSBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKGhhc1VCQVRfUykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaV0gPT0gUykge1xuICAgICAgICAgICAgICAgIGxldmVsc1tpXSA9IGRpcjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbal0gPT0gV1MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsc1tqXSA9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX2ludmVydExldmVsKGxldiwgbGV2ZWxzLCBfYXJyYXkpIHtcbiAgICBpZiAoaGlMZXZlbCA8IGxldikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZXYgPT0gMSAmJiBkaXIgPT0gUlRMICYmICFoYXNVQkFUX0IpIHtcbiAgICAgICAgX2FycmF5LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGVuID0gX2FycmF5Lmxlbmd0aCwgc3RhcnQgPSAwLCBlbmQsIGxvLCBoaSwgdG1wO1xuICAgIHdoaWxlIChzdGFydCA8IGxlbikge1xuICAgICAgICBpZiAobGV2ZWxzW3N0YXJ0XSA+PSBsZXYpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW4gJiYgbGV2ZWxzW2VuZF0gPj0gbGV2KSB7XG4gICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxvID0gc3RhcnQsIGhpID0gZW5kIC0gMTsgbG8gPCBoaTsgbG8rKywgaGktLSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IF9hcnJheVtsb107XG4gICAgICAgICAgICAgICAgX2FycmF5W2xvXSA9IF9hcnJheVtoaV07XG4gICAgICAgICAgICAgICAgX2FycmF5W2hpXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldENoYXJDbGFzcyhjaGFycywgdHlwZXMsIGNsYXNzZXMsIGl4KSB7XG4gICAgdmFyIGNUeXBlID0gdHlwZXNbaXhdLCB3VHlwZSwgblR5cGUsIGxlbiwgaTtcbiAgICBzd2l0Y2ggKGNUeXBlKSB7XG4gICAgICAgIGNhc2UgTDpcbiAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgbGFzdEFyYWJpYyA9IGZhbHNlO1xuICAgICAgICBjYXNlIE9OOlxuICAgICAgICBjYXNlIEFOOlxuICAgICAgICAgICAgcmV0dXJuIGNUeXBlO1xuICAgICAgICBjYXNlIEVOOlxuICAgICAgICAgICAgcmV0dXJuIGxhc3RBcmFiaWMgPyBBTiA6IEVOO1xuICAgICAgICBjYXNlIEFMOlxuICAgICAgICAgICAgbGFzdEFyYWJpYyA9IHRydWU7XG4gICAgICAgICAgICBoYXNVQkFUX0FMID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBSO1xuICAgICAgICBjYXNlIFdTOlxuICAgICAgICAgICAgcmV0dXJuIE9OO1xuICAgICAgICBjYXNlIENTOlxuICAgICAgICAgICAgaWYgKGl4IDwgMSB8fCAoaXggKyAxKSA+PSB0eXBlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAoKHdUeXBlID0gY2xhc3Nlc1tpeCAtIDFdKSAhPSBFTiAmJiB3VHlwZSAhPSBBTikgfHxcbiAgICAgICAgICAgICAgICAoKG5UeXBlID0gdHlwZXNbaXggKyAxXSkgIT0gRU4gJiYgblR5cGUgIT0gQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RBcmFiaWMpIHtcbiAgICAgICAgICAgICAgICBuVHlwZSA9IEFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5UeXBlID09IHdUeXBlID8gblR5cGUgOiBPTjtcbiAgICAgICAgY2FzZSBFUzpcbiAgICAgICAgICAgIHdUeXBlID0gaXggPiAwID8gY2xhc3Nlc1tpeCAtIDFdIDogQjtcbiAgICAgICAgICAgIGlmICh3VHlwZSA9PSBFTiAmJiAoaXggKyAxKSA8IHR5cGVzLmxlbmd0aCAmJiB0eXBlc1tpeCArIDFdID09IEVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9OO1xuICAgICAgICBjYXNlIEVUOlxuICAgICAgICAgICAgaWYgKGl4ID4gMCAmJiBjbGFzc2VzW2l4IC0gMV0gPT0gRU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdEFyYWJpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBpeCArIDE7XG4gICAgICAgICAgICBsZW4gPSB0eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiB0eXBlc1tpXSA9PSBFVCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgbGVuICYmIHR5cGVzW2ldID09IEVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9OO1xuICAgICAgICBjYXNlIE5TTTpcbiAgICAgICAgICAgIGxlbiA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGkgPSBpeCArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiB0eXBlc1tpXSA9PSBOU00pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2hhcnNbaXhdLCBydGxDYW5kaWRhdGUgPSAoYyA+PSAweDA1OTEgJiYgYyA8PSAweDA4RkYpIHx8IGMgPT0gMHhGQjFFO1xuICAgICAgICAgICAgICAgIHdUeXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ0bENhbmRpZGF0ZSAmJiAod1R5cGUgPT0gUiB8fCB3VHlwZSA9PSBBTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl4IDwgMSB8fCAod1R5cGUgPSB0eXBlc1tpeCAtIDFdKSA9PSBCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXNbaXggLSAxXTtcbiAgICAgICAgY2FzZSBCOlxuICAgICAgICAgICAgbGFzdEFyYWJpYyA9IGZhbHNlO1xuICAgICAgICAgICAgaGFzVUJBVF9CID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkaXI7XG4gICAgICAgIGNhc2UgUzpcbiAgICAgICAgICAgIGhhc1VCQVRfUyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gT047XG4gICAgICAgIGNhc2UgTFJFOlxuICAgICAgICBjYXNlIFJMRTpcbiAgICAgICAgY2FzZSBMUk86XG4gICAgICAgIGNhc2UgUkxPOlxuICAgICAgICBjYXNlIFBERjpcbiAgICAgICAgICAgIGxhc3RBcmFiaWMgPSBmYWxzZTtcbiAgICAgICAgY2FzZSBCTjpcbiAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0Q2hhcmFjdGVyVHlwZShjaCkge1xuICAgIHZhciB1YyA9IGNoLmNoYXJDb2RlQXQoMCksIGhpID0gdWMgPj4gODtcbiAgICBpZiAoaGkgPT0gMCkge1xuICAgICAgICByZXR1cm4gKCh1YyA+IDB4MDBCRikgPyBMIDogVW5pY29kZVRCTDAwW3VjXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhpID09IDUpIHtcbiAgICAgICAgcmV0dXJuICgvW1xcdTA1OTEtXFx1MDVmNF0vLnRlc3QoY2gpID8gUiA6IEwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoaSA9PSA2KSB7XG4gICAgICAgIGlmICgvW1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY1ZlxcdTA2ZDYtXFx1MDZlNFxcdTA2ZTctXFx1MDZlZF0vLnRlc3QoY2gpKVxuICAgICAgICAgICAgcmV0dXJuIE5TTTtcbiAgICAgICAgZWxzZSBpZiAoL1tcXHUwNjYwLVxcdTA2NjlcXHUwNjZiLVxcdTA2NmNdLy50ZXN0KGNoKSlcbiAgICAgICAgICAgIHJldHVybiBBTjtcbiAgICAgICAgZWxzZSBpZiAodWMgPT0gMHgwNjZBKVxuICAgICAgICAgICAgcmV0dXJuIEVUO1xuICAgICAgICBlbHNlIGlmICgvW1xcdTA2ZjAtXFx1MDZmOV0vLnRlc3QoY2gpKVxuICAgICAgICAgICAgcmV0dXJuIEVOO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gQUw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhpID09IDB4MjAgJiYgdWMgPD0gMHgyMDVGKSB7XG4gICAgICAgIHJldHVybiBVbmljb2RlVEJMMjBbdWMgJiAweEZGXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGkgPT0gMHhGRSkge1xuICAgICAgICByZXR1cm4gKHVjID49IDB4RkU3MCA/IEFMIDogT04pO1xuICAgIH1cbiAgICByZXR1cm4gT047XG59XG5mdW5jdGlvbiBfaXNBcmFiaWNEaWFjcml0aWNzKGNoKSB7XG4gICAgcmV0dXJuIChjaCA+PSAnXFx1MDY0YicgJiYgY2ggPD0gJ1xcdTA2NTUnKTtcbn1cbmV4cG9ydHMuTCA9IEw7XG5leHBvcnRzLlIgPSBSO1xuZXhwb3J0cy5FTiA9IEVOO1xuZXhwb3J0cy5PTl9SID0gMztcbmV4cG9ydHMuQU4gPSA0O1xuZXhwb3J0cy5SX0ggPSA1O1xuZXhwb3J0cy5CID0gNjtcbmV4cG9ydHMuUkxFID0gNztcbmV4cG9ydHMuRE9UID0gXCJcXHhCN1wiO1xuZXhwb3J0cy5kb0JpZGlSZW9yZGVyID0gZnVuY3Rpb24gKHRleHQsIHRleHRDaGFyVHlwZXMsIGlzUnRsKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciBjaGFycyA9IHRleHQuc3BsaXQoXCJcIiksIGxvZ2ljYWxGcm9tVmlzdWFsID0gbmV3IEFycmF5KGNoYXJzLmxlbmd0aCksIGJpZGlMZXZlbHMgPSBuZXcgQXJyYXkoY2hhcnMubGVuZ3RoKSwgbGV2ZWxzID0gW107XG4gICAgZGlyID0gaXNSdGwgPyBSVEwgOiBMVFI7XG4gICAgX2NvbXB1dGVMZXZlbHMoY2hhcnMsIGxldmVscywgY2hhcnMubGVuZ3RoLCB0ZXh0Q2hhclR5cGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ2ljYWxGcm9tVmlzdWFsLmxlbmd0aDsgbG9naWNhbEZyb21WaXN1YWxbaV0gPSBpLCBpKyspXG4gICAgICAgIDtcbiAgICBfaW52ZXJ0TGV2ZWwoMiwgbGV2ZWxzLCBsb2dpY2FsRnJvbVZpc3VhbCk7XG4gICAgX2ludmVydExldmVsKDEsIGxldmVscywgbG9naWNhbEZyb21WaXN1YWwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9naWNhbEZyb21WaXN1YWwubGVuZ3RoIC0gMTsgaSsrKSB7IC8vZml4IGxldmVscyB0byByZWZsZWN0IGNoYXJhY3RlciB3aWR0aFxuICAgICAgICBpZiAodGV4dENoYXJUeXBlc1tpXSA9PT0gQU4pIHtcbiAgICAgICAgICAgIGxldmVsc1tpXSA9IGV4cG9ydHMuQU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV2ZWxzW2ldID09PSBSICYmICgodGV4dENoYXJUeXBlc1tpXSA+IEFMICYmIHRleHRDaGFyVHlwZXNbaV0gPCBMUkUpXG4gICAgICAgICAgICB8fCB0ZXh0Q2hhclR5cGVzW2ldID09PSBPTiB8fCB0ZXh0Q2hhclR5cGVzW2ldID09PSBCTikpIHtcbiAgICAgICAgICAgIGxldmVsc1tpXSA9IGV4cG9ydHMuT05fUjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoaSA+IDAgJiYgY2hhcnNbaSAtIDFdID09PSAnXFx1MDY0NCcpICYmIC9cXHUwNjIyfFxcdTA2MjN8XFx1MDYyNXxcXHUwNjI3Ly50ZXN0KGNoYXJzW2ldKSkge1xuICAgICAgICAgICAgbGV2ZWxzW2kgLSAxXSA9IGxldmVsc1tpXSA9IGV4cG9ydHMuUl9IO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSA9PT0gZXhwb3J0cy5ET1QpXG4gICAgICAgIGxldmVsc1tjaGFycy5sZW5ndGggLSAxXSA9IGV4cG9ydHMuQjtcbiAgICBpZiAoY2hhcnNbMF0gPT09ICdcXHUyMDJCJylcbiAgICAgICAgbGV2ZWxzWzBdID0gZXhwb3J0cy5STEU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dpY2FsRnJvbVZpc3VhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBiaWRpTGV2ZWxzW2ldID0gbGV2ZWxzW2xvZ2ljYWxGcm9tVmlzdWFsW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2xvZ2ljYWxGcm9tVmlzdWFsJzogbG9naWNhbEZyb21WaXN1YWwsICdiaWRpTGV2ZWxzJzogYmlkaUxldmVscyB9O1xufTtcbmV4cG9ydHMuaGFzQmlkaUNoYXJhY3RlcnMgPSBmdW5jdGlvbiAodGV4dCwgdGV4dENoYXJUeXBlcykge1xuICAgIHZhciByZXQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGV4dENoYXJUeXBlc1tpXSA9IF9nZXRDaGFyYWN0ZXJUeXBlKHRleHQuY2hhckF0KGkpKTtcbiAgICAgICAgaWYgKCFyZXQgJiYgKHRleHRDaGFyVHlwZXNbaV0gPT0gUiB8fCB0ZXh0Q2hhclR5cGVzW2ldID09IEFMIHx8IHRleHRDaGFyVHlwZXNbaV0gPT0gQU4pKVxuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLmdldFZpc3VhbEZyb21Mb2dpY2FsSWR4ID0gZnVuY3Rpb24gKGxvZ0lkeCwgcm93TWFwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dNYXAubG9naWNhbEZyb21WaXN1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvd01hcC5sb2dpY2FsRnJvbVZpc3VhbFtpXSA9PSBsb2dJZHgpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9iaWRpaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9iaWRpdXRpbFwiLFwiYWNlL2xpYi9sYW5nXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGJpZGlVdGlsID0gcmVxdWlyZShcIi4vbGliL2JpZGl1dGlsXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdTIwMkJdLztcbnZhciBCaWRpSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaWRpSGFuZGxlcihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuYmlkaU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRSb3cgPSBudWxsO1xuICAgICAgICB0aGlzLmJpZGlVdGlsID0gYmlkaVV0aWw7XG4gICAgICAgIHRoaXMuY2hhcldpZHRocyA9IFtdO1xuICAgICAgICB0aGlzLkVPTCA9IFwiXFx4QUNcIjtcbiAgICAgICAgdGhpcy5zaG93SW52aXNpYmxlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNSdGxEaXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kaXNSdGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lID0gXCJcIjtcbiAgICAgICAgdGhpcy53cmFwSW5kZW50ID0gMDtcbiAgICAgICAgdGhpcy5FT0YgPSBcIlxceEI2XCI7XG4gICAgICAgIHRoaXMuUkxFID0gXCJcXHUyMDJCXCI7XG4gICAgICAgIHRoaXMuY29udGVudFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5mb250TWV0cmljcyA9IG51bGw7XG4gICAgICAgIHRoaXMucnRsTGluZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMud3JhcE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuaXNNb3ZlTGVmdE9wZXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlZW5CaWRpID0gYmlkaVJFLnRlc3Qoc2Vzc2lvbi5nZXRWYWx1ZSgpKTtcbiAgICB9XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLmlzQmlkaVJvdyA9IGZ1bmN0aW9uIChzY3JlZW5Sb3csIGRvY1Jvdywgc3BsaXRJbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlbkJpZGkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzY3JlZW5Sb3cgIT09IHRoaXMuY3VycmVudFJvdykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Um93ID0gc2NyZWVuUm93O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSb3dMaW5lKGRvY1Jvdywgc3BsaXRJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJpZGlNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iaWRpTWFwLmJpZGlMZXZlbHM7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZW5CaWRpKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCIgJiYgYmlkaVJFLnRlc3QoZGVsdGEubGluZXMuam9pbihcIlxcblwiKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZW5CaWRpID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3cgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Um93ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLmdldERvY3VtZW50Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jUm93ID0gMDtcbiAgICAgICAgdmFyIHJvd0NhY2hlID0gdGhpcy5zZXNzaW9uLiRzY3JlZW5Sb3dDYWNoZTtcbiAgICAgICAgaWYgKHJvd0NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zZXNzaW9uLiRnZXRSb3dDYWNoZUluZGV4KHJvd0NhY2hlLCB0aGlzLmN1cnJlbnRSb3cpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgZG9jUm93ID0gdGhpcy5zZXNzaW9uLiRkb2NSb3dDYWNoZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY1JvdztcbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5nZXRTcGxpdEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IDA7XG4gICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuc2Vzc2lvbi4kc2NyZWVuUm93Q2FjaGU7XG4gICAgICAgIGlmIChyb3dDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXgsIHByZXZJbmRleCA9IHRoaXMuc2Vzc2lvbi4kZ2V0Um93Q2FjaGVJbmRleChyb3dDYWNoZSwgdGhpcy5jdXJyZW50Um93KTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnRSb3cgLSBzcGxpdEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IHRoaXMuc2Vzc2lvbi4kZ2V0Um93Q2FjaGVJbmRleChyb3dDYWNoZSwgdGhpcy5jdXJyZW50Um93IC0gc3BsaXRJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IHByZXZJbmRleClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIHNwbGl0SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwbGl0SW5kZXggPSB0aGlzLmN1cnJlbnRSb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0SW5kZXg7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUudXBkYXRlUm93TGluZSA9IGZ1bmN0aW9uIChkb2NSb3csIHNwbGl0SW5kZXgpIHtcbiAgICAgICAgaWYgKGRvY1JvdyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZG9jUm93ID0gdGhpcy5nZXREb2N1bWVudFJvdygpO1xuICAgICAgICB2YXIgaXNMYXN0Um93ID0gKGRvY1JvdyA9PT0gdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpIC0gMSksIGVuZE9mTGluZSA9IGlzTGFzdFJvdyA/IHRoaXMuRU9GIDogdGhpcy5FT0w7XG4gICAgICAgIHRoaXMud3JhcEluZGVudCA9IDA7XG4gICAgICAgIHRoaXMubGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGRvY1Jvdyk7XG4gICAgICAgIHRoaXMuaXNSdGxEaXIgPSB0aGlzLiRpc1J0bCB8fCB0aGlzLmxpbmUuY2hhckF0KDApID09PSB0aGlzLlJMRTtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdHMgPSB0aGlzLnNlc3Npb24uJHdyYXBEYXRhW2RvY1Jvd107XG4gICAgICAgICAgICBpZiAoc3BsaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0SW5kZXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRJbmRleCA9IHRoaXMuZ2V0U3BsaXRJbmRleCgpO1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdEluZGV4ID4gMCAmJiBzcGxpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcEluZGVudCA9IHNwbGl0cy5pbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcE9mZnNldCA9IHRoaXMud3JhcEluZGVudCAqIHRoaXMuY2hhcldpZHRoc1tiaWRpVXRpbC5MXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lID0gKHNwbGl0SW5kZXggPCBzcGxpdHMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUuc3Vic3RyaW5nKHNwbGl0c1tzcGxpdEluZGV4IC0gMV0sIHNwbGl0c1tzcGxpdEluZGV4XSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lLnN1YnN0cmluZyhzcGxpdHNbc3BsaXRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMubGluZS5zdWJzdHJpbmcoMCwgc3BsaXRzW3NwbGl0SW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0SW5kZXggPT0gc3BsaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgKz0gKHRoaXMuc2hvd0ludmlzaWJsZXMpID8gZW5kT2ZMaW5lIDogYmlkaVV0aWwuRE9UO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZSArPSB0aGlzLnNob3dJbnZpc2libGVzID8gZW5kT2ZMaW5lIDogYmlkaVV0aWwuRE9UO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uLCBzaGlmdCA9IDAsIHNpemU7XG4gICAgICAgIHRoaXMubGluZSA9IHRoaXMubGluZS5yZXBsYWNlKC9cXHR8W1xcdTExMDAtXFx1MjAyOSwgXFx1MjAyRi1cXHVGRkU2XS9nLCBmdW5jdGlvbiAoY2gsIGkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcdCcgfHwgc2Vzc2lvbi5pc0Z1bGxXaWR0aChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAoY2ggPT09ICdcXHQnKSA/IHNlc3Npb24uZ2V0U2NyZWVuVGFiU2l6ZShpICsgc2hpZnQpIDogMjtcbiAgICAgICAgICAgICAgICBzaGlmdCArPSBzaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZy5zdHJpbmdSZXBlYXQoYmlkaVV0aWwuRE9ULCBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlzUnRsRGlyKSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRNZXRyaWNzLiRtYWluLnRleHRDb250ZW50ID0gKHRoaXMubGluZS5jaGFyQXQodGhpcy5saW5lLmxlbmd0aCAtIDEpID09IGJpZGlVdGlsLkRPVCkgPyB0aGlzLmxpbmUuc3Vic3RyKDAsIHRoaXMubGluZS5sZW5ndGggLSAxKSA6IHRoaXMubGluZTtcbiAgICAgICAgICAgIHRoaXMucnRsTGluZU9mZnNldCA9IHRoaXMuY29udGVudFdpZHRoIC0gdGhpcy5mb250TWV0cmljcy4kbWFpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUJpZGlNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0Q2hhclR5cGVzID0gW107XG4gICAgICAgIGlmIChiaWRpVXRpbC5oYXNCaWRpQ2hhcmFjdGVycyh0aGlzLmxpbmUsIHRleHRDaGFyVHlwZXMpIHx8IHRoaXMuaXNSdGxEaXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmlkaU1hcCA9IGJpZGlVdGlsLmRvQmlkaVJlb3JkZXIodGhpcy5saW5lLCB0ZXh0Q2hhclR5cGVzLCB0aGlzLmlzUnRsRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmlkaU1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUubWFya0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFJvdyA9IG51bGw7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUudXBkYXRlQ2hhcmFjdGVyV2lkdGhzID0gZnVuY3Rpb24gKGZvbnRNZXRyaWNzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXJhY3RlcldpZHRoID09PSBmb250TWV0cmljcy4kY2hhcmFjdGVyU2l6ZS53aWR0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5mb250TWV0cmljcyA9IGZvbnRNZXRyaWNzO1xuICAgICAgICB2YXIgY2hhcmFjdGVyV2lkdGggPSB0aGlzLmNoYXJhY3RlcldpZHRoID0gZm9udE1ldHJpY3MuJGNoYXJhY3RlclNpemUud2lkdGg7XG4gICAgICAgIHZhciBiaWRpQ2hhcldpZHRoID0gZm9udE1ldHJpY3MuJG1lYXN1cmVDaGFyV2lkdGgoXCJcXHUwNWQ0XCIpO1xuICAgICAgICB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuTF0gPSB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuRU5dID0gdGhpcy5jaGFyV2lkdGhzW2JpZGlVdGlsLk9OX1JdID0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoc1tiaWRpVXRpbC5SXSA9IHRoaXMuY2hhcldpZHRoc1tiaWRpVXRpbC5BTl0gPSBiaWRpQ2hhcldpZHRoO1xuICAgICAgICB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuUl9IXSA9IGJpZGlDaGFyV2lkdGggKiAwLjQ1O1xuICAgICAgICB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuQl0gPSB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuUkxFXSA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFJvdyA9IG51bGw7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbiAoc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgdGhpcy5zaG93SW52aXNpYmxlcyA9IHNob3dJbnZpc2libGVzO1xuICAgICAgICB0aGlzLmN1cnJlbnRSb3cgPSBudWxsO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnNldEVvbENoYXIgPSBmdW5jdGlvbiAoZW9sQ2hhcikge1xuICAgICAgICB0aGlzLkVPTCA9IGVvbENoYXI7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUuc2V0Q29udGVudFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICAgIHRoaXMuY29udGVudFdpZHRoID0gd2lkdGg7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUuaXNSdGxMaW5lID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBpZiAodGhpcy4kaXNSdGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHJvdyAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdykuY2hhckF0KDApID09IHRoaXMuUkxFKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNSdGxEaXI7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUuc2V0UnRsRGlyZWN0aW9uID0gZnVuY3Rpb24gKGVkaXRvciwgaXNSdGxEaXIpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkFuY2hvcigpLnJvdzsgcm93IDw9IGN1cnNvci5yb3c7IHJvdysrKSB7XG4gICAgICAgICAgICBpZiAoIWlzUnRsRGlyICYmIGVkaXRvci5zZXNzaW9uLmdldExpbmUocm93KS5jaGFyQXQoMCkgPT09IGVkaXRvci5zZXNzaW9uLiRiaWRpSGFuZGxlci5STEUpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24uZG9jLnJlbW92ZUluTGluZShyb3csIDAsIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNSdGxEaXIgJiYgZWRpdG9yLnNlc3Npb24uZ2V0TGluZShyb3cpLmNoYXJBdCgwKSAhPT0gZWRpdG9yLnNlc3Npb24uJGJpZGlIYW5kbGVyLlJMRSlcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5kb2MuaW5zZXJ0KHsgY29sdW1uOiAwLCByb3c6IHJvdyB9LCBlZGl0b3Iuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuUkxFKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLmdldFBvc0xlZnQgPSBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIGNvbCAtPSB0aGlzLndyYXBJbmRlbnQ7XG4gICAgICAgIHZhciBsZWZ0Qm91bmRhcnkgPSAodGhpcy5saW5lLmNoYXJBdCgwKSA9PT0gdGhpcy5STEUpID8gMSA6IDA7XG4gICAgICAgIHZhciBsb2dpY2FsSWR4ID0gKGNvbCA+IGxlZnRCb3VuZGFyeSkgPyAodGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpID8gY29sIDogY29sIC0gMSkgOiBsZWZ0Qm91bmRhcnk7XG4gICAgICAgIHZhciB2aXN1YWxJZHggPSBiaWRpVXRpbC5nZXRWaXN1YWxGcm9tTG9naWNhbElkeChsb2dpY2FsSWR4LCB0aGlzLmJpZGlNYXApLCBsZXZlbHMgPSB0aGlzLmJpZGlNYXAuYmlkaUxldmVscywgbGVmdCA9IDA7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpICYmIGNvbCA8PSBsZWZ0Qm91bmRhcnkgJiYgbGV2ZWxzW3Zpc3VhbElkeF0gJSAyICE9PSAwKVxuICAgICAgICAgICAgdmlzdWFsSWR4Kys7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzdWFsSWR4OyBpKyspIHtcbiAgICAgICAgICAgIGxlZnQgKz0gdGhpcy5jaGFyV2lkdGhzW2xldmVsc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24uZ2V0T3ZlcndyaXRlKCkgJiYgKGNvbCA+IGxlZnRCb3VuZGFyeSkgJiYgKGxldmVsc1t2aXN1YWxJZHhdICUgMiA9PT0gMCkpXG4gICAgICAgICAgICBsZWZ0ICs9IHRoaXMuY2hhcldpZHRoc1tsZXZlbHNbdmlzdWFsSWR4XV07XG4gICAgICAgIGlmICh0aGlzLndyYXBJbmRlbnQpXG4gICAgICAgICAgICBsZWZ0ICs9IHRoaXMuaXNSdGxEaXIgPyAoLTEgKiB0aGlzLndyYXBPZmZzZXQpIDogdGhpcy53cmFwT2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy5pc1J0bERpcilcbiAgICAgICAgICAgIGxlZnQgKz0gdGhpcy5ydGxMaW5lT2Zmc2V0O1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25zID0gZnVuY3Rpb24gKHN0YXJ0Q29sLCBlbmRDb2wpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuYmlkaU1hcCwgbGV2ZWxzID0gbWFwLmJpZGlMZXZlbHMsIGxldmVsLCBzZWxlY3Rpb25zID0gW10sIG9mZnNldCA9IDAsIHNlbENvbE1pbiA9IE1hdGgubWluKHN0YXJ0Q29sLCBlbmRDb2wpIC0gdGhpcy53cmFwSW5kZW50LCBzZWxDb2xNYXggPSBNYXRoLm1heChzdGFydENvbCwgZW5kQ29sKSAtIHRoaXMud3JhcEluZGVudCwgaXNTZWxlY3RlZCA9IGZhbHNlLCBpc1NlbGVjdGVkUHJldiA9IGZhbHNlLCBzZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIGlmICh0aGlzLndyYXBJbmRlbnQpXG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5pc1J0bERpciA/ICgtMSAqIHRoaXMud3JhcE9mZnNldCkgOiB0aGlzLndyYXBPZmZzZXQ7XG4gICAgICAgIGZvciAodmFyIGxvZ0lkeCwgdmlzSWR4ID0gMDsgdmlzSWR4IDwgbGV2ZWxzLmxlbmd0aDsgdmlzSWR4KyspIHtcbiAgICAgICAgICAgIGxvZ0lkeCA9IG1hcC5sb2dpY2FsRnJvbVZpc3VhbFt2aXNJZHhdO1xuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbdmlzSWR4XTtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSAobG9nSWR4ID49IHNlbENvbE1pbikgJiYgKGxvZ0lkeCA8IHNlbENvbE1heCk7XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiAhaXNTZWxlY3RlZFByZXYpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1NlbGVjdGVkICYmIGlzU2VsZWN0ZWRQcmV2KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHsgbGVmdDogc2VsZWN0aW9uU3RhcnQsIHdpZHRoOiBvZmZzZXQgLSBzZWxlY3Rpb25TdGFydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmNoYXJXaWR0aHNbbGV2ZWxdO1xuICAgICAgICAgICAgaXNTZWxlY3RlZFByZXYgPSBpc1NlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlbGVjdGVkICYmICh2aXNJZHggPT09IGxldmVscy5sZW5ndGgpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25zLnB1c2goeyBsZWZ0OiBzZWxlY3Rpb25TdGFydCwgd2lkdGg6IG9mZnNldCAtIHNlbGVjdGlvblN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUnRsRGlyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zW2ldLmxlZnQgKz0gdGhpcy5ydGxMaW5lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25zO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLm9mZnNldFRvQ29sID0gZnVuY3Rpb24gKHBvc1gpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdGxEaXIpXG4gICAgICAgICAgICBwb3NYIC09IHRoaXMucnRsTGluZU9mZnNldDtcbiAgICAgICAgdmFyIGxvZ2ljYWxJZHggPSAwLCBwb3NYID0gTWF0aC5tYXgocG9zWCwgMCksIG9mZnNldCA9IDAsIHZpc3VhbElkeCA9IDAsIGxldmVscyA9IHRoaXMuYmlkaU1hcC5iaWRpTGV2ZWxzLCBjaGFyV2lkdGggPSB0aGlzLmNoYXJXaWR0aHNbbGV2ZWxzW3Zpc3VhbElkeF1dO1xuICAgICAgICBpZiAodGhpcy53cmFwSW5kZW50KVxuICAgICAgICAgICAgcG9zWCAtPSB0aGlzLmlzUnRsRGlyID8gKC0xICogdGhpcy53cmFwT2Zmc2V0KSA6IHRoaXMud3JhcE9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvc1ggPiBvZmZzZXQgKyBjaGFyV2lkdGggLyAyKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hhcldpZHRoO1xuICAgICAgICAgICAgaWYgKHZpc3VhbElkeCA9PT0gbGV2ZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcldpZHRoID0gdGhpcy5jaGFyV2lkdGhzW2xldmVsc1srK3Zpc3VhbElkeF1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXN1YWxJZHggPiAwICYmIChsZXZlbHNbdmlzdWFsSWR4IC0gMV0gJSAyICE9PSAwKSAmJiAobGV2ZWxzW3Zpc3VhbElkeF0gJSAyID09PSAwKSkge1xuICAgICAgICAgICAgaWYgKHBvc1ggPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgdmlzdWFsSWR4LS07XG4gICAgICAgICAgICBsb2dpY2FsSWR4ID0gdGhpcy5iaWRpTWFwLmxvZ2ljYWxGcm9tVmlzdWFsW3Zpc3VhbElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlzdWFsSWR4ID4gMCAmJiAobGV2ZWxzW3Zpc3VhbElkeCAtIDFdICUgMiA9PT0gMCkgJiYgKGxldmVsc1t2aXN1YWxJZHhdICUgMiAhPT0gMCkpIHtcbiAgICAgICAgICAgIGxvZ2ljYWxJZHggPSAxICsgKChwb3NYID4gb2Zmc2V0KSA/IHRoaXMuYmlkaU1hcC5sb2dpY2FsRnJvbVZpc3VhbFt2aXN1YWxJZHhdXG4gICAgICAgICAgICAgICAgOiB0aGlzLmJpZGlNYXAubG9naWNhbEZyb21WaXN1YWxbdmlzdWFsSWR4IC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLmlzUnRsRGlyICYmIHZpc3VhbElkeCA9PT0gbGV2ZWxzLmxlbmd0aCAtIDEgJiYgY2hhcldpZHRoID09PSAwICYmIChsZXZlbHNbdmlzdWFsSWR4IC0gMV0gJSAyID09PSAwKSlcbiAgICAgICAgICAgIHx8ICghdGhpcy5pc1J0bERpciAmJiB2aXN1YWxJZHggPT09IDAgJiYgKGxldmVsc1t2aXN1YWxJZHhdICUgMiAhPT0gMCkpKSB7XG4gICAgICAgICAgICBsb2dpY2FsSWR4ID0gMSArIHRoaXMuYmlkaU1hcC5sb2dpY2FsRnJvbVZpc3VhbFt2aXN1YWxJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZpc3VhbElkeCA+IDAgJiYgKGxldmVsc1t2aXN1YWxJZHggLSAxXSAlIDIgIT09IDApICYmIGNoYXJXaWR0aCAhPT0gMClcbiAgICAgICAgICAgICAgICB2aXN1YWxJZHgtLTtcbiAgICAgICAgICAgIGxvZ2ljYWxJZHggPSB0aGlzLmJpZGlNYXAubG9naWNhbEZyb21WaXN1YWxbdmlzdWFsSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9naWNhbElkeCA9PT0gMCAmJiB0aGlzLmlzUnRsRGlyKVxuICAgICAgICAgICAgbG9naWNhbElkeCsrO1xuICAgICAgICByZXR1cm4gKGxvZ2ljYWxJZHggKyB0aGlzLndyYXBJbmRlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpZGlIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuQmlkaUhhbmRsZXIgPSBCaWRpSGFuZGxlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uvc2VsZWN0aW9uXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBTZWxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5kb2MgPSBzZXNzaW9uLmdldERvY3VtZW50KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmxlYWQgPSB0aGlzLmRvYy5jcmVhdGVBbmNob3IoMCwgMCk7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gdGhpcy5kb2MuY3JlYXRlQW5jaG9yKDAsIDApO1xuICAgICAgICB0aGlzLiRzaWxlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmN1cnNvci5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi4kY3Vyc29yQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXNlbGYuJHNpbGVudClcbiAgICAgICAgICAgICAgICBzZWxmLl9lbWl0KFwiY2hhbmdlQ3Vyc29yXCIpO1xuICAgICAgICAgICAgaWYgKCFzZWxmLiRpc0VtcHR5ICYmICFzZWxmLiRzaWxlbnQpXG4gICAgICAgICAgICAgICAgc2VsZi5fZW1pdChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIGlmICghc2VsZi4ka2VlcERlc2lyZWRDb2x1bW5PbkNoYW5nZSAmJiBlLm9sZC5jb2x1bW4gIT0gZS52YWx1ZS5jb2x1bW4pXG4gICAgICAgICAgICAgICAgc2VsZi4kZGVzaXJlZENvbHVtbiA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuY2hvci5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLiRhbmNob3JDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghc2VsZi4kaXNFbXB0eSAmJiAhc2VsZi4kc2lsZW50KVxuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpc0VtcHR5IHx8ICh0aGlzLmFuY2hvci5yb3cgPT0gdGhpcy5sZWFkLnJvdyAmJlxuICAgICAgICAgICAgdGhpcy5hbmNob3IuY29sdW1uID09IHRoaXMubGVhZC5jb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5pc011bHRpTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLiRpc0VtcHR5ICYmIHRoaXMuYW5jaG9yLnJvdyAhPSB0aGlzLmN1cnNvci5yb3c7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmdldEN1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZC5nZXRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRBbmNob3IgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy4kaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuY2hvci5zZXRQb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmdldEFuY2hvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25MZWFkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvci5nZXRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25MZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWFkLmdldFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmlzQmFja3dhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICByZXR1cm4gKGFuY2hvci5yb3cgPiBsZWFkLnJvdyB8fCAoYW5jaG9yLnJvdyA9PSBsZWFkLnJvdyAmJiBhbmNob3IuY29sdW1uID4gbGVhZC5jb2x1bW4pKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIGlmICh0aGlzLiRpc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMobGVhZCwgbGVhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQmFja3dhcmRzKClcbiAgICAgICAgICAgID8gUmFuZ2UuZnJvbVBvaW50cyhsZWFkLCBhbmNob3IpXG4gICAgICAgICAgICA6IFJhbmdlLmZyb21Qb2ludHMoYW5jaG9yLCBsZWFkKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kaXNFbXB0eSkge1xuICAgICAgICAgICAgdGhpcy4kaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlU2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kc2V0U2VsZWN0aW9uKDAsIDAsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgcmV2ZXJzZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSByZXZlcnNlID8gcmFuZ2UuZW5kIDogcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSByZXZlcnNlID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7XG4gICAgICAgIHRoaXMuJHNldFNlbGVjdGlvbihzdGFydC5yb3csIHN0YXJ0LmNvbHVtbiwgZW5kLnJvdywgZW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLiRzZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoYW5jaG9yUm93LCBhbmNob3JDb2x1bW4sIGN1cnNvclJvdywgY3Vyc29yQ29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLiRzaWxlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB3YXNFbXB0eSA9IHRoaXMuJGlzRW1wdHk7XG4gICAgICAgIHZhciB3YXNNdWx0aXNlbGVjdCA9IHRoaXMuaW5NdWx0aVNlbGVjdE1vZGU7XG4gICAgICAgIHRoaXMuJHNpbGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuJGN1cnNvckNoYW5nZWQgPSB0aGlzLiRhbmNob3JDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5jaG9yLnNldFBvc2l0aW9uKGFuY2hvclJvdywgYW5jaG9yQ29sdW1uKTtcbiAgICAgICAgdGhpcy5jdXJzb3Iuc2V0UG9zaXRpb24oY3Vyc29yUm93LCBjdXJzb3JDb2x1bW4pO1xuICAgICAgICB0aGlzLiRpc0VtcHR5ID0gIVJhbmdlLmNvbXBhcmVQb2ludHModGhpcy5hbmNob3IsIHRoaXMuY3Vyc29yKTtcbiAgICAgICAgdGhpcy4kc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiRjdXJzb3JDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZUN1cnNvclwiKTtcbiAgICAgICAgaWYgKHRoaXMuJGN1cnNvckNoYW5nZWQgfHwgdGhpcy4kYW5jaG9yQ2hhbmdlZCB8fCB3YXNFbXB0eSAhPSB0aGlzLiRpc0VtcHR5IHx8IHdhc011bHRpc2VsZWN0KVxuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuJG1vdmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAobW92ZXIpIHtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIGlmICh0aGlzLiRpc0VtcHR5KVxuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25BbmNob3IobGVhZC5yb3csIGxlYWQuY29sdW1uKTtcbiAgICAgICAgbW92ZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0VG8gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZVRvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihwb3MpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JVcCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdERvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yRG93bik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvclJpZ2h0KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JMZWZ0KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0TGluZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckxpbmVTdGFydCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdExpbmVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yTGluZUVuZCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdEZpbGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yRmlsZUVuZCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdEZpbGVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JGaWxlU3RhcnQpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RXb3JkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yV29yZFJpZ2h0KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0V29yZExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yV29yZExlZnQpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRXb3JkUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJvdyB8fCB0aGlzLmxlYWQ7XG4gICAgICAgICAgICByb3cgPSBjdXJzb3Iucm93O1xuICAgICAgICAgICAgY29sdW1uID0gY3Vyc29yLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFdvcmRSYW5nZShyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdFdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5nZXRXb3JkUmFuZ2UoKSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdEFXb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZXNzaW9uLmdldEFXb3JkUmFuZ2UoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRMaW5lUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBleGNsdWRlTGFzdENoYXIpIHtcbiAgICAgICAgdmFyIHJvd1N0YXJ0ID0gdHlwZW9mIHJvdyA9PSBcIm51bWJlclwiID8gcm93IDogdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIHJvd0VuZDtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldEZvbGRMaW5lKHJvd1N0YXJ0KTtcbiAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICByb3dTdGFydCA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIHJvd0VuZCA9IGZvbGRMaW5lLmVuZC5yb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dFbmQgPSByb3dTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjbHVkZUxhc3RDaGFyID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyb3dTdGFydCwgMCwgcm93RW5kLCB0aGlzLnNlc3Npb24uZ2V0TGluZShyb3dFbmQpLmxlbmd0aCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uocm93U3RhcnQsIDAsIHJvd0VuZCArIDEsIDApO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKHRoaXMuZ2V0TGluZVJhbmdlKCkpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KC0xLCAwKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDEsIDApO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS53b3VsZE1vdmVJbnRvU29mdFRhYiA9IGZ1bmN0aW9uIChjdXJzb3IsIHRhYlNpemUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBjdXJzb3IuY29sdW1uO1xuICAgICAgICB2YXIgZW5kID0gY3Vyc29yLmNvbHVtbiArIHRhYlNpemU7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IGN1cnNvci5jb2x1bW4gLSB0YWJTaXplO1xuICAgICAgICAgICAgZW5kID0gY3Vyc29yLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmlzVGFiU3RvcChjdXJzb3IpICYmIHRoaXMuZG9jLmdldExpbmUoY3Vyc29yLnJvdykuc2xpY2Uoc3RhcnQsIGVuZCkuc3BsaXQoXCIgXCIpLmxlbmd0aCAtIDEgPT0gdGFiU2l6ZTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKSwgZm9sZDtcbiAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4sIC0xKSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhjdXJzb3Iucm93IC0gMSwgdGhpcy5kb2MuZ2V0TGluZShjdXJzb3Iucm93IC0gMSkubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLndvdWxkTW92ZUludG9Tb2Z0VGFiKGN1cnNvciwgdGFiU2l6ZSwgLTEpICYmICF0aGlzLnNlc3Npb24uZ2V0TmF2aWdhdGVXaXRoaW5Tb2Z0VGFicygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkoMCwgLXRhYlNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMubGVhZC5nZXRQb3NpdGlvbigpLCBmb2xkO1xuICAgICAgICBpZiAoZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbiwgMSkpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlYWQuY29sdW1uID09IHRoaXMuZG9jLmdldExpbmUodGhpcy5sZWFkLnJvdykubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWFkLnJvdyA8IHRoaXMuZG9jLmdldExlbmd0aCgpIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHRoaXMubGVhZC5yb3cgKyAxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmxlYWQ7XG4gICAgICAgICAgICBpZiAodGhpcy53b3VsZE1vdmVJbnRvU29mdFRhYihjdXJzb3IsIHRhYlNpemUsIDEpICYmICF0aGlzLnNlc3Npb24uZ2V0TmF2aWdhdGVXaXRoaW5Tb2Z0VGFicygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkoMCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JCeSgwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yTGluZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XG4gICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhyb3csIGNvbHVtbik7XG4gICAgICAgIHZhciBmaXJzdENvbHVtblBvc2l0aW9uID0gdGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIDApO1xuICAgICAgICB2YXIgYmVmb3JlQ3Vyc29yID0gdGhpcy5zZXNzaW9uLmdldERpc3BsYXlMaW5lKHJvdywgbnVsbCwgZmlyc3RDb2x1bW5Qb3NpdGlvbi5yb3csIGZpcnN0Q29sdW1uUG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgdmFyIGxlYWRpbmdTcGFjZSA9IGJlZm9yZUN1cnNvci5tYXRjaCgvXlxccyovKTtcbiAgICAgICAgaWYgKGxlYWRpbmdTcGFjZVswXS5sZW5ndGggIT0gY29sdW1uICYmICF0aGlzLnNlc3Npb24uJHVzZUVtYWNzU3R5bGVMaW5lU3RhcnQpXG4gICAgICAgICAgICBmaXJzdENvbHVtblBvc2l0aW9uLmNvbHVtbiArPSBsZWFkaW5nU3BhY2VbMF0ubGVuZ3RoO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKGZpcnN0Q29sdW1uUG9zaXRpb24pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yTGluZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIHZhciBsaW5lRW5kID0gdGhpcy5zZXNzaW9uLmdldERvY3VtZW50TGFzdFJvd0NvbHVtblBvc2l0aW9uKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XG4gICAgICAgIGlmICh0aGlzLmxlYWQuY29sdW1uID09IGxpbmVFbmQuY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGxpbmVFbmQucm93KTtcbiAgICAgICAgICAgIGlmIChsaW5lRW5kLmNvbHVtbiA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0RW5kID0gbGluZS5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbmQgPiAwKVxuICAgICAgICAgICAgICAgICAgICBsaW5lRW5kLmNvbHVtbiA9IHRleHRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8obGluZUVuZC5yb3csIGxpbmVFbmQuY29sdW1uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckZpbGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmRvYy5nZXRMZW5ndGgoKSAtIDE7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmRvYy5nZXRMaW5lKHJvdykubGVuZ3RoO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JGaWxlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKDAsIDApO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yTG9uZ1dvcmRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMubGVhZC5yb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxlYWQuY29sdW1uO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcbiAgICAgICAgdmFyIHJpZ2h0T2ZDdXJzb3IgPSBsaW5lLnN1YnN0cmluZyhjb2x1bW4pO1xuICAgICAgICB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBjb2x1bW4sIDEpO1xuICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5leGVjKHJpZ2h0T2ZDdXJzb3IpKSB7XG4gICAgICAgICAgICBjb2x1bW4gKz0gdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHJpZ2h0T2ZDdXJzb3IgPSBsaW5lLnN1YnN0cmluZyhjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4gPj0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgbGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yUmlnaHQoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPCB0aGlzLmRvYy5nZXRMZW5ndGgoKSAtIDEpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yV29yZFJpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi50b2tlblJlLmV4ZWMocmlnaHRPZkN1cnNvcikpIHtcbiAgICAgICAgICAgIGNvbHVtbiArPSB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckxvbmdXb3JkTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMubGVhZC5yb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxlYWQuY29sdW1uO1xuICAgICAgICB2YXIgZm9sZDtcbiAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAtMSkpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkU3RyaW5nQXQocm93LCBjb2x1bW4sIC0xKTtcbiAgICAgICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdykuc3Vic3RyaW5nKDAsIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnRPZkN1cnNvciA9IGxhbmcuc3RyaW5nUmV2ZXJzZShzdHIpO1xuICAgICAgICB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLm5vblRva2VuUmUuZXhlYyhsZWZ0T2ZDdXJzb3IpKSB7XG4gICAgICAgICAgICBjb2x1bW4gLT0gdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4O1xuICAgICAgICAgICAgbGVmdE9mQ3Vyc29yID0gbGVmdE9mQ3Vyc29yLnNsaWNlKHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4gPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCAwKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckxlZnQoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcldvcmRMZWZ0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi50b2tlblJlLmV4ZWMobGVmdE9mQ3Vyc29yKSkge1xuICAgICAgICAgICAgY29sdW1uIC09IHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS4kc2hvcnRXb3JkRW5kSW5kZXggPSBmdW5jdGlvbiAocmlnaHRPZkN1cnNvcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwLCBjaDtcbiAgICAgICAgdmFyIHdoaXRlc3BhY2VSZSA9IC9cXHMvO1xuICAgICAgICB2YXIgdG9rZW5SZSA9IHRoaXMuc2Vzc2lvbi50b2tlblJlO1xuICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24udG9rZW5SZS5leGVjKHJpZ2h0T2ZDdXJzb3IpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgoY2ggPSByaWdodE9mQ3Vyc29yW2luZGV4XSkgJiYgd2hpdGVzcGFjZVJlLnRlc3QoY2gpKVxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAxKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSByaWdodE9mQ3Vyc29yW2luZGV4XSkgJiYgIXRva2VuUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2hpdGVzcGFjZVJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSByaWdodE9mQ3Vyc29yW2luZGV4XSkgJiYgd2hpdGVzcGFjZVJlLnRlc3QoY2gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yU2hvcnRXb3JkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciByaWdodE9mQ3Vyc29yID0gbGluZS5zdWJzdHJpbmcoY29sdW1uKTtcbiAgICAgICAgdmFyIGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAxKTtcbiAgICAgICAgaWYgKGZvbGQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICBpZiAoY29sdW1uID09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZG9jLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgIHJpZ2h0T2ZDdXJzb3IgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XG4gICAgICAgICAgICB9IHdoaWxlIChyb3cgPCBsICYmIC9eXFxzKiQvLnRlc3QocmlnaHRPZkN1cnNvcikpO1xuICAgICAgICAgICAgaWYgKCEvXlxccysvLnRlc3QocmlnaHRPZkN1cnNvcikpXG4gICAgICAgICAgICAgICAgcmlnaHRPZkN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICBjb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuJHNob3J0V29yZEVuZEluZGV4KHJpZ2h0T2ZDdXJzb3IpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbiArIGluZGV4KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvclNob3J0V29yZExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcbiAgICAgICAgdmFyIGZvbGQ7XG4gICAgICAgIGlmIChmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChyb3csIGNvbHVtbiwgLTEpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUocm93KS5zdWJzdHJpbmcoMCwgY29sdW1uKTtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJvdy0tO1xuICAgICAgICAgICAgICAgIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XG4gICAgICAgICAgICB9IHdoaWxlIChyb3cgPiAwICYmIC9eXFxzKiQvLnRlc3QobGluZSkpO1xuICAgICAgICAgICAgY29sdW1uID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIS9cXHMrJC8udGVzdChsaW5lKSlcbiAgICAgICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdE9mQ3Vyc29yID0gbGFuZy5zdHJpbmdSZXZlcnNlKGxpbmUpO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLiRzaG9ydFdvcmRFbmRJbmRleChsZWZ0T2ZDdXJzb3IpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4gLSBpbmRleCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JXb3JkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uJHNlbGVjdExvbmdXb3JkcylcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckxvbmdXb3JkUmlnaHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yU2hvcnRXb3JkUmlnaHQoKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvcldvcmRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRzZWxlY3RMb25nV29yZHMpXG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JMb25nV29yZExlZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yU2hvcnRXb3JkTGVmdCgpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yQnkgPSBmdW5jdGlvbiAocm93cywgY2hhcnMpIHtcbiAgICAgICAgdmFyIHNjcmVlblBvcyA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5sZWFkLnJvdywgdGhpcy5sZWFkLmNvbHVtbik7XG4gICAgICAgIHZhciBvZmZzZXRYO1xuICAgICAgICBpZiAoY2hhcnMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyb3dzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuaXNCaWRpUm93KHNjcmVlblBvcy5yb3csIHRoaXMubGVhZC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSB0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLmdldFBvc0xlZnQoc2NyZWVuUG9zLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblBvcy5jb2x1bW4gPSBNYXRoLnJvdW5kKG9mZnNldFggLyB0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLmNoYXJXaWR0aHNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHNjcmVlblBvcy5jb2x1bW4gKiB0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLmNoYXJXaWR0aHNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJGRlc2lyZWRDb2x1bW4pXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zLmNvbHVtbiA9IHRoaXMuJGRlc2lyZWRDb2x1bW47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IHNjcmVlblBvcy5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvd3MgIT0gMCAmJiB0aGlzLnNlc3Npb24ubGluZVdpZGdldHMgJiYgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3RoaXMubGVhZC5yb3ddKSB7XG4gICAgICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3RoaXMubGVhZC5yb3ddO1xuICAgICAgICAgICAgaWYgKHJvd3MgPCAwKVxuICAgICAgICAgICAgICAgIHJvd3MgLT0gd2lkZ2V0LnJvd3NBYm92ZSB8fCAwO1xuICAgICAgICAgICAgZWxzZSBpZiAocm93cyA+IDApXG4gICAgICAgICAgICAgICAgcm93cyArPSB3aWRnZXQucm93Q291bnQgLSAod2lkZ2V0LnJvd3NBYm92ZSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jUG9zID0gdGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Qb3Mucm93ICsgcm93cywgc2NyZWVuUG9zLmNvbHVtbiwgb2Zmc2V0WCk7XG4gICAgICAgIGlmIChyb3dzICE9PSAwICYmIGNoYXJzID09PSAwICYmIGRvY1Bvcy5yb3cgPT09IHRoaXMubGVhZC5yb3cgJiYgZG9jUG9zLmNvbHVtbiA9PT0gdGhpcy5sZWFkLmNvbHVtbikge1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGRvY1Bvcy5yb3csIGRvY1Bvcy5jb2x1bW4gKyBjaGFycywgY2hhcnMgPT09IDApO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JUbyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwga2VlcERlc2lyZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAxKTtcbiAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgIHJvdyA9IGZvbGQuc3RhcnQucm93O1xuICAgICAgICAgICAgY29sdW1uID0gZm9sZC5zdGFydC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4ka2VlcERlc2lyZWRDb2x1bW5PbkNoYW5nZSA9IHRydWU7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgaWYgKC9bXFx1REMwMC1cXHVERkZGXS8udGVzdChsaW5lLmNoYXJBdChjb2x1bW4pKSAmJiBsaW5lLmNoYXJBdChjb2x1bW4gLSAxKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVhZC5yb3cgPT0gcm93ICYmIHRoaXMubGVhZC5jb2x1bW4gPT0gY29sdW1uICsgMSlcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWFkLnNldFBvc2l0aW9uKHJvdywgY29sdW1uKTtcbiAgICAgICAgdGhpcy4ka2VlcERlc2lyZWRDb2x1bW5PbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIWtlZXBEZXNpcmVkQ29sdW1uKVxuICAgICAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IG51bGw7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JUb1NjcmVlbiA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwga2VlcERlc2lyZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24ocm93LCBjb2x1bW4pO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhwb3Mucm93LCBwb3MuY29sdW1uLCBrZWVwRGVzaXJlZENvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sZWFkLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmFuY2hvci5kZXRhY2goKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZnJvbU9yaWVudGVkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgcmFuZ2UuY3Vyc29yID09IHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IHJhbmdlLmRlc2lyZWRDb2x1bW4gfHwgdGhpcy4kZGVzaXJlZENvbHVtbjtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUudG9PcmllbnRlZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHIuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gci5zdGFydC5yb3c7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gci5lbmQuY29sdW1uO1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IHIuZW5kLnJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0gcjtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5jdXJzb3IgPSB0aGlzLmlzQmFja3dhcmRzKCkgPyByYW5nZS5zdGFydCA6IHJhbmdlLmVuZDtcbiAgICAgICAgcmFuZ2UuZGVzaXJlZENvbHVtbiA9IHRoaXMuJGRlc2lyZWRDb2x1bW47XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0UmFuZ2VPZk1vdmVtZW50cyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oc3RhcnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCkgeyB2YXIgZGF0YSA9IHRoaXMucmFuZ2VzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHZhciByMSA9IHIuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICByMS5pc0JhY2t3YXJkcyA9IHIuY3Vyc29yID09IHIuc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IHZhciBkYXRhID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgZGF0YS5pc0JhY2t3YXJkcyA9IHRoaXMuaXNCYWNrd2FyZHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlTGlzdCAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoZGF0YVswXSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gUmFuZ2UuZnJvbVBvaW50cyhkYXRhW2ldLnN0YXJ0LCBkYXRhW2ldLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLmlzQmFja3dhcmRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgci5jdXJzb3IgPSByLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFJhbmdlKHIsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QpXG4gICAgICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoZGF0YSk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UoZGF0YSwgZGF0YS5pc0JhY2t3YXJkcyk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmlzRXF1YWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoKGRhdGEubGVuZ3RoIHx8IHRoaXMucmFuZ2VDb3VudCkgJiYgZGF0YS5sZW5ndGggIT0gdGhpcy5yYW5nZUNvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoIHx8ICF0aGlzLnJhbmdlcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlKCkuaXNFcXVhbChkYXRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5pc0VxdWFsKGRhdGFbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3Rpb247XG59KCkpO1xuU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25BbmNob3IgPSBTZWxlY3Rpb24ucHJvdG90eXBlLnNldEFuY2hvcjtcblNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQW5jaG9yID0gU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRBbmNob3I7XG5TZWxlY3Rpb24ucHJvdG90eXBlLnNldFNlbGVjdGlvblJhbmdlID0gU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRSYW5nZTtcbm9vcC5pbXBsZW1lbnQoU2VsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuU2VsZWN0aW9uID0gU2VsZWN0aW9uO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS90b2tlbml6ZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvcmVwb3J0X2Vycm9yXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIHJlcG9ydEVycm9yID0gcmVxdWlyZShcIi4vbGliL3JlcG9ydF9lcnJvclwiKS5yZXBvcnRFcnJvcjtcbnZhciBNQVhfVE9LRU5fQ09VTlQgPSAyMDAwO1xudmFyIFRva2VuaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIocnVsZXMpIHtcbiAgICAgICAgdGhpcy5zcGxpdFJlZ2V4O1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHJ1bGVzO1xuICAgICAgICB0aGlzLnJlZ0V4cHMgPSB7fTtcbiAgICAgICAgdGhpcy5tYXRjaE1hcHBpbmdzID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN0YXRlcykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZXNba2V5XTtcbiAgICAgICAgICAgIHZhciBydWxlUmVnRXhwcyA9IFtdO1xuICAgICAgICAgICAgdmFyIG1hdGNoVG90YWwgPSAwO1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLm1hdGNoTWFwcGluZ3Nba2V5XSA9IHsgZGVmYXVsdFRva2VuOiBcInRleHRcIiB9O1xuICAgICAgICAgICAgdmFyIGZsYWcgPSBcImdcIjtcbiAgICAgICAgICAgIHZhciBzcGxpdHRlclJ1cmxlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gc3RhdGVbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZGVmYXVsdFRva2VuKVxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmRlZmF1bHRUb2tlbiA9IHJ1bGUuZGVmYXVsdFRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmNhc2VJbnNlbnNpdGl2ZSAmJiBmbGFnLmluZGV4T2YoXCJpXCIpID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZmxhZyArPSBcImlcIjtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS51bmljb2RlICYmIGZsYWcuaW5kZXhPZihcInVcIikgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmbGFnICs9IFwidVwiO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLnJlZ2V4ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLnJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAgICAgICAgICAgICBydWxlLnJlZ2V4ID0gcnVsZS5yZWdleC50b1N0cmluZygpLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRyZWdleCA9IHJ1bGUucmVnZXg7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoY291bnQgPSBuZXcgUmVnRXhwKFwiKD86KFwiICsgYWRqdXN0ZWRyZWdleCArIFwiKXwoLikpXCIpLmV4ZWMoXCJhXCIpLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZS50b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudG9rZW4ubGVuZ3RoID09IDEgfHwgbWF0Y2hjb3VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gcnVsZS50b2tlblswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGNvdW50IC0gMSAhPSBydWxlLnRva2VuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIm51bWJlciBvZiBjbGFzc2VzIGFuZCByZWdleHAgZ3JvdXBzIGRvZXNuJ3QgbWF0Y2hcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBDb3VudDogbWF0Y2hjb3VudCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbiA9IHJ1bGUudG9rZW5bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuQXJyYXkgPSBydWxlLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm9uTWF0Y2ggPSB0aGlzLiRhcnJheVRva2VucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZS50b2tlbiA9PSBcImZ1bmN0aW9uXCIgJiYgIXJ1bGUub25NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hjb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm9uTWF0Y2ggPSB0aGlzLiRhcHBseVRva2VuO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm9uTWF0Y2ggPSBydWxlLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9cXFxcXFxkLy50ZXN0KHJ1bGUucmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZHJlZ2V4ID0gcnVsZS5yZWdleC5yZXBsYWNlKC9cXFxcKFswLTldKykvZywgZnVuY3Rpb24gKG1hdGNoLCBkaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIChwYXJzZUludChkaWdpdCwgMTApICsgbWF0Y2hUb3RhbCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkcmVnZXggPSB0aGlzLnJlbW92ZUNhcHR1cmluZ0dyb3VwcyhydWxlLnJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUuc3BsaXRSZWdleCAmJiB0eXBlb2YgcnVsZS50b2tlbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXR0ZXJSdXJsZXMucHVzaChydWxlKTsgLy8gZmxhZyB3aWxsIGJlIGtub3duIG9ubHkgYXQgdGhlIHZlcnkgZW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcHBpbmdbbWF0Y2hUb3RhbF0gPSBpO1xuICAgICAgICAgICAgICAgIG1hdGNoVG90YWwgKz0gbWF0Y2hjb3VudDtcbiAgICAgICAgICAgICAgICBydWxlUmVnRXhwcy5wdXNoKGFkanVzdGVkcmVnZXgpO1xuICAgICAgICAgICAgICAgIGlmICghcnVsZS5vbk1hdGNoKVxuICAgICAgICAgICAgICAgICAgICBydWxlLm9uTWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlUmVnRXhwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nWzBdID0gMDtcbiAgICAgICAgICAgICAgICBydWxlUmVnRXhwcy5wdXNoKFwiJFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGl0dGVyUnVybGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBydWxlLnNwbGl0UmVnZXggPSB0aGlzLmNyZWF0ZVNwbGl0dGVyUmVnZXhwKHJ1bGUucmVnZXgsIGZsYWcpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlZ0V4cHNba2V5XSA9IG5ldyBSZWdFeHAoXCIoXCIgKyBydWxlUmVnRXhwcy5qb2luKFwiKXwoXCIpICsgXCIpfCgkKVwiLCBmbGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLiRzZXRNYXhUb2tlbkNvdW50ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgTUFYX1RPS0VOX0NPVU5UID0gbSB8IDA7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLiRhcHBseVRva2VuID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5zcGxpdFJlZ2V4LmV4ZWMoc3RyKS5zbGljZSgxKTtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy50b2tlbi5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIFt7IHR5cGU6IHR5cGVzLCB2YWx1ZTogc3RyIH1dO1xuICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2ldKVxuICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLiRhcnJheVRva2VucyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnNwbGl0UmVnZXguZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIXZhbHVlcylcbiAgICAgICAgICAgIHJldHVybiBcInRleHRcIjtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgdHlwZXMgPSB0aGlzLnRva2VuQXJyYXk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2kgKyAxXSlcbiAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2kgKyAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlQ2FwdHVyaW5nR3JvdXBzID0gZnVuY3Rpb24gKHNyYykge1xuICAgICAgICB2YXIgciA9IHNyYy5yZXBsYWNlKC9cXFxcLnxcXFsoPzpcXFxcLnxbXlxcXFxcXF1dKSp8XFwoXFw/Wzo9ITxdfChcXCgpL2csIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB5ID8gXCIoPzpcIiA6IHg7IH0pO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuY3JlYXRlU3BsaXR0ZXJSZWdleHAgPSBmdW5jdGlvbiAoc3JjLCBmbGFnKSB7XG4gICAgICAgIGlmIChzcmMuaW5kZXhPZihcIig/PVwiKSAhPSAtMSkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gMDtcbiAgICAgICAgICAgIHZhciBpbkNoQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsYXN0Q2FwdHVyZSA9IHt9O1xuICAgICAgICAgICAgc3JjLnJlcGxhY2UoLyhcXFxcLil8KFxcKCg/OlxcP1s9IV0pPyl8KFxcKSl8KFtcXFtcXF1dKS9nLCBmdW5jdGlvbiAobSwgZXNjLCBwYXJlbk9wZW4sIHBhcmVuQ2xvc2UsIHNxdWFyZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5DaENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQ2hDbGFzcyA9IHNxdWFyZSAhPSBcIl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQ2hDbGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrID09IGxhc3RDYXB0dXJlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2FwdHVyZS5lbmQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2FwdHVyZS5zdGFjayA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVuT3Blbikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjaysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW5PcGVuLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2FwdHVyZS5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxhc3RDYXB0dXJlLmVuZCAhPSBudWxsICYmIC9eXFwpKiQvLnRlc3Qoc3JjLnN1YnN0cihsYXN0Q2FwdHVyZS5lbmQpKSlcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKDAsIGxhc3RDYXB0dXJlLnN0YXJ0KSArIHNyYy5zdWJzdHIobGFzdENhcHR1cmUuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLmNoYXJBdCgwKSAhPSBcIl5cIilcbiAgICAgICAgICAgIHNyYyA9IFwiXlwiICsgc3JjO1xuICAgICAgICBpZiAoc3JjLmNoYXJBdChzcmMubGVuZ3RoIC0gMSkgIT0gXCIkXCIpXG4gICAgICAgICAgICBzcmMgKz0gXCIkXCI7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHNyYywgKGZsYWcgfHwgXCJcIikucmVwbGFjZShcImdcIiwgXCJcIikpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5nZXRMaW5lVG9rZW5zID0gZnVuY3Rpb24gKGxpbmUsIHN0YXJ0U3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXJ0U3RhdGUgJiYgdHlwZW9mIHN0YXJ0U3RhdGUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gc3RhcnRTdGF0ZS5zbGljZSgwKTtcbiAgICAgICAgICAgIHN0YXJ0U3RhdGUgPSBzdGFja1swXTtcbiAgICAgICAgICAgIGlmIChzdGFydFN0YXRlID09PSBcIiN0bXBcIikge1xuICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgc3RhcnRTdGF0ZSA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSAvKipAdHlwZXtzdHJpbmd9Ki8gKHN0YXJ0U3RhdGUpIHx8IFwic3RhcnRcIjtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZXNbY3VycmVudFN0YXRlXTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5tYXRjaE1hcHBpbmdzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgIHZhciByZSA9IHRoaXMucmVnRXhwc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgbWF0Y2gsIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1hdGNoQXR0ZW1wdHMgPSAwO1xuICAgICAgICB2YXIgdG9rZW4gPSB7IHR5cGU6IG51bGwsIHZhbHVlOiBcIlwiIH07XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWFwcGluZy5kZWZhdWx0VG9rZW47XG4gICAgICAgICAgICB2YXIgcnVsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIGlmIChpbmRleCAtIHZhbHVlLmxlbmd0aCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBza2lwcGVkID0gbGluZS5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCAtIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArPSBza2lwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0geyB0eXBlOiB0eXBlLCB2YWx1ZTogc2tpcHBlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2gubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2kgKyAxXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBydWxlID0gc3RhdGVbbWFwcGluZ1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUub25NYXRjaClcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJ1bGUub25NYXRjaCh2YWx1ZSwgY3VycmVudFN0YXRlLCBzdGFjaywgbGluZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gcnVsZS50b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5uZXh0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHJ1bGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHJ1bGUubmV4dChjdXJyZW50U3RhdGUsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhdGVzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXCJzdGF0ZSBkb2Vzbid0IGV4aXN0XCIsIGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBcInN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhdGVzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMubWF0Y2hNYXBwaW5nc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmUgPSB0aGlzLnJlZ0V4cHNbY3VycmVudFN0YXRlXTtcbiAgICAgICAgICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWVMaW5lRW5kKVxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFydWxlIHx8IHJ1bGUubWVyZ2UgIT09IGZhbHNlKSAmJiB0b2tlbi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0geyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHsgdHlwZTogbnVsbCwgdmFsdWU6IFwiXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godHlwZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKG1hdGNoQXR0ZW1wdHMrKyA+IE1BWF9UT0tFTl9DT1VOVCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaEF0dGVtcHRzID4gMiAqIGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXCJpbmZpbml0ZSBsb29wIHdpdGggaW4gYWNlIHRva2VuaXplclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN0YXRlOiBzdGFydFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaW5lLnN1YnN0cmluZyhsYXN0SW5kZXgsIGxhc3RJbmRleCArPSA1MDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICBzdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlKVxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrWzBdICE9PSBjdXJyZW50U3RhdGUpXG4gICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdChcIiN0bXBcIiwgY3VycmVudFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW5zOiB0b2tlbnMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhY2subGVuZ3RoID8gc3RhY2sgOiBjdXJyZW50U3RhdGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUb2tlbml6ZXI7XG59KCkpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vZGUvdGV4dF9oaWdobGlnaHRfcnVsZXNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZGVlcF9jb3B5XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRlZXBDb3B5ID0gcmVxdWlyZShcIi4uL2xpYi9kZWVwX2NvcHlcIikuZGVlcENvcHk7XG52YXIgVGV4dEhpZ2hsaWdodFJ1bGVzO1xuVGV4dEhpZ2hsaWdodFJ1bGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHJ1bGVzID0ge1xuICAgICAgICBcInN0YXJ0XCI6IFt7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwiZW1wdHlfbGluZVwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAnXiQnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFRva2VuOiBcInRleHRcIlxuICAgICAgICAgICAgfV1cbiAgICB9O1xufTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGRSdWxlcyA9IGZ1bmN0aW9uIChydWxlcywgcHJlZml4KSB7XG4gICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcnVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy4kcnVsZXNba2V5XSA9IHJ1bGVzW2tleV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gc3RhdGVbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dCB8fCBydWxlLm9uTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLm5leHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dC5pbmRleE9mKHByZWZpeCkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0ID0gcHJlZml4ICsgcnVsZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLm5leHRTdGF0ZSAmJiBydWxlLm5leHRTdGF0ZS5pbmRleE9mKHByZWZpeCkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5leHRTdGF0ZSA9IHByZWZpeCArIHJ1bGUubmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHJ1bGVzW3ByZWZpeCArIGtleV0gPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJ1bGVzO1xuICAgIH07XG4gICAgdGhpcy5lbWJlZFJ1bGVzID0gZnVuY3Rpb24gKEhpZ2hsaWdodFJ1bGVzLCBwcmVmaXgsIGVzY2FwZVJ1bGVzLCBzdGF0ZXMsIGFwcGVuZCkge1xuICAgICAgICB2YXIgZW1iZWRSdWxlcyA9IHR5cGVvZiBIaWdobGlnaHRSdWxlcyA9PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gbmV3IEhpZ2hsaWdodFJ1bGVzKCkuZ2V0UnVsZXMoKVxuICAgICAgICAgICAgOiBIaWdobGlnaHRSdWxlcztcbiAgICAgICAgaWYgKHN0YXRlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVzW2ldID0gcHJlZml4ICsgc3RhdGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZW1iZWRSdWxlcylcbiAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaChwcmVmaXggKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkUnVsZXMoZW1iZWRSdWxlcywgcHJlZml4KTtcbiAgICAgICAgaWYgKGVzY2FwZVJ1bGVzKSB7XG4gICAgICAgICAgICB2YXIgYWRkUnVsZXMgPSBBcnJheS5wcm90b3R5cGVbYXBwZW5kID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBhZGRSdWxlcy5hcHBseSh0aGlzLiRydWxlc1tzdGF0ZXNbaV1dLCBkZWVwQ29weShlc2NhcGVSdWxlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy4kZW1iZWRzKVxuICAgICAgICAgICAgdGhpcy4kZW1iZWRzID0gW107XG4gICAgICAgIHRoaXMuJGVtYmVkcy5wdXNoKHByZWZpeCk7XG4gICAgfTtcbiAgICB0aGlzLmdldEVtYmVkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVtYmVkcztcbiAgICB9O1xuICAgIHZhciBwdXNoU3RhdGUgPSBmdW5jdGlvbiAoY3VycmVudFN0YXRlLCBzdGFjaykge1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlICE9IFwic3RhcnRcIiB8fCBzdGFjay5sZW5ndGgpXG4gICAgICAgICAgICBzdGFjay51bnNoaWZ0KHRoaXMubmV4dFN0YXRlLCBjdXJyZW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0U3RhdGU7XG4gICAgfTtcbiAgICB2YXIgcG9wU3RhdGUgPSBmdW5jdGlvbiAoY3VycmVudFN0YXRlLCBzdGFjaykge1xuICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gc3RhY2suc2hpZnQoKSB8fCBcInN0YXJ0XCI7XG4gICAgfTtcbiAgICB0aGlzLm5vcm1hbGl6ZVJ1bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSAwO1xuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLiRydWxlcztcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1N0YXRlKGtleSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgIHN0YXRlW1wicHJvY2Vzc2VkXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHN0YXRlW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0b0luc2VydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9JbnNlcnQgPSBydWxlO1xuICAgICAgICAgICAgICAgICAgICBydWxlID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcnVsZS5yZWdleCAmJiBydWxlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUucmVnZXggPSBydWxlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUubmV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBydWxlLm5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VG9rZW46IHJ1bGUudG9rZW5cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHJ1bGUudG9rZW4gKyBcIi5lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBydWxlLmVuZCB8fCBydWxlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogXCJwb3BcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbiA9IHJ1bGUudG9rZW4gKyBcIi5zdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBydWxlLnB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHJ1bGUubmV4dCB8fCBydWxlLnB1c2g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVOYW1lID0gcnVsZS5zdGF0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU5hbWUgPSBydWxlLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZU5hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU5hbWUgPSBzdGF0ZU5hbWVbMF0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc1tzdGF0ZU5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSArPSBpZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW3N0YXRlTmFtZV0gPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBydWxlLm5leHQgPSBzdGF0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NTdGF0ZShzdGF0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09IFwicG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0ID0gcG9wU3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLnB1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0U3RhdGUgPSBydWxlLm5leHQgfHwgcnVsZS5wdXNoO1xuICAgICAgICAgICAgICAgICAgICBydWxlLm5leHQgPSBwdXNoU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlLnB1c2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgaW4gcnVsZS5ydWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzW3JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzW3JdLnB1c2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzW3JdLnB1c2guYXBwbHkocnVsZXNbcl0sIHJ1bGUucnVsZXNbcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNbcl0gPSBydWxlLnJ1bGVzW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlTmFtZSA9IHR5cGVvZiBydWxlID09IFwic3RyaW5nXCIgPyBydWxlIDogcnVsZS5pbmNsdWRlO1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZU5hbWUgPT09IFwiJHNlbGZcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVOYW1lID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmNsdWRlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0luc2VydCA9IGluY2x1ZGVOYW1lLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcnVsZXNbeF07IH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0luc2VydCA9IHJ1bGVzW2luY2x1ZGVOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW2ksIDFdLmNvbmNhdCh0b0luc2VydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLm5vRXNjYXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAheC5uZXh0OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3BsaWNlLmFwcGx5KHN0YXRlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5rZXl3b3JkTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSB0aGlzLmNyZWF0ZUtleXdvcmRNYXBwZXIocnVsZS5rZXl3b3JkTWFwLCBydWxlLmRlZmF1bHRUb2tlbiB8fCBcInRleHRcIiwgcnVsZS5jYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZS5kZWZhdWx0VG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHJ1bGVzKS5mb3JFYWNoKHByb2Nlc3NTdGF0ZSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLmNyZWF0ZUtleXdvcmRNYXBwZXIgPSBmdW5jdGlvbiAobWFwLCBkZWZhdWx0VG9rZW4sIGlnbm9yZUNhc2UsIHNwbGl0Q2hhcikge1xuICAgICAgICB2YXIga2V5d29yZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLiRrZXl3b3JkTGlzdCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdmFyIGEgPSBtYXBbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gYS5zcGxpdChzcGxpdENoYXIgfHwgXCJ8XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmQgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuJGtleXdvcmRMaXN0LnB1c2god29yZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZUNhc2UpXG4gICAgICAgICAgICAgICAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAga2V5d29yZHNbd29yZF0gPSBjbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBtYXAgPSBudWxsO1xuICAgICAgICByZXR1cm4gaWdub3JlQ2FzZVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGtleXdvcmRzW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IGRlZmF1bHRUb2tlbjsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGtleXdvcmRzW3ZhbHVlXSB8fCBkZWZhdWx0VG9rZW47IH07XG4gICAgfTtcbiAgICB0aGlzLmdldEtleXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4ka2V5d29yZHM7XG4gICAgfTtcbn0pLmNhbGwoVGV4dEhpZ2hsaWdodFJ1bGVzLnByb3RvdHlwZSk7XG5leHBvcnRzLlRleHRIaWdobGlnaHRSdWxlcyA9IFRleHRIaWdobGlnaHRSdWxlcztcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS9iZWhhdmlvdXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgQmVoYXZpb3VyO1xuQmVoYXZpb3VyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJlaGF2aW91cnMgPSB7fTtcbn07XG4oZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gKG5hbWUsIGFjdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgc3dpdGNoICh1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy4kYmVoYXZpb3VyczpcbiAgICAgICAgICAgICAgICB0aGlzLiRiZWhhdmlvdXJzID0ge307XG4gICAgICAgICAgICBjYXNlIHRoaXMuJGJlaGF2aW91cnNbbmFtZV06XG4gICAgICAgICAgICAgICAgdGhpcy4kYmVoYXZpb3Vyc1tuYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGJlaGF2aW91cnNbbmFtZV1bYWN0aW9uXSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgdGhpcy5hZGRCZWhhdmlvdXJzID0gZnVuY3Rpb24gKGJlaGF2aW91cnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJlaGF2aW91cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGFjdGlvbiBpbiBiZWhhdmlvdXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChrZXksIGFjdGlvbiwgYmVoYXZpb3Vyc1trZXldW2FjdGlvbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLiRiZWhhdmlvdXJzICYmIHRoaXMuJGJlaGF2aW91cnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRiZWhhdmlvdXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmluaGVyaXQgPSBmdW5jdGlvbiAobW9kZSwgZmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3VycyA9IG5ldyBtb2RlKCkuZ2V0QmVoYXZpb3VycyhmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW91cnMgPSBtb2RlLmdldEJlaGF2aW91cnMoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEJlaGF2aW91cnMoYmVoYXZpb3Vycyk7XG4gICAgfTtcbiAgICB0aGlzLmdldEJlaGF2aW91cnMgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kYmVoYXZpb3VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGJlaGF2aW91cnNbZmlsdGVyW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICByZXRbZmlsdGVyW2ldXSA9IHRoaXMuJGJlaGF2aW91cnNbZmlsdGVyW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfTtcbn0pLmNhbGwoQmVoYXZpb3VyLnByb3RvdHlwZSk7XG5leHBvcnRzLkJlaGF2aW91ciA9IEJlaGF2aW91cjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdG9rZW5faXRlcmF0b3JcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIFRva2VuSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBpbml0aWFsUm93LCBpbml0aWFsQ29sdW1uKSB7XG4gICAgICAgIHRoaXMuJHNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLiRyb3cgPSBpbml0aWFsUm93O1xuICAgICAgICB0aGlzLiRyb3dUb2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhpbml0aWFsUm93KTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Vzc2lvbi5nZXRUb2tlbkF0KGluaXRpYWxSb3csIGluaXRpYWxDb2x1bW4pO1xuICAgICAgICB0aGlzLiR0b2tlbkluZGV4ID0gdG9rZW4gPyB0b2tlbi5pbmRleCA6IC0xO1xuICAgIH1cbiAgICBUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZS5zdGVwQmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJHRva2VuSW5kZXggLT0gMTtcbiAgICAgICAgd2hpbGUgKHRoaXMuJHRva2VuSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLiRyb3cgLT0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRyb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcm93ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHJvd1Rva2VucyA9IHRoaXMuJHNlc3Npb24uZ2V0VG9rZW5zKHRoaXMuJHJvdyk7XG4gICAgICAgICAgICB0aGlzLiR0b2tlbkluZGV4ID0gdGhpcy4kcm93VG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvd1Rva2Vuc1t0aGlzLiR0b2tlbkluZGV4XTtcbiAgICB9O1xuICAgIFRva2VuSXRlcmF0b3IucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiR0b2tlbkluZGV4ICs9IDE7XG4gICAgICAgIHZhciByb3dDb3VudDtcbiAgICAgICAgd2hpbGUgKHRoaXMuJHRva2VuSW5kZXggPj0gdGhpcy4kcm93VG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy4kcm93ICs9IDE7XG4gICAgICAgICAgICBpZiAoIXJvd0NvdW50KVxuICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy4kc2Vzc2lvbi5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRyb3cgPj0gcm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyb3cgPSByb3dDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRyb3dUb2tlbnMgPSB0aGlzLiRzZXNzaW9uLmdldFRva2Vucyh0aGlzLiRyb3cpO1xuICAgICAgICAgICAgdGhpcy4kdG9rZW5JbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvd1Rva2Vuc1t0aGlzLiR0b2tlbkluZGV4XTtcbiAgICB9O1xuICAgIFRva2VuSXRlcmF0b3IucHJvdG90eXBlLmdldEN1cnJlbnRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvd1Rva2Vuc1t0aGlzLiR0b2tlbkluZGV4XTtcbiAgICB9O1xuICAgIFRva2VuSXRlcmF0b3IucHJvdG90eXBlLmdldEN1cnJlbnRUb2tlblJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvdztcbiAgICB9O1xuICAgIFRva2VuSXRlcmF0b3IucHJvdG90eXBlLmdldEN1cnJlbnRUb2tlbkNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd1Rva2VucyA9IHRoaXMuJHJvd1Rva2VucztcbiAgICAgICAgdmFyIHRva2VuSW5kZXggPSB0aGlzLiR0b2tlbkluZGV4O1xuICAgICAgICB2YXIgY29sdW1uID0gcm93VG9rZW5zW3Rva2VuSW5kZXhdLnN0YXJ0O1xuICAgICAgICBpZiAoY29sdW1uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICBjb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAodG9rZW5JbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRva2VuSW5kZXggLT0gMTtcbiAgICAgICAgICAgIGNvbHVtbiArPSByb3dUb2tlbnNbdG9rZW5JbmRleF0udmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfTtcbiAgICBUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VG9rZW5Qb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgcm93OiB0aGlzLiRyb3csIGNvbHVtbjogdGhpcy5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSB9O1xuICAgIH07XG4gICAgVG9rZW5JdGVyYXRvci5wcm90b3R5cGUuZ2V0Q3VycmVudFRva2VuUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuJHJvd1Rva2Vuc1t0aGlzLiR0b2tlbkluZGV4XTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCk7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy4kcm93LCBjb2x1bW4sIHRoaXMuJHJvdywgY29sdW1uICsgdG9rZW4udmFsdWUubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2tlbkl0ZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuVG9rZW5JdGVyYXRvciA9IFRva2VuSXRlcmF0b3I7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vZGUvYmVoYXZpb3VyL2NzdHlsZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9tb2RlL2JlaGF2aW91clwiLFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsXCJhY2UvbGliL2xhbmdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4uLy4uL2xpYi9vb3BcIik7XG52YXIgQmVoYXZpb3VyID0gcmVxdWlyZShcIi4uL2JlaGF2aW91clwiKS5CZWhhdmlvdXI7XG52YXIgVG9rZW5JdGVyYXRvciA9IHJlcXVpcmUoXCIuLi8uLi90b2tlbl9pdGVyYXRvclwiKS5Ub2tlbkl0ZXJhdG9yO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vLi4vbGliL2xhbmdcIik7XG52YXIgU0FGRV9JTlNFUlRfSU5fVE9LRU5TID0gW1widGV4dFwiLCBcInBhcmVuLnJwYXJlblwiLCBcInJwYXJlblwiLCBcInBhcmVuXCIsIFwicHVuY3R1YXRpb24ub3BlcmF0b3JcIl07XG52YXIgU0FGRV9JTlNFUlRfQkVGT1JFX1RPS0VOUyA9IFtcInRleHRcIiwgXCJwYXJlbi5ycGFyZW5cIiwgXCJycGFyZW5cIiwgXCJwYXJlblwiLCBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsIFwiY29tbWVudFwiXTtcbnZhciBjb250ZXh0O1xudmFyIGNvbnRleHRDYWNoZSA9IHt9O1xudmFyIGRlZmF1bHRRdW90ZXMgPSB7ICdcIic6ICdcIicsIFwiJ1wiOiBcIidcIiB9O1xudmFyIGluaXRDb250ZXh0ID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgIHZhciBpZCA9IC0xO1xuICAgIGlmIChlZGl0b3IubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgaWQgPSBlZGl0b3Iuc2VsZWN0aW9uLmluZGV4O1xuICAgICAgICBpZiAoY29udGV4dENhY2hlLnJhbmdlQ291bnQgIT0gZWRpdG9yLm11bHRpU2VsZWN0LnJhbmdlQ291bnQpXG4gICAgICAgICAgICBjb250ZXh0Q2FjaGUgPSB7IHJhbmdlQ291bnQ6IGVkaXRvci5tdWx0aVNlbGVjdC5yYW5nZUNvdW50IH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0Q2FjaGVbaWRdKVxuICAgICAgICByZXR1cm4gY29udGV4dCA9IGNvbnRleHRDYWNoZVtpZF07XG4gICAgY29udGV4dCA9IGNvbnRleHRDYWNoZVtpZF0gPSB7XG4gICAgICAgIGF1dG9JbnNlcnRlZEJyYWNrZXRzOiAwLFxuICAgICAgICBhdXRvSW5zZXJ0ZWRSb3c6IC0xLFxuICAgICAgICBhdXRvSW5zZXJ0ZWRMaW5lRW5kOiBcIlwiLFxuICAgICAgICBtYXliZUluc2VydGVkQnJhY2tldHM6IDAsXG4gICAgICAgIG1heWJlSW5zZXJ0ZWRSb3c6IC0xLFxuICAgICAgICBtYXliZUluc2VydGVkTGluZVN0YXJ0OiBcIlwiLFxuICAgICAgICBtYXliZUluc2VydGVkTGluZUVuZDogXCJcIlxuICAgIH07XG59O1xudmFyIGdldFdyYXBwZWQgPSBmdW5jdGlvbiAoc2VsZWN0aW9uLCBzZWxlY3RlZCwgb3BlbmluZywgY2xvc2luZykge1xuICAgIHZhciByb3dEaWZmID0gc2VsZWN0aW9uLmVuZC5yb3cgLSBzZWxlY3Rpb24uc3RhcnQucm93O1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IG9wZW5pbmcgKyBzZWxlY3RlZCArIGNsb3NpbmcsXG4gICAgICAgIHNlbGVjdGlvbjogW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgcm93RGlmZixcbiAgICAgICAgICAgIHNlbGVjdGlvbi5lbmQuY29sdW1uICsgKHJvd0RpZmYgPyAwIDogMSlcbiAgICAgICAgXVxuICAgIH07XG59O1xudmFyIENzdHlsZUJlaGF2aW91cjtcbkNzdHlsZUJlaGF2aW91ciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5hZGQoXCJicmFjZXNcIiwgXCJpbnNlcnRpb25cIiwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgdGV4dCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgaWYgKHRleHQgPT0gJ3snKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBzZXNzaW9uLmdldFRva2VuQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgc2VsZWN0ZWQgIT09IFwie1wiICYmIGVkaXRvci5nZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXcmFwcGVkKHNlbGVjdGlvbiwgc2VsZWN0ZWQsICd7JywgJ30nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICYmIC8oPzpzdHJpbmcpXFwucXVhc2l8XFwueG1sLy50ZXN0KHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2x1ZGVUb2tlbnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC90YWdcXC0oPzpvcGVufG5hbWUpLywgL2F0dHJpYnV0ZVxcLW5hbWUvXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZVRva2Vucy5zb21lKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwudGVzdCh0b2tlbi50eXBlKTsgfSkgfHwgLyhzdHJpbmcpXFwucXVhc2kvLnRlc3QodG9rZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgdG9rZW4udmFsdWVbY3Vyc29yLmNvbHVtbiAtIHRva2VuLnN0YXJ0IC0gMV0gIT09ICckJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5yZWNvcmRBdXRvSW5zZXJ0KGVkaXRvciwgc2Vzc2lvbiwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICd7fScsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKENzdHlsZUJlaGF2aW91ci5pc1NhbmVJbnNlcnRpb24oZWRpdG9yLCBzZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIGlmICgvW1xcXVxcfVxcKV0vLnRlc3QobGluZVtjdXJzb3IuY29sdW1uXSkgfHwgZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlIHx8IG9wdGlvbnMuYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5yZWNvcmRBdXRvSW5zZXJ0KGVkaXRvciwgc2Vzc2lvbiwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3t9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkTWF5YmVJbnNlcnQoZWRpdG9yLCBzZXNzaW9uLCBcIntcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAneycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09ICd9Jykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09ICd9Jykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IHNlc3Npb24uJGZpbmRPcGVuaW5nQnJhY2tldCgnfScsIHsgY29sdW1uOiBjdXJzb3IuY29sdW1uICsgMSwgcm93OiBjdXJzb3Iucm93IH0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZyAhPT0gbnVsbCAmJiBDc3R5bGVCZWhhdmlvdXIuaXNBdXRvSW5zZXJ0ZWRDbG9zaW5nKGN1cnNvciwgbGluZSwgdGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLnBvcEF1dG9JbnNlcnRlZENsb3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIlxcblwiIHx8IHRleHQgPT0gXCJcXHJcXG5cIikge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBjbG9zaW5nID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNNYXliZUluc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgY2xvc2luZyA9IGxhbmcuc3RyaW5nUmVwZWF0KFwifVwiLCBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cyk7XG4gICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLmNsZWFyTWF5YmVJbnNlcnRlZENsb3NpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlbkJyYWNlUG9zID0gc2Vzc2lvbi5maW5kTWF0Y2hpbmdCcmFja2V0KHsgcm93OiBjdXJzb3Iucm93LCBjb2x1bW46IGN1cnNvci5jb2x1bW4gKyAxIH0sICd9Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuQnJhY2VQb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X2luZGVudCA9IHRoaXMuJGdldEluZGVudChzZXNzaW9uLmdldExpbmUob3BlbkJyYWNlUG9zLnJvdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2luZykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X2luZGVudCA9IHRoaXMuJGdldEluZGVudChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5jbGVhck1heWJlSW5zZXJ0ZWRDbG9zaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGVudCA9IG5leHRfaW5kZW50ICsgc2Vzc2lvbi5nZXRUYWJTdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogJ1xcbicgKyBpbmRlbnQgKyAnXFxuJyArIG5leHRfaW5kZW50ICsgY2xvc2luZyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCBpbmRlbnQubGVuZ3RoLCAxLCBpbmRlbnQubGVuZ3RoXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5jbGVhck1heWJlSW5zZXJ0ZWRDbG9zaW5nKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZChcImJyYWNlc1wiLCBcImRlbGV0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHJhbmdlKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmICghcmFuZ2UuaXNNdWx0aUxpbmUoKSAmJiBzZWxlY3RlZCA9PSAneycpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhyYW5nZS5lbmQuY29sdW1uLCByYW5nZS5lbmQuY29sdW1uICsgMSk7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09ICd9Jykge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGQoXCJwYXJlbnNcIiwgXCJpbnNlcnRpb25cIiwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgdGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSAnKCcpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2Uoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAhPT0gXCJcIiAmJiBlZGl0b3IuZ2V0V3JhcEJlaGF2aW91cnNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZChzZWxlY3Rpb24sIHNlbGVjdGVkLCAnKCcsICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uKGVkaXRvciwgc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnKCknLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSAnKScpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnKScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBzZXNzaW9uLiRmaW5kT3BlbmluZ0JyYWNrZXQoJyknLCB7IGNvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEsIHJvdzogY3Vyc29yLnJvdyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmcgIT09IG51bGwgJiYgQ3N0eWxlQmVoYXZpb3VyLmlzQXV0b0luc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUsIHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5wb3BBdXRvSW5zZXJ0ZWRDbG9zaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGQoXCJwYXJlbnNcIiwgXCJkZWxldGlvblwiLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCByYW5nZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgc2VsZWN0ZWQgPT0gJygnKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uICsgMSwgcmFuZ2Uuc3RhcnQuY29sdW1uICsgMik7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09ICcpJykge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZChcImJyYWNrZXRzXCIsIFwiaW5zZXJ0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gJ1snKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWQoc2VsZWN0aW9uLCBzZWxlY3RlZCwgJ1snLCAnXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQ3N0eWxlQmVoYXZpb3VyLmlzU2FuZUluc2VydGlvbihlZGl0b3IsIHNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLnJlY29yZEF1dG9JbnNlcnQoZWRpdG9yLCBzZXNzaW9uLCBcIl1cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1tdJyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gJ10nKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcbiAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KCddJywgeyBjb2x1bW46IGN1cnNvci5jb2x1bW4gKyAxLCByb3c6IGN1cnNvci5yb3cgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nICE9PSBudWxsICYmIENzdHlsZUJlaGF2aW91ci5pc0F1dG9JbnNlcnRlZENsb3NpbmcoY3Vyc29yLCBsaW5lLCB0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkKFwiYnJhY2tldHNcIiwgXCJkZWxldGlvblwiLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCByYW5nZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgc2VsZWN0ZWQgPT0gJ1snKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uICsgMSwgcmFuZ2Uuc3RhcnQuY29sdW1uICsgMik7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09ICddJykge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZChcInN0cmluZ19kcXVvdGVzXCIsIFwiaW5zZXJ0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgdmFyIHF1b3RlcyA9IHNlc3Npb24uJG1vZGUuJHF1b3RlcyB8fCBkZWZhdWx0UXVvdGVzO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSAmJiBxdW90ZXNbdGV4dF0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVDb21tZW50U3RhcnQgJiYgdGhpcy5saW5lQ29tbWVudFN0YXJ0LmluZGV4T2YodGV4dCkgIT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBxdW90ZSA9IHRleHQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2Uoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAhPT0gXCJcIiAmJiAoc2VsZWN0ZWQubGVuZ3RoICE9IDEgfHwgIXF1b3Rlc1tzZWxlY3RlZF0pICYmIGVkaXRvci5nZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXcmFwcGVkKHNlbGVjdGlvbiwgc2VsZWN0ZWQsIHF1b3RlLCBxdW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4gLSAxLCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlc3Npb24uZ2V0VG9rZW5BdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRUb2tlbiA9IHNlc3Npb24uZ2V0VG9rZW5BdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDaGFyID09IFwiXFxcXFwiICYmIHRva2VuICYmIC9lc2NhcGUvLnRlc3QodG9rZW4udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdCZWZvcmUgPSB0b2tlbiAmJiAvc3RyaW5nfGVzY2FwZS8udGVzdCh0b2tlbi50eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nQWZ0ZXIgPSAhcmlnaHRUb2tlbiB8fCAvc3RyaW5nfGVzY2FwZS8udGVzdChyaWdodFRva2VuLnR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBwYWlyO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpciA9IHN0cmluZ0JlZm9yZSAhPT0gc3RyaW5nQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyICYmIC9zdHJpbmdcXC5lbmQvLnRlc3QocmlnaHRUb2tlbi50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdCZWZvcmUgJiYgIXN0cmluZ0FmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIHdyYXAgc3RyaW5nIHdpdGggZGlmZmVyZW50IHF1b3RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdCZWZvcmUgJiYgc3RyaW5nQWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG8gbm90IHBhaXIgcXVvdGVzIGluc2lkZSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIHZhciB3b3JkUmUgPSBzZXNzaW9uLiRtb2RlLnRva2VuUmU7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNXb3JkQmVmb3JlID0gd29yZFJlLnRlc3QobGVmdENoYXIpO1xuICAgICAgICAgICAgICAgICAgICB3b3JkUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzV29yZEFmdGVyID0gd29yZFJlLnRlc3QocmlnaHRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJRdW90ZXNBZnRlciA9IHNlc3Npb24uJG1vZGUuJHBhaXJRdW90ZXNBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFBhaXJRdW90ZXMgPSBwYWlyUXVvdGVzQWZ0ZXIgJiYgcGFpclF1b3Rlc0FmdGVyW3F1b3RlXSAmJiBwYWlyUXVvdGVzQWZ0ZXJbcXVvdGVdLnRlc3QobGVmdENoYXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFzaG91bGRQYWlyUXVvdGVzICYmIGlzV29yZEJlZm9yZSkgfHwgaXNXb3JkQWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gYmVmb3JlIG9yIGFmdGVyIGFscGhhbnVtZXJpY1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRDaGFyICYmICEvW1xcczssLn0pXFxdXFxcXF0vLnRlc3QocmlnaHRDaGFyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyB0aGVyZSBpcyByaWdodENoYXIgYW5kIGl0IGlzbid0IGNsb3NpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJCZWZvcmUgPSBsaW5lW2N1cnNvci5jb2x1bW4gLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRDaGFyID09IHF1b3RlICYmIChjaGFyQmVmb3JlID09IHF1b3RlIHx8IHdvcmRSZS50ZXN0KGNoYXJCZWZvcmUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwYWlyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogcGFpciA/IHF1b3RlICsgcXVvdGUgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZChcInN0cmluZ19kcXVvdGVzXCIsIFwiZGVsZXRpb25cIiwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHF1b3RlcyA9IHNlc3Npb24uJG1vZGUuJHF1b3RlcyB8fCBkZWZhdWx0UXVvdGVzO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgcXVvdGVzLmhhc093blByb3BlcnR5KHNlbGVjdGVkKSkge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiArIDEsIHJhbmdlLnN0YXJ0LmNvbHVtbiArIDIpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5jbG9zZURvY0NvbW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRkKFwiZG9jIGNvbW1lbnQgZW5kXCIsIFwiaW5zZXJ0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJkb2Mtc3RhcnRcIiAmJiAodGV4dCA9PT0gXCJcXG5cIiB8fCB0ZXh0ID09PSBcIlxcclxcblwiKSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dExpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gc2Vzc2lvbi5nZXRUb2tlbnMoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSB0b2tlbnNbaV0udmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gY3Vyc29yLmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBjdXJzb3IuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvXFwuZG9jLy50ZXN0KGN1cnJlbnRUb2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwqXFwvLy50ZXN0KGN1cnJlbnRUb2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRva2Vuc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFRva2VuIHx8ICEvXFwuZG9jLy50ZXN0KG5leHRUb2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvc0luVG9rZW4gPSBjdXJzb3IuY29sdW1uIC0gKGluZGV4IC0gY3VycmVudFRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VEb2NQb3MgPSBjdXJyZW50VG9rZW4udmFsdWUuaW5kZXhPZihcIiovXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5Eb2NQb3MgPSBjdXJyZW50VG9rZW4udmFsdWUuaW5kZXhPZihcIi8qKlwiLCBjbG9zZURvY1BvcyA+IC0xID8gY2xvc2VEb2NQb3MgKyAyIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkRvY1BvcyAhPT0gLTEgJiYgY3Vyc29yUG9zSW5Ub2tlbiA+IG9wZW5Eb2NQb3MgJiYgY3Vyc29yUG9zSW5Ub2tlbiA8IG9wZW5Eb2NQb3MgKyAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlRG9jUG9zICE9PSAtMSAmJiBvcGVuRG9jUG9zICE9PSAtMSAmJiBjdXJzb3JQb3NJblRva2VuID49IGNsb3NlRG9jUG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY3Vyc29yUG9zSW5Ub2tlbiA8PSBvcGVuRG9jUG9zIHx8ICEvXFwuZG9jLy50ZXN0KGN1cnJlbnRUb2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLiRnZXRJbmRlbnQobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKC9cXHMqXFwqLy50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXHMqXFwqLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQgKyBpbmRlbnQgKyBcIiogXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMiArIGluZGVudC5sZW5ndGgsIDEsIDIgKyBpbmRlbnQubGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCArIGluZGVudCArIFwiICogXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMyArIGluZGVudC5sZW5ndGgsIDEsIDMgKyBpbmRlbnQubGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL1xcL1xcKlxcKi8udGVzdChsaW5lLnN1YnN0cmluZygwLCBjdXJzb3IuY29sdW1uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQgKyBpbmRlbnQgKyBcIiAqIFwiICsgdGV4dCArIFwiIFwiICsgaW5kZW50ICsgXCIqL1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgNCArIGluZGVudC5sZW5ndGgsIDEsIDQgKyBpbmRlbnQubGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbkNzdHlsZUJlaGF2aW91ci5pc1NhbmVJbnNlcnRpb24gPSBmdW5jdGlvbiAoZWRpdG9yLCBzZXNzaW9uKSB7XG4gICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgIGlmICghdGhpcy4kbWF0Y2hUb2tlblR5cGUoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCkgfHwgXCJ0ZXh0XCIsIFNBRkVfSU5TRVJUX0lOX1RPS0VOUykpIHtcbiAgICAgICAgaWYgKC9bKX1cXF1dLy50ZXN0KGVkaXRvci5zZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdylbY3Vyc29yLmNvbHVtbl0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBpdGVyYXRvcjIgPSBuZXcgVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgIGlmICghdGhpcy4kbWF0Y2hUb2tlblR5cGUoaXRlcmF0b3IyLmdldEN1cnJlbnRUb2tlbigpIHx8IFwidGV4dFwiLCBTQUZFX0lOU0VSVF9JTl9UT0tFTlMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgIHJldHVybiBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSAhPT0gY3Vyc29yLnJvdyB8fFxuICAgICAgICB0aGlzLiRtYXRjaFRva2VuVHlwZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKSB8fCBcInRleHRcIiwgU0FGRV9JTlNFUlRfQkVGT1JFX1RPS0VOUyk7XG59O1xuQ3N0eWxlQmVoYXZpb3VyW1wiJG1hdGNoVG9rZW5UeXBlXCJdID0gZnVuY3Rpb24gKHRva2VuLCB0eXBlcykge1xuICAgIHJldHVybiB0eXBlcy5pbmRleE9mKHRva2VuLnR5cGUgfHwgdG9rZW4pID4gLTE7XG59O1xuQ3N0eWxlQmVoYXZpb3VyW1wicmVjb3JkQXV0b0luc2VydFwiXSA9IGZ1bmN0aW9uIChlZGl0b3IsIHNlc3Npb24sIGJyYWNrZXQpIHtcbiAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgIGlmICghdGhpc1tcImlzQXV0b0luc2VydGVkQ2xvc2luZ1wiXShjdXJzb3IsIGxpbmUsIGNvbnRleHQuYXV0b0luc2VydGVkTGluZUVuZFswXSkpXG4gICAgICAgIGNvbnRleHQuYXV0b0luc2VydGVkQnJhY2tldHMgPSAwO1xuICAgIGNvbnRleHQuYXV0b0luc2VydGVkUm93ID0gY3Vyc29yLnJvdztcbiAgICBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQgPSBicmFja2V0ICsgbGluZS5zdWJzdHIoY3Vyc29yLmNvbHVtbik7XG4gICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cysrO1xufTtcbkNzdHlsZUJlaGF2aW91cltcInJlY29yZE1heWJlSW5zZXJ0XCJdID0gZnVuY3Rpb24gKGVkaXRvciwgc2Vzc2lvbiwgYnJhY2tldCkge1xuICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgaWYgKCF0aGlzW1wiaXNNYXliZUluc2VydGVkQ2xvc2luZ1wiXShjdXJzb3IsIGxpbmUpKVxuICAgICAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cyA9IDA7XG4gICAgY29udGV4dC5tYXliZUluc2VydGVkUm93ID0gY3Vyc29yLnJvdztcbiAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lU3RhcnQgPSBsaW5lLnN1YnN0cigwLCBjdXJzb3IuY29sdW1uKSArIGJyYWNrZXQ7XG4gICAgY29udGV4dC5tYXliZUluc2VydGVkTGluZUVuZCA9IGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pO1xuICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZEJyYWNrZXRzKys7XG59O1xuQ3N0eWxlQmVoYXZpb3VyW1wiaXNBdXRvSW5zZXJ0ZWRDbG9zaW5nXCJdID0gZnVuY3Rpb24gKGN1cnNvciwgbGluZSwgYnJhY2tldCkge1xuICAgIHJldHVybiBjb250ZXh0LmF1dG9JbnNlcnRlZEJyYWNrZXRzID4gMCAmJlxuICAgICAgICBjdXJzb3Iucm93ID09PSBjb250ZXh0LmF1dG9JbnNlcnRlZFJvdyAmJlxuICAgICAgICBicmFja2V0ID09PSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmRbMF0gJiZcbiAgICAgICAgbGluZS5zdWJzdHIoY3Vyc29yLmNvbHVtbikgPT09IGNvbnRleHQuYXV0b0luc2VydGVkTGluZUVuZDtcbn07XG5Dc3R5bGVCZWhhdmlvdXJbXCJpc01heWJlSW5zZXJ0ZWRDbG9zaW5nXCJdID0gZnVuY3Rpb24gKGN1cnNvciwgbGluZSkge1xuICAgIHJldHVybiBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cyA+IDAgJiZcbiAgICAgICAgY3Vyc29yLnJvdyA9PT0gY29udGV4dC5tYXliZUluc2VydGVkUm93ICYmXG4gICAgICAgIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pID09PSBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lRW5kICYmXG4gICAgICAgIGxpbmUuc3Vic3RyKDAsIGN1cnNvci5jb2x1bW4pID09IGNvbnRleHQubWF5YmVJbnNlcnRlZExpbmVTdGFydDtcbn07XG5Dc3R5bGVCZWhhdmlvdXJbXCJwb3BBdXRvSW5zZXJ0ZWRDbG9zaW5nXCJdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQuYXV0b0luc2VydGVkTGluZUVuZCA9IGNvbnRleHQuYXV0b0luc2VydGVkTGluZUVuZC5zdWJzdHIoMSk7XG4gICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cy0tO1xufTtcbkNzdHlsZUJlaGF2aW91cltcImNsZWFyTWF5YmVJbnNlcnRlZENsb3NpbmdcIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMgPSAwO1xuICAgICAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRSb3cgPSAtMTtcbiAgICB9XG59O1xub29wLmluaGVyaXRzKENzdHlsZUJlaGF2aW91ciwgQmVoYXZpb3VyKTtcbmV4cG9ydHMuQ3N0eWxlQmVoYXZpb3VyID0gQ3N0eWxlQmVoYXZpb3VyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS91bmljb2RlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIHdvcmRDaGFycyA9IFs0OCwgOSwgOCwgMjUsIDUsIDAsIDIsIDI1LCA0OCwgMCwgMTEsIDAsIDUsIDAsIDYsIDIyLCAyLCAzMCwgMiwgNDU3LCA1LCAxMSwgMTUsIDQsIDgsIDAsIDIsIDAsIDE4LCAxMTYsIDIsIDEsIDMsIDMsIDksIDAsIDIsIDIsIDIsIDAsIDIsIDE5LCAyLCA4MiwgMiwgMTM4LCAyLCA0LCAzLCAxNTUsIDEyLCAzNywgMywgMCwgOCwgMzgsIDEwLCA0NCwgMiwgMCwgMiwgMSwgMiwgMSwgMiwgMCwgOSwgMjYsIDYsIDIsIDMwLCAxMCwgNywgNjEsIDIsIDksIDUsIDEwMSwgMiwgNywgMywgOSwgMiwgMTgsIDMsIDAsIDE3LCA1OCwgMywgMTAwLCAxNSwgNTMsIDUsIDAsIDYsIDQ1LCAyMTEsIDU3LCAzLCAxOCwgMiwgNSwgMywgMTEsIDMsIDksIDIsIDEsIDcsIDYsIDIsIDIsIDIsIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAwLCA0LCAzLCAzLCA4LCAzLCAxLCAzLCAzLCA5LCAwLCA1LCAxLCAyLCA0LCAzLCAxMSwgMTYsIDIsIDIsIDUsIDUsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCAxLCAyLCAxLCAzLCAwLCAyLCA0LCA1LCAxLCAzLCAyLCA0LCAwLCA4LCAzLCAyLCAwLCA4LCAxNSwgMTIsIDIsIDIsIDgsIDIsIDIsIDIsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCAzLCA5LCAyLCAyLCAyLCAyLCAzLCAwLCAxNiwgMywgMywgOSwgMTgsIDIsIDIsIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCAzLCA4LCAzLCAxLCAzLCAyLCA5LCAxLCA1LCAxLCAyLCA0LCAzLCA5LCAyLCAwLCAxNywgMSwgMiwgNSwgNCwgMiwgMiwgMywgNCwgMSwgMiwgMCwgMiwgMSwgNCwgMSwgNCwgMiwgNCwgMTEsIDUsIDQsIDQsIDIsIDIsIDMsIDMsIDAsIDcsIDAsIDE1LCA5LCAxOCwgMiwgMiwgNywgMiwgMiwgMiwgMjIsIDIsIDksIDIsIDQsIDQsIDcsIDIsIDIsIDIsIDMsIDgsIDEsIDIsIDEsIDcsIDMsIDMsIDksIDE5LCAxLCAyLCA3LCAyLCAyLCAyLCAyMiwgMiwgOSwgMiwgNCwgMywgOCwgMiwgMiwgMiwgMywgOCwgMSwgOCwgMCwgMiwgMywgMywgOSwgMTksIDEsIDIsIDcsIDIsIDIsIDIsIDIyLCAyLCAxNSwgNCwgNywgMiwgMiwgMiwgMywgMTAsIDAsIDksIDMsIDMsIDksIDExLCA1LCAzLCAxLCAyLCAxNywgNCwgMjMsIDIsIDgsIDIsIDAsIDMsIDYsIDQsIDAsIDUsIDUsIDIsIDAsIDIsIDcsIDE5LCAxLCAxNCwgNTcsIDYsIDE0LCAyLCA5LCA0MCwgMSwgMiwgMCwgMywgMSwgMiwgMCwgMywgMCwgNywgMywgMiwgNiwgMiwgMiwgMiwgMCwgMiwgMCwgMywgMSwgMiwgMTIsIDIsIDIsIDMsIDQsIDIsIDAsIDIsIDUsIDMsIDksIDMsIDEsIDM1LCAwLCAyNCwgMSwgNywgOSwgMTIsIDAsIDIsIDAsIDIsIDAsIDUsIDksIDIsIDM1LCA1LCAxOSwgMiwgNSwgNSwgNywgMiwgMzUsIDEwLCAwLCA1OCwgNzMsIDcsIDc3LCAzLCAzNywgMTEsIDQyLCAyLCAwLCA0LCAzMjgsIDIsIDMsIDMsIDYsIDIsIDAsIDIsIDMsIDMsIDQwLCAyLCAzLCAzLCAzMiwgMiwgMywgMywgNiwgMiwgMCwgMiwgMywgMywgMTQsIDIsIDU2LCAyLCAzLCAzLCA2NiwgNSwgMCwgMzMsIDE1LCAxNywgODQsIDEzLCA2MTksIDMsIDE2LCAyLCAyNSwgNiwgNzQsIDIyLCAxMiwgMiwgNiwgMTIsIDIwLCAxMiwgMTksIDEzLCAxMiwgMiwgMiwgMiwgMSwgMTMsIDUxLCAzLCAyOSwgNCwgMCwgNSwgMSwgMywgOSwgMzQsIDIsIDMsIDksIDcsIDg3LCA5LCA0MiwgNiwgNjksIDExLCAyOCwgNCwgMTEsIDUsIDExLCAxMSwgMzksIDMsIDQsIDEyLCA0MywgNSwgMjUsIDcsIDEwLCAzOCwgMjcsIDUsIDYyLCAyLCAyOCwgMywgMTAsIDcsIDksIDE0LCAwLCA4OSwgNzUsIDUsIDksIDE4LCA4LCAxMywgNDIsIDQsIDExLCA3MSwgNTUsIDksIDksIDQsIDQ4LCA4MywgMiwgMiwgMzAsIDE0LCAyMzAsIDIzLCAyODAsIDMsIDUsIDMsIDM3LCAzLCA1LCAzLCA3LCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAzMCwgMywgNTIsIDIsIDYsIDIsIDAsIDQsIDIsIDIsIDYsIDQsIDMsIDMsIDUsIDUsIDEyLCA2LCAyLCAyLCA2LCA2NywgMSwgMjAsIDAsIDI5LCAwLCAxNCwgMCwgMTcsIDQsIDYwLCAxMiwgNSwgMCwgNCwgMTEsIDE4LCAwLCA1LCAwLCAzLCA5LCAyLCAwLCA0LCA0LCA3LCAwLCAyLCAwLCAyLCAwLCAyLCAzLCAyLCAxMCwgMywgMywgNiwgNCwgNSwgMCwgNTMsIDEsIDI2ODQsIDQ2LCAyLCA0NiwgMiwgMTMyLCA3LCA2LCAxNSwgMzcsIDExLCA1MywgMTAsIDAsIDE3LCAyMiwgMTAsIDYsIDIsIDYsIDIsIDYsIDIsIDYsIDIsIDYsIDIsIDYsIDIsIDYsIDIsIDYsIDIsIDMxLCA0OCwgMCwgNDcwLCAxLCAzNiwgNSwgMiwgNCwgNiwgMSwgNSwgODUsIDMsIDEsIDMsIDIsIDIsIDg5LCAyLCAzLCA2LCA0MCwgNCwgOTMsIDE4LCAyMywgNTcsIDE1LCA1MTMsIDY1ODEsIDc1LCAyMDkzOSwgNTMsIDExNjQsIDY4LCA0NSwgMywgMjY4LCA0LCAyNywgMjEsIDMxLCAzLCAxMywgMTMsIDEsIDIsIDI0LCA5LCA2OSwgMTEsIDEsIDM4LCA4LCAzLCAxMDIsIDMsIDEsIDExMSwgNDQsIDI1LCA1MSwgMTMsIDY4LCAxMiwgOSwgNywgMjMsIDQsIDAsIDUsIDQ1LCAzLCAzNSwgMTMsIDI4LCA0LCA2NCwgMTUsIDEwLCAzOSwgNTQsIDEwLCAxMywgMywgOSwgNywgMjIsIDQsIDEsIDUsIDY2LCAyNSwgMiwgMjI3LCA0MiwgMiwgMSwgMywgOSwgNywgMTExNzEsIDEzLCAyMiwgNSwgNDgsIDg0NTMsIDMwMSwgMywgNjEsIDMsIDEwNSwgMzksIDYsIDEzLCA0LCA2LCAxMSwgMiwgMTIsIDIsIDQsIDIsIDAsIDIsIDEsIDIsIDEsIDIsIDEwNywgMzQsIDM2MiwgMTksIDYzLCAzLCA1MywgNDEsIDExLCA1LCAxNSwgMTcsIDYsIDEzLCAxLCAyNSwgMiwgMzMsIDQsIDIsIDEzNCwgMjAsIDksIDgsIDI1LCA1LCAwLCAyLCAyNSwgMTIsIDg4LCA0LCA1LCAzLCA1LCAzLCA1LCAzLCAyXTtcbnZhciBjb2RlID0gMDtcbnZhciBzdHIgPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc3RyLnB1c2goY29kZSArPSB3b3JkQ2hhcnNbaV0pO1xuICAgIGlmICh3b3JkQ2hhcnNbaSArIDFdKVxuICAgICAgICBzdHIucHVzaCg0NSwgY29kZSArPSB3b3JkQ2hhcnNbaSArIDFdKTtcbn1cbmV4cG9ydHMud29yZENoYXJzID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBzdHIpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL3RleHRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9jb25maWdcIixcImFjZS90b2tlbml6ZXJcIixcImFjZS9tb2RlL3RleHRfaGlnaGxpZ2h0X3J1bGVzXCIsXCJhY2UvbW9kZS9iZWhhdmlvdXIvY3N0eWxlXCIsXCJhY2UvdW5pY29kZVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvdG9rZW5faXRlcmF0b3JcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xudmFyIFRva2VuaXplciA9IHJlcXVpcmUoXCIuLi90b2tlbml6ZXJcIikuVG9rZW5pemVyO1xudmFyIFRleHRIaWdobGlnaHRSdWxlcyA9IHJlcXVpcmUoXCIuL3RleHRfaGlnaGxpZ2h0X3J1bGVzXCIpLlRleHRIaWdobGlnaHRSdWxlcztcbnZhciBDc3R5bGVCZWhhdmlvdXIgPSByZXF1aXJlKFwiLi9iZWhhdmlvdXIvY3N0eWxlXCIpLkNzdHlsZUJlaGF2aW91cjtcbnZhciB1bmljb2RlID0gcmVxdWlyZShcIi4uL3VuaWNvZGVcIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi9saWIvbGFuZ1wiKTtcbnZhciBUb2tlbkl0ZXJhdG9yID0gcmVxdWlyZShcIi4uL3Rva2VuX2l0ZXJhdG9yXCIpLlRva2VuSXRlcmF0b3I7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgTW9kZTtcbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5IaWdobGlnaHRSdWxlcyA9IFRleHRIaWdobGlnaHRSdWxlcztcbn07XG4oZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGRlZmF1bHRCZWhhdmlvdXIgPSBuZXcgQ3N0eWxlQmVoYXZpb3VyKCk7XG4gICAgdGhpcy50b2tlblJlID0gbmV3IFJlZ0V4cChcIl5bXCIgKyB1bmljb2RlLndvcmRDaGFycyArIFwiXFxcXCRfXStcIiwgXCJnXCIpO1xuICAgIHRoaXMubm9uVG9rZW5SZSA9IG5ldyBSZWdFeHAoXCJeKD86W15cIiArIHVuaWNvZGUud29yZENoYXJzICsgXCJcXFxcJF9dfFxcXFxzXSkrXCIsIFwiZ1wiKTtcbiAgICB0aGlzLmdldFRva2VuaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0b2tlbml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodFJ1bGVzID0gdGhpcy4kaGlnaGxpZ2h0UnVsZXMgfHwgbmV3IHRoaXMuSGlnaGxpZ2h0UnVsZXModGhpcy4kaGlnaGxpZ2h0UnVsZUNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHRoaXMuJGhpZ2hsaWdodFJ1bGVzLmdldFJ1bGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiR0b2tlbml6ZXI7XG4gICAgfTtcbiAgICB0aGlzLmxpbmVDb21tZW50U3RhcnQgPSBcIlwiO1xuICAgIHRoaXMuYmxvY2tDb21tZW50ID0gXCJcIjtcbiAgICB0aGlzLnRvZ2dsZUNvbW1lbnRMaW5lcyA9IGZ1bmN0aW9uIChzdGF0ZSwgc2Vzc2lvbiwgc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICB2YXIgZG9jID0gc2Vzc2lvbi5kb2M7XG4gICAgICAgIHZhciBpZ25vcmVCbGFua0xpbmVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNob3VsZFJlbW92ZSA9IHRydWU7XG4gICAgICAgIHZhciBtaW5JbmRlbnQgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHRhYlNpemUgPSBzZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgdmFyIGluc2VydEF0VGFiU3RvcCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMubGluZUNvbW1lbnRTdGFydCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJsb2NrQ29tbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbGluZUNvbW1lbnRTdGFydCA9IHRoaXMuYmxvY2tDb21tZW50LnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50RW5kID0gdGhpcy5ibG9ja0NvbW1lbnQuZW5kO1xuICAgICAgICAgICAgdmFyIHJlZ2V4cFN0YXJ0ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKSg/OlwiICsgbGFuZy5lc2NhcGVSZWdFeHAobGluZUNvbW1lbnRTdGFydCkgKyBcIilcIik7XG4gICAgICAgICAgICB2YXIgcmVnZXhwRW5kID0gbmV3IFJlZ0V4cChcIig/OlwiICsgbGFuZy5lc2NhcGVSZWdFeHAobGluZUNvbW1lbnRFbmQpICsgXCIpXFxcXHMqJFwiKTtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFJlbW92ZShsaW5lLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghaWdub3JlQmxhbmtMaW5lcyB8fCAvXFxTLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRJbkxpbmUoeyByb3c6IGksIGNvbHVtbjogbGluZS5sZW5ndGggfSwgbGluZUNvbW1lbnRFbmQpO1xuICAgICAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0SW5MaW5lKHsgcm93OiBpLCBjb2x1bW46IG1pbkluZGVudCB9LCBsaW5lQ29tbWVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHVuY29tbWVudCA9IGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICAgICAgaWYgKG0gPSBsaW5lLm1hdGNoKHJlZ2V4cEVuZCkpXG4gICAgICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVJbkxpbmUoaSwgbGluZS5sZW5ndGggLSBtWzBdLmxlbmd0aCwgbGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChtID0gbGluZS5tYXRjaChyZWdleHBTdGFydCkpXG4gICAgICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVJbkxpbmUoaSwgbVsxXS5sZW5ndGgsIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGVzdFJlbW92ZSA9IGZ1bmN0aW9uIChsaW5lLCByb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXhwU3RhcnQudGVzdChsaW5lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSBcImNvbW1lbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmxpbmVDb21tZW50U3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cFN0YXJ0ID0gdGhpcy5saW5lQ29tbWVudFN0YXJ0Lm1hcChsYW5nLmVzY2FwZVJlZ0V4cCkuam9pbihcInxcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50U3RhcnQgPSB0aGlzLmxpbmVDb21tZW50U3RhcnRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwU3RhcnQgPSBsYW5nLmVzY2FwZVJlZ0V4cCh0aGlzLmxpbmVDb21tZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudFN0YXJ0ID0gdGhpcy5saW5lQ29tbWVudFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnZXhwU3RhcnQgPSBuZXcgUmVnRXhwKFwiXihcXFxccyopKD86XCIgKyByZWdleHBTdGFydCArIFwiKSA/XCIpO1xuICAgICAgICAgICAgaW5zZXJ0QXRUYWJTdG9wID0gc2Vzc2lvbi5nZXRVc2VTb2Z0VGFicygpO1xuICAgICAgICAgICAgdmFyIHVuY29tbWVudCA9IGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKHJlZ2V4cFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBtWzFdLmxlbmd0aCwgZW5kID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRJbnNlcnRTcGFjZShsaW5lLCBzdGFydCwgZW5kKSAmJiBtWzBdW2VuZCAtIDFdID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlSW5MaW5lKGksIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb21tZW50V2l0aFNwYWNlID0gbGluZUNvbW1lbnRTdGFydCArIFwiIFwiO1xuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgICAgIGlmICghaWdub3JlQmxhbmtMaW5lcyB8fCAvXFxTLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJbnNlcnRTcGFjZShsaW5lLCBtaW5JbmRlbnQsIG1pbkluZGVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0SW5MaW5lKHsgcm93OiBpLCBjb2x1bW46IG1pbkluZGVudCB9LCBjb21tZW50V2l0aFNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7IHJvdzogaSwgY29sdW1uOiBtaW5JbmRlbnQgfSwgbGluZUNvbW1lbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0ZXN0UmVtb3ZlID0gZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwU3RhcnQudGVzdChsaW5lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2hvdWxkSW5zZXJ0U3BhY2UgPSBmdW5jdGlvbiAobGluZSwgYmVmb3JlLCBhZnRlcikge1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChiZWZvcmUtLSAmJiBsaW5lLmNoYXJBdChiZWZvcmUpID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICBzcGFjZXMrKztcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VzICUgdGFiU2l6ZSAhPSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlcyA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxpbmUuY2hhckF0KGFmdGVyKyspID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICBzcGFjZXMrKztcbiAgICAgICAgICAgICAgICBpZiAodGFiU2l6ZSA+IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGFjZXMgJSB0YWJTaXplICE9IHRhYlNpemUgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlcyAlIHRhYlNpemUgPT0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXRlcihmdW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7IGkrKylcbiAgICAgICAgICAgICAgICBmdW4oZG9jLmdldExpbmUoaSksIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5FbXB0eUxlbmd0aCA9IEluZmluaXR5O1xuICAgICAgICBpdGVyKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gbGluZS5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgaWYgKGluZGVudCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSAmJiAhdGVzdFJlbW92ZShsaW5lLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtaW5FbXB0eUxlbmd0aCA+IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWluRW1wdHlMZW5ndGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaW5JbmRlbnQgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIG1pbkluZGVudCA9IG1pbkVtcHR5TGVuZ3RoO1xuICAgICAgICAgICAgaWdub3JlQmxhbmtMaW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgc2hvdWxkUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydEF0VGFiU3RvcCAmJiBtaW5JbmRlbnQgJSB0YWJTaXplICE9IDApXG4gICAgICAgICAgICBtaW5JbmRlbnQgPSBNYXRoLmZsb29yKG1pbkluZGVudCAvIHRhYlNpemUpICogdGFiU2l6ZTtcbiAgICAgICAgaXRlcihzaG91bGRSZW1vdmUgPyB1bmNvbW1lbnQgOiBjb21tZW50KTtcbiAgICB9O1xuICAgIHRoaXMudG9nZ2xlQmxvY2tDb21tZW50ID0gZnVuY3Rpb24gKHN0YXRlLCBzZXNzaW9uLCByYW5nZSwgY3Vyc29yKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5ibG9ja0NvbW1lbnQ7XG4gICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjb21tZW50LnN0YXJ0ICYmIGNvbW1lbnRbMF0pXG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudFswXTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3Ioc2Vzc2lvbiwgY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB2YXIgc2VsID0gc2Vzc2lvbi5zZWxlY3Rpb247XG4gICAgICAgIHZhciBpbml0aWFsUmFuZ2UgPSBzZXNzaW9uLnNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcbiAgICAgICAgdmFyIHN0YXJ0Um93LCBjb2xEaWZmO1xuICAgICAgICBpZiAodG9rZW4gJiYgL2NvbW1lbnQvLnRlc3QodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFJhbmdlLCBlbmRSYW5nZTtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbiAmJiAvY29tbWVudC8udGVzdCh0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdG9rZW4udmFsdWUuaW5kZXhPZihjb21tZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIGk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4sIHJvdywgY29sdW1uICsgY29tbWVudC5zdGFydC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gJiYgL2NvbW1lbnQvLnRlc3QodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRva2VuLnZhbHVlLmluZGV4T2YoY29tbWVudC5lbmQpO1xuICAgICAgICAgICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgaTtcbiAgICAgICAgICAgICAgICAgICAgZW5kUmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4sIHJvdywgY29sdW1uICsgY29tbWVudC5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRSYW5nZSlcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZShlbmRSYW5nZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKHN0YXJ0UmFuZ2UpO1xuICAgICAgICAgICAgICAgIHN0YXJ0Um93ID0gc3RhcnRSYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICAgICAgY29sRGlmZiA9IC1jb21tZW50LnN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbERpZmYgPSBjb21tZW50LnN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQocmFuZ2UuZW5kLCBjb21tZW50LmVuZCk7XG4gICAgICAgICAgICBzZXNzaW9uLmluc2VydChyYW5nZS5zdGFydCwgY29tbWVudC5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxSYW5nZS5zdGFydC5yb3cgPT0gc3RhcnRSb3cpXG4gICAgICAgICAgICBpbml0aWFsUmFuZ2Uuc3RhcnQuY29sdW1uICs9IGNvbERpZmY7XG4gICAgICAgIGlmIChpbml0aWFsUmFuZ2UuZW5kLnJvdyA9PSBzdGFydFJvdylcbiAgICAgICAgICAgIGluaXRpYWxSYW5nZS5lbmQuY29sdW1uICs9IGNvbERpZmY7XG4gICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKGluaXRpYWxSYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLmdldE5leHRMaW5lSW5kZW50ID0gZnVuY3Rpb24gKHN0YXRlLCBsaW5lLCB0YWIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGdldEluZGVudChsaW5lKTtcbiAgICB9O1xuICAgIHRoaXMuY2hlY2tPdXRkZW50ID0gZnVuY3Rpb24gKHN0YXRlLCBsaW5lLCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmF1dG9PdXRkZW50ID0gZnVuY3Rpb24gKHN0YXRlLCBkb2MsIHJvdykge1xuICAgIH07XG4gICAgdGhpcy4kZ2V0SW5kZW50ID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmUubWF0Y2goL15cXHMqLylbMF07XG4gICAgfTtcbiAgICB0aGlzLmNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdGhpcy5jcmVhdGVNb2RlRGVsZWdhdGVzID0gZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdGhpcy4kZW1iZWRzID0gW107XG4gICAgICAgIHRoaXMuJG1vZGVzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgaWYgKG1hcHBpbmdbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgTW9kZSA9IG1hcHBpbmdbaV07XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gTW9kZS5wcm90b3R5cGUuJGlkO1xuICAgICAgICAgICAgICAgIHZhciBtb2RlID0gY29uZmlnLiRtb2Rlc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFtb2RlKVxuICAgICAgICAgICAgICAgICAgICBjb25maWcuJG1vZGVzW2lkXSA9IG1vZGUgPSBuZXcgTW9kZSgpO1xuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLiRtb2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLiRtb2Rlc1tpXSA9IG1vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1iZWRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kbW9kZXNbaV0gPSBtb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxlZ2F0aW9ucyA9IFtcInRvZ2dsZUJsb2NrQ29tbWVudFwiLCBcInRvZ2dsZUNvbW1lbnRMaW5lc1wiLCBcImdldE5leHRMaW5lSW5kZW50XCIsXG4gICAgICAgICAgICBcImNoZWNrT3V0ZGVudFwiLCBcImF1dG9PdXRkZW50XCIsIFwidHJhbnNmb3JtQWN0aW9uXCIsIFwiZ2V0Q29tcGxldGlvbnNcIl07XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZGVsZWdhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRIYW5kbGVyID0gc2NvcGVbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICAgICAgICBzY29wZVtkZWxlZ2F0aW9uc1tpXV0gPVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZGVsZWdhdG9yKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRzLCBkZWZhdWx0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KHRoaXNfMSkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxlZ2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy4kZGVsZWdhdG9yID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncywgZGVmYXVsdEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gYXJnc1swXSB8fCBcInN0YXJ0XCI7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGVbMl0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gc3RhdGVbMl1bc3RhdGVbMl0ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG1vZGUgPSB0aGlzLiRtb2Rlc1tsYW5ndWFnZV07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlW21ldGhvZF0uYXBwbHkobW9kZSwgW3N0YXRlWzFdXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzLCAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVswXSB8fCBcInN0YXJ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRlbWJlZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kbW9kZXNbdGhpcy4kZW1iZWRzW2ldXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHN0YXRlLnNwbGl0KHRoaXMuJGVtYmVkc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXNwbGl0WzBdICYmIHNwbGl0WzFdKSB7XG4gICAgICAgICAgICAgICAgYXJnc1swXSA9IHNwbGl0WzFdO1xuICAgICAgICAgICAgICAgIHZhciBtb2RlID0gdGhpcy4kbW9kZXNbdGhpcy4kZW1iZWRzW2ldXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZVttZXRob2RdLmFwcGx5KG1vZGUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSBkZWZhdWx0SGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRIYW5kbGVyID8gcmV0IDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdGhpcy50cmFuc2Zvcm1BY3Rpb24gPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAodGhpcy4kYmVoYXZpb3VyKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3VycyA9IHRoaXMuJGJlaGF2aW91ci5nZXRCZWhhdmlvdXJzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmVoYXZpb3Vycykge1xuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvdXJzW2tleV1bYWN0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gYmVoYXZpb3Vyc1trZXldW2FjdGlvbl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRLZXl3b3JkcyA9IGZ1bmN0aW9uIChhcHBlbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRpb25LZXl3b3Jkcykge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy4kdG9rZW5pemVyW1wicnVsZXNcIl07XG4gICAgICAgICAgICB2YXIgY29tcGxldGlvbktleXdvcmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBydWxlIGluIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVJdHIgPSBydWxlc1tydWxlXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgbCA9IHJ1bGVJdHIubGVuZ3RoOyByIDwgbDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZUl0cltyXS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9rZXl3b3JkfHN1cHBvcnR8c3RvcmFnZS8udGVzdChydWxlSXRyW3JdLnRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uS2V5d29yZHMucHVzaChydWxlSXRyW3JdLnJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZUl0cltyXS50b2tlbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDAsIGFMZW5ndGggPSBydWxlSXRyW3JdLnRva2VuLmxlbmd0aDsgYSA8IGFMZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgva2V5d29yZHxzdXBwb3J0fHN0b3JhZ2UvLnRlc3QocnVsZUl0cltyXS50b2tlblthXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlSXRyW3JdLnJlZ2V4Lm1hdGNoKC9cXCguKz9cXCkvZylbYV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25LZXl3b3Jkcy5wdXNoKHJ1bGUuc3Vic3RyKDEsIHJ1bGUubGVuZ3RoIC0gMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbktleXdvcmRzID0gY29tcGxldGlvbktleXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXBwZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGtleXdvcmRMaXN0O1xuICAgICAgICByZXR1cm4gY29tcGxldGlvbktleXdvcmRzLmNvbmNhdCh0aGlzLiRrZXl3b3JkTGlzdCB8fCBbXSk7XG4gICAgfTtcbiAgICB0aGlzLiRjcmVhdGVLZXl3b3JkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRoaWdobGlnaHRSdWxlcylcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5pemVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRrZXl3b3JkTGlzdCA9IHRoaXMuJGhpZ2hsaWdodFJ1bGVzLiRrZXl3b3JkTGlzdCB8fCBbXTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q29tcGxldGlvbnMgPSBmdW5jdGlvbiAoc3RhdGUsIHNlc3Npb24sIHBvcywgcHJlZml4KSB7XG4gICAgICAgIHZhciBrZXl3b3JkcyA9IHRoaXMuJGtleXdvcmRMaXN0IHx8IHRoaXMuJGNyZWF0ZUtleXdvcmRMaXN0KCk7XG4gICAgICAgIHJldHVybiBrZXl3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogd29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgICAgICBtZXRhOiBcImtleXdvcmRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLiRpZCA9IFwiYWNlL21vZGUvdGV4dFwiO1xufSkuY2FsbChNb2RlLnByb3RvdHlwZSk7XG5leHBvcnRzLk1vZGUgPSBNb2RlO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9hcHBseV9kZWx0YVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHRocm93RGVsdGFFcnJvcihkZWx0YSwgZXJyb3JUZXh0KSB7XG4gICAgY29uc29sZS5sb2coXCJJbnZhbGlkIERlbHRhOlwiLCBkZWx0YSk7XG4gICAgdGhyb3cgXCJJbnZhbGlkIERlbHRhOiBcIiArIGVycm9yVGV4dDtcbn1cbmZ1bmN0aW9uIHBvc2l0aW9uSW5Eb2N1bWVudChkb2NMaW5lcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb24ucm93ID49IDAgJiYgcG9zaXRpb24ucm93IDwgZG9jTGluZXMubGVuZ3RoICYmXG4gICAgICAgIHBvc2l0aW9uLmNvbHVtbiA+PSAwICYmIHBvc2l0aW9uLmNvbHVtbiA8PSBkb2NMaW5lc1twb3NpdGlvbi5yb3ddLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRGVsdGEoZG9jTGluZXMsIGRlbHRhKSB7XG4gICAgaWYgKGRlbHRhLmFjdGlvbiAhPSBcImluc2VydFwiICYmIGRlbHRhLmFjdGlvbiAhPSBcInJlbW92ZVwiKVxuICAgICAgICB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsIFwiZGVsdGEuYWN0aW9uIG11c3QgYmUgJ2luc2VydCcgb3IgJ3JlbW92ZSdcIik7XG4gICAgaWYgKCEoZGVsdGEubGluZXMgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgIHRocm93RGVsdGFFcnJvcihkZWx0YSwgXCJkZWx0YS5saW5lcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgIGlmICghZGVsdGEuc3RhcnQgfHwgIWRlbHRhLmVuZClcbiAgICAgICAgdGhyb3dEZWx0YUVycm9yKGRlbHRhLCBcImRlbHRhLnN0YXJ0L2VuZCBtdXN0IGJlIGFuIHByZXNlbnRcIik7XG4gICAgdmFyIHN0YXJ0ID0gZGVsdGEuc3RhcnQ7XG4gICAgaWYgKCFwb3NpdGlvbkluRG9jdW1lbnQoZG9jTGluZXMsIGRlbHRhLnN0YXJ0KSlcbiAgICAgICAgdGhyb3dEZWx0YUVycm9yKGRlbHRhLCBcImRlbHRhLnN0YXJ0IG11c3QgYmUgY29udGFpbmVkIGluIGRvY3VtZW50XCIpO1xuICAgIHZhciBlbmQgPSBkZWx0YS5lbmQ7XG4gICAgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVwiICYmICFwb3NpdGlvbkluRG9jdW1lbnQoZG9jTGluZXMsIGVuZCkpXG4gICAgICAgIHRocm93RGVsdGFFcnJvcihkZWx0YSwgXCJkZWx0YS5lbmQgbXVzdCBjb250YWluZWQgaW4gZG9jdW1lbnQgZm9yICdyZW1vdmUnIGFjdGlvbnNcIik7XG4gICAgdmFyIG51bVJhbmdlUm93cyA9IGVuZC5yb3cgLSBzdGFydC5yb3c7XG4gICAgdmFyIG51bVJhbmdlTGFzdExpbmVDaGFycyA9IChlbmQuY29sdW1uIC0gKG51bVJhbmdlUm93cyA9PSAwID8gc3RhcnQuY29sdW1uIDogMCkpO1xuICAgIGlmIChudW1SYW5nZVJvd3MgIT0gZGVsdGEubGluZXMubGVuZ3RoIC0gMSB8fCBkZWx0YS5saW5lc1tudW1SYW5nZVJvd3NdLmxlbmd0aCAhPSBudW1SYW5nZUxhc3RMaW5lQ2hhcnMpXG4gICAgICAgIHRocm93RGVsdGFFcnJvcihkZWx0YSwgXCJkZWx0YS5yYW5nZSBtdXN0IG1hdGNoIGRlbHRhIGxpbmVzXCIpO1xufVxuZXhwb3J0cy5hcHBseURlbHRhID0gZnVuY3Rpb24gKGRvY0xpbmVzLCBkZWx0YSwgZG9Ob3RWYWxpZGF0ZSkge1xuICAgIHZhciByb3cgPSBkZWx0YS5zdGFydC5yb3c7XG4gICAgdmFyIHN0YXJ0Q29sdW1uID0gZGVsdGEuc3RhcnQuY29sdW1uO1xuICAgIHZhciBsaW5lID0gZG9jTGluZXNbcm93XSB8fCBcIlwiO1xuICAgIHN3aXRjaCAoZGVsdGEuYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGRlbHRhLmxpbmVzO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRvY0xpbmVzW3Jvd10gPSBsaW5lLnN1YnN0cmluZygwLCBzdGFydENvbHVtbikgKyBkZWx0YS5saW5lc1swXSArIGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW3JvdywgMV0uY29uY2F0KGRlbHRhLmxpbmVzKTtcbiAgICAgICAgICAgICAgICBkb2NMaW5lcy5zcGxpY2UuYXBwbHkoZG9jTGluZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGRvY0xpbmVzW3Jvd10gPSBsaW5lLnN1YnN0cmluZygwLCBzdGFydENvbHVtbikgKyBkb2NMaW5lc1tyb3ddO1xuICAgICAgICAgICAgICAgIGRvY0xpbmVzW3JvdyArIGRlbHRhLmxpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gZGVsdGEuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIHZhciBlbmRSb3cgPSBkZWx0YS5lbmQucm93O1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gZW5kUm93KSB7XG4gICAgICAgICAgICAgICAgZG9jTGluZXNbcm93XSA9IGxpbmUuc3Vic3RyaW5nKDAsIHN0YXJ0Q29sdW1uKSArIGxpbmUuc3Vic3RyaW5nKGVuZENvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2NMaW5lcy5zcGxpY2Uocm93LCBlbmRSb3cgLSByb3cgKyAxLCBsaW5lLnN1YnN0cmluZygwLCBzdGFydENvbHVtbikgKyBkb2NMaW5lc1tlbmRSb3ddLnN1YnN0cmluZyhlbmRDb2x1bW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2FuY2hvclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBBbmNob3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5jaG9yKGRvYywgcm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy4kb25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0YWNoKGRvYyk7XG4gICAgICAgIGlmICh0eXBlb2Ygcm93ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHJvdy5yb3csIHJvdy5jb2x1bW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHJvdywgY29sdW1uKTtcbiAgICB9XG4gICAgQW5jaG9yLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQodGhpcy5yb3csIHRoaXMuY29sdW1uKTtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50O1xuICAgIH07XG4gICAgQW5jaG9yLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICBpZiAoZGVsdGEuc3RhcnQucm93ID09IGRlbHRhLmVuZC5yb3cgJiYgZGVsdGEuc3RhcnQucm93ICE9IHRoaXMucm93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZGVsdGEuc3RhcnQucm93ID4gdGhpcy5yb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwb2ludCA9ICRnZXRUcmFuc2Zvcm1lZFBvaW50KGRlbHRhLCB7IHJvdzogdGhpcy5yb3csIGNvbHVtbjogdGhpcy5jb2x1bW4gfSwgdGhpcy4kaW5zZXJ0UmlnaHQpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHBvaW50LnJvdywgcG9pbnQuY29sdW1uLCB0cnVlKTtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIG5vQ2xpcCkge1xuICAgICAgICB2YXIgcG9zO1xuICAgICAgICBpZiAobm9DbGlwKSB7XG4gICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KHJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3cgPT0gcG9zLnJvdyAmJiB0aGlzLmNvbHVtbiA9PSBwb3MuY29sdW1uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb2xkID0ge1xuICAgICAgICAgICAgcm93OiB0aGlzLnJvdyxcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yb3cgPSBwb3Mucm93O1xuICAgICAgICB0aGlzLmNvbHVtbiA9IHBvcy5jb2x1bW47XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCB7XG4gICAgICAgICAgICBvbGQ6IG9sZCxcbiAgICAgICAgICAgIHZhbHVlOiBwb3NcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBbmNob3IucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UpO1xuICAgIH07XG4gICAgQW5jaG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2MgfHwgdGhpcy5kb2N1bWVudDtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vbihcImNoYW5nZVwiLCB0aGlzLiRvbkNoYW5nZSk7XG4gICAgfTtcbiAgICBBbmNob3IucHJvdG90eXBlLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBwb3MgPSB7fTtcbiAgICAgICAgaWYgKHJvdyA+PSB0aGlzLmRvY3VtZW50LmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgICBwb3Mucm93ID0gTWF0aC5tYXgoMCwgdGhpcy5kb2N1bWVudC5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICAgICAgcG9zLmNvbHVtbiA9IHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgcG9zLnJvdyA9IDA7XG4gICAgICAgICAgICBwb3MuY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcy5yb3cgPSByb3c7XG4gICAgICAgICAgICBwb3MuY29sdW1uID0gTWF0aC5taW4odGhpcy5kb2N1bWVudC5nZXRMaW5lKHBvcy5yb3cpLmxlbmd0aCwgTWF0aC5tYXgoMCwgY29sdW1uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbiA8IDApXG4gICAgICAgICAgICBwb3MuY29sdW1uID0gMDtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIHJldHVybiBBbmNob3I7XG59KCkpO1xuQW5jaG9yLnByb3RvdHlwZS4kaW5zZXJ0UmlnaHQgPSBmYWxzZTtcbm9vcC5pbXBsZW1lbnQoQW5jaG9yLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uICRwb2ludHNJbk9yZGVyKHBvaW50MSwgcG9pbnQyLCBlcXVhbFBvaW50c0luT3JkZXIpIHtcbiAgICB2YXIgYkNvbElzQWZ0ZXIgPSBlcXVhbFBvaW50c0luT3JkZXIgPyBwb2ludDEuY29sdW1uIDw9IHBvaW50Mi5jb2x1bW4gOiBwb2ludDEuY29sdW1uIDwgcG9pbnQyLmNvbHVtbjtcbiAgICByZXR1cm4gKHBvaW50MS5yb3cgPCBwb2ludDIucm93KSB8fCAocG9pbnQxLnJvdyA9PSBwb2ludDIucm93ICYmIGJDb2xJc0FmdGVyKTtcbn1cbmZ1bmN0aW9uICRnZXRUcmFuc2Zvcm1lZFBvaW50KGRlbHRhLCBwb2ludCwgbW92ZUlmRXF1YWwpIHtcbiAgICB2YXIgZGVsdGFJc0luc2VydCA9IGRlbHRhLmFjdGlvbiA9PSBcImluc2VydFwiO1xuICAgIHZhciBkZWx0YVJvd1NoaWZ0ID0gKGRlbHRhSXNJbnNlcnQgPyAxIDogLTEpICogKGRlbHRhLmVuZC5yb3cgLSBkZWx0YS5zdGFydC5yb3cpO1xuICAgIHZhciBkZWx0YUNvbFNoaWZ0ID0gKGRlbHRhSXNJbnNlcnQgPyAxIDogLTEpICogKGRlbHRhLmVuZC5jb2x1bW4gLSBkZWx0YS5zdGFydC5jb2x1bW4pO1xuICAgIHZhciBkZWx0YVN0YXJ0ID0gZGVsdGEuc3RhcnQ7XG4gICAgdmFyIGRlbHRhRW5kID0gZGVsdGFJc0luc2VydCA/IGRlbHRhU3RhcnQgOiBkZWx0YS5lbmQ7IC8vIENvbGxhcHNlIGluc2VydCByYW5nZS5cbiAgICBpZiAoJHBvaW50c0luT3JkZXIocG9pbnQsIGRlbHRhU3RhcnQsIG1vdmVJZkVxdWFsKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiBwb2ludC5yb3csXG4gICAgICAgICAgICBjb2x1bW46IHBvaW50LmNvbHVtblxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoJHBvaW50c0luT3JkZXIoZGVsdGFFbmQsIHBvaW50LCAhbW92ZUlmRXF1YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3c6IHBvaW50LnJvdyArIGRlbHRhUm93U2hpZnQsXG4gICAgICAgICAgICBjb2x1bW46IHBvaW50LmNvbHVtbiArIChwb2ludC5yb3cgPT0gZGVsdGFFbmQucm93ID8gZGVsdGFDb2xTaGlmdCA6IDApXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvdzogZGVsdGFTdGFydC5yb3csXG4gICAgICAgIGNvbHVtbjogZGVsdGFTdGFydC5jb2x1bW5cbiAgICB9O1xufVxuZXhwb3J0cy5BbmNob3IgPSBBbmNob3I7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2RvY3VtZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2FwcGx5X2RlbHRhXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9yYW5nZVwiLFwiYWNlL2FuY2hvclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIGFwcGx5RGVsdGEgPSByZXF1aXJlKFwiLi9hcHBseV9kZWx0YVwiKS5hcHBseURlbHRhO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoXCIuL2FuY2hvclwiKS5BbmNob3I7XG52YXIgRG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnQodGV4dE9yTGluZXMpIHtcbiAgICAgICAgdGhpcy4kbGluZXMgPSBbXCJcIl07XG4gICAgICAgIGlmICh0ZXh0T3JMaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuJGxpbmVzID0gW1wiXCJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGV4dE9yTGluZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydE1lcmdlZExpbmVzKHsgcm93OiAwLCBjb2x1bW46IDAgfSwgdGV4dE9yTGluZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQoeyByb3c6IDAsIGNvbHVtbjogMCB9LCB0ZXh0T3JMaW5lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB0aGlzLnJlbW92ZShuZXcgUmFuZ2UoMCwgMCwgbGVuLCB0aGlzLmdldExpbmUobGVuKS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoeyByb3c6IDAsIGNvbHVtbjogMCB9LCB0ZXh0IHx8IFwiXCIpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxMaW5lcygpLmpvaW4odGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUFuY2hvciA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gbmV3IEFuY2hvcih0aGlzLCByb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuJGRldGVjdE5ld0xpbmUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eLio/KFxcclxcbnxcXHJ8XFxuKS9tKTtcbiAgICAgICAgdGhpcy4kYXV0b05ld0xpbmUgPSBtYXRjaCA/IG1hdGNoWzFdIDogXCJcXG5cIjtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlTmV3TGluZU1vZGVcIik7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuZ2V0TmV3TGluZUNoYXJhY3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLiRuZXdMaW5lTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcIndpbmRvd3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHJcXG5cIjtcbiAgICAgICAgICAgIGNhc2UgXCJ1bml4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRhdXRvTmV3TGluZSB8fCBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuc2V0TmV3TGluZU1vZGUgPSBmdW5jdGlvbiAobmV3TGluZU1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJG5ld0xpbmVNb2RlID09PSBuZXdMaW5lTW9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kbmV3TGluZU1vZGUgPSBuZXdMaW5lTW9kZTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlTmV3TGluZU1vZGVcIik7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuZ2V0TmV3TGluZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRuZXdMaW5lTW9kZTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5pc05ld0xpbmUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gKHRleHQgPT0gXCJcXHJcXG5cIiB8fCB0ZXh0ID09IFwiXFxyXCIgfHwgdGV4dCA9PSBcIlxcblwiKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRMaW5lID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbGluZXNbcm93XSB8fCBcIlwiO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRsaW5lcy5zbGljZShmaXJzdFJvdywgbGFzdFJvdyArIDEpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldEFsbExpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lcygwLCB0aGlzLmdldExlbmd0aCgpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRsaW5lcy5sZW5ndGg7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuZ2V0VGV4dFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExpbmVzRm9yUmFuZ2UocmFuZ2UpLmpvaW4odGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVzRm9yUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGxpbmVzO1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID09PSByYW5nZS5lbmQucm93KSB7XG4gICAgICAgICAgICBsaW5lcyA9IFt0aGlzLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uLCByYW5nZS5lbmQuY29sdW1uKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuZ2V0TGluZXMocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5lbmQucm93KTtcbiAgICAgICAgICAgIGxpbmVzWzBdID0gKGxpbmVzWzBdIHx8IFwiXCIpLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgdmFyIGwgPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cgPT0gbClcbiAgICAgICAgICAgICAgICBsaW5lc1tsXSA9IGxpbmVzW2xdLnN1YnN0cmluZygwLCByYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuaW5zZXJ0TGluZXMgPSBmdW5jdGlvbiAocm93LCBsaW5lcykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVc2Ugb2YgZG9jdW1lbnQuaW5zZXJ0TGluZXMgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBpbnNlcnRGdWxsTGluZXMgbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRGdWxsTGluZXMocm93LCBsaW5lcyk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucmVtb3ZlTGluZXMgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVXNlIG9mIGRvY3VtZW50LnJlbW92ZUxpbmVzIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgcmVtb3ZlRnVsbExpbmVzIG1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRnVsbExpbmVzKGZpcnN0Um93LCBsYXN0Um93KTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5pbnNlcnROZXdMaW5lID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVzZSBvZiBkb2N1bWVudC5pbnNlcnROZXdMaW5lIGlzIGRlcHJlY2F0ZWQuIFVzZSBpbnNlcnRNZXJnZWRMaW5lcyhwb3NpdGlvbiwgWycnLCAnJ10pIGluc3RlYWQuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRNZXJnZWRMaW5lcyhwb3NpdGlvbiwgW1wiXCIsIFwiXCJdKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocG9zaXRpb24sIHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0TGVuZ3RoKCkgPD0gMSlcbiAgICAgICAgICAgIHRoaXMuJGRldGVjdE5ld0xpbmUodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydE1lcmdlZExpbmVzKHBvc2l0aW9uLCB0aGlzLiRzcGxpdCh0ZXh0KSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuaW5zZXJ0SW5MaW5lID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuY2xpcHBlZFBvcyhwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnBvcyhwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbiArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5hcHBseURlbHRhKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgYWN0aW9uOiBcImluc2VydFwiLFxuICAgICAgICAgICAgbGluZXM6IFt0ZXh0XVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVQb3MoZW5kKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5jbGlwcGVkUG9zID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICBpZiAocm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJvdyA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3cgPCAwKSB7XG4gICAgICAgICAgICByb3cgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdyA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJvdyA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb2x1bW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocm93KTtcbiAgICAgICAgaWYgKGNvbHVtbiA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjb2x1bW4gPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY29sdW1uID0gTWF0aC5taW4oTWF0aC5tYXgoY29sdW1uLCAwKSwgbGluZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4geyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5jbG9uZVBvcyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgcm93OiBwb3Mucm93LCBjb2x1bW46IHBvcy5jb2x1bW4gfTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuJGNsaXBQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLnJvdyA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnJvdyA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcG9zaXRpb24uY29sdW1uID0gdGhpcy5nZXRMaW5lKGxlbmd0aCAtIDEpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnJvdyA9IE1hdGgubWF4KDAsIHBvc2l0aW9uLnJvdyk7XG4gICAgICAgICAgICBwb3NpdGlvbi5jb2x1bW4gPSBNYXRoLm1pbihNYXRoLm1heChwb3NpdGlvbi5jb2x1bW4sIDApLCB0aGlzLmdldExpbmUocG9zaXRpb24ucm93KS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5pbnNlcnRGdWxsTGluZXMgPSBmdW5jdGlvbiAocm93LCBsaW5lcykge1xuICAgICAgICByb3cgPSBNYXRoLm1pbihNYXRoLm1heChyb3csIDApLCB0aGlzLmdldExlbmd0aCgpKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IDA7XG4gICAgICAgIGlmIChyb3cgPCB0aGlzLmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVzLmNvbmNhdChbXCJcIl0pO1xuICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVzID0gW1wiXCJdLmNvbmNhdChsaW5lcyk7XG4gICAgICAgICAgICByb3ctLTtcbiAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuJGxpbmVzW3Jvd10ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0TWVyZ2VkTGluZXMoeyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gfSwgbGluZXMpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmluc2VydE1lcmdlZExpbmVzID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lcykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmNsaXBwZWRQb3MocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICB2YXIgZW5kID0ge1xuICAgICAgICAgICAgcm93OiBzdGFydC5yb3cgKyBsaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgY29sdW1uOiAobGluZXMubGVuZ3RoID09IDEgPyBzdGFydC5jb2x1bW4gOiAwKSArIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5zZXJ0XCIsXG4gICAgICAgICAgICBsaW5lczogbGluZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lUG9zKGVuZCk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuY2xpcHBlZFBvcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmNsaXBwZWRQb3MocmFuZ2UuZW5kLnJvdywgcmFuZ2UuZW5kLmNvbHVtbik7XG4gICAgICAgIHRoaXMuYXBwbHlEZWx0YSh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVcIixcbiAgICAgICAgICAgIGxpbmVzOiB0aGlzLmdldExpbmVzRm9yUmFuZ2UoeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZVBvcyhzdGFydCk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucmVtb3ZlSW5MaW5lID0gZnVuY3Rpb24gKHJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmNsaXBwZWRQb3Mocm93LCBzdGFydENvbHVtbik7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmNsaXBwZWRQb3Mocm93LCBlbmRDb2x1bW4pO1xuICAgICAgICB0aGlzLmFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBhY3Rpb246IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICBsaW5lczogdGhpcy5nZXRMaW5lc0ZvclJhbmdlKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVQb3Moc3RhcnQpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZUZ1bGxMaW5lcyA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICBmaXJzdFJvdyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGZpcnN0Um93KSwgdGhpcy5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICBsYXN0Um93ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbGFzdFJvdyksIHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgdmFyIGRlbGV0ZUZpcnN0TmV3TGluZSA9IGxhc3RSb3cgPT0gdGhpcy5nZXRMZW5ndGgoKSAtIDEgJiYgZmlyc3RSb3cgPiAwO1xuICAgICAgICB2YXIgZGVsZXRlTGFzdE5ld0xpbmUgPSBsYXN0Um93IDwgdGhpcy5nZXRMZW5ndGgoKSAtIDE7XG4gICAgICAgIHZhciBzdGFydFJvdyA9IChkZWxldGVGaXJzdE5ld0xpbmUgPyBmaXJzdFJvdyAtIDEgOiBmaXJzdFJvdyk7XG4gICAgICAgIHZhciBzdGFydENvbCA9IChkZWxldGVGaXJzdE5ld0xpbmUgPyB0aGlzLmdldExpbmUoc3RhcnRSb3cpLmxlbmd0aCA6IDApO1xuICAgICAgICB2YXIgZW5kUm93ID0gKGRlbGV0ZUxhc3ROZXdMaW5lID8gbGFzdFJvdyArIDEgOiBsYXN0Um93KTtcbiAgICAgICAgdmFyIGVuZENvbCA9IChkZWxldGVMYXN0TmV3TGluZSA/IDAgOiB0aGlzLmdldExpbmUoZW5kUm93KS5sZW5ndGgpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sLCBlbmRSb3csIGVuZENvbCk7XG4gICAgICAgIHZhciBkZWxldGVkTGluZXMgPSB0aGlzLiRsaW5lcy5zbGljZShmaXJzdFJvdywgbGFzdFJvdyArIDEpO1xuICAgICAgICB0aGlzLmFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgc3RhcnQ6IHJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiByYW5nZS5lbmQsXG4gICAgICAgICAgICBhY3Rpb246IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICBsaW5lczogdGhpcy5nZXRMaW5lc0ZvclJhbmdlKHJhbmdlKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWRMaW5lcztcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVOZXdMaW5lID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBpZiAocm93IDwgdGhpcy5nZXRMZW5ndGgoKSAtIDEgJiYgcm93ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZWx0YSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucG9zKHJvdywgdGhpcy5nZXRMaW5lKHJvdykubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMucG9zKHJvdyArIDEsIDApLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICBsaW5lczogW1wiXCIsIFwiXCJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCAmJiByYW5nZS5pc0VtcHR5KCkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmICh0ZXh0ID09IHRoaXMuZ2V0VGV4dFJhbmdlKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5lbmQ7XG4gICAgICAgIHRoaXMucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuaW5zZXJ0KHJhbmdlLnN0YXJ0LCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuYXBwbHlEZWx0YXMgPSBmdW5jdGlvbiAoZGVsdGFzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVsdGEoZGVsdGFzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJldmVydERlbHRhcyA9IGZ1bmN0aW9uIChkZWx0YXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlbHRhcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5yZXZlcnREZWx0YShkZWx0YXNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuYXBwbHlEZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSwgZG9Ob3RWYWxpZGF0ZSkge1xuICAgICAgICB2YXIgaXNJbnNlcnQgPSBkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIjtcbiAgICAgICAgaWYgKGlzSW5zZXJ0ID8gZGVsdGEubGluZXMubGVuZ3RoIDw9IDEgJiYgIWRlbHRhLmxpbmVzWzBdXG4gICAgICAgICAgICA6ICFSYW5nZS5jb21wYXJlUG9pbnRzKGRlbHRhLnN0YXJ0LCBkZWx0YS5lbmQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5zZXJ0ICYmIGRlbHRhLmxpbmVzLmxlbmd0aCA+IDIwMDAwKSB7XG4gICAgICAgICAgICB0aGlzLiRzcGxpdEFuZGFwcGx5TGFyZ2VEZWx0YShkZWx0YSwgMjAwMDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXBwbHlEZWx0YSh0aGlzLiRsaW5lcywgZGVsdGEsIGRvTm90VmFsaWRhdGUpO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlXCIsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLiRzYWZlQXBwbHlEZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgZG9jTGVuZ3RoID0gdGhpcy4kbGluZXMubGVuZ3RoO1xuICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlXCIgJiYgZGVsdGEuc3RhcnQucm93IDwgZG9jTGVuZ3RoICYmIGRlbHRhLmVuZC5yb3cgPCBkb2NMZW5ndGhcbiAgICAgICAgICAgIHx8IGRlbHRhLmFjdGlvbiA9PSBcImluc2VydFwiICYmIGRlbHRhLnN0YXJ0LnJvdyA8PSBkb2NMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZWx0YShkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS4kc3BsaXRBbmRhcHBseUxhcmdlRGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEsIE1BWCkge1xuICAgICAgICB2YXIgbGluZXMgPSBkZWx0YS5saW5lcztcbiAgICAgICAgdmFyIGwgPSBsaW5lcy5sZW5ndGggLSBNQVggKyAxO1xuICAgICAgICB2YXIgcm93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gZGVsdGEuc3RhcnQuY29sdW1uO1xuICAgICAgICBmb3IgKHZhciBmcm9tID0gMCwgdG8gPSAwOyBmcm9tIDwgbDsgZnJvbSA9IHRvKSB7XG4gICAgICAgICAgICB0byArPSBNQVggLSAxO1xuICAgICAgICAgICAgdmFyIGNodW5rID0gbGluZXMuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgY2h1bmsucHVzaChcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZWx0YSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucG9zKHJvdyArIGZyb20sIGNvbHVtbiksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBvcyhyb3cgKyB0bywgY29sdW1uID0gMCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBkZWx0YS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgbGluZXM6IGNodW5rXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YS5saW5lcyA9IGxpbmVzLnNsaWNlKGZyb20pO1xuICAgICAgICBkZWx0YS5zdGFydC5yb3cgPSByb3cgKyBmcm9tO1xuICAgICAgICBkZWx0YS5zdGFydC5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMuYXBwbHlEZWx0YShkZWx0YSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucmV2ZXJ0RGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdGhpcy4kc2FmZUFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2xvbmVQb3MoZGVsdGEuc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiB0aGlzLmNsb25lUG9zKGRlbHRhLmVuZCksXG4gICAgICAgICAgICBhY3Rpb246IChkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIiA/IFwicmVtb3ZlXCIgOiBcImluc2VydFwiKSxcbiAgICAgICAgICAgIGxpbmVzOiBkZWx0YS5saW5lcy5zbGljZSgpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmluZGV4VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgc3RhcnRSb3cpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy4kbGluZXMgfHwgdGhpcy5nZXRBbGxMaW5lcygpO1xuICAgICAgICB2YXIgbmV3bGluZUxlbmd0aCA9IHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93IHx8IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4IC09IGxpbmVzW2ldLmxlbmd0aCArIG5ld2xpbmVMZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJvdzogaSwgY29sdW1uOiBpbmRleCArIGxpbmVzW2ldLmxlbmd0aCArIG5ld2xpbmVMZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByb3c6IGwgLSAxLCBjb2x1bW46IGluZGV4ICsgbGluZXNbbCAtIDFdLmxlbmd0aCArIG5ld2xpbmVMZW5ndGggfTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5wb3NpdGlvblRvSW5kZXggPSBmdW5jdGlvbiAocG9zLCBzdGFydFJvdykge1xuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLiRsaW5lcyB8fCB0aGlzLmdldEFsbExpbmVzKCk7XG4gICAgICAgIHZhciBuZXdsaW5lTGVuZ3RoID0gdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgcm93ID0gTWF0aC5taW4ocG9zLnJvdywgbGluZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93IHx8IDA7IGkgPCByb3c7ICsraSlcbiAgICAgICAgICAgIGluZGV4ICs9IGxpbmVzW2ldLmxlbmd0aCArIG5ld2xpbmVMZW5ndGg7XG4gICAgICAgIHJldHVybiBpbmRleCArIHBvcy5jb2x1bW47XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuJHNwbGl0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdW1lbnQ7XG59KCkpO1xuRG9jdW1lbnQucHJvdG90eXBlLiRhdXRvTmV3TGluZSA9IFwiXCI7XG5Eb2N1bWVudC5wcm90b3R5cGUuJG5ld0xpbmVNb2RlID0gXCJhdXRvXCI7XG5vb3AuaW1wbGVtZW50KERvY3VtZW50LnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYmFja2dyb3VuZF90b2tlbml6ZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgQmFja2dyb3VuZFRva2VuaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYWNrZ3JvdW5kVG9rZW5pemVyKHRva2VuaXplciwgc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gMDtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy4kd29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd29ya2VyU3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gc2VsZi5jdXJyZW50TGluZTtcbiAgICAgICAgICAgIHZhciBlbmRMaW5lID0gLTE7XG4gICAgICAgICAgICB2YXIgZG9jID0gc2VsZi5kb2M7XG4gICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gY3VycmVudExpbmU7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZi5saW5lc1tjdXJyZW50TGluZV0pXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmUrKztcbiAgICAgICAgICAgIHZhciBsZW4gPSBkb2MuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkTGluZXMgPSAwO1xuICAgICAgICAgICAgc2VsZi5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudExpbmUgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLiR0b2tlbml6ZVJvdyhjdXJyZW50TGluZSk7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmUrKztcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzZWxmLmxpbmVzW2N1cnJlbnRMaW5lXSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTGluZXMrKztcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3NlZExpbmVzICUgNSA9PT0gMCkgJiYgKG5ldyBEYXRlKCkgLSB3b3JrZXJTdGFydCkgPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJ1bm5pbmcgPSBzZXRUaW1lb3V0KHNlbGYuJHdvcmtlciwgMjApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRMaW5lID0gY3VycmVudExpbmU7XG4gICAgICAgICAgICBpZiAoZW5kTGluZSA9PSAtMSlcbiAgICAgICAgICAgICAgICBlbmRMaW5lID0gY3VycmVudExpbmU7XG4gICAgICAgICAgICBpZiAoc3RhcnRMaW5lIDw9IGVuZExpbmUpXG4gICAgICAgICAgICAgICAgc2VsZi5maXJlVXBkYXRlRXZlbnQoc3RhcnRMaW5lLCBlbmRMaW5lKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuc2V0VG9rZW5pemVyID0gZnVuY3Rpb24gKHRva2VuaXplcikge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0KDApO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuZmlyZVVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgZmlyc3Q6IGZpcnN0Um93LFxuICAgICAgICAgICAgbGFzdDogbGFzdFJvd1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJ1cGRhdGVcIiwgeyBkYXRhOiBkYXRhIH0pO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnRSb3cpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IE1hdGgubWluKHN0YXJ0Um93IHx8IDAsIHRoaXMuY3VycmVudExpbmUsIHRoaXMuZG9jLmdldExlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UodGhpcy5jdXJyZW50TGluZSwgdGhpcy5saW5lcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlcy5zcGxpY2UodGhpcy5jdXJyZW50TGluZSwgdGhpcy5zdGF0ZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHNldFRpbWVvdXQodGhpcy4kd29ya2VyLCA3MDApO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuc2NoZWR1bGVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpXG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBzZXRUaW1lb3V0KHRoaXMuJHdvcmtlciwgNzAwKTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLiR1cGRhdGVPbkNoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSBkZWx0YS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBsZW4gPSBkZWx0YS5lbmQucm93IC0gc3RhcnRSb3c7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGluZXNbc3RhcnRSb3ddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5zcGxpY2Uoc3RhcnRSb3csIGxlbiArIDEsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMuc3BsaWNlKHN0YXJ0Um93LCBsZW4gKyAxLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoc3RhcnRSb3csIDEpO1xuICAgICAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UuYXBwbHkodGhpcy5saW5lcywgYXJncyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5zcGxpY2UuYXBwbHkodGhpcy5zdGF0ZXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSBNYXRoLm1pbihzdGFydFJvdywgdGhpcy5jdXJyZW50TGluZSwgdGhpcy5kb2MuZ2V0TGVuZ3RoKCkpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ydW5uaW5nKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZS5nZXRUb2tlbnMgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzW3Jvd10gfHwgdGhpcy4kdG9rZW5pemVSb3cocm93KTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TGluZSA9PSByb3cpXG4gICAgICAgICAgICB0aGlzLiR0b2tlbml6ZVJvdyhyb3cpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbcm93XSB8fCBcInN0YXJ0XCI7XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZS4kdG9rZW5pemVSb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlc1tyb3cgLSAxXTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnRva2VuaXplci5nZXRMaW5lVG9rZW5zKGxpbmUsIHN0YXRlLCByb3cpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXNbcm93XSArIFwiXCIgIT09IGRhdGEuc3RhdGUgKyBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlc1tyb3ddID0gZGF0YS5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMubGluZXNbcm93ICsgMV0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExpbmUgPiByb3cgKyAxKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExpbmUgPSByb3cgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudExpbmUgPT0gcm93KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gcm93ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tyb3ddID0gZGF0YS50b2tlbnM7XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gMDtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIHJldHVybiBCYWNrZ3JvdW5kVG9rZW5pemVyO1xufSgpKTtcbm9vcC5pbXBsZW1lbnQoQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLkJhY2tncm91bmRUb2tlbml6ZXIgPSBCYWNrZ3JvdW5kVG9rZW5pemVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9zZWFyY2hfaGlnaGxpZ2h0XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBTZWFyY2hIaWdobGlnaHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VhcmNoSGlnaGxpZ2h0KHJlZ0V4cCwgY2xhenosIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gXCJ0ZXh0XCI7IH1cbiAgICAgICAgdGhpcy5zZXRSZWdleHAocmVnRXhwKTtcbiAgICAgICAgdGhpcy5jbGF6eiA9IGNsYXp6O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBTZWFyY2hIaWdobGlnaHQucHJvdG90eXBlLnNldFJlZ2V4cCA9IGZ1bmN0aW9uIChyZWdFeHApIHtcbiAgICAgICAgaWYgKHRoaXMucmVnRXhwICsgXCJcIiA9PSByZWdFeHAgKyBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlZ0V4cCA9IHJlZ0V4cDtcbiAgICAgICAgdGhpcy5jYWNoZSA9IFtdO1xuICAgIH07XG4gICAgU2VhcmNoSGlnaGxpZ2h0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaHRtbCwgbWFya2VyTGF5ZXIsIHNlc3Npb24sIGNvbmZpZykge1xuICAgICAgICBpZiAoIXRoaXMucmVnRXhwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhcnQgPSBjb25maWcuZmlyc3RSb3csIGVuZCA9IGNvbmZpZy5sYXN0Um93O1xuICAgICAgICB2YXIgcmVuZGVyZWRNYXJrZXJSYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5jYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcyA9IGxhbmcuZ2V0TWF0Y2hPZmZzZXRzKHNlc3Npb24uZ2V0TGluZShpKSwgdGhpcy5yZWdFeHApO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gdGhpcy5NQVhfUkFOR0VTKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSByYW5nZXMuc2xpY2UoMCwgdGhpcy5NQVhfUkFOR0VTKTtcbiAgICAgICAgICAgICAgICByYW5nZXMgPSByYW5nZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGksIG1hdGNoLm9mZnNldCwgaSwgbWF0Y2gub2Zmc2V0ICsgbWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW2ldID0gcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcyA6IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcmFuZ2VzLmxlbmd0aDsgai0tOykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZVRvQWRkTWFya2VyVG8gPSByYW5nZXNbal0udG9TY3JlZW5SYW5nZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VBc1N0cmluZyA9IHJhbmdlVG9BZGRNYXJrZXJUby50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZE1hcmtlclJhbmdlc1tyYW5nZUFzU3RyaW5nXSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRNYXJrZXJSYW5nZXNbcmFuZ2VBc1N0cmluZ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcmtlckxheWVyLmRyYXdTaW5nbGVMaW5lTWFya2VyKGh0bWwsIHJhbmdlVG9BZGRNYXJrZXJUbywgdGhpcy5jbGF6eiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaEhpZ2hsaWdodDtcbn0oKSk7XG5TZWFyY2hIaWdobGlnaHQucHJvdG90eXBlLk1BWF9SQU5HRVMgPSA1MDA7XG5leHBvcnRzLlNlYXJjaEhpZ2hsaWdodCA9IFNlYXJjaEhpZ2hsaWdodDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdW5kb21hbmFnZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBVbmRvTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbmRvTWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy4ka2VlcFJlZG9TdGFjaztcbiAgICAgICAgdGhpcy4kbWF4UmV2ID0gMDtcbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kdW5kb0RlcHRoID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmFkZFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLiRzZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGVsdGEsIGFsbG93TWVyZ2UsIHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHRoaXMuJGZyb21VbmRvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZGVsdGEgPT0gdGhpcy4kbGFzdERlbHRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuJGtlZXBSZWRvU3RhY2spXG4gICAgICAgICAgICB0aGlzLiRyZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGFsbG93TWVyZ2UgPT09IGZhbHNlIHx8ICF0aGlzLmxhc3REZWx0YXMpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdERlbHRhcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHVuZG9TdGFja0xlbmd0aCA9IHRoaXMuJHVuZG9TdGFjay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodW5kb1N0YWNrTGVuZ3RoID4gdGhpcy4kdW5kb0RlcHRoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHVuZG9TdGFjay5zcGxpY2UoMCwgdW5kb1N0YWNrTGVuZ3RoIC0gdGhpcy4kdW5kb0RlcHRoICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR1bmRvU3RhY2sucHVzaCh0aGlzLmxhc3REZWx0YXMpO1xuICAgICAgICAgICAgZGVsdGEuaWQgPSB0aGlzLiRyZXYgPSArK3RoaXMuJG1heFJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlXCIgfHwgZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCIpXG4gICAgICAgICAgICB0aGlzLiRsYXN0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgdGhpcy5sYXN0RGVsdGFzLnB1c2goZGVsdGEpO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmFkZFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24sIHJldikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogc2VsZWN0aW9uLFxuICAgICAgICAgICAgcmV2OiByZXYgfHwgdGhpcy4kcmV2XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLnN0YXJ0TmV3R3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFzdERlbHRhcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZXY7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUubWFya0lnbm9yZWQgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHRoaXMuJHJldiArIDE7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuJHVuZG9TdGFjaztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gc3RhY2tbaV1bMF07XG4gICAgICAgICAgICBpZiAoZGVsdGEuaWQgPD0gZnJvbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChkZWx0YS5pZCA8IHRvKVxuICAgICAgICAgICAgICAgIGRlbHRhLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0RGVsdGFzID0gbnVsbDtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAocmV2LCBhZnRlcikge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnNlbGVjdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGFja1tpXTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ucmV2IDwgcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBzdGFja1tpICsgMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmdldFJldmlzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmV2O1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmdldERlbHRhcyA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gdGhpcy4kcmV2ICsgMTtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy4kdW5kb1N0YWNrO1xuICAgICAgICB2YXIgZW5kID0gbnVsbCwgc3RhcnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBzdGFja1tpXVswXTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5pZCA8IHRvICYmICFlbmQpXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoZGVsdGEuaWQgPD0gZnJvbSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmdldENoYW5nZWRSYW5nZXMgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHRoaXMuJHJldiArIDE7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuZ2V0Q2hhbmdlZExpbmVzID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSB0aGlzLiRyZXYgKyAxO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAoc2Vzc2lvbiwgZG9udFNlbGVjdCkge1xuICAgICAgICB0aGlzLmxhc3REZWx0YXMgPSBudWxsO1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLiR1bmRvU3RhY2s7XG4gICAgICAgIGlmICghcmVhcnJhbmdlVW5kb1N0YWNrKHN0YWNrLCBzdGFjay5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXNlc3Npb24pXG4gICAgICAgICAgICBzZXNzaW9uID0gdGhpcy4kc2Vzc2lvbjtcbiAgICAgICAgaWYgKHRoaXMuJHJlZG9TdGFja0Jhc2VSZXYgIT09IHRoaXMuJHJldiAmJiB0aGlzLiRyZWRvU3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy4kcmVkb1N0YWNrID0gW107XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRlbHRhU2V0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciB1bmRvU2VsZWN0aW9uUmFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAoZGVsdGFTZXQpIHtcbiAgICAgICAgICAgIHVuZG9TZWxlY3Rpb25SYW5nZSA9IHNlc3Npb24udW5kb0NoYW5nZXMoZGVsdGFTZXQsIGRvbnRTZWxlY3QpO1xuICAgICAgICAgICAgdGhpcy4kcmVkb1N0YWNrLnB1c2goZGVsdGFTZXQpO1xuICAgICAgICAgICAgdGhpcy4kc3luY1JldigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB1bmRvU2VsZWN0aW9uUmFuZ2U7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uIChzZXNzaW9uLCBkb250U2VsZWN0KSB7XG4gICAgICAgIHRoaXMubGFzdERlbHRhcyA9IG51bGw7XG4gICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgIHNlc3Npb24gPSB0aGlzLiRzZXNzaW9uO1xuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiRyZWRvU3RhY2tCYXNlUmV2ICE9IHRoaXMuJHJldikge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmdldERlbHRhcyh0aGlzLiRyZWRvU3RhY2tCYXNlUmV2LCB0aGlzLiRyZXYgKyAxKTtcbiAgICAgICAgICAgIHJlYmFzZVJlZG9TdGFjayh0aGlzLiRyZWRvU3RhY2ssIGRpZmYpO1xuICAgICAgICAgICAgdGhpcy4kcmVkb1N0YWNrQmFzZVJldiA9IHRoaXMuJHJldjtcbiAgICAgICAgICAgIHRoaXMuJHJlZG9TdGFjay5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgeFswXS5pZCA9ICsrdGhpcy4kbWF4UmV2O1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbHRhU2V0ID0gdGhpcy4kcmVkb1N0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVkb1NlbGVjdGlvblJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKGRlbHRhU2V0KSB7XG4gICAgICAgICAgICByZWRvU2VsZWN0aW9uUmFuZ2UgPSBzZXNzaW9uLnJlZG9DaGFuZ2VzKGRlbHRhU2V0LCBkb250U2VsZWN0KTtcbiAgICAgICAgICAgIHRoaXMuJHVuZG9TdGFjay5wdXNoKGRlbHRhU2V0KTtcbiAgICAgICAgICAgIHRoaXMuJHN5bmNSZXYoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVkb1NlbGVjdGlvblJhbmdlO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLiRzeW5jUmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLiR1bmRvU3RhY2s7XG4gICAgICAgIHZhciBuZXh0RGVsdGEgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlkID0gbmV4dERlbHRhICYmIG5leHREZWx0YVswXS5pZCB8fCAwO1xuICAgICAgICB0aGlzLiRyZWRvU3RhY2tCYXNlUmV2ID0gaWQ7XG4gICAgICAgIHRoaXMuJHJldiA9IGlkO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhc3REZWx0YXMgPSBudWxsO1xuICAgICAgICB0aGlzLiRsYXN0RGVsdGEgPSBudWxsO1xuICAgICAgICB0aGlzLiR1bmRvU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy4kcmVkb1N0YWNrID0gW107XG4gICAgICAgIHRoaXMuJHJldiA9IDA7XG4gICAgICAgIHRoaXMubWFyayA9IDA7XG4gICAgICAgIHRoaXMuJHJlZG9TdGFja0Jhc2VSZXYgPSB0aGlzLiRyZXY7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmNhblVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5jYW5SZWRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuYm9va21hcmsgPSBmdW5jdGlvbiAocmV2KSB7XG4gICAgICAgIGlmIChyZXYgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV2ID0gdGhpcy4kcmV2O1xuICAgICAgICB0aGlzLm1hcmsgPSByZXY7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuaXNBdEJvb2ttYXJrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmV2ID09PSB0aGlzLm1hcms7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHJlZG9TdGFjazogdGhpcy4kcmVkb1N0YWNrLFxuICAgICAgICAgICAgJHVuZG9TdGFjazogdGhpcy4kdW5kb1N0YWNrXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuJHVuZG9TdGFjayA9IGpzb24uJHVuZG9TdGFjaztcbiAgICAgICAgdGhpcy4kcmVkb1N0YWNrID0ganNvbi4kcmVkb1N0YWNrO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLiRwcmV0dHlQcmludCA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICBpZiAoZGVsdGEpXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5RGVsdGEoZGVsdGEpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5RGVsdGEodGhpcy4kdW5kb1N0YWNrKSArIFwiXFxuLS0tXFxuXCIgKyBzdHJpbmdpZnlEZWx0YSh0aGlzLiRyZWRvU3RhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFVuZG9NYW5hZ2VyO1xufSgpKTtcblVuZG9NYW5hZ2VyLnByb3RvdHlwZS5oYXNVbmRvID0gVW5kb01hbmFnZXIucHJvdG90eXBlLmNhblVuZG87XG5VbmRvTWFuYWdlci5wcm90b3R5cGUuaGFzUmVkbyA9IFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5jYW5SZWRvO1xuVW5kb01hbmFnZXIucHJvdG90eXBlLmlzQ2xlYW4gPSBVbmRvTWFuYWdlci5wcm90b3R5cGUuaXNBdEJvb2ttYXJrO1xuVW5kb01hbmFnZXIucHJvdG90eXBlLm1hcmtDbGVhbiA9IFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5ib29rbWFyaztcbmZ1bmN0aW9uIHJlYXJyYW5nZVVuZG9TdGFjayhzdGFjaywgcG9zKSB7XG4gICAgZm9yICh2YXIgaSA9IHBvczsgaS0tOykge1xuICAgICAgICB2YXIgZGVsdGFTZXQgPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRlbHRhU2V0ICYmICFkZWx0YVNldFswXS5pZ25vcmUpIHtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgcG9zIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBzd2FwcGVkID0gc3dhcEdyb3VwcyhzdGFja1tpXSwgc3RhY2tbaSArIDFdKTtcbiAgICAgICAgICAgICAgICBzdGFja1tpXSA9IHN3YXBwZWRbMF07XG4gICAgICAgICAgICAgICAgc3RhY2tbaSArIDFdID0gc3dhcHBlZFsxXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIGNtcCA9IFJhbmdlLmNvbXBhcmVQb2ludHM7XG52YXIgY29tcGFyZVBvaW50cyA9IFJhbmdlLmNvbXBhcmVQb2ludHM7XG5mdW5jdGlvbiAkdXBkYXRlTWFya2VycyhkZWx0YSkge1xuICAgIHZhciBpc0luc2VydCA9IGRlbHRhLmFjdGlvbiA9PSBcImluc2VydFwiO1xuICAgIHZhciBzdGFydCA9IGRlbHRhLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBkZWx0YS5lbmQ7XG4gICAgdmFyIHJvd1NoaWZ0ID0gKGVuZC5yb3cgLSBzdGFydC5yb3cpICogKGlzSW5zZXJ0ID8gMSA6IC0xKTtcbiAgICB2YXIgY29sU2hpZnQgPSAoZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbikgKiAoaXNJbnNlcnQgPyAxIDogLTEpO1xuICAgIGlmIChpc0luc2VydClcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMubWFya3NbaV07XG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJlUG9pbnRzKHBvaW50LCBzdGFydCk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZGVsdGEgc3RhcnRzIGFmdGVyIHRoZSByYW5nZVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc0luc2VydCkge1xuICAgICAgICAgICAgICAgIGlmIChwb2ludC5iaWFzID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY21wID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LmJpYXMgPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY21wMiA9IGlzSW5zZXJ0ID8gY21wIDogY29tcGFyZVBvaW50cyhwb2ludCwgZW5kKTtcbiAgICAgICAgaWYgKGNtcDIgPiAwKSB7XG4gICAgICAgICAgICBwb2ludC5yb3cgKz0gcm93U2hpZnQ7XG4gICAgICAgICAgICBwb2ludC5jb2x1bW4gKz0gcG9pbnQucm93ID09IGVuZC5yb3cgPyBjb2xTaGlmdCA6IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW5zZXJ0ICYmIGNtcDIgPD0gMCkge1xuICAgICAgICAgICAgcG9pbnQucm93ID0gc3RhcnQucm93O1xuICAgICAgICAgICAgcG9pbnQuY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgaWYgKGNtcDIgPT09IDApXG4gICAgICAgICAgICAgICAgcG9pbnQuYmlhcyA9IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbG9uZVBvcyhwb3MpIHtcbiAgICByZXR1cm4geyByb3c6IHBvcy5yb3csIGNvbHVtbjogcG9zLmNvbHVtbiB9O1xufVxuZnVuY3Rpb24gY2xvbmVEZWx0YShkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNsb25lUG9zKGQuc3RhcnQpLFxuICAgICAgICBlbmQ6IGNsb25lUG9zKGQuZW5kKSxcbiAgICAgICAgYWN0aW9uOiBkLmFjdGlvbixcbiAgICAgICAgbGluZXM6IGQubGluZXMuc2xpY2UoKVxuICAgIH07XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlEZWx0YShkKSB7XG4gICAgZCA9IGQgfHwgdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgICByZXR1cm4gZC5tYXAoc3RyaW5naWZ5RGVsdGEpLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHZhciB0eXBlID0gXCJcIjtcbiAgICBpZiAoZC5hY3Rpb24pIHtcbiAgICAgICAgdHlwZSA9IGQuYWN0aW9uID09IFwiaW5zZXJ0XCIgPyBcIitcIiA6IFwiLVwiO1xuICAgICAgICB0eXBlICs9IFwiW1wiICsgZC5saW5lcyArIFwiXVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChkLnZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGQudmFsdWUpKSB7XG4gICAgICAgICAgICB0eXBlID0gZC52YWx1ZS5tYXAoc3RyaW5naWZ5UmFuZ2UpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gc3RyaW5naWZ5UmFuZ2UoZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGQuc3RhcnQpIHtcbiAgICAgICAgdHlwZSArPSBzdHJpbmdpZnlSYW5nZShkKTtcbiAgICB9XG4gICAgaWYgKGQuaWQgfHwgZC5yZXYpIHtcbiAgICAgICAgdHlwZSArPSBcIlxcdChcIiArIChkLmlkIHx8IGQucmV2KSArIFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJhbmdlKHIpIHtcbiAgICByZXR1cm4gci5zdGFydC5yb3cgKyBcIjpcIiArIHIuc3RhcnQuY29sdW1uXG4gICAgICAgICsgXCI9PlwiICsgci5lbmQucm93ICsgXCI6XCIgKyByLmVuZC5jb2x1bW47XG59XG5mdW5jdGlvbiBzd2FwKGQxLCBkMikge1xuICAgIHZhciBpMSA9IGQxLmFjdGlvbiA9PSBcImluc2VydFwiO1xuICAgIHZhciBpMiA9IGQyLmFjdGlvbiA9PSBcImluc2VydFwiO1xuICAgIGlmIChpMSAmJiBpMikge1xuICAgICAgICBpZiAoY21wKGQyLnN0YXJ0LCBkMS5lbmQpID49IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQyLCBkMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcChkMi5zdGFydCwgZDEuc3RhcnQpIDw9IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBkMiwgKzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaTEgJiYgIWkyKSB7XG4gICAgICAgIGlmIChjbXAoZDIuc3RhcnQsIGQxLmVuZCkgPj0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDIsIGQxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wKGQyLmVuZCwgZDEuc3RhcnQpIDw9IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBkMiwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWkxICYmIGkyKSB7XG4gICAgICAgIGlmIChjbXAoZDIuc3RhcnQsIGQxLnN0YXJ0KSA+PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMiwgZDEsICsxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAoZDIuc3RhcnQsIGQxLnN0YXJ0KSA8PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMSwgZDIsICsxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpMSAmJiAhaTIpIHtcbiAgICAgICAgaWYgKGNtcChkMi5zdGFydCwgZDEuc3RhcnQpID49IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQyLCBkMSwgKzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcChkMi5lbmQsIGQxLnN0YXJ0KSA8PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMSwgZDIsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbZDIsIGQxXTtcbn1cbmZ1bmN0aW9uIHN3YXBHcm91cHMoZHMxLCBkczIpIHtcbiAgICBmb3IgKHZhciBpID0gZHMxLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRzMi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFzd2FwKGRzMVtpXSwgZHMyW2pdKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZHMxLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwKGRzMltqXSwgZHMxW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqID0gZHMyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2RzMSwgZHMyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkczEuc2VsZWN0aW9uQmVmb3JlID0gZHMyLnNlbGVjdGlvbkJlZm9yZSA9XG4gICAgICAgIGRzMS5zZWxlY3Rpb25BZnRlciA9IGRzMi5zZWxlY3Rpb25BZnRlciA9IG51bGw7XG4gICAgcmV0dXJuIFtkczIsIGRzMV07XG59XG5mdW5jdGlvbiB4Zm9ybShkMSwgYzEpIHtcbiAgICB2YXIgaTEgPSBkMS5hY3Rpb24gPT0gXCJpbnNlcnRcIjtcbiAgICB2YXIgaTIgPSBjMS5hY3Rpb24gPT0gXCJpbnNlcnRcIjtcbiAgICBpZiAoaTEgJiYgaTIpIHtcbiAgICAgICAgaWYgKGNtcChkMS5zdGFydCwgYzEuc3RhcnQpIDwgMCkge1xuICAgICAgICAgICAgc2hpZnQoYzEsIGQxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBjMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaTEgJiYgIWkyKSB7XG4gICAgICAgIGlmIChjbXAoZDEuc3RhcnQsIGMxLmVuZCkgPj0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDEsIGMxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wKGQxLnN0YXJ0LCBjMS5zdGFydCkgPD0gMCkge1xuICAgICAgICAgICAgc2hpZnQoYzEsIGQxLCArMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaGlmdChkMSwgUmFuZ2UuZnJvbVBvaW50cyhjMS5zdGFydCwgZDEuc3RhcnQpLCAtMSk7XG4gICAgICAgICAgICBzaGlmdChjMSwgZDEsICsxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaTEgJiYgaTIpIHtcbiAgICAgICAgaWYgKGNtcChjMS5zdGFydCwgZDEuZW5kKSA+PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChjMSwgZDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAoYzEuc3RhcnQsIGQxLnN0YXJ0KSA8PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMSwgYzEsICsxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNoaWZ0KGMxLCBSYW5nZS5mcm9tUG9pbnRzKGQxLnN0YXJ0LCBjMS5zdGFydCksIC0xKTtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBjMSwgKzEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpMSAmJiAhaTIpIHtcbiAgICAgICAgaWYgKGNtcChjMS5zdGFydCwgZDEuZW5kKSA+PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChjMSwgZDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAoYzEuZW5kLCBkMS5zdGFydCkgPD0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDEsIGMxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgICAgIGlmIChjbXAoZDEuc3RhcnQsIGMxLnN0YXJ0KSA8IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBkMTtcbiAgICAgICAgICAgICAgICBkMSA9IHNwbGl0RGVsdGEoZDEsIGMxLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbXAoZDEuZW5kLCBjMS5lbmQpID4gMCkge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gc3BsaXREZWx0YShkMSwgYzEuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoaWZ0UG9zKGMxLmVuZCwgZDEuc3RhcnQsIGQxLmVuZCwgLTEpO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmICFiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBkMS5saW5lcyA9IGFmdGVyLmxpbmVzO1xuICAgICAgICAgICAgICAgIGQxLnN0YXJ0ID0gYWZ0ZXIuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZDEuZW5kID0gYWZ0ZXIuZW5kO1xuICAgICAgICAgICAgICAgIGFmdGVyID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2MxLCBiZWZvcmUsIGFmdGVyXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjMSwgZDFdO1xufVxuZnVuY3Rpb24gc2hpZnQoZDEsIGQyLCBkaXIpIHtcbiAgICBzaGlmdFBvcyhkMS5zdGFydCwgZDIuc3RhcnQsIGQyLmVuZCwgZGlyKTtcbiAgICBzaGlmdFBvcyhkMS5lbmQsIGQyLnN0YXJ0LCBkMi5lbmQsIGRpcik7XG59XG5mdW5jdGlvbiBzaGlmdFBvcyhwb3MsIHN0YXJ0LCBlbmQsIGRpcikge1xuICAgIGlmIChwb3Mucm93ID09IChkaXIgPT0gMSA/IHN0YXJ0IDogZW5kKS5yb3cpIHtcbiAgICAgICAgcG9zLmNvbHVtbiArPSBkaXIgKiAoZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbik7XG4gICAgfVxuICAgIHBvcy5yb3cgKz0gZGlyICogKGVuZC5yb3cgLSBzdGFydC5yb3cpO1xufVxuZnVuY3Rpb24gc3BsaXREZWx0YShjLCBwb3MpIHtcbiAgICB2YXIgbGluZXMgPSBjLmxpbmVzO1xuICAgIHZhciBlbmQgPSBjLmVuZDtcbiAgICBjLmVuZCA9IGNsb25lUG9zKHBvcyk7XG4gICAgdmFyIHJvd3NCZWZvcmUgPSBjLmVuZC5yb3cgLSBjLnN0YXJ0LnJvdztcbiAgICB2YXIgb3RoZXJMaW5lcyA9IGxpbmVzLnNwbGljZShyb3dzQmVmb3JlLCBsaW5lcy5sZW5ndGgpO1xuICAgIHZhciBjb2wgPSByb3dzQmVmb3JlID8gcG9zLmNvbHVtbiA6IHBvcy5jb2x1bW4gLSBjLnN0YXJ0LmNvbHVtbjtcbiAgICBsaW5lcy5wdXNoKG90aGVyTGluZXNbMF0uc3Vic3RyaW5nKDAsIGNvbCkpO1xuICAgIG90aGVyTGluZXNbMF0gPSBvdGhlckxpbmVzWzBdLnN1YnN0cihjb2wpO1xuICAgIHZhciByZXN0ID0ge1xuICAgICAgICBzdGFydDogY2xvbmVQb3MocG9zKSxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIGxpbmVzOiBvdGhlckxpbmVzLFxuICAgICAgICBhY3Rpb246IGMuYWN0aW9uXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YXNCeU9uZShyZWRvU3RhY2ssIGQpIHtcbiAgICBkID0gY2xvbmVEZWx0YShkKTtcbiAgICBmb3IgKHZhciBqID0gcmVkb1N0YWNrLmxlbmd0aDsgai0tOykge1xuICAgICAgICB2YXIgZGVsdGFTZXQgPSByZWRvU3RhY2tbal07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gZGVsdGFTZXRbaV07XG4gICAgICAgICAgICB2YXIgeGZvcm1lZCA9IHhmb3JtKHgsIGQpO1xuICAgICAgICAgICAgZCA9IHhmb3JtZWRbMF07XG4gICAgICAgICAgICBpZiAoeGZvcm1lZC5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgICAgIGlmICh4Zm9ybWVkWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU2V0LnNwbGljZShpICsgMSwgMSwgeGZvcm1lZFsxXSwgeGZvcm1lZFsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXhmb3JtZWRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFTZXQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsdGFTZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWRvU3RhY2suc3BsaWNlKGosIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWRvU3RhY2s7XG59XG5mdW5jdGlvbiByZWJhc2VSZWRvU3RhY2socmVkb1N0YWNrLCBkZWx0YVNldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhU2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVsdGFzID0gZGVsdGFTZXRzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRlbHRhcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbW92ZURlbHRhc0J5T25lKHJlZG9TdGFjaywgZGVsdGFzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5kb01hbmFnZXIgPSBVbmRvTWFuYWdlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdF9zZXNzaW9uL2ZvbGRfbGluZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIEZvbGRMaW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvbGRMaW5lKGZvbGREYXRhLCBmb2xkcykge1xuICAgICAgICB0aGlzLmZvbGREYXRhID0gZm9sZERhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvbGRzKSkge1xuICAgICAgICAgICAgdGhpcy5mb2xkcyA9IGZvbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9sZHMgPSB0aGlzLmZvbGRzID0gW2ZvbGRzXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdCA9IGZvbGRzW2ZvbGRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKGZvbGRzWzBdLnN0YXJ0LnJvdywgZm9sZHNbMF0uc3RhcnQuY29sdW1uLCBsYXN0LmVuZC5yb3csIGxhc3QuZW5kLmNvbHVtbik7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLnJhbmdlLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHRoaXMucmFuZ2UuZW5kO1xuICAgICAgICB0aGlzLmZvbGRzLmZvckVhY2goZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgIGZvbGQuc2V0Rm9sZExpbmUodGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBGb2xkTGluZS5wcm90b3R5cGUuc2hpZnRSb3cgPSBmdW5jdGlvbiAoc2hpZnQpIHtcbiAgICAgICAgdGhpcy5zdGFydC5yb3cgKz0gc2hpZnQ7XG4gICAgICAgIHRoaXMuZW5kLnJvdyArPSBzaGlmdDtcbiAgICAgICAgdGhpcy5mb2xkcy5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICBmb2xkLnN0YXJ0LnJvdyArPSBzaGlmdDtcbiAgICAgICAgICAgIGZvbGQuZW5kLnJvdyArPSBzaGlmdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUuYWRkRm9sZCA9IGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgIGlmIChmb2xkLnNhbWVSb3cpIHtcbiAgICAgICAgICAgIGlmIChmb2xkLnN0YXJ0LnJvdyA8IHRoaXMuc3RhcnRSb3cgfHwgZm9sZC5lbmRSb3cgPiB0aGlzLmVuZFJvdykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGFkZCBhIGZvbGQgdG8gdGhpcyBGb2xkTGluZSBhcyBpdCBoYXMgbm8gY29ubmVjdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9sZHMucHVzaChmb2xkKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtYS5yYW5nZS5jb21wYXJlRW5kKGIuc3RhcnQucm93LCBiLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlLmNvbXBhcmVFbmQoZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZC5yb3cgPSBmb2xkLmVuZC5yb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yYW5nZS5jb21wYXJlU3RhcnQoZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb2xkLnN0YXJ0LnJvdyA9PSB0aGlzLmVuZC5yb3cpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZHMucHVzaChmb2xkKTtcbiAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IGZvbGQuZW5kLnJvdztcbiAgICAgICAgICAgIHRoaXMuZW5kLmNvbHVtbiA9IGZvbGQuZW5kLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb2xkLmVuZC5yb3cgPT0gdGhpcy5zdGFydC5yb3cpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZHMudW5zaGlmdChmb2xkKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGFkZCBmb2xkIHRvIEZvbGRSb3cgdGhhdCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyByb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9sZC5mb2xkTGluZSA9IHRoaXM7XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUuY29udGFpbnNSb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cgPj0gdGhpcy5zdGFydC5yb3cgJiYgcm93IDw9IHRoaXMuZW5kLnJvdztcbiAgICB9O1xuICAgIEZvbGRMaW5lLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbmRSb3csIGVuZENvbHVtbikge1xuICAgICAgICB2YXIgbGFzdEVuZCA9IDAsIGZvbGRzID0gdGhpcy5mb2xkcywgZm9sZCwgY21wLCBzdG9wLCBpc05ld1JvdyA9IHRydWU7XG4gICAgICAgIGlmIChlbmRSb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kUm93ID0gdGhpcy5lbmQucm93O1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gdGhpcy5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvbGQgPSBmb2xkc1tpXTtcbiAgICAgICAgICAgIGNtcCA9IGZvbGQucmFuZ2UuY29tcGFyZVN0YXJ0KGVuZFJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBlbmRSb3csIGVuZENvbHVtbiwgbGFzdEVuZCwgaXNOZXdSb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3AgPSBjYWxsYmFjayhudWxsLCBmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4sIGxhc3RFbmQsIGlzTmV3Um93KTtcbiAgICAgICAgICAgIHN0b3AgPSAhc3RvcCAmJiBjYWxsYmFjayhmb2xkLnBsYWNlaG9sZGVyLCBmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4sIGxhc3RFbmQpO1xuICAgICAgICAgICAgaWYgKHN0b3AgfHwgY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNOZXdSb3cgPSAhZm9sZC5zYW1lUm93O1xuICAgICAgICAgICAgbGFzdEVuZCA9IGZvbGQuZW5kLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBlbmRSb3csIGVuZENvbHVtbiwgbGFzdEVuZCwgaXNOZXdSb3cpO1xuICAgIH07XG4gICAgRm9sZExpbmUucHJvdG90eXBlLmdldE5leHRGb2xkVG8gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGZvbGQsIGNtcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb2xkID0gdGhpcy5mb2xkc1tpXTtcbiAgICAgICAgICAgIGNtcCA9IGZvbGQucmFuZ2UuY29tcGFyZUVuZChyb3csIGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZDogZm9sZCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogXCJhZnRlclwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGQ6IGZvbGQsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiaW5zaWRlXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRm9sZExpbmUucHJvdG90eXBlLmFkZFJlbW92ZUNoYXJzID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCBsZW4pIHtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuZ2V0TmV4dEZvbGRUbyhyb3csIGNvbHVtbiksIGZvbGQsIGZvbGRzO1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICBmb2xkID0gcmV0LmZvbGQ7XG4gICAgICAgICAgICBpZiAocmV0LmtpbmQgPT0gXCJpbnNpZGVcIlxuICAgICAgICAgICAgICAgICYmIGZvbGQuc3RhcnQuY29sdW1uICE9IGNvbHVtblxuICAgICAgICAgICAgICAgICYmIGZvbGQuc3RhcnQucm93ICE9IHJvdykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZyhyb3csIGNvbHVtbiwgZm9sZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmb2xkLnN0YXJ0LnJvdyA9PSByb3cpIHtcbiAgICAgICAgICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHM7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmb2xkcy5pbmRleE9mKGZvbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZCA9IGZvbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb2xkLnN0YXJ0LmNvbHVtbiArPSBsZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9sZC5zYW1lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9sZC5lbmQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRm9sZExpbmUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldE5leHRGb2xkVG8ocm93LCBjb2x1bW4pO1xuICAgICAgICBpZiAoIXBvcyB8fCBwb3Mua2luZCA9PSBcImluc2lkZVwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBmb2xkID0gcG9zLmZvbGQ7XG4gICAgICAgIHZhciBmb2xkcyA9IHRoaXMuZm9sZHM7XG4gICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuZm9sZERhdGE7XG4gICAgICAgIHZhciBpID0gZm9sZHMuaW5kZXhPZihmb2xkKTtcbiAgICAgICAgdmFyIGZvbGRCZWZvcmUgPSBmb2xkc1tpIC0gMV07XG4gICAgICAgIHRoaXMuZW5kLnJvdyA9IGZvbGRCZWZvcmUuZW5kLnJvdztcbiAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gZm9sZEJlZm9yZS5lbmQuY29sdW1uO1xuICAgICAgICBmb2xkcyA9IGZvbGRzLnNwbGljZShpLCBmb2xkcy5sZW5ndGggLSBpKTtcbiAgICAgICAgdmFyIG5ld0ZvbGRMaW5lID0gbmV3IEZvbGRMaW5lKGZvbGREYXRhLCBmb2xkcyk7XG4gICAgICAgIGZvbGREYXRhLnNwbGljZShmb2xkRGF0YS5pbmRleE9mKHRoaXMpICsgMSwgMCwgbmV3Rm9sZExpbmUpO1xuICAgICAgICByZXR1cm4gbmV3Rm9sZExpbmU7XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoZm9sZExpbmVOZXh0KSB7XG4gICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lTmV4dC5mb2xkcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkKGZvbGRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLmZvbGREYXRhO1xuICAgICAgICBmb2xkRGF0YS5zcGxpY2UoZm9sZERhdGEuaW5kZXhPZihmb2xkTGluZU5leHQpLCAxKTtcbiAgICB9O1xuICAgIEZvbGRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IFt0aGlzLnJhbmdlLnRvU3RyaW5nKCkgKyBcIjogW1wiXTtcbiAgICAgICAgdGhpcy5mb2xkcy5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICByZXQucHVzaChcIiAgXCIgKyBmb2xkLnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0LnB1c2goXCJdXCIpO1xuICAgICAgICByZXR1cm4gcmV0LmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUuaWR4VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGxhc3RGb2xkRW5kQ29sdW1uID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZm9sZHNbaV07XG4gICAgICAgICAgICBpZHggLT0gZm9sZC5zdGFydC5jb2x1bW4gLSBsYXN0Rm9sZEVuZENvbHVtbjtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiBmb2xkLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBmb2xkLnN0YXJ0LmNvbHVtbiArIGlkeFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggLT0gZm9sZC5wbGFjZWhvbGRlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEZvbGRFbmRDb2x1bW4gPSBmb2xkLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogdGhpcy5lbmQucm93LFxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmVuZC5jb2x1bW4gKyBpZHhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBGb2xkTGluZTtcbn0oKSk7XG5leHBvcnRzLkZvbGRMaW5lID0gRm9sZExpbmU7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3JhbmdlX2xpc3RcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIGNvbXBhcmVQb2ludHMgPSBSYW5nZS5jb21wYXJlUG9pbnRzO1xudmFyIFJhbmdlTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5nZUxpc3QoKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuJGJpYXMgPSAxO1xuICAgIH1cbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLnBvaW50SW5kZXggPSBmdW5jdGlvbiAocG9zLCBleGNsdWRlRWRnZXMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgICAgICAgICB2YXIgY21wRW5kID0gY29tcGFyZVBvaW50cyhwb3MsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICBpZiAoY21wRW5kID4gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBjbXBTdGFydCA9IGNvbXBhcmVQb2ludHMocG9zLCByYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoY21wRW5kID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlRWRnZXMgJiYgY21wU3RhcnQgIT09IDAgPyAtaSAtIDIgOiBpO1xuICAgICAgICAgICAgaWYgKGNtcFN0YXJ0ID4gMCB8fCAoY21wU3RhcnQgPT09IDAgJiYgIWV4Y2x1ZGVFZGdlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICByZXR1cm4gLWkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtaSAtIDE7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgZXhjbHVkZUVkZ2VzID0gIXJhbmdlLmlzRW1wdHkoKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLnBvaW50SW5kZXgocmFuZ2Uuc3RhcnQsIGV4Y2x1ZGVFZGdlcyk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgMClcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAtc3RhcnRJbmRleCAtIDE7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMucG9pbnRJbmRleChyYW5nZS5lbmQsIGV4Y2x1ZGVFZGdlcywgc3RhcnRJbmRleCk7XG4gICAgICAgIGlmIChlbmRJbmRleCA8IDApXG4gICAgICAgICAgICBlbmRJbmRleCA9IC1lbmRJbmRleCAtIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVuZEluZGV4Kys7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5zcGxpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXggLSBzdGFydEluZGV4LCByYW5nZSk7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLmFkZExpc3QgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaC5hcHBseShyZW1vdmVkLCB0aGlzLmFkZChsaXN0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLnN1YnN0cmFjdFBvaW50ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgaSA9IHRoaXMucG9pbnRJbmRleChwb3MpO1xuICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLnNwbGljZShpLCAxKTtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGxpc3QgPSBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEuc3RhcnQsIGIuc3RhcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5leHQgPSBsaXN0WzBdLCByYW5nZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5zdGFydCk7XG4gICAgICAgICAgICBpZiAoY21wIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gMCAmJiAhcmFuZ2UuaXNFbXB0eSgpICYmICFuZXh0LmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5lbmQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IG5leHQuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgbmV4dCA9IHJhbmdlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmFuZ2VzID0gbGlzdDtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50SW5kZXgoeyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gfSkgPj0gMDtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRJbmRleChwb3MpID49IDA7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLnJhbmdlQXRQb2ludCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnBvaW50SW5kZXgocG9zKTtcbiAgICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpXTtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuY2xpcFJvd3MgPSBmdW5jdGlvbiAoc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBpZiAobGlzdFswXS5zdGFydC5yb3cgPiBlbmRSb3cgfHwgbGlzdFtsaXN0Lmxlbmd0aCAtIDFdLnN0YXJ0LnJvdyA8IHN0YXJ0Um93KVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMucG9pbnRJbmRleCh7IHJvdzogc3RhcnRSb3csIGNvbHVtbjogMCB9KTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCAwKVxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IC1zdGFydEluZGV4IC0gMTtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHsgcm93OiBlbmRSb3csIGNvbHVtbjogMCB9LCBzdGFydEluZGV4KTtcbiAgICAgICAgaWYgKGVuZEluZGV4IDwgMClcbiAgICAgICAgICAgIGVuZEluZGV4ID0gLWVuZEluZGV4IC0gMTtcbiAgICAgICAgdmFyIGNsaXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjbGlwcGVkLnB1c2gobGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaXBwZWQ7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLnNwbGljZSgwLCB0aGlzLnJhbmdlcy5sZW5ndGgpO1xuICAgIH07XG4gICAgUmFuZ2VMaXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMuJG9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLiRvbkNoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBkZWx0YS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGRlbHRhLmVuZDtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gc3RhcnQucm93O1xuICAgICAgICB2YXIgZW5kUm93ID0gZW5kLnJvdztcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHIuZW5kLnJvdyA+PSBzdGFydFJvdylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCIpIHtcbiAgICAgICAgICAgIHZhciBsaW5lRGlmID0gZW5kUm93IC0gc3RhcnRSb3c7XG4gICAgICAgICAgICB2YXIgY29sRGlmZiA9IC1zdGFydC5jb2x1bW4gKyBlbmQuY29sdW1uO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoci5zdGFydC5yb3cgPiBzdGFydFJvdylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHIuc3RhcnQucm93ID09IHN0YXJ0Um93ICYmIHIuc3RhcnQuY29sdW1uID49IHN0YXJ0LmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5zdGFydC5jb2x1bW4gPT0gc3RhcnQuY29sdW1uICYmIHRoaXMuJGJpYXMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gKz0gY29sRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc3RhcnQucm93ICs9IGxpbmVEaWY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuZW5kLnJvdyA9PSBzdGFydFJvdyAmJiByLmVuZC5jb2x1bW4gPj0gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmVuZC5jb2x1bW4gPT0gc3RhcnQuY29sdW1uICYmIHRoaXMuJGJpYXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5lbmQuY29sdW1uID09IHN0YXJ0LmNvbHVtbiAmJiBjb2xEaWZmID4gMCAmJiBpIDwgbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmVuZC5jb2x1bW4gPiByLnN0YXJ0LmNvbHVtbiAmJiByLmVuZC5jb2x1bW4gPT0gcmFuZ2VzW2kgKyAxXS5zdGFydC5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5lbmQuY29sdW1uIC09IGNvbERpZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgci5lbmQuY29sdW1uICs9IGNvbERpZmY7XG4gICAgICAgICAgICAgICAgICAgIHIuZW5kLnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaW5lRGlmID0gc3RhcnRSb3cgLSBlbmRSb3c7XG4gICAgICAgICAgICB2YXIgY29sRGlmZiA9IHN0YXJ0LmNvbHVtbiAtIGVuZC5jb2x1bW47XG4gICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0LnJvdyA+IGVuZFJvdylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHIuZW5kLnJvdyA8IGVuZFJvd1xuICAgICAgICAgICAgICAgICAgICAmJiAoc3RhcnRSb3cgPCByLmVuZC5yb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHN0YXJ0Um93ID09IHIuZW5kLnJvdyAmJiBzdGFydC5jb2x1bW4gPCByLmVuZC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHIuZW5kLnJvdyA9IHN0YXJ0Um93O1xuICAgICAgICAgICAgICAgICAgICByLmVuZC5jb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIuZW5kLnJvdyA9PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuZW5kLmNvbHVtbiA8PSBlbmQuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZURpZiB8fCByLmVuZC5jb2x1bW4gPiBzdGFydC5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmVuZC5jb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5lbmQucm93ID0gc3RhcnQucm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5lbmQuY29sdW1uICs9IGNvbERpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICByLmVuZC5yb3cgKz0gbGluZURpZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmVuZC5yb3cgPiBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgci5lbmQucm93ICs9IGxpbmVEaWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0LnJvdyA8IGVuZFJvd1xuICAgICAgICAgICAgICAgICAgICAmJiAoc3RhcnRSb3cgPCByLnN0YXJ0LnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgc3RhcnRSb3cgPT0gci5zdGFydC5yb3cgJiYgc3RhcnQuY29sdW1uIDwgci5zdGFydC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHIuc3RhcnQucm93ID0gc3RhcnRSb3c7XG4gICAgICAgICAgICAgICAgICAgIHIuc3RhcnQuY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLnN0YXJ0LnJvdyA9PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuc3RhcnQuY29sdW1uIDw9IGVuZC5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lRGlmIHx8IHIuc3RhcnQuY29sdW1uID4gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5zdGFydC5yb3cgPSBzdGFydC5yb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiArPSBjb2xEaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5zdGFydC5yb3cgKz0gbGluZURpZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLnN0YXJ0LnJvdyA+IGVuZFJvdykge1xuICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZURpZiAhPSAwICYmIGkgPCBuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHIuc3RhcnQucm93ICs9IGxpbmVEaWY7XG4gICAgICAgICAgICAgICAgci5lbmQucm93ICs9IGxpbmVEaWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSYW5nZUxpc3Q7XG59KCkpO1xuUmFuZ2VMaXN0LnByb3RvdHlwZS5jb21wYXJlUG9pbnRzID0gY29tcGFyZVBvaW50cztcbmV4cG9ydHMuUmFuZ2VMaXN0ID0gUmFuZ2VMaXN0O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9lZGl0X3Nlc3Npb24vZm9sZFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlX2xpc3RcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJhbmdlTGlzdCA9IHJlcXVpcmUoXCIuLi9yYW5nZV9saXN0XCIpLlJhbmdlTGlzdDtcbnZhciBGb2xkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb2xkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvbGQocmFuZ2UsIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZvbGRMaW5lID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgX3RoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgX3RoaXMuc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgX3RoaXMuZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICBfdGhpcy5zYW1lUm93ID0gcmFuZ2Uuc3RhcnQucm93ID09IHJhbmdlLmVuZC5yb3c7XG4gICAgICAgIF90aGlzLnN1YkZvbGRzID0gX3RoaXMucmFuZ2VzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRm9sZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdGhpcy5wbGFjZWhvbGRlciArICdcIiAnICsgdGhpcy5yYW5nZS50b1N0cmluZygpO1xuICAgIH07XG4gICAgRm9sZC5wcm90b3R5cGUuc2V0Rm9sZExpbmUgPSBmdW5jdGlvbiAoZm9sZExpbmUpIHtcbiAgICAgICAgdGhpcy5mb2xkTGluZSA9IGZvbGRMaW5lO1xuICAgICAgICB0aGlzLnN1YkZvbGRzLmZvckVhY2goZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgIGZvbGQuc2V0Rm9sZExpbmUoZm9sZExpbmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmNsb25lKCk7XG4gICAgICAgIHZhciBmb2xkID0gbmV3IEZvbGQocmFuZ2UsIHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnN1YkZvbGRzLmZvckVhY2goZnVuY3Rpb24gKHN1YkZvbGQpIHtcbiAgICAgICAgICAgIGZvbGQuc3ViRm9sZHMucHVzaChzdWJGb2xkLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9sZC5jb2xsYXBzZUNoaWxkcmVuID0gdGhpcy5jb2xsYXBzZUNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gZm9sZDtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLmFkZFN1YkZvbGQgPSBmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZS5pc0VxdWFsKGZvbGQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdW1lUmFuZ2UoZm9sZCwgdGhpcy5zdGFydCk7XG4gICAgICAgIHZhciByb3cgPSBmb2xkLnN0YXJ0LnJvdywgY29sdW1uID0gZm9sZC5zdGFydC5jb2x1bW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjbXAgPSAtMTsgaSA8IHRoaXMuc3ViRm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuc3ViRm9sZHNbaV0ucmFuZ2UuY29tcGFyZShyb3csIGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY21wICE9IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVyU3RhcnQgPSB0aGlzLnN1YkZvbGRzW2ldO1xuICAgICAgICB2YXIgZmlyc3RDb25zdW1lZCA9IDA7XG4gICAgICAgIGlmIChjbXAgPT0gMCkge1xuICAgICAgICAgICAgaWYgKGFmdGVyU3RhcnQucmFuZ2UuY29udGFpbnNSYW5nZShmb2xkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJTdGFydC5hZGRTdWJGb2xkKGZvbGQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZpcnN0Q29uc3VtZWQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3cgPSBmb2xkLnJhbmdlLmVuZC5yb3csIGNvbHVtbiA9IGZvbGQucmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgZm9yICh2YXIgaiA9IGksIGNtcCA9IC0xOyBqIDwgdGhpcy5zdWJGb2xkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY21wID0gdGhpcy5zdWJGb2xkc1tqXS5yYW5nZS5jb21wYXJlKHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21wID09IDApXG4gICAgICAgICAgICBqKys7XG4gICAgICAgIHZhciBjb25zdW1lZEZvbGRzID0gdGhpcy5zdWJGb2xkcy5zcGxpY2UoaSwgaiAtIGksIGZvbGQpO1xuICAgICAgICB2YXIgbGFzdCA9IGNtcCA9PSAwID8gY29uc3VtZWRGb2xkcy5sZW5ndGggLSAxIDogY29uc3VtZWRGb2xkcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGsgPSBmaXJzdENvbnN1bWVkOyBrIDwgbGFzdDsgaysrKSB7XG4gICAgICAgICAgICBmb2xkLmFkZFN1YkZvbGQoY29uc3VtZWRGb2xkc1trXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9sZC5zZXRGb2xkTGluZSh0aGlzLmZvbGRMaW5lKTtcbiAgICAgICAgcmV0dXJuIGZvbGQ7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5yZXN0b3JlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RvcmVSYW5nZShyYW5nZSwgdGhpcy5zdGFydCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9sZDtcbn0oUmFuZ2VMaXN0KSk7XG5mdW5jdGlvbiBjb25zdW1lUG9pbnQocG9pbnQsIGFuY2hvcikge1xuICAgIHBvaW50LnJvdyAtPSBhbmNob3Iucm93O1xuICAgIGlmIChwb2ludC5yb3cgPT0gMClcbiAgICAgICAgcG9pbnQuY29sdW1uIC09IGFuY2hvci5jb2x1bW47XG59XG5mdW5jdGlvbiBjb25zdW1lUmFuZ2UocmFuZ2UsIGFuY2hvcikge1xuICAgIGNvbnN1bWVQb2ludChyYW5nZS5zdGFydCwgYW5jaG9yKTtcbiAgICBjb25zdW1lUG9pbnQocmFuZ2UuZW5kLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gcmVzdG9yZVBvaW50KHBvaW50LCBhbmNob3IpIHtcbiAgICBpZiAocG9pbnQucm93ID09IDApXG4gICAgICAgIHBvaW50LmNvbHVtbiArPSBhbmNob3IuY29sdW1uO1xuICAgIHBvaW50LnJvdyArPSBhbmNob3Iucm93O1xufVxuZnVuY3Rpb24gcmVzdG9yZVJhbmdlKHJhbmdlLCBhbmNob3IpIHtcbiAgICByZXN0b3JlUG9pbnQocmFuZ2Uuc3RhcnQsIGFuY2hvcik7XG4gICAgcmVzdG9yZVBvaW50KHJhbmdlLmVuZCwgYW5jaG9yKTtcbn1cbmV4cG9ydHMuRm9sZCA9IEZvbGQ7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkaW5nXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIixcImFjZS9lZGl0X3Nlc3Npb24vZm9sZF9saW5lXCIsXCJhY2UvZWRpdF9zZXNzaW9uL2ZvbGRcIixcImFjZS90b2tlbl9pdGVyYXRvclwiLFwiYWNlL21vdXNlL21vdXNlX2V2ZW50XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpey8vIEB0cy1ub2NoZWNrXG5cInVzZSBzdHJpY3RcIjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBGb2xkTGluZSA9IHJlcXVpcmUoXCIuL2ZvbGRfbGluZVwiKS5Gb2xkTGluZTtcbnZhciBGb2xkID0gcmVxdWlyZShcIi4vZm9sZFwiKS5Gb2xkO1xudmFyIFRva2VuSXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbnZhciBNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4uL21vdXNlL21vdXNlX2V2ZW50XCIpLk1vdXNlRXZlbnQ7XG5mdW5jdGlvbiBGb2xkaW5nKCkge1xuICAgIHRoaXMuZ2V0Rm9sZEF0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCBzaWRlKSB7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUocm93KTtcbiAgICAgICAgaWYgKCFmb2xkTGluZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgZm9sZHMgPSBmb2xkTGluZS5mb2xkcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZm9sZHNbaV0ucmFuZ2U7XG4gICAgICAgICAgICBpZiAocmFuZ2UuY29udGFpbnMocm93LCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPT0gMSAmJiByYW5nZS5pc0VuZChyb3csIGNvbHVtbikgJiYgIXJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA9PSAtMSAmJiByYW5nZS5pc1N0YXJ0KHJvdywgY29sdW1uKSAmJiAhcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZHNJblJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICB2YXIgZm9sZExpbmVzID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgIHZhciBmb3VuZEZvbGRzID0gW107XG4gICAgICAgIHN0YXJ0LmNvbHVtbiArPSAxO1xuICAgICAgICBlbmQuY29sdW1uIC09IDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY21wID0gZm9sZExpbmVzW2ldLnJhbmdlLmNvbXBhcmVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpZiAoY21wID09IDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PSAtMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmVzW2ldLmZvbGRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb2xkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBmb2xkID0gZm9sZHNbal07XG4gICAgICAgICAgICAgICAgY21wID0gZm9sZC5yYW5nZS5jb21wYXJlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChjbXAgPT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIGlmIChjbXAgPT0gNDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvdW5kRm9sZHMucHVzaChmb2xkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydC5jb2x1bW4gLT0gMTtcbiAgICAgICAgZW5kLmNvbHVtbiArPSAxO1xuICAgICAgICByZXR1cm4gZm91bmRGb2xkcztcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZHNJblJhbmdlTGlzdCA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmFuZ2VzKSkge1xuICAgICAgICAgICAgdmFyIGZvbGRzID0gW107XG4gICAgICAgICAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmb2xkcyA9IGZvbGRzLmNvbmNhdCh0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZSkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2xkcztcbiAgICB9O1xuICAgIHRoaXMuZ2V0QWxsRm9sZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb2xkcyA9IFtdO1xuICAgICAgICB2YXIgZm9sZExpbmVzID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZExpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb2xkTGluZXNbaV0uZm9sZHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgZm9sZHMucHVzaChmb2xkTGluZXNbaV0uZm9sZHNbal0pO1xuICAgICAgICByZXR1cm4gZm9sZHM7XG4gICAgfTtcbiAgICB0aGlzLmdldEZvbGRTdHJpbmdBdCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwgdHJpbSwgZm9sZExpbmUpIHtcbiAgICAgICAgZm9sZExpbmUgPSBmb2xkTGluZSB8fCB0aGlzLmdldEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIGlmICghZm9sZExpbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RGb2xkID0ge1xuICAgICAgICAgICAgZW5kOiB7IGNvbHVtbjogMCB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHIsIGZvbGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZExpbmUuZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvbGQgPSBmb2xkTGluZS5mb2xkc1tpXTtcbiAgICAgICAgICAgIHZhciBjbXAgPSBmb2xkLnJhbmdlLmNvbXBhcmVFbmQocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLmdldExpbmUoZm9sZC5zdGFydC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcobGFzdEZvbGQuZW5kLmNvbHVtbiwgZm9sZC5zdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Rm9sZCA9IGZvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHIpXG4gICAgICAgICAgICBzdHIgPSB0aGlzLmdldExpbmUoZm9sZC5zdGFydC5yb3cpLnN1YnN0cmluZyhsYXN0Rm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgaWYgKHRyaW0gPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBjb2x1bW4gLSBsYXN0Rm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgZWxzZSBpZiAodHJpbSA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoY29sdW1uIC0gbGFzdEZvbGQuZW5kLmNvbHVtbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICB0aGlzLmdldEZvbGRMaW5lID0gZnVuY3Rpb24gKGRvY1Jvdywgc3RhcnRGb2xkTGluZSkge1xuICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoc3RhcnRGb2xkTGluZSlcbiAgICAgICAgICAgIGkgPSBmb2xkRGF0YS5pbmRleE9mKHN0YXJ0Rm9sZExpbmUpO1xuICAgICAgICBpZiAoaSA9PSAtMSlcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICBmb3IgKGk7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV07XG4gICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93IDw9IGRvY1JvdyAmJiBmb2xkTGluZS5lbmQucm93ID49IGRvY1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkTGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZvbGRMaW5lLmVuZC5yb3cgPiBkb2NSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TmV4dEZvbGRMaW5lID0gZnVuY3Rpb24gKGRvY1Jvdywgc3RhcnRGb2xkTGluZSkge1xuICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoc3RhcnRGb2xkTGluZSlcbiAgICAgICAgICAgIGkgPSBmb2xkRGF0YS5pbmRleE9mKHN0YXJ0Rm9sZExpbmUpO1xuICAgICAgICBpZiAoaSA9PSAtMSlcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICBmb3IgKGk7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV07XG4gICAgICAgICAgICBpZiAoZm9sZExpbmUuZW5kLnJvdyA+PSBkb2NSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZExpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmdldEZvbGRlZFJvd0NvdW50ID0gZnVuY3Rpb24gKGZpcnN0LCBsYXN0KSB7XG4gICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhLCByb3dDb3VudCA9IGxhc3QgLSBmaXJzdCArIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGREYXRhW2ldLCBlbmQgPSBmb2xkTGluZS5lbmQucm93LCBzdGFydCA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGlmIChlbmQgPj0gbGFzdCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgLT0gbGFzdCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb3VudCA9IDA7IC8vIGluIG9uZSBmb2xkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID49IGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGZpcnN0KSAvLyBmb2xkIGluc2lkZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICByb3dDb3VudCAtPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50IC09IGVuZCAtIGZpcnN0ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93Q291bnQ7XG4gICAgfTtcbiAgICB0aGlzLiRhZGRGb2xkTGluZSA9IGZ1bmN0aW9uIChmb2xkTGluZSkge1xuICAgICAgICB0aGlzLiRmb2xkRGF0YS5wdXNoKGZvbGRMaW5lKTtcbiAgICAgICAgdGhpcy4kZm9sZERhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQucm93IC0gYi5zdGFydC5yb3c7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9sZExpbmU7XG4gICAgfTtcbiAgICB0aGlzLmFkZEZvbGQgPSBmdW5jdGlvbiAocGxhY2Vob2xkZXIsIHJhbmdlKSB7XG4gICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICB2YXIgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZvbGQ7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciBpbnN0YW5jZW9mIEZvbGQpXG4gICAgICAgICAgICBmb2xkID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9sZCA9IG5ldyBGb2xkKHJhbmdlLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4gPSByYW5nZS5jb2xsYXBzZUNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGNsaXBSYW5nZVRvRG9jdW1lbnQoZm9sZC5yYW5nZSk7XG4gICAgICAgIHZhciBzdGFydFJvdyA9IGZvbGQuc3RhcnQucm93O1xuICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgdmFyIGVuZFJvdyA9IGZvbGQuZW5kLnJvdztcbiAgICAgICAgdmFyIGVuZENvbHVtbiA9IGZvbGQuZW5kLmNvbHVtbjtcbiAgICAgICAgdmFyIHN0YXJ0Rm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHN0YXJ0Um93LCBzdGFydENvbHVtbiwgMSk7XG4gICAgICAgIHZhciBlbmRGb2xkID0gdGhpcy5nZXRGb2xkQXQoZW5kUm93LCBlbmRDb2x1bW4sIC0xKTtcbiAgICAgICAgaWYgKHN0YXJ0Rm9sZCAmJiBlbmRGb2xkID09IHN0YXJ0Rm9sZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydEZvbGQuYWRkU3ViRm9sZChmb2xkKTtcbiAgICAgICAgaWYgKHN0YXJ0Rm9sZCAmJiAhc3RhcnRGb2xkLnJhbmdlLmlzU3RhcnQoc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSlcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChzdGFydEZvbGQpO1xuICAgICAgICBpZiAoZW5kRm9sZCAmJiAhZW5kRm9sZC5yYW5nZS5pc0VuZChlbmRSb3csIGVuZENvbHVtbikpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZW5kRm9sZCk7XG4gICAgICAgIHZhciBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKGZvbGQucmFuZ2UpO1xuICAgICAgICBpZiAoZm9sZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkcyhmb2xkcyk7XG4gICAgICAgICAgICBpZiAoIWZvbGQuY29sbGFwc2VDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24gKHN1YkZvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZC5hZGRTdWJGb2xkKHN1YkZvbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGREYXRhW2ldO1xuICAgICAgICAgICAgaWYgKGVuZFJvdyA9PSBmb2xkTGluZS5zdGFydC5yb3cpIHtcbiAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRGb2xkKGZvbGQpO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0Um93ID09IGZvbGRMaW5lLmVuZC5yb3cpIHtcbiAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRGb2xkKGZvbGQpO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbGQuc2FtZVJvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmVOZXh0ID0gZm9sZERhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmVOZXh0ICYmIGZvbGRMaW5lTmV4dC5zdGFydC5yb3cgPT0gZW5kUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5tZXJnZShmb2xkTGluZU5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRSb3cgPD0gZm9sZExpbmUuc3RhcnQucm93KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZGRlZClcbiAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy4kYWRkRm9sZExpbmUobmV3IEZvbGRMaW5lKHRoaXMuJGZvbGREYXRhLCBmb2xkKSk7XG4gICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVdyYXBEYXRhKGZvbGRMaW5lLnN0YXJ0LnJvdywgZm9sZExpbmUuc3RhcnQucm93KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlUm93TGVuZ3RoQ2FjaGUoZm9sZExpbmUuc3RhcnQucm93LCBmb2xkTGluZS5zdGFydC5yb3cpO1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUZvbGRcIiwgeyBkYXRhOiBmb2xkLCBhY3Rpb246IFwiYWRkXCIgfSk7XG4gICAgICAgIHJldHVybiBmb2xkO1xuICAgIH07XG4gICAgdGhpcy5hZGRGb2xkcyA9IGZ1bmN0aW9uIChmb2xkcykge1xuICAgICAgICBmb2xkcy5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGQoZm9sZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVGb2xkID0gZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZC5mb2xkTGluZTtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICB2YXIgZW5kUm93ID0gZm9sZExpbmUuZW5kLnJvdztcbiAgICAgICAgdmFyIGZvbGRMaW5lcyA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICB2YXIgZm9sZHMgPSBmb2xkTGluZS5mb2xkcztcbiAgICAgICAgaWYgKGZvbGRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBmb2xkTGluZXMuc3BsaWNlKGZvbGRMaW5lcy5pbmRleE9mKGZvbGRMaW5lKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAgaWYgKGZvbGRMaW5lLnJhbmdlLmlzRW5kKGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKSkge1xuICAgICAgICAgICAgZm9sZHMucG9wKCk7XG4gICAgICAgICAgICBmb2xkTGluZS5lbmQucm93ID0gZm9sZHNbZm9sZHMubGVuZ3RoIC0gMV0uZW5kLnJvdztcbiAgICAgICAgICAgIGZvbGRMaW5lLmVuZC5jb2x1bW4gPSBmb2xkc1tmb2xkcy5sZW5ndGggLSAxXS5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgXG4gICAgICAgIGlmIChmb2xkTGluZS5yYW5nZS5pc1N0YXJ0KGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbikpIHtcbiAgICAgICAgICAgIGZvbGRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBmb2xkTGluZS5zdGFydC5yb3cgPSBmb2xkc1swXS5zdGFydC5yb3c7XG4gICAgICAgICAgICBmb2xkTGluZS5zdGFydC5jb2x1bW4gPSBmb2xkc1swXS5zdGFydC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAgaWYgKGZvbGQuc2FtZVJvdykge1xuICAgICAgICAgICAgZm9sZHMuc3BsaWNlKGZvbGRzLmluZGV4T2YoZm9sZCksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuZXdGb2xkTGluZSA9IGZvbGRMaW5lLnNwbGl0KGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICBmb2xkcyA9IG5ld0ZvbGRMaW5lLmZvbGRzO1xuICAgICAgICAgICAgZm9sZHMuc2hpZnQoKTtcbiAgICAgICAgICAgIG5ld0ZvbGRMaW5lLnN0YXJ0LnJvdyA9IGZvbGRzWzBdLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIG5ld0ZvbGRMaW5lLnN0YXJ0LmNvbHVtbiA9IGZvbGRzWzBdLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuJHVwZGF0aW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoc3RhcnRSb3csIGVuZFJvdyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlUm93TGVuZ3RoQ2FjaGUoc3RhcnRSb3csIGVuZFJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VGb2xkXCIsIHsgZGF0YTogZm9sZCwgYWN0aW9uOiBcInJlbW92ZVwiIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVGb2xkcyA9IGZ1bmN0aW9uIChmb2xkcykge1xuICAgICAgICB2YXIgY2xvbmVGb2xkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZUZvbGRzLnB1c2goZm9sZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lRm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5leHBhbmRGb2xkID0gZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICBmb2xkLnN1YkZvbGRzLmZvckVhY2goZnVuY3Rpb24gKHN1YkZvbGQpIHtcbiAgICAgICAgICAgIGZvbGQucmVzdG9yZVJhbmdlKHN1YkZvbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkKHN1YkZvbGQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKGZvbGQuY29sbGFwc2VDaGlsZHJlbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZEFsbChmb2xkLnN0YXJ0LnJvdyArIDEsIGZvbGQuZW5kLnJvdywgZm9sZC5jb2xsYXBzZUNoaWxkcmVuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9sZC5zdWJGb2xkcyA9IFtdO1xuICAgIH07XG4gICAgdGhpcy5leHBhbmRGb2xkcyA9IGZ1bmN0aW9uIChmb2xkcykge1xuICAgICAgICBmb2xkcy5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGQoZm9sZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy51bmZvbGQgPSBmdW5jdGlvbiAobG9jYXRpb24sIGV4cGFuZElubmVyKSB7XG4gICAgICAgIHZhciByYW5nZSwgZm9sZHM7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZSgwLCAwLCB0aGlzLmdldExlbmd0aCgpLCAwKTtcbiAgICAgICAgICAgIGlmIChleHBhbmRJbm5lciA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGV4cGFuZElubmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG9jYXRpb24gPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UobG9jYXRpb24sIDAsIGxvY2F0aW9uLCB0aGlzLmdldExpbmUobG9jYXRpb24pLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJyb3dcIiBpbiBsb2NhdGlvbikge1xuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGxvY2F0aW9uLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGZvbGRzID0gW107XG4gICAgICAgICAgICBsb2NhdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIGZvbGRzID0gZm9sZHMuY29uY2F0KHRoaXMudW5mb2xkKHJhbmdlKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBmb2xkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZUxpc3QocmFuZ2UpO1xuICAgICAgICB2YXIgb3V0ZXJtb3N0Rm9sZHMgPSBmb2xkcztcbiAgICAgICAgd2hpbGUgKGZvbGRzLmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAmJiBSYW5nZS5jb21wYXJlUG9pbnRzKGZvbGRzWzBdLnN0YXJ0LCByYW5nZS5zdGFydCkgPCAwXG4gICAgICAgICAgICAmJiBSYW5nZS5jb21wYXJlUG9pbnRzKGZvbGRzWzBdLmVuZCwgcmFuZ2UuZW5kKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZHMoZm9sZHMpO1xuICAgICAgICAgICAgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZUxpc3QocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBhbmRJbm5lciAhPSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkcyhmb2xkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGRzKGZvbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0ZXJtb3N0Rm9sZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG91dGVybW9zdEZvbGRzO1xuICAgIH07XG4gICAgdGhpcy5pc1Jvd0ZvbGRlZCA9IGZ1bmN0aW9uIChkb2NSb3csIHN0YXJ0Rm9sZFJvdykge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldEZvbGRMaW5lKGRvY1Jvdywgc3RhcnRGb2xkUm93KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Um93Rm9sZEVuZCA9IGZ1bmN0aW9uIChkb2NSb3csIHN0YXJ0Rm9sZFJvdykge1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGRvY1Jvdywgc3RhcnRGb2xkUm93KTtcbiAgICAgICAgcmV0dXJuIGZvbGRMaW5lID8gZm9sZExpbmUuZW5kLnJvdyA6IGRvY1JvdztcbiAgICB9O1xuICAgIHRoaXMuZ2V0Um93Rm9sZFN0YXJ0ID0gZnVuY3Rpb24gKGRvY1Jvdywgc3RhcnRGb2xkUm93KSB7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZG9jUm93LCBzdGFydEZvbGRSb3cpO1xuICAgICAgICByZXR1cm4gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBkb2NSb3c7XG4gICAgfTtcbiAgICB0aGlzLmdldEZvbGREaXNwbGF5TGluZSA9IGZ1bmN0aW9uIChmb2xkTGluZSwgZW5kUm93LCBlbmRDb2x1bW4sIHN0YXJ0Um93LCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAoc3RhcnRSb3cgPT0gbnVsbClcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPT0gbnVsbClcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gMDtcbiAgICAgICAgaWYgKGVuZFJvdyA9PSBudWxsKVxuICAgICAgICAgICAgZW5kUm93ID0gZm9sZExpbmUuZW5kLnJvdztcbiAgICAgICAgaWYgKGVuZENvbHVtbiA9PSBudWxsKVxuICAgICAgICAgICAgZW5kQ29sdW1uID0gdGhpcy5nZXRMaW5lKGVuZFJvdykubGVuZ3RoO1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIHZhciB0ZXh0TGluZSA9IFwiXCI7XG4gICAgICAgIGZvbGRMaW5lLndhbGsoZnVuY3Rpb24gKHBsYWNlaG9sZGVyLCByb3csIGNvbHVtbiwgbGFzdENvbHVtbikge1xuICAgICAgICAgICAgaWYgKHJvdyA8IHN0YXJ0Um93KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyb3cgPT0gc3RhcnRSb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uIDwgc3RhcnRDb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsYXN0Q29sdW1uID0gTWF0aC5tYXgoc3RhcnRDb2x1bW4sIGxhc3RDb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lICs9IGRvYy5nZXRMaW5lKHJvdykuc3Vic3RyaW5nKGxhc3RDb2x1bW4sIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVuZFJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHRleHRMaW5lO1xuICAgIH07XG4gICAgdGhpcy5nZXREaXNwbGF5TGluZSA9IGZ1bmN0aW9uIChyb3csIGVuZENvbHVtbiwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUocm93KTtcbiAgICAgICAgaWYgKCFmb2xkTGluZSkge1xuICAgICAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uIHx8IDAsIGVuZENvbHVtbiB8fCBsaW5lLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb2xkRGlzcGxheUxpbmUoZm9sZExpbmUsIHJvdywgZW5kQ29sdW1uLCBzdGFydFJvdywgc3RhcnRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiRjbG9uZUZvbGREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmQgPSBbXTtcbiAgICAgICAgZmQgPSB0aGlzLiRmb2xkRGF0YS5tYXAoZnVuY3Rpb24gKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgZm9sZHMgPSBmb2xkTGluZS5mb2xkcy5tYXAoZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZC5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRMaW5lKGZkLCBmb2xkcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZUZvbGQgPSBmdW5jdGlvbiAodHJ5VG9VbmZvbGQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIGZvbGQ7XG4gICAgICAgIHZhciBicmFja2V0UG9zO1xuICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICBmb2xkID0gdGhpcy5nZXRGb2xkQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZChmb2xkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChicmFja2V0UG9zID0gdGhpcy5maW5kTWF0Y2hpbmdCcmFja2V0KGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZVBvaW50KGJyYWNrZXRQb3MpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kID0gYnJhY2tldFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gYnJhY2tldFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChicmFja2V0UG9zID0gdGhpcy5maW5kTWF0Y2hpbmdCcmFja2V0KHsgcm93OiBjdXJzb3Iucm93LCBjb2x1bW46IGN1cnNvci5jb2x1bW4gKyAxIH0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmVQb2ludChicmFja2V0UG9zKSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQgPSBicmFja2V0UG9zO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSBicmFja2V0UG9zO1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmdldENvbW1lbnRGb2xkUmFuZ2UoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbikgfHwgcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpZiAodHJ5VG9VbmZvbGQgJiYgZm9sZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkcyhmb2xkcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9sZHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBmb2xkID0gZm9sZHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb2xkKVxuICAgICAgICAgICAgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgaWYgKGZvbGQgJiYgZm9sZC5yYW5nZS50b1N0cmluZygpID09IHJhbmdlLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZChmb2xkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBcIi4uLlwiO1xuICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gdGhpcy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlci50cmltKCkuc3Vic3RyaW5nKDAsIDIpICsgXCIuLlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRm9sZChwbGFjZWhvbGRlciwgcmFuZ2UpO1xuICAgIH07XG4gICAgdGhpcy5nZXRDb21tZW50Rm9sZFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCBkaXIpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcm93LCBjb2x1bW4pO1xuICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlbiAmJiB0b2tlbi50eXBlO1xuICAgICAgICBpZiAodG9rZW4gJiYgL15jb21tZW50fHN0cmluZy8udGVzdCh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUubWF0Y2goL2NvbW1lbnR8c3RyaW5nLylbMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIilcbiAgICAgICAgICAgICAgICB0eXBlICs9IFwifGRvYy1zdGFydHxcXFxcLmRvY1wiO1xuICAgICAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh0eXBlKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGRpciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICYmIHJlLnRlc3QodG9rZW4udHlwZSkpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyB0b2tlbi52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHRoaXMsIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBpbml0U3RhdGUgPSB0aGlzLmdldFN0YXRlKGl0ZXJhdG9yLiRyb3cpO1xuICAgICAgICAgICAgaWYgKGRpciAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Um93ID0gLTE7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Um93ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGl0ZXJhdG9yLiRyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRTdGF0ZS50b1N0cmluZygpICE9PSBzdGF0ZS50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSb3cgPSBpdGVyYXRvci4kcm93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZXJhdG9yLiRyb3cgPiBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICYmIHJlLnRlc3QodG9rZW4udHlwZSkpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5mb2xkQWxsID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBlbmRSb3csIGRlcHRoLCB0ZXN0KSB7XG4gICAgICAgIGlmIChkZXB0aCA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkZXB0aCA9IDEwMDAwMDsgLy8gSlNPTi5zdHJpbmdpZnkgZG9lc24ndCBoYW5sZSBJbmZpbml0eVxuICAgICAgICB2YXIgZm9sZFdpZGdldHMgPSB0aGlzLmZvbGRXaWRnZXRzO1xuICAgICAgICBpZiAoIWZvbGRXaWRnZXRzKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBtb2RlIGRvZXNuJ3Qgc3VwcG9ydCBmb2xkaW5nXG4gICAgICAgIGVuZFJvdyA9IGVuZFJvdyB8fCB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICBzdGFydFJvdyA9IHN0YXJ0Um93IHx8IDA7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPCBlbmRSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICBpZiAoZm9sZFdpZGdldHNbcm93XSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGZvbGRXaWRnZXRzW3Jvd10gPSB0aGlzLmdldEZvbGRXaWRnZXQocm93KTtcbiAgICAgICAgICAgIGlmIChmb2xkV2lkZ2V0c1tyb3ddICE9IFwic3RhcnRcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0ZXN0ICYmICF0ZXN0KHJvdykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZShyb3cpO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmlzTXVsdGlMaW5lKClcbiAgICAgICAgICAgICAgICAmJiByYW5nZS5lbmQucm93IDw9IGVuZFJvd1xuICAgICAgICAgICAgICAgICYmIHJhbmdlLnN0YXJ0LnJvdyA+PSBzdGFydFJvdykge1xuICAgICAgICAgICAgICAgIHJvdyA9IHJhbmdlLmVuZC5yb3c7XG4gICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2VDaGlsZHJlbiA9IGRlcHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZm9sZFRvTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgdGhpcy5mb2xkQWxsKCk7XG4gICAgICAgIHdoaWxlIChsZXZlbC0tID4gMClcbiAgICAgICAgICAgIHRoaXMudW5mb2xkKG51bGwsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuZm9sZEFsbENvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZm9sZEFsbChudWxsLCBudWxsLCBudWxsLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gc2Vzc2lvbi5nZXRUb2tlbnMocm93KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09IFwidGV4dFwiICYmIC9eXFxzKyQvLnRlc3QodG9rZW4udmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoL2NvbW1lbnQvLnRlc3QodG9rZW4udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLiRmb2xkU3R5bGVzID0ge1xuICAgICAgICBcIm1hbnVhbFwiOiAxLFxuICAgICAgICBcIm1hcmtiZWdpblwiOiAxLFxuICAgICAgICBcIm1hcmtiZWdpbmVuZFwiOiAxXG4gICAgfTtcbiAgICB0aGlzLiRmb2xkU3R5bGUgPSBcIm1hcmtiZWdpblwiO1xuICAgIHRoaXMuc2V0Rm9sZFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmICghdGhpcy4kZm9sZFN0eWxlc1tzdHlsZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvbGQgc3R5bGU6IFwiICsgc3R5bGUgKyBcIltcIiArIE9iamVjdC5rZXlzKHRoaXMuJGZvbGRTdHlsZXMpLmpvaW4oXCIsIFwiKSArIFwiXVwiKTtcbiAgICAgICAgaWYgKHRoaXMuJGZvbGRTdHlsZSA9PSBzdHlsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kZm9sZFN0eWxlID0gc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcIm1hbnVhbFwiKVxuICAgICAgICAgICAgdGhpcy51bmZvbGQoKTtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLiRmb2xkTW9kZTtcbiAgICAgICAgdGhpcy4kc2V0Rm9sZGluZyhudWxsKTtcbiAgICAgICAgdGhpcy4kc2V0Rm9sZGluZyhtb2RlKTtcbiAgICB9O1xuICAgIHRoaXMuJHNldEZvbGRpbmcgPSBmdW5jdGlvbiAoZm9sZE1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGZvbGRNb2RlID09IGZvbGRNb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRmb2xkTW9kZSA9IGZvbGRNb2RlO1xuICAgICAgICB0aGlzLm9mZignY2hhbmdlJywgdGhpcy4kdXBkYXRlRm9sZFdpZGdldHMpO1xuICAgICAgICB0aGlzLm9mZigndG9rZW5pemVyVXBkYXRlJywgdGhpcy4kdG9rZW5pemVyVXBkYXRlRm9sZFdpZGdldHMpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VBbm5vdGF0aW9uXCIpO1xuICAgICAgICBpZiAoIWZvbGRNb2RlIHx8IHRoaXMuJGZvbGRTdHlsZSA9PSBcIm1hbnVhbFwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvbGRXaWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuZ2V0Rm9sZFdpZGdldCA9IGZvbGRNb2RlLmdldEZvbGRXaWRnZXQuYmluZChmb2xkTW9kZSwgdGhpcywgdGhpcy4kZm9sZFN0eWxlKTtcbiAgICAgICAgdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UgPSBmb2xkTW9kZS5nZXRGb2xkV2lkZ2V0UmFuZ2UuYmluZChmb2xkTW9kZSwgdGhpcywgdGhpcy4kZm9sZFN0eWxlKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlRm9sZFdpZGdldHMgPSB0aGlzLnVwZGF0ZUZvbGRXaWRnZXRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuJHRva2VuaXplclVwZGF0ZUZvbGRXaWRnZXRzID0gdGhpcy50b2tlbml6ZXJVcGRhdGVGb2xkV2lkZ2V0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLiR1cGRhdGVGb2xkV2lkZ2V0cyk7XG4gICAgICAgIHRoaXMub24oJ3Rva2VuaXplclVwZGF0ZScsIHRoaXMuJHRva2VuaXplclVwZGF0ZUZvbGRXaWRnZXRzKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YSA9IGZ1bmN0aW9uIChyb3csIGlnbm9yZUN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGZ3ID0gdGhpcy5mb2xkV2lkZ2V0cztcbiAgICAgICAgaWYgKCFmdyB8fCAoaWdub3JlQ3VycmVudCAmJiBmd1tyb3ddKSlcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgdmFyIGkgPSByb3cgLSAxLCBmaXJzdFJhbmdlO1xuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGZ3W2ldO1xuICAgICAgICAgICAgaWYgKGMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjID0gZndbaV0gPSB0aGlzLmdldEZvbGRXaWRnZXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZShpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuZW5kLnJvdyA+PSByb3cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogaSAhPT0gLTEgJiYgcmFuZ2UsXG4gICAgICAgICAgICBmaXJzdFJhbmdlOiBmaXJzdFJhbmdlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm9uRm9sZFdpZGdldENsaWNrID0gZnVuY3Rpb24gKHJvdywgZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpXG4gICAgICAgICAgICBlID0gZS5kb21FdmVudDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGFsbDogZS5jdHJsS2V5IHx8IGUubWV0YUtleSxcbiAgICAgICAgICAgIHNpYmxpbmdzOiBlLmFsdEtleVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLiR0b2dnbGVGb2xkV2lkZ2V0KHJvdywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVsICYmIC9hY2VfZm9sZC13aWRnZXQvLnRlc3QoZWwuY2xhc3NOYW1lKSlcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgYWNlX2ludmFsaWRcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy4kdG9nZ2xlRm9sZFdpZGdldCA9IGZ1bmN0aW9uIChyb3csIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldEZvbGRXaWRnZXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRGb2xkV2lkZ2V0KHJvdyk7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBkaXIgPSB0eXBlID09PSBcImVuZFwiID8gLTEgOiAxO1xuICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJvdywgZGlyID09PSAtMSA/IDAgOiBsaW5lLmxlbmd0aCwgZGlyKTtcbiAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNoaWxkcmVuIHx8IG9wdGlvbnMuYWxsKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICByZXR1cm4gZm9sZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZShyb3csIHRydWUpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgIXJhbmdlLmlzTXVsdGlMaW5lKCkpIHtcbiAgICAgICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbiwgMSk7XG4gICAgICAgICAgICBpZiAoZm9sZCAmJiByYW5nZS5pc0VxdWFsKGZvbGQucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNpYmxpbmdzKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YShyb3cpO1xuICAgICAgICAgICAgaWYgKGRhdGEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBkYXRhLnJhbmdlLnN0YXJ0LnJvdyArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJvdyA9IGRhdGEucmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9sZEFsbChzdGFydFJvdywgZW5kUm93LCBvcHRpb25zLmFsbCA/IDEwMDAwIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgICAgICAgZW5kUm93ID0gcmFuZ2UgPyByYW5nZS5lbmQucm93IDogdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZEFsbChyb3cgKyAxLCBlbmRSb3csIG9wdGlvbnMuYWxsID8gMTAwMDAgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsKVxuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlQ2hpbGRyZW4gPSAxMDAwMDtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGVGb2xkV2lkZ2V0ID0gZnVuY3Rpb24gKHRvZ2dsZVBhcmVudCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xuICAgICAgICByb3cgPSB0aGlzLmdldFJvd0ZvbGRTdGFydChyb3cpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLiR0b2dnbGVGb2xkV2lkZ2V0KHJvdywge30pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhKHJvdywgdHJ1ZSk7XG4gICAgICAgIHJhbmdlID0gZGF0YS5yYW5nZSB8fCBkYXRhLmZpcnN0UmFuZ2U7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgdmFyIGZvbGQgPSB0aGlzLmdldEZvbGRBdChyb3csIHRoaXMuZ2V0TGluZShyb3cpLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgICAgICB2YXIgbGVuID0gZGVsdGEuZW5kLnJvdyAtIGZpcnN0Um93O1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzW2ZpcnN0Um93XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzLnNwbGljZShmaXJzdFJvdywgbGVuICsgMSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5KGxlbiArIDEpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KGZpcnN0Um93LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHMuc3BsaWNlLmFwcGx5KHRoaXMuZm9sZFdpZGdldHMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnRva2VuaXplclVwZGF0ZUZvbGRXaWRnZXRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBlLmRhdGE7XG4gICAgICAgIGlmIChyb3dzLmZpcnN0ICE9IHJvd3MubGFzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9sZFdpZGdldHMubGVuZ3RoID4gcm93cy5maXJzdClcbiAgICAgICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzLnNwbGljZShyb3dzLmZpcnN0LCB0aGlzLmZvbGRXaWRnZXRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5Gb2xkaW5nID0gRm9sZGluZztcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdF9zZXNzaW9uL2JyYWNrZXRfbWF0Y2hcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS90b2tlbl9pdGVyYXRvclwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFRva2VuSXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbmZ1bmN0aW9uIEJyYWNrZXRNYXRjaCgpIHtcbiAgICB0aGlzLmZpbmRNYXRjaGluZ0JyYWNrZXQgPSBmdW5jdGlvbiAocG9zaXRpb24sIGNocikge1xuICAgICAgICBpZiAocG9zaXRpb24uY29sdW1uID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGNoYXJCZWZvcmVDdXJzb3IgPSBjaHIgfHwgdGhpcy5nZXRMaW5lKHBvc2l0aW9uLnJvdykuY2hhckF0KHBvc2l0aW9uLmNvbHVtbiAtIDEpO1xuICAgICAgICBpZiAoY2hhckJlZm9yZUN1cnNvciA9PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBtYXRjaCA9IGNoYXJCZWZvcmVDdXJzb3IubWF0Y2goLyhbXFwoXFxbXFx7XSl8KFtcXClcXF1cXH1dKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChtYXRjaFsxXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRmaW5kQ2xvc2luZ0JyYWNrZXQobWF0Y2hbMV0sIHBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZpbmRPcGVuaW5nQnJhY2tldChtYXRjaFsyXSwgcG9zaXRpb24pO1xuICAgIH07XG4gICAgdGhpcy5nZXRCcmFja2V0UmFuZ2UgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHBvcy5yb3cpO1xuICAgICAgICB2YXIgYmVmb3JlID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgIHZhciBjaHIgPSBsaW5lLmNoYXJBdChwb3MuY29sdW1uIC0gMSk7XG4gICAgICAgIHZhciBtYXRjaCA9IGNociAmJiBjaHIubWF0Y2goLyhbXFwoXFxbXFx7XSl8KFtcXClcXF1cXH1dKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBjaHIgPSBsaW5lLmNoYXJBdChwb3MuY29sdW1uKTtcbiAgICAgICAgICAgIHBvcyA9IHsgcm93OiBwb3Mucm93LCBjb2x1bW46IHBvcy5jb2x1bW4gKyAxIH07XG4gICAgICAgICAgICBtYXRjaCA9IGNociAmJiBjaHIubWF0Y2goLyhbXFwoXFxbXFx7XSl8KFtcXClcXF1cXH1dKS8pO1xuICAgICAgICAgICAgYmVmb3JlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIHZhciBicmFja2V0UG9zID0gdGhpcy4kZmluZENsb3NpbmdCcmFja2V0KG1hdGNoWzFdLCBwb3MpO1xuICAgICAgICAgICAgaWYgKCFicmFja2V0UG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKHBvcywgYnJhY2tldFBvcyk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBicmFja2V0UG9zID0gdGhpcy4kZmluZE9wZW5pbmdCcmFja2V0KG1hdGNoWzJdLCBwb3MpO1xuICAgICAgICAgICAgaWYgKCFicmFja2V0UG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGJyYWNrZXRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbisrO1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TWF0Y2hpbmdCcmFja2V0UmFuZ2VzID0gZnVuY3Rpb24gKHBvcywgaXNCYWNrd2FyZHMpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocG9zLnJvdyk7XG4gICAgICAgIHZhciBicmFja2V0c1JlZ0V4cCA9IC8oW1xcKFxcW1xce10pfChbXFwpXFxdXFx9XSkvO1xuICAgICAgICB2YXIgY2hyID0gIWlzQmFja3dhcmRzICYmIGxpbmUuY2hhckF0KHBvcy5jb2x1bW4gLSAxKTtcbiAgICAgICAgdmFyIG1hdGNoID0gY2hyICYmIGNoci5tYXRjaChicmFja2V0c1JlZ0V4cCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGNociA9IChpc0JhY2t3YXJkcyA9PT0gdW5kZWZpbmVkIHx8IGlzQmFja3dhcmRzKSAmJiBsaW5lLmNoYXJBdChwb3MuY29sdW1uKTtcbiAgICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgICAgICAgICByb3c6IHBvcy5yb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBwb3MuY29sdW1uICsgMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hdGNoID0gY2hyICYmIGNoci5tYXRjaChicmFja2V0c1JlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgc3RhcnRSYW5nZSA9IG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uIC0gMSwgcG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgIHZhciBicmFja2V0UG9zID0gbWF0Y2hbMV0gPyB0aGlzLiRmaW5kQ2xvc2luZ0JyYWNrZXQobWF0Y2hbMV0sIHBvcylcbiAgICAgICAgICAgIDogdGhpcy4kZmluZE9wZW5pbmdCcmFja2V0KG1hdGNoWzJdLCBwb3MpO1xuICAgICAgICBpZiAoIWJyYWNrZXRQb3MpXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0UmFuZ2VdO1xuICAgICAgICB2YXIgZW5kUmFuZ2UgPSBuZXcgUmFuZ2UoYnJhY2tldFBvcy5yb3csIGJyYWNrZXRQb3MuY29sdW1uLCBicmFja2V0UG9zLnJvdywgYnJhY2tldFBvcy5jb2x1bW4gKyAxKTtcbiAgICAgICAgcmV0dXJuIFtzdGFydFJhbmdlLCBlbmRSYW5nZV07XG4gICAgfTtcbiAgICB0aGlzLiRicmFja2V0cyA9IHtcbiAgICAgICAgXCIpXCI6IFwiKFwiLFxuICAgICAgICBcIihcIjogXCIpXCIsXG4gICAgICAgIFwiXVwiOiBcIltcIixcbiAgICAgICAgXCJbXCI6IFwiXVwiLFxuICAgICAgICBcIntcIjogXCJ9XCIsXG4gICAgICAgIFwifVwiOiBcIntcIixcbiAgICAgICAgXCI8XCI6IFwiPlwiLFxuICAgICAgICBcIj5cIjogXCI8XCJcbiAgICB9O1xuICAgIHRoaXMuJGZpbmRPcGVuaW5nQnJhY2tldCA9IGZ1bmN0aW9uIChicmFja2V0LCBwb3NpdGlvbiwgdHlwZVJlKSB7XG4gICAgICAgIHZhciBvcGVuQnJhY2tldCA9IHRoaXMuJGJyYWNrZXRzW2JyYWNrZXRdO1xuICAgICAgICB2YXIgZGVwdGggPSAxO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLCBwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XG4gICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXR5cGVSZSkge1xuICAgICAgICAgICAgdHlwZVJlID0gbmV3IFJlZ0V4cChcIihcXFxcLj9cIiArXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZS5yZXBsYWNlKFwiLlwiLCBcIlxcXFwuXCIpLnJlcGxhY2UoXCJycGFyZW5cIiwgXCIucGFyZW5cIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYig/OmVuZClcXGIvLCBcIig/OnN0YXJ0fGJlZ2lufGVuZClcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLy1jbG9zZVxcYi8sIFwiLShjbG9zZXxvcGVuKVwiKVxuICAgICAgICAgICAgICAgICsgXCIpK1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVJbmRleCA9IHBvc2l0aW9uLmNvbHVtbiAtIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpIC0gMjtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWVJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNociA9IHZhbHVlLmNoYXJBdCh2YWx1ZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09IG9wZW5CcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByb3c6IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdmFsdWVJbmRleCArIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09IGJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVJbmRleCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiAhdHlwZVJlLnRlc3QodG9rZW4udHlwZSkpO1xuICAgICAgICAgICAgaWYgKHRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWVJbmRleCA9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLiRmaW5kQ2xvc2luZ0JyYWNrZXQgPSBmdW5jdGlvbiAoYnJhY2tldCwgcG9zaXRpb24sIHR5cGVSZSkge1xuICAgICAgICB2YXIgY2xvc2luZ0JyYWNrZXQgPSB0aGlzLiRicmFja2V0c1ticmFja2V0XTtcbiAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0eXBlUmUpIHtcbiAgICAgICAgICAgIHR5cGVSZSA9IG5ldyBSZWdFeHAoXCIoXFxcXC4/XCIgK1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUucmVwbGFjZShcIi5cIiwgXCJcXFxcLlwiKS5yZXBsYWNlKFwibHBhcmVuXCIsIFwiLnBhcmVuXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXGIoPzpzdGFydHxiZWdpbilcXGIvLCBcIig/OnN0YXJ0fGJlZ2lufGVuZClcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLy1vcGVuXFxiLywgXCItKGNsb3NlfG9wZW4pXCIpXG4gICAgICAgICAgICAgICAgKyBcIikrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUluZGV4ID0gcG9zaXRpb24uY29sdW1uIC0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZUluZGV4IDwgdmFsdWVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hyID0gdmFsdWUuY2hhckF0KHZhbHVlSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPT0gY2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJvdzogaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB2YWx1ZUluZGV4ICsgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaHIgPT0gYnJhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgIXR5cGVSZS50ZXN0KHRva2VuLnR5cGUpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWVJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmdldE1hdGNoaW5nVGFncyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuJGZpbmRUYWdOYW1lKGl0ZXJhdG9yKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHByZXZUb2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRmaW5kQ2xvc2luZ1RhZyhpdGVyYXRvciwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZpbmRPcGVuaW5nVGFnKGl0ZXJhdG9yLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJGZpbmRUYWdOYW1lID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGJhY2t3YXJkID0gZmFsc2U7XG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgPT09IC0xKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2t3YXJkKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IFwiLz5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja3dhcmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICYmICFmb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG4gICAgdGhpcy4kZmluZENsb3NpbmdUYWcgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRva2VuKSB7XG4gICAgICAgIHZhciBwcmV2VG9rZW47XG4gICAgICAgIHZhciBjdXJyZW50VGFnID0gdG9rZW4udmFsdWU7XG4gICAgICAgIHZhciB0YWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgdmFyIG9wZW5UYWdTdGFydCA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDEpO1xuICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIHZhciBmb3VuZE9wZW5UYWdFbmQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcHJldlRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBpZiAocHJldlRva2VuLnR5cGUuaW5kZXhPZigndGFnLWNsb3NlJykgIT09IC0xICYmICFmb3VuZE9wZW5UYWdFbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ0VuZCA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDEpOyAvL1JhbmdlIGZvciBgPmBcbiAgICAgICAgICAgICAgICBmb3VuZE9wZW5UYWdFbmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnPicgJiYgIWZvdW5kT3BlblRhZ0VuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ0VuZCA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDEpOyAvL1JhbmdlIGZvciBgPmBcbiAgICAgICAgICAgICAgICAgICAgZm91bmRPcGVuVGFnRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhZyA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSBjdXJyZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPC8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPCAwKSB7IC8vZm91bmQgY2xvc2luZyB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVRhZ1N0YXJ0ID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMik7IC8vUmFuZ2UgZm9yIDwvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlVGFnTmFtZSA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1jbG9zZScpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi52YWx1ZSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VUYWdFbmQgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAxKTsgLy9SYW5nZSBmb3IgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gY3VycmVudFRhZyAmJiB0b2tlbi52YWx1ZSA9PT0gJy8+JykgeyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8IDApIHsgLy9mb3VuZCBzZWxmLWNsb3NpbmcgdGFnIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlVGFnU3RhcnQgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVRhZ05hbWUgPSBjbG9zZVRhZ1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlVGFnRW5kID0gY2xvc2VUYWdOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdFbmQgPSBuZXcgUmFuZ2Uob3BlblRhZ05hbWUuZW5kLnJvdywgb3BlblRhZ05hbWUuZW5kLmNvbHVtbiwgb3BlblRhZ05hbWUuZW5kLnJvdywgb3BlblRhZ05hbWUuZW5kLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiBkZXB0aCA+PSAwKTtcbiAgICAgICAgaWYgKG9wZW5UYWdTdGFydCAmJiBvcGVuVGFnRW5kICYmIGNsb3NlVGFnU3RhcnQgJiYgY2xvc2VUYWdFbmQgJiYgb3BlblRhZ05hbWUgJiYgY2xvc2VUYWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZW5UYWc6IG5ldyBSYW5nZShvcGVuVGFnU3RhcnQuc3RhcnQucm93LCBvcGVuVGFnU3RhcnQuc3RhcnQuY29sdW1uLCBvcGVuVGFnRW5kLmVuZC5yb3csIG9wZW5UYWdFbmQuZW5kLmNvbHVtbiksXG4gICAgICAgICAgICAgICAgY2xvc2VUYWc6IG5ldyBSYW5nZShjbG9zZVRhZ1N0YXJ0LnN0YXJ0LnJvdywgY2xvc2VUYWdTdGFydC5zdGFydC5jb2x1bW4sIGNsb3NlVGFnRW5kLmVuZC5yb3csIGNsb3NlVGFnRW5kLmVuZC5jb2x1bW4pLFxuICAgICAgICAgICAgICAgIG9wZW5UYWdOYW1lOiBvcGVuVGFnTmFtZSxcbiAgICAgICAgICAgICAgICBjbG9zZVRhZ05hbWU6IGNsb3NlVGFnTmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy4kZmluZE9wZW5pbmdUYWcgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRva2VuKSB7XG4gICAgICAgIHZhciBwcmV2VG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdmFyIHRhZyA9IHRva2VuLnZhbHVlO1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKTtcbiAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCk7XG4gICAgICAgIHZhciBlbmRDb2x1bW4gPSBzdGFydENvbHVtbiArIDI7XG4gICAgICAgIHZhciBjbG9zZVRhZ1N0YXJ0ID0gbmV3IFJhbmdlKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgc3RhcnRSb3csIGVuZENvbHVtbik7IC8vUmFuZ2UgZm9yIDwvXG4gICAgICAgIGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgIHZhciBjbG9zZVRhZ05hbWUgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyB0b2tlbi52YWx1ZS5sZW5ndGgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZS5pbmRleE9mKCd0YWctY2xvc2UnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRva2VuIHx8IHRva2VuLnZhbHVlICE9PSBcIj5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNsb3NlVGFnRW5kID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7IC8vUmFuZ2UgZm9yID5cbiAgICAgICAgaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgIGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0b2tlbiA9IHByZXZUb2tlbjtcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpO1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gc3RhcnRDb2x1bW4gKyB0b2tlbi52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBwcmV2VG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IDApIHsgLy9mb3VuZCBvcGVuaW5nIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ05hbWUgPSBuZXcgUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdTdGFydCA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDEpOyAvL1JhbmdlIGZvciA8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgdG9rZW4udmFsdWUgIT09ICc+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuVGFnRW5kID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7IC8vUmFuZ2UgZm9yID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8LycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnLz4nKSB7IC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXBDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBUb2tlbiA9IHByZXZUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRtcFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpICE9PSAtMSAmJiB0bXBUb2tlbi52YWx1ZSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRtcFRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXBDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChwcmV2VG9rZW4gJiYgZGVwdGggPD0gMCk7XG4gICAgICAgIGlmIChvcGVuVGFnU3RhcnQgJiYgb3BlblRhZ0VuZCAmJiBjbG9zZVRhZ1N0YXJ0ICYmIGNsb3NlVGFnRW5kICYmIG9wZW5UYWdOYW1lICYmIGNsb3NlVGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcGVuVGFnOiBuZXcgUmFuZ2Uob3BlblRhZ1N0YXJ0LnN0YXJ0LnJvdywgb3BlblRhZ1N0YXJ0LnN0YXJ0LmNvbHVtbiwgb3BlblRhZ0VuZC5lbmQucm93LCBvcGVuVGFnRW5kLmVuZC5jb2x1bW4pLFxuICAgICAgICAgICAgICAgIGNsb3NlVGFnOiBuZXcgUmFuZ2UoY2xvc2VUYWdTdGFydC5zdGFydC5yb3csIGNsb3NlVGFnU3RhcnQuc3RhcnQuY29sdW1uLCBjbG9zZVRhZ0VuZC5lbmQucm93LCBjbG9zZVRhZ0VuZC5lbmQuY29sdW1uKSxcbiAgICAgICAgICAgICAgICBvcGVuVGFnTmFtZTogb3BlblRhZ05hbWUsXG4gICAgICAgICAgICAgICAgY2xvc2VUYWdOYW1lOiBjbG9zZVRhZ05hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5CcmFja2V0TWF0Y2ggPSBCcmFja2V0TWF0Y2g7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2VkaXRfc2Vzc2lvblwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2JpZGloYW5kbGVyXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9zZWxlY3Rpb25cIixcImFjZS9tb2RlL3RleHRcIixcImFjZS9yYW5nZVwiLFwiYWNlL2RvY3VtZW50XCIsXCJhY2UvYmFja2dyb3VuZF90b2tlbml6ZXJcIixcImFjZS9zZWFyY2hfaGlnaGxpZ2h0XCIsXCJhY2UvdW5kb21hbmFnZXJcIixcImFjZS9lZGl0X3Nlc3Npb24vZm9sZGluZ1wiLFwiYWNlL2VkaXRfc2Vzc2lvbi9icmFja2V0X21hdGNoXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIEJpZGlIYW5kbGVyID0gcmVxdWlyZShcIi4vYmlkaWhhbmRsZXJcIikuQmlkaUhhbmRsZXI7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBTZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25cIikuU2VsZWN0aW9uO1xudmFyIFRleHRNb2RlID0gcmVxdWlyZShcIi4vbW9kZS90ZXh0XCIpLk1vZGU7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBEb2N1bWVudCA9IHJlcXVpcmUoXCIuL2RvY3VtZW50XCIpLkRvY3VtZW50O1xudmFyIEJhY2tncm91bmRUb2tlbml6ZXIgPSByZXF1aXJlKFwiLi9iYWNrZ3JvdW5kX3Rva2VuaXplclwiKS5CYWNrZ3JvdW5kVG9rZW5pemVyO1xudmFyIFNlYXJjaEhpZ2hsaWdodCA9IHJlcXVpcmUoXCIuL3NlYXJjaF9oaWdobGlnaHRcIikuU2VhcmNoSGlnaGxpZ2h0O1xudmFyIFVuZG9NYW5hZ2VyID0gcmVxdWlyZShcIi4vdW5kb21hbmFnZXJcIikuVW5kb01hbmFnZXI7XG52YXIgRWRpdFNlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRpdFNlc3Npb24odGV4dCwgbW9kZSkgeyB0aGlzLmRvYztcbiAgICAgICAgdGhpcy4kYnJlYWtwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy4kZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy4kZnJvbnRNYXJrZXJzID0ge307XG4gICAgICAgIHRoaXMuJGJhY2tNYXJrZXJzID0ge307XG4gICAgICAgIHRoaXMuJG1hcmtlcklkID0gMTtcbiAgICAgICAgdGhpcy4kdW5kb1NlbGVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuJGZvbGREYXRhID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBcInNlc3Npb25cIiArICgrK0VkaXRTZXNzaW9uLiR1aWQpO1xuICAgICAgICB0aGlzLiRmb2xkRGF0YS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIgPSBuZXcgQmFja2dyb3VuZFRva2VuaXplcigobmV3IFRleHRNb2RlKCkpLmdldFRva2VuaXplcigpLCB0aGlzKTtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5vbihcInVwZGF0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3NlbGYuX3NpZ25hbChcInRva2VuaXplclVwZGF0ZVwiLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2VGb2xkXCIsIHRoaXMub25DaGFuZ2VGb2xkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLiRvbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9IFwib2JqZWN0XCIgfHwgIXRleHQuZ2V0TGluZSlcbiAgICAgICAgICAgIHRleHQgPSBuZXcgRG9jdW1lbnQoLyoqQHR5cGV7c3RyaW5nfSovICh0ZXh0KSk7XG4gICAgICAgIHRoaXMuc2V0RG9jdW1lbnQodGV4dCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbih0aGlzKTtcbiAgICAgICAgdGhpcy4kYmlkaUhhbmRsZXIgPSBuZXcgQmlkaUhhbmRsZXIodGhpcyk7XG4gICAgICAgIGNvbmZpZy5yZXNldE9wdGlvbnModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZShtb2RlKTtcbiAgICAgICAgY29uZmlnLl9zaWduYWwoXCJzZXNzaW9uXCIsIHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIH1cbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmRvYylcbiAgICAgICAgICAgIHRoaXMuZG9jLm9mZihcImNoYW5nZVwiLCB0aGlzLiRvbkNoYW5nZSk7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICBkb2Mub24oXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UsIHRydWUpO1xuICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnNldERvY3VtZW50KHRoaXMuZ2V0RG9jdW1lbnQoKSk7XG4gICAgICAgIHRoaXMucmVzZXRDYWNoZXMoKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXREb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRyZXNldFJvd0NhY2hlID0gZnVuY3Rpb24gKGRvY1Jvdykge1xuICAgICAgICBpZiAoIWRvY1Jvdykge1xuICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuJHNjcmVlblJvd0NhY2hlID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGwgPSB0aGlzLiRkb2NSb3dDYWNoZS5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gdGhpcy4kZ2V0Um93Q2FjaGVJbmRleCh0aGlzLiRkb2NSb3dDYWNoZSwgZG9jUm93KSArIDE7XG4gICAgICAgIGlmIChsID4gaSkge1xuICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUuc3BsaWNlKGksIGwpO1xuICAgICAgICAgICAgdGhpcy4kc2NyZWVuUm93Q2FjaGUuc3BsaWNlKGksIGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGdldFJvd0NhY2hlSW5kZXggPSBmdW5jdGlvbiAoY2FjaGVBcnJheSwgdmFsKSB7XG4gICAgICAgIHZhciBsb3cgPSAwO1xuICAgICAgICB2YXIgaGkgPSBjYWNoZUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsb3cgPD0gaGkpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGkpID4+IDE7XG4gICAgICAgICAgICB2YXIgYyA9IGNhY2hlQXJyYXlbbWlkXTtcbiAgICAgICAgICAgIGlmICh2YWwgPiBjKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCBjKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkIC0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb3cgLSAxO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnJlc2V0Q2FjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJHdyYXBEYXRhID0gW107XG4gICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlID0gW107XG4gICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnN0YXJ0KDApO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLm9uQ2hhbmdlRm9sZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBmb2xkID0gZS5kYXRhO1xuICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKGZvbGQuc3RhcnQucm93KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJGJpZGlIYW5kbGVyLm9uQ2hhbmdlKGRlbHRhKTtcbiAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZShkZWx0YS5zdGFydC5yb3cpO1xuICAgICAgICB2YXIgcmVtb3ZlZEZvbGRzID0gdGhpcy4kdXBkYXRlSW50ZXJuYWxEYXRhT25DaGFuZ2UoZGVsdGEpO1xuICAgICAgICBpZiAoIXRoaXMuJGZyb21VbmRvICYmIHRoaXMuJHVuZG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZEZvbGRzICYmIHJlbW92ZWRGb2xkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1bmRvTWFuYWdlci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVtb3ZlRm9sZHNcIixcbiAgICAgICAgICAgICAgICAgICAgZm9sZHM6IHJlbW92ZWRGb2xkc1xuICAgICAgICAgICAgICAgIH0sIHRoaXMubWVyZ2VVbmRvRGVsdGFzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lcmdlVW5kb0RlbHRhcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR1bmRvTWFuYWdlci5hZGQoZGVsdGEsIHRoaXMubWVyZ2VVbmRvRGVsdGFzKTtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VVbmRvRGVsdGFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGluZm9ybVVuZG9NYW5hZ2VyLnNjaGVkdWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZ1Rva2VuaXplci4kdXBkYXRlT25DaGFuZ2UoZGVsdGEpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwgZGVsdGEpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5kb2Muc2V0VmFsdWUodGV4dCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVUbygwLCAwKTtcbiAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcbiAgICAgICAgdGhpcy5zZXRVbmRvTWFuYWdlcih0aGlzLiR1bmRvTWFuYWdlcik7XG4gICAgICAgIHRoaXMuZ2V0VW5kb01hbmFnZXIoKS5yZXNldCgpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24uZnJvbUpTT04gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb24gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHNlc3Npb24gPSBKU09OLnBhcnNlKHNlc3Npb24pO1xuICAgICAgICB2YXIgdW5kb01hbmFnZXIgPSBuZXcgVW5kb01hbmFnZXIoKTtcbiAgICAgICAgdW5kb01hbmFnZXIuJHVuZG9TdGFjayA9IHNlc3Npb24uaGlzdG9yeS51bmRvO1xuICAgICAgICB1bmRvTWFuYWdlci4kcmVkb1N0YWNrID0gc2Vzc2lvbi5oaXN0b3J5LnJlZG87XG4gICAgICAgIHVuZG9NYW5hZ2VyLm1hcmsgPSBzZXNzaW9uLmhpc3RvcnkubWFyaztcbiAgICAgICAgdW5kb01hbmFnZXIuJHJldiA9IHNlc3Npb24uaGlzdG9yeS5yZXY7XG4gICAgICAgIHZhciBlZGl0U2Vzc2lvbiA9IG5ldyBFZGl0U2Vzc2lvbihzZXNzaW9uLnZhbHVlKTtcbiAgICAgICAgc2Vzc2lvbi5mb2xkcy5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICBlZGl0U2Vzc2lvbi5hZGRGb2xkKFwiLi4uXCIsIFJhbmdlLmZyb21Qb2ludHMoZm9sZC5zdGFydCwgZm9sZC5lbmQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRTZXNzaW9uLnNldEFubm90YXRpb25zKHNlc3Npb24uYW5ub3RhdGlvbnMpO1xuICAgICAgICBlZGl0U2Vzc2lvbi5zZXRCcmVha3BvaW50cyhzZXNzaW9uLmJyZWFrcG9pbnRzKTtcbiAgICAgICAgZWRpdFNlc3Npb24uc2V0TW9kZShzZXNzaW9uLm1vZGUpO1xuICAgICAgICBlZGl0U2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KHNlc3Npb24uc2Nyb2xsTGVmdCk7XG4gICAgICAgIGVkaXRTZXNzaW9uLnNldFNjcm9sbFRvcChzZXNzaW9uLnNjcm9sbFRvcCk7XG4gICAgICAgIGVkaXRTZXNzaW9uLnNldFVuZG9NYW5hZ2VyKHVuZG9NYW5hZ2VyKTtcbiAgICAgICAgZWRpdFNlc3Npb24uc2VsZWN0aW9uLmZyb21KU09OKHNlc3Npb24uc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGVkaXRTZXNzaW9uO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFubm90YXRpb25zOiB0aGlzLiRhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB0aGlzLiRicmVha3BvaW50cyxcbiAgICAgICAgICAgIGZvbGRzOiB0aGlzLmdldEFsbEZvbGRzKCkubWFwKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvbGQucmFuZ2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGhpc3Rvcnk6IHRoaXMuZ2V0VW5kb01hbmFnZXIoKSxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMuJG1vZGUuJGlkLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdDogdGhpcy4kc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy4kc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRvYy5nZXRWYWx1ZSgpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRWYWx1ZSgpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZ1Rva2VuaXplci5nZXRTdGF0ZShyb3cpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFRva2VucyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmdUb2tlbml6ZXIuZ2V0VG9rZW5zKHJvdyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VG9rZW5BdCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5iZ1Rva2VuaXplci5nZXRUb2tlbnMocm93KTtcbiAgICAgICAgdmFyIHRva2VuLCBjID0gMDtcbiAgICAgICAgaWYgKGNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0TGluZShyb3cpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyArPSB0b2tlbnNbaV0udmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjID49IGNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdG9rZW4uaW5kZXggPSBpO1xuICAgICAgICB0b2tlbi5zdGFydCA9IGMgLSB0b2tlbi52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRVbmRvTWFuYWdlciA9IGZ1bmN0aW9uICh1bmRvTWFuYWdlcikge1xuICAgICAgICB0aGlzLiR1bmRvTWFuYWdlciA9IHVuZG9NYW5hZ2VyO1xuICAgICAgICBpZiAodGhpcy4kaW5mb3JtVW5kb01hbmFnZXIpXG4gICAgICAgICAgICB0aGlzLiRpbmZvcm1VbmRvTWFuYWdlci5jYW5jZWwoKTtcbiAgICAgICAgaWYgKHVuZG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB1bmRvTWFuYWdlci5hZGRTZXNzaW9uKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuJGluZm9ybVVuZG9NYW5hZ2VyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHNlbGYubWVyZ2VVbmRvRGVsdGFzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy4kaW5mb3JtVW5kb01hbmFnZXIgPSBsYW5nLmRlbGF5ZWRDYWxsKHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRzeW5jSW5mb3JtVW5kb01hbmFnZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5tYXJrVW5kb0dyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyKVxuICAgICAgICAgICAgdGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyKCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VW5kb01hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1bmRvTWFuYWdlciB8fCB0aGlzLiRkZWZhdWx0VW5kb01hbmFnZXI7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VGFiU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRVc2VTb2Z0VGFicygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIHRoaXMuZ2V0VGFiU2l6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcdFwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0VXNlU29mdFRhYnMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidXNlU29mdFRhYnNcIiwgdmFsKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRVc2VTb2Z0VGFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVzZVNvZnRUYWJzICYmICF0aGlzLiRtb2RlLiRpbmRlbnRXaXRoVGFicztcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRUYWJTaXplID0gZnVuY3Rpb24gKHRhYlNpemUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJ0YWJTaXplXCIsIHRhYlNpemUpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFRhYlNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0YWJTaXplO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmlzVGFiU3RvcCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4kdXNlU29mdFRhYnMgJiYgKHBvc2l0aW9uLmNvbHVtbiAlIHRoaXMuJHRhYlNpemUgPT09IDApO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldE5hdmlnYXRlV2l0aGluU29mdFRhYnMgPSBmdW5jdGlvbiAobmF2aWdhdGVXaXRoaW5Tb2Z0VGFicykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcIm5hdmlnYXRlV2l0aGluU29mdFRhYnNcIiwgbmF2aWdhdGVXaXRoaW5Tb2Z0VGFicyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0TmF2aWdhdGVXaXRoaW5Tb2Z0VGFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG5hdmlnYXRlV2l0aGluU29mdFRhYnM7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0T3ZlcndyaXRlID0gZnVuY3Rpb24gKG92ZXJ3cml0ZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcIm92ZXJ3cml0ZVwiLCBvdmVyd3JpdGUpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG92ZXJ3cml0ZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS50b2dnbGVPdmVyd3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcndyaXRlKCF0aGlzLiRvdmVyd3JpdGUpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmFkZEd1dHRlckRlY29yYXRpb24gPSBmdW5jdGlvbiAocm93LCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkZWNvcmF0aW9uc1tyb3ddKVxuICAgICAgICAgICAgdGhpcy4kZGVjb3JhdGlvbnNbcm93XSA9IFwiXCI7XG4gICAgICAgIHRoaXMuJGRlY29yYXRpb25zW3Jvd10gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUJyZWFrcG9pbnRcIiwge30pO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnJlbW92ZUd1dHRlckRlY29yYXRpb24gPSBmdW5jdGlvbiAocm93LCBjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy4kZGVjb3JhdGlvbnNbcm93XSA9ICh0aGlzLiRkZWNvcmF0aW9uc1tyb3ddIHx8IFwiXCIpLnJlcGxhY2UoXCIgXCIgKyBjbGFzc05hbWUsIFwiXCIpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRCcmVha3BvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGJyZWFrcG9pbnRzO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldEJyZWFrcG9pbnRzID0gZnVuY3Rpb24gKHJvd3MpIHtcbiAgICAgICAgdGhpcy4kYnJlYWtwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLiRicmVha3BvaW50c1tyb3dzW2ldXSA9IFwiYWNlX2JyZWFrcG9pbnRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5jbGVhckJyZWFrcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRicmVha3BvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRCcmVha3BvaW50ID0gZnVuY3Rpb24gKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IFwiYWNlX2JyZWFrcG9pbnRcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSlcbiAgICAgICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzW3Jvd10gPSBjbGFzc05hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRicmVha3BvaW50c1tyb3ddO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5jbGVhckJyZWFrcG9pbnQgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLiRicmVha3BvaW50c1tyb3ddO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAocmFuZ2UsIGNsYXp6LCB0eXBlLCBpbkZyb250KSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuJG1hcmtlcklkKys7XG4gICAgICAgIHZhciBtYXJrZXIgPSB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8IFwibGluZVwiLFxuICAgICAgICAgICAgcmVuZGVyZXI6IHR5cGVvZiB0eXBlID09IFwiZnVuY3Rpb25cIiA/IHR5cGUgOiBudWxsLFxuICAgICAgICAgICAgY2xheno6IGNsYXp6LFxuICAgICAgICAgICAgaW5Gcm9udDogISFpbkZyb250LFxuICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbkZyb250KSB7XG4gICAgICAgICAgICB0aGlzLiRmcm9udE1hcmtlcnNbaWRdID0gbWFya2VyO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlRnJvbnRNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRiYWNrTWFya2Vyc1tpZF0gPSBtYXJrZXI7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCYWNrTWFya2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5hZGREeW5hbWljTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlciwgaW5Gcm9udCkge1xuICAgICAgICBpZiAoIW1hcmtlci51cGRhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpZCA9IHRoaXMuJG1hcmtlcklkKys7XG4gICAgICAgIG1hcmtlci5pZCA9IGlkO1xuICAgICAgICBtYXJrZXIuaW5Gcm9udCA9ICEhaW5Gcm9udDtcbiAgICAgICAgaWYgKGluRnJvbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGZyb250TWFya2Vyc1tpZF0gPSBtYXJrZXI7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VGcm9udE1hcmtlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGJhY2tNYXJrZXJzW2lkXSA9IG1hcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUJhY2tNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5yZW1vdmVNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VySWQpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuJGZyb250TWFya2Vyc1ttYXJrZXJJZF0gfHwgdGhpcy4kYmFja01hcmtlcnNbbWFya2VySWRdO1xuICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSBtYXJrZXIuaW5Gcm9udCA/IHRoaXMuJGZyb250TWFya2VycyA6IHRoaXMuJGJhY2tNYXJrZXJzO1xuICAgICAgICBkZWxldGUgKG1hcmtlcnNbbWFya2VySWRdKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKG1hcmtlci5pbkZyb250ID8gXCJjaGFuZ2VGcm9udE1hcmtlclwiIDogXCJjaGFuZ2VCYWNrTWFya2VyXCIpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldE1hcmtlcnMgPSBmdW5jdGlvbiAoaW5Gcm9udCkge1xuICAgICAgICByZXR1cm4gaW5Gcm9udCA/IHRoaXMuJGZyb250TWFya2VycyA6IHRoaXMuJGJhY2tNYXJrZXJzO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChyZSkge1xuICAgICAgICBpZiAoIXRoaXMuJHNlYXJjaEhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IG5ldyBTZWFyY2hIaWdobGlnaHQobnVsbCwgXCJhY2Vfc2VsZWN0ZWQtd29yZFwiLCBcInRleHRcIik7XG4gICAgICAgICAgICB0aGlzLiRzZWFyY2hIaWdobGlnaHQgPSB0aGlzLmFkZER5bmFtaWNNYXJrZXIoaGlnaGxpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzZWFyY2hIaWdobGlnaHQuc2V0UmVnZXhwKHJlKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5oaWdobGlnaHRMaW5lcyA9IGZ1bmN0aW9uIChzdGFydFJvdywgZW5kUm93LCBjbGF6eiwgaW5Gcm9udCkge1xuICAgICAgICBpZiAodHlwZW9mIGVuZFJvdyAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjbGF6eiA9IGVuZFJvdztcbiAgICAgICAgICAgIGVuZFJvdyA9IHN0YXJ0Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2xhenopXG4gICAgICAgICAgICBjbGF6eiA9IFwiYWNlX3N0ZXBcIjtcbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0Um93LCAwLCBlbmRSb3csIEluZmluaXR5KTtcbiAgICAgICAgcmFuZ2UuaWQgPSB0aGlzLmFkZE1hcmtlcihyYW5nZSwgY2xhenosIFwiZnVsbExpbmVcIiwgaW5Gcm9udCk7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLiRhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VBbm5vdGF0aW9uXCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGFubm90YXRpb25zIHx8IFtdO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmNsZWFyQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0QW5ub3RhdGlvbnMoW10pO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRkZXRlY3ROZXdMaW5lID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXi4qPyhcXHI/XFxuKS9tKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0aGlzLiRhdXRvTmV3TGluZSA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kYXV0b05ld0xpbmUgPSBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0V29yZFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBpblRva2VuID0gZmFsc2U7XG4gICAgICAgIGlmIChjb2x1bW4gPiAwKVxuICAgICAgICAgICAgaW5Ub2tlbiA9ICEhbGluZS5jaGFyQXQoY29sdW1uIC0gMSkubWF0Y2godGhpcy50b2tlblJlKTtcbiAgICAgICAgaWYgKCFpblRva2VuKVxuICAgICAgICAgICAgaW5Ub2tlbiA9ICEhbGluZS5jaGFyQXQoY29sdW1uKS5tYXRjaCh0aGlzLnRva2VuUmUpO1xuICAgICAgICBpZiAoaW5Ub2tlbilcbiAgICAgICAgICAgIHZhciByZSA9IHRoaXMudG9rZW5SZTtcbiAgICAgICAgZWxzZSBpZiAoL15cXHMrJC8udGVzdChsaW5lLnNsaWNlKGNvbHVtbiAtIDEsIGNvbHVtbiArIDEpKSlcbiAgICAgICAgICAgIHZhciByZSA9IC9cXHMvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLm5vblRva2VuUmU7XG4gICAgICAgIHZhciBzdGFydCA9IGNvbHVtbjtcbiAgICAgICAgaWYgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB9IHdoaWxlIChzdGFydCA+PSAwICYmIGxpbmUuY2hhckF0KHN0YXJ0KS5tYXRjaChyZSkpO1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0gY29sdW1uO1xuICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgbGluZS5jaGFyQXQoZW5kKS5tYXRjaChyZSkpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uocm93LCBzdGFydCwgcm93LCBlbmQpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldEFXb3JkUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHdvcmRSYW5nZSA9IHRoaXMuZ2V0V29yZFJhbmdlKHJvdywgY29sdW1uKTtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUod29yZFJhbmdlLmVuZC5yb3cpO1xuICAgICAgICB3aGlsZSAobGluZS5jaGFyQXQod29yZFJhbmdlLmVuZC5jb2x1bW4pLm1hdGNoKC9bIFxcdF0vKSkge1xuICAgICAgICAgICAgd29yZFJhbmdlLmVuZC5jb2x1bW4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZFJhbmdlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldE5ld0xpbmVNb2RlID0gZnVuY3Rpb24gKG5ld0xpbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuZG9jLnNldE5ld0xpbmVNb2RlKG5ld0xpbmVNb2RlKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXROZXdMaW5lTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldE5ld0xpbmVNb2RlKCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0VXNlV29ya2VyID0gZnVuY3Rpb24gKHVzZVdvcmtlcikgeyB0aGlzLnNldE9wdGlvbihcInVzZVdvcmtlclwiLCB1c2VXb3JrZXIpOyB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRVc2VXb3JrZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiR1c2VXb3JrZXI7IH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLm9uUmVsb2FkVG9rZW5pemVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBlLmRhdGE7XG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc3RhcnQocm93cy5maXJzdCk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcInRva2VuaXplclVwZGF0ZVwiLCBlKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24gKG1vZGUsIGNiKSB7XG4gICAgICAgIGlmIChtb2RlICYmIHR5cGVvZiBtb2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAobW9kZS5nZXRUb2tlbml6ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9uQ2hhbmdlTW9kZShtb2RlKTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gbW9kZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IC8qKkB0eXBle3N0cmluZ30qLyAobW9kZSkgfHwgXCJhY2UvbW9kZS90ZXh0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRtb2Rlc1tcImFjZS9tb2RlL3RleHRcIl0pXG4gICAgICAgICAgICB0aGlzLiRtb2Rlc1tcImFjZS9tb2RlL3RleHRcIl0gPSBuZXcgVGV4dE1vZGUoKTtcbiAgICAgICAgaWYgKHRoaXMuJG1vZGVzW3BhdGhdICYmICFvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLiRvbkNoYW5nZU1vZGUodGhpcy4kbW9kZXNbcGF0aF0pO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRtb2RlSWQgPSBwYXRoO1xuICAgICAgICBjb25maWcubG9hZE1vZHVsZShbXCJtb2RlXCIsIHBhdGhdLCBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJG1vZGVJZCAhPT0gcGF0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRtb2Rlc1twYXRoXSAmJiAhb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSh0aGlzLiRtb2Rlc1twYXRoXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtICYmIG0uTW9kZSkge1xuICAgICAgICAgICAgICAgIG0gPSBuZXcgbS5Nb2RlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRtb2Rlc1twYXRoXSA9IG07XG4gICAgICAgICAgICAgICAgICAgIG0uJGlkID0gcGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKCF0aGlzLiRtb2RlKVxuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKHRoaXMuJG1vZGVzW1wiYWNlL21vZGUvdGV4dFwiXSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJG9uQ2hhbmdlTW9kZSA9IGZ1bmN0aW9uIChtb2RlLCAkaXNQbGFjZWhvbGRlcikge1xuICAgICAgICBpZiAoISRpc1BsYWNlaG9sZGVyKVxuICAgICAgICAgICAgdGhpcy4kbW9kZUlkID0gbW9kZS4kaWQ7XG4gICAgICAgIGlmICh0aGlzLiRtb2RlID09PSBtb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb2xkTW9kZSA9IHRoaXMuJG1vZGU7XG4gICAgICAgIHRoaXMuJG1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLiRzdG9wV29ya2VyKCk7XG4gICAgICAgIGlmICh0aGlzLiR1c2VXb3JrZXIpXG4gICAgICAgICAgICB0aGlzLiRzdGFydFdvcmtlcigpO1xuICAgICAgICB2YXIgdG9rZW5pemVyID0gbW9kZS5nZXRUb2tlbml6ZXIoKTtcbiAgICAgICAgaWYgKHRva2VuaXplci5vbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgb25SZWxvYWRUb2tlbml6ZXIgPSB0aGlzLm9uUmVsb2FkVG9rZW5pemVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0b2tlbml6ZXIub24oXCJ1cGRhdGVcIiwgb25SZWxvYWRUb2tlbml6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0VG9rZW5pemVyKHRva2VuaXplcik7XG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0RG9jdW1lbnQodGhpcy5nZXREb2N1bWVudCgpKTtcbiAgICAgICAgdGhpcy50b2tlblJlID0gbW9kZS50b2tlblJlO1xuICAgICAgICB0aGlzLm5vblRva2VuUmUgPSBtb2RlLm5vblRva2VuUmU7XG4gICAgICAgIGlmICghJGlzUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGlmIChtb2RlLmF0dGFjaFRvU2Vzc2lvbilcbiAgICAgICAgICAgICAgICBtb2RlLmF0dGFjaFRvU2Vzc2lvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuJG9wdGlvbnMud3JhcE1ldGhvZC5zZXQuY2FsbCh0aGlzLCB0aGlzLiR3cmFwTWV0aG9kKTtcbiAgICAgICAgICAgIHRoaXMuJHNldEZvbGRpbmcobW9kZS5mb2xkaW5nUnVsZXMpO1xuICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zdGFydCgwKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJjaGFuZ2VNb2RlXCIsIHsgb2xkTW9kZTogb2xkTW9kZSwgbW9kZTogbW9kZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzdG9wV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kd29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLiR3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHN0YXJ0V29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kd29ya2VyID0gdGhpcy4kbW9kZS5jcmVhdGVXb3JrZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbmZpZy53YXJuKFwiQ291bGQgbm90IGxvYWQgd29ya2VyXCIsIGUpO1xuICAgICAgICAgICAgdGhpcy4kd29ya2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb2RlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFRvcCA9PT0gc2Nyb2xsVG9wIHx8IGlzTmFOKHNjcm9sbFRvcCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlU2Nyb2xsVG9wXCIsIHNjcm9sbFRvcCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoc2Nyb2xsTGVmdCkge1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsTGVmdCA9PT0gc2Nyb2xsTGVmdCB8fCBpc05hTihzY3JvbGxMZWZ0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNjcm9sbExlZnRcIiwgc2Nyb2xsTGVmdCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0U2NyZWVuV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGNvbXB1dGVXaWR0aCgpO1xuICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmdldExpbmVXaWRnZXRNYXhXaWR0aCgpLCB0aGlzLnNjcmVlbldpZHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuV2lkdGg7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0TGluZVdpZGdldE1heFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0c1dpZHRoICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lV2lkZ2V0c1dpZHRoO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB0aGlzLmxpbmVXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIGlmICh3ICYmIHcuc2NyZWVuV2lkdGggPiB3aWR0aClcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHcuc2NyZWVuV2lkdGg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lV2lkZ2V0V2lkdGggPSB3aWR0aDtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kY29tcHV0ZVdpZHRoID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgIGlmICh0aGlzLiRtb2RpZmllZCB8fCBmb3JjZSkge1xuICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5XaWR0aCA9IHRoaXMuJHdyYXBMaW1pdDtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZG9jLmdldEFsbExpbmVzKCk7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLiRyb3dMZW5ndGhDYWNoZTtcbiAgICAgICAgICAgIHZhciBsb25nZXN0U2NyZWVuTGluZSA9IDA7XG4gICAgICAgICAgICB2YXIgZm9sZEluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuJGZvbGREYXRhW2ZvbGRJbmRleF07XG4gICAgICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBsZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLiRmb2xkRGF0YVtmb2xkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWNoZVtpXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZVtpXSA9IHRoaXMuJGdldFN0cmluZ1NjcmVlbldpZHRoKGxpbmVzW2ldKVswXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVbaV0gPiBsb25nZXN0U2NyZWVuTGluZSlcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdFNjcmVlbkxpbmUgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NyZWVuV2lkdGggPSBsb25nZXN0U2NyZWVuTGluZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldExpbmUgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldExpbmVzKGZpcnN0Um93LCBsYXN0Um93KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRMZW5ndGgoKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRUZXh0UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldFRleHRSYW5nZShyYW5nZSB8fCB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocG9zaXRpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmluc2VydChwb3NpdGlvbiwgdGV4dCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5yZW1vdmUocmFuZ2UpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnJlbW92ZUZ1bGxMaW5lcyA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MucmVtb3ZlRnVsbExpbmVzKGZpcnN0Um93LCBsYXN0Um93KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS51bmRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChkZWx0YXMsIGRvbnRTZWxlY3QpIHtcbiAgICAgICAgaWYgKCFkZWx0YXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSBkZWx0YXMubGVuZ3RoIC0gMTsgaSAhPSAtMTsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG4gICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCIgfHwgZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvYy5yZXZlcnREZWx0YShkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YS5mb2xkcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZHMoZGVsdGEuZm9sZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9udFNlbGVjdCAmJiB0aGlzLiR1bmRvU2VsZWN0KSB7XG4gICAgICAgICAgICBpZiAoZGVsdGFzLnNlbGVjdGlvbkJlZm9yZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mcm9tSlNPTihkZWx0YXMuc2VsZWN0aW9uQmVmb3JlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZSh0aGlzLiRnZXRVbmRvU2VsZWN0aW9uKGRlbHRhcywgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gZmFsc2U7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUucmVkb0NoYW5nZXMgPSBmdW5jdGlvbiAoZGVsdGFzLCBkb250U2VsZWN0KSB7XG4gICAgICAgIGlmICghZGVsdGFzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZGVsdGFzW2ldO1xuICAgICAgICAgICAgaWYgKGRlbHRhLmFjdGlvbiA9PSBcImluc2VydFwiIHx8IGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MuJHNhZmVBcHBseURlbHRhKGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRTZWxlY3QgJiYgdGhpcy4kdW5kb1NlbGVjdCkge1xuICAgICAgICAgICAgaWYgKGRlbHRhcy5zZWxlY3Rpb25BZnRlcilcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mcm9tSlNPTihkZWx0YXMuc2VsZWN0aW9uQWZ0ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKHRoaXMuJGdldFVuZG9TZWxlY3Rpb24oZGVsdGFzLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gZmFsc2U7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0VW5kb1NlbGVjdCA9IGZ1bmN0aW9uIChlbmFibGUpIHtcbiAgICAgICAgdGhpcy4kdW5kb1NlbGVjdCA9IGVuYWJsZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kZ2V0VW5kb1NlbGVjdGlvbiA9IGZ1bmN0aW9uIChkZWx0YXMsIGlzVW5kbykge1xuICAgICAgICBmdW5jdGlvbiBpc0luc2VydChkZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVW5kbyA/IGRlbHRhLmFjdGlvbiAhPT0gXCJpbnNlcnRcIiA6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UsIHBvaW50O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZGVsdGFzW2ldO1xuICAgICAgICAgICAgaWYgKCFkZWx0YS5zdGFydClcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBmb2xkc1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0luc2VydChkZWx0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnN0YXJ0LCBkZWx0YS5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnN0YXJ0LCBkZWx0YS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5zZXJ0KGRlbHRhKSkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gZGVsdGEuc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmUocG9pbnQucm93LCBwb2ludC5jb2x1bW4pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBkZWx0YS5lbmQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmUocG9pbnQucm93LCBwb2ludC5jb2x1bW4pID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGRlbHRhLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKHBvaW50LnJvdywgcG9pbnQuY29sdW1uKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoZGVsdGEuc3RhcnQsIGRlbHRhLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnJlcGxhY2UocmFuZ2UsIHRleHQpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLm1vdmVUZXh0ID0gZnVuY3Rpb24gKGZyb21SYW5nZSwgdG9Qb3NpdGlvbiwgY29weSkge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dFJhbmdlKGZyb21SYW5nZSk7XG4gICAgICAgIHZhciBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKGZyb21SYW5nZSk7XG4gICAgICAgIHZhciB0b1JhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyh0b1Bvc2l0aW9uLCB0b1Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFjb3B5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShmcm9tUmFuZ2UpO1xuICAgICAgICAgICAgdmFyIHJvd0RpZmYgPSBmcm9tUmFuZ2Uuc3RhcnQucm93IC0gZnJvbVJhbmdlLmVuZC5yb3c7XG4gICAgICAgICAgICB2YXIgY29sbERpZmYgPSByb3dEaWZmID8gLWZyb21SYW5nZS5lbmQuY29sdW1uIDogZnJvbVJhbmdlLnN0YXJ0LmNvbHVtbiAtIGZyb21SYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICAgICAgaWYgKGNvbGxEaWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvUmFuZ2Uuc3RhcnQucm93ID09IGZyb21SYW5nZS5lbmQucm93ICYmIHRvUmFuZ2Uuc3RhcnQuY29sdW1uID4gZnJvbVJhbmdlLmVuZC5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIHRvUmFuZ2Uuc3RhcnQuY29sdW1uICs9IGNvbGxEaWZmO1xuICAgICAgICAgICAgICAgIGlmICh0b1JhbmdlLmVuZC5yb3cgPT0gZnJvbVJhbmdlLmVuZC5yb3cgJiYgdG9SYW5nZS5lbmQuY29sdW1uID4gZnJvbVJhbmdlLmVuZC5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIHRvUmFuZ2UuZW5kLmNvbHVtbiArPSBjb2xsRGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3dEaWZmICYmIHRvUmFuZ2Uuc3RhcnQucm93ID49IGZyb21SYW5nZS5lbmQucm93KSB7XG4gICAgICAgICAgICAgICAgdG9SYW5nZS5zdGFydC5yb3cgKz0gcm93RGlmZjtcbiAgICAgICAgICAgICAgICB0b1JhbmdlLmVuZC5yb3cgKz0gcm93RGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1JhbmdlLmVuZCA9IHRoaXMuaW5zZXJ0KHRvUmFuZ2Uuc3RhcnQsIHRleHQpO1xuICAgICAgICBpZiAoZm9sZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhcnQgPSBmcm9tUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSB0b1JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIHJvd0RpZmYgPSBuZXdTdGFydC5yb3cgLSBvbGRTdGFydC5yb3c7XG4gICAgICAgICAgICB2YXIgY29sbERpZmYgPSBuZXdTdGFydC5jb2x1bW4gLSBvbGRTdGFydC5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGRzKGZvbGRzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHguc3RhcnQucm93ID09IG9sZFN0YXJ0LnJvdylcbiAgICAgICAgICAgICAgICAgICAgeC5zdGFydC5jb2x1bW4gKz0gY29sbERpZmY7XG4gICAgICAgICAgICAgICAgaWYgKHguZW5kLnJvdyA9PSBvbGRTdGFydC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIHguZW5kLmNvbHVtbiArPSBjb2xsRGlmZjtcbiAgICAgICAgICAgICAgICB4LnN0YXJ0LnJvdyArPSByb3dEaWZmO1xuICAgICAgICAgICAgICAgIHguZW5kLnJvdyArPSByb3dEaWZmO1xuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1JhbmdlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmluZGVudFJvd3MgPSBmdW5jdGlvbiAoc3RhcnRSb3csIGVuZFJvdywgaW5kZW50U3RyaW5nKSB7XG4gICAgICAgIGluZGVudFN0cmluZyA9IGluZGVudFN0cmluZy5yZXBsYWNlKC9cXHQvZywgdGhpcy5nZXRUYWJTdHJpbmcoKSk7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPD0gZW5kUm93OyByb3crKylcbiAgICAgICAgICAgIHRoaXMuZG9jLmluc2VydEluTGluZSh7IHJvdzogcm93LCBjb2x1bW46IDAgfSwgaW5kZW50U3RyaW5nKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5vdXRkZW50Um93cyA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgcm93UmFuZ2UgPSByYW5nZS5jb2xsYXBzZVJvd3MoKTtcbiAgICAgICAgdmFyIGRlbGV0ZVJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIDAsIDApO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGFiU2l6ZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gcm93UmFuZ2Uuc3RhcnQucm93OyBpIDw9IHJvd1JhbmdlLmVuZC5yb3c7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUoaSk7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5zdGFydC5yb3cgPSBpO1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2UuZW5kLnJvdyA9IGk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemU7ICsrailcbiAgICAgICAgICAgICAgICBpZiAobGluZS5jaGFyQXQoaikgIT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChqIDwgc2l6ZSAmJiBsaW5lLmNoYXJBdChqKSA9PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlLnN0YXJ0LmNvbHVtbiA9IGo7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmFuZ2UuZW5kLmNvbHVtbiA9IGogKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQuY29sdW1uID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlbGV0ZVJhbmdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRtb3ZlTGluZXMgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3csIGRpcikge1xuICAgICAgICBmaXJzdFJvdyA9IHRoaXMuZ2V0Um93Rm9sZFN0YXJ0KGZpcnN0Um93KTtcbiAgICAgICAgbGFzdFJvdyA9IHRoaXMuZ2V0Um93Rm9sZEVuZChsYXN0Um93KTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvd0ZvbGRTdGFydChmaXJzdFJvdyArIGRpcik7XG4gICAgICAgICAgICBpZiAocm93IDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHZhciBkaWZmID0gcm93IC0gZmlyc3RSb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93Rm9sZEVuZChsYXN0Um93ICsgZGlyKTtcbiAgICAgICAgICAgIGlmIChyb3cgPiB0aGlzLmRvYy5nZXRMZW5ndGgoKSAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHJvdyAtIGxhc3RSb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaXJzdFJvdyA9IHRoaXMuJGNsaXBSb3dUb0RvY3VtZW50KGZpcnN0Um93KTtcbiAgICAgICAgICAgIGxhc3RSb3cgPSB0aGlzLiRjbGlwUm93VG9Eb2N1bWVudChsYXN0Um93KTtcbiAgICAgICAgICAgIHZhciBkaWZmID0gbGFzdFJvdyAtIGZpcnN0Um93ICsgMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoZmlyc3RSb3csIDAsIGxhc3RSb3csIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB4ID0geC5jbG9uZSgpO1xuICAgICAgICAgICAgeC5zdGFydC5yb3cgKz0gZGlmZjtcbiAgICAgICAgICAgIHguZW5kLnJvdyArPSBkaWZmO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGluZXMgPSBkaXIgPT0gMFxuICAgICAgICAgICAgPyB0aGlzLmRvYy5nZXRMaW5lcyhmaXJzdFJvdywgbGFzdFJvdylcbiAgICAgICAgICAgIDogdGhpcy5kb2MucmVtb3ZlRnVsbExpbmVzKGZpcnN0Um93LCBsYXN0Um93KTtcbiAgICAgICAgdGhpcy5kb2MuaW5zZXJ0RnVsbExpbmVzKGZpcnN0Um93ICsgZGlmZiwgbGluZXMpO1xuICAgICAgICBmb2xkcy5sZW5ndGggJiYgdGhpcy5hZGRGb2xkcyhmb2xkcyk7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLm1vdmVMaW5lc1VwID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb3ZlTGluZXMoZmlyc3RSb3csIGxhc3RSb3csIC0xKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5tb3ZlTGluZXNEb3duID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb3ZlTGluZXMoZmlyc3RSb3csIGxhc3RSb3csIDEpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmR1cGxpY2F0ZUxpbmVzID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb3ZlTGluZXMoZmlyc3RSb3csIGxhc3RSb3csIDApO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRjbGlwUm93VG9Eb2N1bWVudCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHJvdywgdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxKSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGNsaXBDb2x1bW5Ub1JvdyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uIDwgMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5kb2MuZ2V0TGluZShyb3cpLmxlbmd0aCwgY29sdW1uKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBjb2x1bW4gPSBNYXRoLm1heCgwLCBjb2x1bW4pO1xuICAgICAgICBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgcm93ID0gMDtcbiAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAocm93ID49IGxlbikge1xuICAgICAgICAgICAgICAgIHJvdyA9IGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShsZW4gLSAxKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLm1pbih0aGlzLmRvYy5nZXRMaW5lKHJvdykubGVuZ3RoLCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGNsaXBSYW5nZVRvRG9jdW1lbnQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdyA9IDA7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gdGhpcy4kY2xpcENvbHVtblRvUm93KHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICBpZiAocmFuZ2UuZW5kLnJvdyA+IGxlbikge1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IGxlbjtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSB0aGlzLmRvYy5nZXRMaW5lKGxlbikubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IHRoaXMuJGNsaXBDb2x1bW5Ub1JvdyhyYW5nZS5lbmQucm93LCByYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0VXNlV3JhcE1vZGUgPSBmdW5jdGlvbiAodXNlV3JhcE1vZGUpIHtcbiAgICAgICAgaWYgKHVzZVdyYXBNb2RlICE9IHRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLiR1c2VXcmFwTW9kZSA9IHVzZVdyYXBNb2RlO1xuICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcbiAgICAgICAgICAgIGlmICh1c2VXcmFwTW9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHdyYXBEYXRhID0gQXJyYXkobGVuKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YSgwLCBsZW4gLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVdyYXBNb2RlXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VXNlV3JhcE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1c2VXcmFwTW9kZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRXcmFwTGltaXRSYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICBpZiAodGhpcy4kd3JhcExpbWl0UmFuZ2UubWluICE9PSBtaW4gfHwgdGhpcy4kd3JhcExpbWl0UmFuZ2UubWF4ICE9PSBtYXgpIHtcbiAgICAgICAgICAgIHRoaXMuJHdyYXBMaW1pdFJhbmdlID0geyBtaW46IG1pbiwgbWF4OiBtYXggfTtcbiAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGJpZGlIYW5kbGVyLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlV3JhcE1vZGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5hZGp1c3RXcmFwTGltaXQgPSBmdW5jdGlvbiAoZGVzaXJlZExpbWl0LCAkcHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdmFyIGxpbWl0cyA9IHRoaXMuJHdyYXBMaW1pdFJhbmdlO1xuICAgICAgICBpZiAobGltaXRzLm1heCA8IDApXG4gICAgICAgICAgICBsaW1pdHMgPSB7IG1pbjogJHByaW50TWFyZ2luLCBtYXg6ICRwcmludE1hcmdpbiB9O1xuICAgICAgICB2YXIgd3JhcExpbWl0ID0gdGhpcy4kY29uc3RyYWluV3JhcExpbWl0KGRlc2lyZWRMaW1pdCwgbGltaXRzLm1pbiwgbGltaXRzLm1heCk7XG4gICAgICAgIGlmICh3cmFwTGltaXQgIT0gdGhpcy4kd3JhcExpbWl0ICYmIHdyYXBMaW1pdCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuJHdyYXBMaW1pdCA9IHdyYXBMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVdyYXBEYXRhKDAsIHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVdyYXBMaW1pdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kY29uc3RyYWluV3JhcExpbWl0ID0gZnVuY3Rpb24gKHdyYXBMaW1pdCwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKG1pbilcbiAgICAgICAgICAgIHdyYXBMaW1pdCA9IE1hdGgubWF4KG1pbiwgd3JhcExpbWl0KTtcbiAgICAgICAgaWYgKG1heClcbiAgICAgICAgICAgIHdyYXBMaW1pdCA9IE1hdGgubWluKG1heCwgd3JhcExpbWl0KTtcbiAgICAgICAgcmV0dXJuIHdyYXBMaW1pdDtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRXcmFwTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR3cmFwTGltaXQ7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0V3JhcExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgIHRoaXMuc2V0V3JhcExpbWl0UmFuZ2UobGltaXQsIGxpbWl0KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRXcmFwTGltaXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogdGhpcy4kd3JhcExpbWl0UmFuZ2UubWluLFxuICAgICAgICAgICAgbWF4OiB0aGlzLiR3cmFwTGltaXRSYW5nZS5tYXhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kdXBkYXRlSW50ZXJuYWxEYXRhT25DaGFuZ2UgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIHVzZVdyYXBNb2RlID0gdGhpcy4kdXNlV3JhcE1vZGU7XG4gICAgICAgIHZhciBhY3Rpb24gPSBkZWx0YS5hY3Rpb247XG4gICAgICAgIHZhciBzdGFydCA9IGRlbHRhLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gZGVsdGEuZW5kO1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSBzdGFydC5yb3c7XG4gICAgICAgIHZhciBsYXN0Um93ID0gZW5kLnJvdztcbiAgICAgICAgdmFyIGxlbiA9IGxhc3RSb3cgLSBmaXJzdFJvdztcbiAgICAgICAgdmFyIHJlbW92ZWRGb2xkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbiAhPSAwKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t1c2VXcmFwTW9kZSA/IFwiJHdyYXBEYXRhXCIgOiBcIiRyb3dMZW5ndGhDYWNoZVwiXS5zcGxpY2UoZmlyc3RSb3csIGxlbik7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lcyA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRGb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKHJlbW92ZWRGb2xkcyk7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShlbmQucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkUmVtb3ZlQ2hhcnMoZW5kLnJvdywgZW5kLmNvbHVtbiwgc3RhcnQuY29sdW1uIC0gZW5kLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KC1sZW4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmVCZWZvcmUgPSB0aGlzLmdldEZvbGRMaW5lKGZpcnN0Um93KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lQmVmb3JlICYmIGZvbGRMaW5lQmVmb3JlICE9PSBmb2xkTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmVCZWZvcmUubWVyZ2UoZm9sZExpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSBmb2xkTGluZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZHggPSBmb2xkTGluZXMuaW5kZXhPZihmb2xkTGluZSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGlkeDsgaWR4IDwgZm9sZExpbmVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZExpbmVzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZS5zdGFydC5yb3cgPj0gZW5kLnJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUuc2hpZnRSb3coLWxlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFJvdyA9IGZpcnN0Um93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChmaXJzdFJvdywgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IHVzZVdyYXBNb2RlID8gdGhpcy4kd3JhcERhdGEgOiB0aGlzLiRyb3dMZW5ndGhDYWNoZTtcbiAgICAgICAgICAgICAgICBhcnIuc3BsaWNlLmFwcGx5KGFyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lcyA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY21wID0gZm9sZExpbmUucmFuZ2UuY29tcGFyZUluc2lkZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSBmb2xkTGluZS5zcGxpdChzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZFJlbW92ZUNoYXJzKGxhc3RSb3csIDAsIGVuZC5jb2x1bW4gLSBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZFJlbW92ZUNoYXJzKGZpcnN0Um93LCAwLCBlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KGxlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gZm9sZExpbmVzLmluZGV4T2YoZm9sZExpbmUpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpZHg7IGlkeCA8IGZvbGRMaW5lcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGRMaW5lc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93ID49IGZpcnN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVuID0gTWF0aC5hYnMoZGVsdGEuc3RhcnQuY29sdW1uIC0gZGVsdGEuZW5kLmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZGVsdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZHMocmVtb3ZlZEZvbGRzKTtcbiAgICAgICAgICAgICAgICBsZW4gPSAtbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShmaXJzdFJvdyk7XG4gICAgICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRSZW1vdmVDaGFycyhmaXJzdFJvdywgc3RhcnQuY29sdW1uLCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VXcmFwTW9kZSAmJiB0aGlzLiR3cmFwRGF0YS5sZW5ndGggIT0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkb2MuZ2V0TGVuZ3RoKCkgYW5kICR3cmFwRGF0YS5sZW5ndGggaGF2ZSB0byBiZSB0aGUgc2FtZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHVzZVdyYXBNb2RlKVxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVSb3dMZW5ndGhDYWNoZShmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgICAgIHJldHVybiByZW1vdmVkRm9sZHM7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHVwZGF0ZVJvd0xlbmd0aENhY2hlID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlW2ZpcnN0Um93XSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlW2xhc3RSb3ddID0gbnVsbDtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kdXBkYXRlV3JhcERhdGEgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5kb2MuZ2V0QWxsTGluZXMoKTtcbiAgICAgICAgdmFyIHRhYlNpemUgPSB0aGlzLmdldFRhYlNpemUoKTtcbiAgICAgICAgdmFyIHdyYXBEYXRhID0gdGhpcy4kd3JhcERhdGE7XG4gICAgICAgIHZhciB3cmFwTGltaXQgPSB0aGlzLiR3cmFwTGltaXQ7XG4gICAgICAgIHZhciB0b2tlbnM7XG4gICAgICAgIHZhciBmb2xkTGluZTtcbiAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xuICAgICAgICBsYXN0Um93ID0gTWF0aC5taW4obGFzdFJvdywgbGluZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHdoaWxlIChyb3cgPD0gbGFzdFJvdykge1xuICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKHJvdywgZm9sZExpbmUpO1xuICAgICAgICAgICAgaWYgKCFmb2xkTGluZSkge1xuICAgICAgICAgICAgICAgIHRva2VucyA9IHRoaXMuJGdldERpc3BsYXlUb2tlbnMobGluZXNbcm93XSk7XG4gICAgICAgICAgICAgICAgd3JhcERhdGFbcm93XSA9IHRoaXMuJGNvbXB1dGVXcmFwU3BsaXRzKHRva2Vucywgd3JhcExpbWl0LCB0YWJTaXplKTtcbiAgICAgICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lLndhbGsoZnVuY3Rpb24gKHBsYWNlaG9sZGVyLCByb3csIGNvbHVtbiwgbGFzdENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnMgPSB0aGlzLiRnZXREaXNwbGF5VG9rZW5zKHBsYWNlaG9sZGVyLCB0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnNbMF0gPSBQTEFDRUhPTERFUl9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgd2Fsa1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnNbaV0gPSBQTEFDRUhPTERFUl9CT0RZO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1Rva2VucyA9IHRoaXMuJGdldERpc3BsYXlUb2tlbnMobGluZXNbcm93XS5zdWJzdHJpbmcobGFzdENvbHVtbiwgY29sdW1uKSwgdG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdCh3YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIGZvbGRMaW5lLmVuZC5yb3csIGxpbmVzW2ZvbGRMaW5lLmVuZC5yb3ddLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIHdyYXBEYXRhW2ZvbGRMaW5lLnN0YXJ0LnJvd10gPSB0aGlzLiRjb21wdXRlV3JhcFNwbGl0cyh0b2tlbnMsIHdyYXBMaW1pdCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcm93ID0gZm9sZExpbmUuZW5kLnJvdyArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kY29tcHV0ZVdyYXBTcGxpdHMgPSBmdW5jdGlvbiAodG9rZW5zLCB3cmFwTGltaXQsIHRhYlNpemUpIHtcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcGxpdHMgPSBbXTtcbiAgICAgICAgdmFyIGRpc3BsYXlMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdFNwbGl0ID0gMCwgbGFzdERvY1NwbGl0ID0gMDtcbiAgICAgICAgdmFyIGlzQ29kZSA9IHRoaXMuJHdyYXBBc0NvZGU7XG4gICAgICAgIHZhciBpbmRlbnRlZFNvZnRXcmFwID0gdGhpcy4kaW5kZW50ZWRTb2Z0V3JhcDtcbiAgICAgICAgdmFyIG1heEluZGVudCA9IHdyYXBMaW1pdCA8PSBNYXRoLm1heCgyICogdGFiU2l6ZSwgOClcbiAgICAgICAgICAgIHx8IGluZGVudGVkU29mdFdyYXAgPT09IGZhbHNlID8gMCA6IE1hdGguZmxvb3Iod3JhcExpbWl0IC8gMik7XG4gICAgICAgIGZ1bmN0aW9uIGdldFdyYXBJbmRlbnQoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50YXRpb24gPSAwO1xuICAgICAgICAgICAgaWYgKG1heEluZGVudCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpZiAoaW5kZW50ZWRTb2Z0V3JhcCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09IFNQQUNFKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT0gVEFCKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gdGFiU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT0gVEFCX1NQQUNFKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvZGUgJiYgaW5kZW50ZWRTb2Z0V3JhcCAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gdGFiU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihpbmRlbnRhdGlvbiwgbWF4SW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRTcGxpdChzY3JlZW5Qb3MpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBzY3JlZW5Qb3MgLSBsYXN0U3BsaXQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGFzdFNwbGl0OyBpIDwgc2NyZWVuUG9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMiB8fCBjaCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBnZXRXcmFwSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgc3BsaXRzLmluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3REb2NTcGxpdCArPSBsZW47XG4gICAgICAgICAgICBzcGxpdHMucHVzaChsYXN0RG9jU3BsaXQpO1xuICAgICAgICAgICAgbGFzdFNwbGl0ID0gc2NyZWVuUG9zO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRlbnQgPSAwO1xuICAgICAgICB3aGlsZSAoZGlzcGxheUxlbmd0aCAtIGxhc3RTcGxpdCA+IHdyYXBMaW1pdCAtIGluZGVudCkge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gbGFzdFNwbGl0ICsgd3JhcExpbWl0IC0gaW5kZW50O1xuICAgICAgICAgICAgaWYgKHRva2Vuc1tzcGxpdCAtIDFdID49IFNQQUNFICYmIHRva2Vuc1tzcGxpdF0gPj0gU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICBhZGRTcGxpdChzcGxpdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSA9PSBQTEFDRUhPTERFUl9TVEFSVCB8fCB0b2tlbnNbc3BsaXRdID09IFBMQUNFSE9MREVSX0JPRFkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHNwbGl0OyBzcGxpdCAhPSBsYXN0U3BsaXQgLSAxOyBzcGxpdC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXRdID09IFBMQUNFSE9MREVSX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQgPiBsYXN0U3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BsaXQgPSBsYXN0U3BsaXQgKyB3cmFwTGltaXQ7XG4gICAgICAgICAgICAgICAgZm9yIChzcGxpdDsgc3BsaXQgPCB0b2tlbnMubGVuZ3RoOyBzcGxpdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXRdICE9IFBMQUNFSE9MREVSX0JPRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGxpdCA9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBCcmVha3MgdGhlIHdoaWxlLWxvb3AuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFNwbGl0KHNwbGl0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5TcGxpdCA9IE1hdGgubWF4KHNwbGl0IC0gKHdyYXBMaW1pdCAtICh3cmFwTGltaXQgPj4gMikpLCBsYXN0U3BsaXQgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPCBQTEFDRUhPTERFUl9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHNwbGl0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0ID4gbWluU3BsaXQgJiYgdG9rZW5zW3NwbGl0XSA8IFBMQUNFSE9MREVSX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPT0gUFVOQ1RVQVRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BsaXQgPiBtaW5TcGxpdCAmJiB0b2tlbnNbc3BsaXRdIDwgU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXQgPiBtaW5TcGxpdCkge1xuICAgICAgICAgICAgICAgIGFkZFNwbGl0KCsrc3BsaXQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BsaXQgPSBsYXN0U3BsaXQgKyB3cmFwTGltaXQ7XG4gICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSA9PSBDSEFSX0VYVClcbiAgICAgICAgICAgICAgICBzcGxpdC0tO1xuICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQgLSBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdHM7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGdldERpc3BsYXlUb2tlbnMgPSBmdW5jdGlvbiAoc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICB2YXIgdGFiU2l6ZTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT0gOSkge1xuICAgICAgICAgICAgICAgIHRhYlNpemUgPSB0aGlzLmdldFNjcmVlblRhYlNpemUoYXJyLmxlbmd0aCArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goVEFCKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMTsgbiA8IHRhYlNpemU7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChUQUJfU1BBQ0UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChTUEFDRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYyA+IDM5ICYmIGMgPCA0OCkgfHwgKGMgPiA1NyAmJiBjIDwgNjQpKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goUFVOQ1RVQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA+PSAweDExMDAgJiYgaXNGdWxsV2lkdGgoYykpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChDSEFSLCBDSEFSX0VYVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChDSEFSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRnZXRTdHJpbmdTY3JlZW5XaWR0aCA9IGZ1bmN0aW9uIChzdHIsIG1heFNjcmVlbkNvbHVtbiwgc2NyZWVuQ29sdW1uKSB7XG4gICAgICAgIGlmIChtYXhTY3JlZW5Db2x1bW4gPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgIGlmIChtYXhTY3JlZW5Db2x1bW4gPT0gbnVsbClcbiAgICAgICAgICAgIG1heFNjcmVlbkNvbHVtbiA9IEluZmluaXR5O1xuICAgICAgICBzY3JlZW5Db2x1bW4gPSBzY3JlZW5Db2x1bW4gfHwgMDtcbiAgICAgICAgdmFyIGMsIGNvbHVtbjtcbiAgICAgICAgZm9yIChjb2x1bW4gPSAwOyBjb2x1bW4gPCBzdHIubGVuZ3RoOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoYyA9PSA5KSB7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IHRoaXMuZ2V0U2NyZWVuVGFiU2l6ZShzY3JlZW5Db2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA+PSAweDExMDAgJiYgaXNGdWxsV2lkdGgoYykpIHtcbiAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjcmVlbkNvbHVtbiA+IG1heFNjcmVlbkNvbHVtbikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc2NyZWVuQ29sdW1uLCBjb2x1bW5dO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFJvd0xlbmd0aCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGggPSAxO1xuICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIGggKz0gdGhpcy5saW5lV2lkZ2V0c1tyb3ddICYmIHRoaXMubGluZVdpZGdldHNbcm93XS5yb3dDb3VudCB8fCAwO1xuICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlIHx8ICF0aGlzLiR3cmFwRGF0YVtyb3ddKVxuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwRGF0YVtyb3ddLmxlbmd0aCArIGg7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0Um93TGluZUNvdW50ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlIHx8ICF0aGlzLiR3cmFwRGF0YVtyb3ddKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwRGF0YVtyb3ddLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRSb3dXcmFwSW5kZW50ID0gZnVuY3Rpb24gKHNjcmVlblJvdykge1xuICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHRoaXMuJHdyYXBEYXRhW3Bvcy5yb3ddO1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0cy5sZW5ndGggJiYgc3BsaXRzWzBdIDwgcG9zLmNvbHVtbiA/IHNwbGl0cy5pbmRlbnQgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRTY3JlZW5MYXN0Um93Q29sdW1uID0gZnVuY3Rpb24gKHNjcmVlblJvdykge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUb1NjcmVlbkNvbHVtbihwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXREb2N1bWVudExhc3RSb3dDb2x1bW4gPSBmdW5jdGlvbiAoZG9jUm93LCBkb2NDb2x1bW4pIHtcbiAgICAgICAgdmFyIHNjcmVlblJvdyA9IHRoaXMuZG9jdW1lbnRUb1NjcmVlblJvdyhkb2NSb3csIGRvY0NvbHVtbik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcmVlbkxhc3RSb3dDb2x1bW4oc2NyZWVuUm93KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXREb2N1bWVudExhc3RSb3dDb2x1bW5Qb3NpdGlvbiA9IGZ1bmN0aW9uIChkb2NSb3csIGRvY0NvbHVtbikge1xuICAgICAgICB2YXIgc2NyZWVuUm93ID0gdGhpcy5kb2N1bWVudFRvU2NyZWVuUm93KGRvY1JvdywgZG9jQ29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgTnVtYmVyLk1BWF9WQUxVRSAvIDEwKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRSb3dTcGxpdERhdGEgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIGlmICghdGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcERhdGFbcm93XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFNjcmVlblRhYlNpemUgPSBmdW5jdGlvbiAoc2NyZWVuQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0YWJTaXplIC0gKHNjcmVlbkNvbHVtbiAlIHRoaXMuJHRhYlNpemUgfCAwKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zY3JlZW5Ub0RvY3VtZW50Um93ID0gZnVuY3Rpb24gKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIHNjcmVlbkNvbHVtbikucm93O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNjcmVlblRvRG9jdW1lbnRDb2x1bW4gPSBmdW5jdGlvbiAoc2NyZWVuUm93LCBzY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKS5jb2x1bW47XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uLCBvZmZzZXRYKSB7XG4gICAgICAgIGlmIChzY3JlZW5Sb3cgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgcm93OiAwLCBjb2x1bW46IDAgfTtcbiAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgIHZhciBkb2NSb3cgPSAwO1xuICAgICAgICB2YXIgZG9jQ29sdW1uID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbjtcbiAgICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICAgIHZhciByb3dMZW5ndGggPSAwO1xuICAgICAgICB2YXIgcm93Q2FjaGUgPSB0aGlzLiRzY3JlZW5Sb3dDYWNoZTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRnZXRSb3dDYWNoZUluZGV4KHJvd0NhY2hlLCBzY3JlZW5Sb3cpO1xuICAgICAgICB2YXIgbCA9IHJvd0NhY2hlLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgJiYgaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gcm93Q2FjaGVbaV07XG4gICAgICAgICAgICB2YXIgZG9jUm93ID0gdGhpcy4kZG9jUm93Q2FjaGVbaV07XG4gICAgICAgICAgICB2YXIgZG9DYWNoZSA9IHNjcmVlblJvdyA+IHJvd0NhY2hlW2wgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkb0NhY2hlID0gIWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heFJvdyA9IHRoaXMuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShkb2NSb3cpO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgd2hpbGUgKHJvdyA8PSBzY3JlZW5Sb3cpIHtcbiAgICAgICAgICAgIHJvd0xlbmd0aCA9IHRoaXMuZ2V0Um93TGVuZ3RoKGRvY1Jvdyk7XG4gICAgICAgICAgICBpZiAocm93ICsgcm93TGVuZ3RoID4gc2NyZWVuUm93IHx8IGRvY1JvdyA+PSBtYXhSb3cpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdyArPSByb3dMZW5ndGg7XG4gICAgICAgICAgICAgICAgZG9jUm93Kys7XG4gICAgICAgICAgICAgICAgaWYgKGRvY1JvdyA+IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBkb2NSb3cgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShkb2NSb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9DYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRvY1Jvd0NhY2hlLnB1c2goZG9jUm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZS5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbGRMaW5lICYmIGZvbGRMaW5lLnN0YXJ0LnJvdyA8PSBkb2NSb3cpIHtcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLmdldEZvbGREaXNwbGF5TGluZShmb2xkTGluZSk7XG4gICAgICAgICAgICBkb2NSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm93ICsgcm93TGVuZ3RoIDw9IHNjcmVlblJvdyB8fCBkb2NSb3cgPiBtYXhSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93OiBtYXhSb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmdldExpbmUobWF4Um93KS5sZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5nZXRMaW5lKGRvY1Jvdyk7XG4gICAgICAgICAgICBmb2xkTGluZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJbmRlbnQgPSAwLCBzcGxpdEluZGV4ID0gTWF0aC5mbG9vcihzY3JlZW5Sb3cgLSByb3cpO1xuICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdHMgPSB0aGlzLiR3cmFwRGF0YVtkb2NSb3ddO1xuICAgICAgICAgICAgaWYgKHNwbGl0cykge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHNwbGl0c1tzcGxpdEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRJbmRleCA+IDAgJiYgc3BsaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwSW5kZW50ID0gc3BsaXRzLmluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgZG9jQ29sdW1uID0gc3BsaXRzW3NwbGl0SW5kZXggLSAxXSB8fCBzcGxpdHNbc3BsaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoZG9jQ29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldFggIT09IHVuZGVmaW5lZCAmJiB0aGlzLiRiaWRpSGFuZGxlci5pc0JpZGlSb3cocm93ICsgc3BsaXRJbmRleCwgZG9jUm93LCBzcGxpdEluZGV4KSlcbiAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJGJpZGlIYW5kbGVyLm9mZnNldFRvQ29sKG9mZnNldFgpO1xuICAgICAgICBkb2NDb2x1bW4gKz0gdGhpcy4kZ2V0U3RyaW5nU2NyZWVuV2lkdGgobGluZSwgc2NyZWVuQ29sdW1uIC0gd3JhcEluZGVudClbMV07XG4gICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSAmJiBkb2NDb2x1bW4gPj0gY29sdW1uKVxuICAgICAgICAgICAgZG9jQ29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgaWYgKGZvbGRMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRMaW5lLmlkeFRvUG9zaXRpb24oZG9jQ29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHsgcm93OiBkb2NSb3csIGNvbHVtbjogZG9jQ29sdW1uIH07XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uID0gZnVuY3Rpb24gKGRvY1JvdywgZG9jQ29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jQ29sdW1uID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQoLyoqQHR5cGV7UG9pbnR9Ki8gKGRvY1Jvdykucm93LCAvKipAdHlwZXtQb2ludH0qLyAoZG9jUm93KS5jb2x1bW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwb3MgPSB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KC8qKkB0eXBle251bWJlcn0qLyAoZG9jUm93KSwgZG9jQ29sdW1uKTtcbiAgICAgICAgZG9jUm93ID0gcG9zLnJvdztcbiAgICAgICAgZG9jQ29sdW1uID0gcG9zLmNvbHVtbjtcbiAgICAgICAgdmFyIHNjcmVlblJvdyA9IDA7XG4gICAgICAgIHZhciBmb2xkU3RhcnRSb3cgPSBudWxsO1xuICAgICAgICB2YXIgZm9sZCA9IG51bGw7XG4gICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChkb2NSb3csIGRvY0NvbHVtbiwgMSk7XG4gICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICBkb2NSb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGRvY0NvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3dFbmQsIHJvdyA9IDA7XG4gICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuJGRvY1Jvd0NhY2hlO1xuICAgICAgICB2YXIgaSA9IHRoaXMuJGdldFJvd0NhY2hlSW5kZXgocm93Q2FjaGUsIGRvY1Jvdyk7XG4gICAgICAgIHZhciBsID0gcm93Q2FjaGUubGVuZ3RoO1xuICAgICAgICBpZiAobCAmJiBpID49IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dDYWNoZVtpXTtcbiAgICAgICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLiRzY3JlZW5Sb3dDYWNoZVtpXTtcbiAgICAgICAgICAgIHZhciBkb0NhY2hlID0gZG9jUm93ID4gcm93Q2FjaGVbbCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRvQ2FjaGUgPSAhbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShyb3cpO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgd2hpbGUgKHJvdyA8IGRvY1Jvdykge1xuICAgICAgICAgICAgaWYgKHJvdyA+PSBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByb3dFbmQgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAocm93RW5kID4gZG9jUm93KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBmb2xkTGluZSA9IHRoaXMuZ2V0TmV4dEZvbGRMaW5lKHJvd0VuZCwgZm9sZExpbmUpO1xuICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3dFbmQgPSByb3cgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyZWVuUm93ICs9IHRoaXMuZ2V0Um93TGVuZ3RoKHJvdyk7XG4gICAgICAgICAgICByb3cgPSByb3dFbmQ7XG4gICAgICAgICAgICBpZiAoZG9DYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRvY1Jvd0NhY2hlLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZS5wdXNoKHNjcmVlblJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRMaW5lID0gXCJcIjtcbiAgICAgICAgaWYgKGZvbGRMaW5lICYmIHJvdyA+PSBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgIHRleHRMaW5lID0gdGhpcy5nZXRGb2xkRGlzcGxheUxpbmUoZm9sZExpbmUsIGRvY1JvdywgZG9jQ29sdW1uKTtcbiAgICAgICAgICAgIGZvbGRTdGFydFJvdyA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRMaW5lID0gdGhpcy5nZXRMaW5lKGRvY1Jvdykuc3Vic3RyaW5nKDAsIGRvY0NvbHVtbik7XG4gICAgICAgICAgICBmb2xkU3RhcnRSb3cgPSBkb2NSb3c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJbmRlbnQgPSAwO1xuICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHZhciB3cmFwUm93ID0gdGhpcy4kd3JhcERhdGFbZm9sZFN0YXJ0Um93XTtcbiAgICAgICAgICAgIGlmICh3cmFwUm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcmVlblJvd09mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRleHRMaW5lLmxlbmd0aCA+PSB3cmFwUm93W3NjcmVlblJvd09mZnNldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuUm93Kys7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblJvd09mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cmluZyh3cmFwUm93W3NjcmVlblJvd09mZnNldCAtIDFdIHx8IDAsIHRleHRMaW5lLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgd3JhcEluZGVudCA9IHNjcmVlblJvd09mZnNldCA+IDAgPyB3cmFwUm93LmluZGVudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHMgJiYgdGhpcy5saW5lV2lkZ2V0c1tyb3ddICYmIHRoaXMubGluZVdpZGdldHNbcm93XS5yb3dzQWJvdmUpXG4gICAgICAgICAgICBzY3JlZW5Sb3cgKz0gdGhpcy5saW5lV2lkZ2V0c1tyb3ddLnJvd3NBYm92ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogc2NyZWVuUm93LFxuICAgICAgICAgICAgY29sdW1uOiB3cmFwSW5kZW50ICsgdGhpcy4kZ2V0U3RyaW5nU2NyZWVuV2lkdGgodGV4dExpbmUpWzBdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZG9jdW1lbnRUb1NjcmVlbkNvbHVtbiA9IGZ1bmN0aW9uIChyb3csIGRvY0NvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocm93LCBkb2NDb2x1bW4pLmNvbHVtbjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5kb2N1bWVudFRvU2NyZWVuUm93ID0gZnVuY3Rpb24gKGRvY1JvdywgZG9jQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihkb2NSb3csIGRvY0NvbHVtbikucm93O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFNjcmVlbkxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcmVlblJvd3MgPSAwO1xuICAgICAgICB2YXIgZm9sZCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHNjcmVlblJvd3MgPSB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9sZCA9IGZvbGREYXRhW2ldO1xuICAgICAgICAgICAgICAgIHNjcmVlblJvd3MgLT0gZm9sZC5lbmQucm93IC0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdFJvdyA9IHRoaXMuJHdyYXBEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciByb3cgPSAwLCBpID0gMDtcbiAgICAgICAgICAgIHZhciBmb2xkID0gdGhpcy4kZm9sZERhdGFbaSsrXTtcbiAgICAgICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkID8gZm9sZC5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIHdoaWxlIChyb3cgPCBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHRoaXMuJHdyYXBEYXRhW3Jvd107XG4gICAgICAgICAgICAgICAgc2NyZWVuUm93cyArPSBzcGxpdHMgPyBzcGxpdHMubGVuZ3RoICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBmb2xkLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICBmb2xkID0gdGhpcy4kZm9sZERhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgc2NyZWVuUm93cyArPSB0aGlzLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGgoKTtcbiAgICAgICAgcmV0dXJuIHNjcmVlblJvd3M7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHNldEZvbnRNZXRyaWNzID0gZnVuY3Rpb24gKGZtKSB7XG4gICAgICAgIGlmICghdGhpcy4kZW5hYmxlVmFyQ2hhcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kZ2V0U3RyaW5nU2NyZWVuV2lkdGggPSBmdW5jdGlvbiAoc3RyLCBtYXhTY3JlZW5Db2x1bW4sIHNjcmVlbkNvbHVtbikge1xuICAgICAgICAgICAgaWYgKG1heFNjcmVlbkNvbHVtbiA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICAgICAgaWYgKCFtYXhTY3JlZW5Db2x1bW4pXG4gICAgICAgICAgICAgICAgbWF4U2NyZWVuQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSBzY3JlZW5Db2x1bW4gfHwgMDtcbiAgICAgICAgICAgIHZhciBjLCBjb2x1bW47XG4gICAgICAgICAgICBmb3IgKGNvbHVtbiA9IDA7IGNvbHVtbiA8IHN0ci5sZW5ndGg7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQXQoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXHRcIikge1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gdGhpcy5nZXRTY3JlZW5UYWJTaXplKHNjcmVlbkNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gZm0uZ2V0Q2hhcmFjdGVyV2lkdGgoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY3JlZW5Db2x1bW4gPiBtYXhTY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtzY3JlZW5Db2x1bW4sIGNvbHVtbl07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0UHJlY2VkaW5nQ2hhcmFjdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmIChwb3MuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zLnJvdyA9PT0gMCA/IFwiXCIgOiB0aGlzLmRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdGhpcy5nZXRMaW5lKHBvcy5yb3cpO1xuICAgICAgICByZXR1cm4gY3VycmVudExpbmVbcG9zLmNvbHVtbiAtIDFdO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0RG9jdW1lbnQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmJnVG9rZW5pemVyLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzdG9wV29ya2VyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLmRvYykge1xuICAgICAgICAgICAgdGhpcy5kb2Mub2ZmKFwiY2hhbmdlXCIsIHRoaXMuJG9uQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5kZXRhY2goKTtcbiAgICB9O1xuICAgIHJldHVybiBFZGl0U2Vzc2lvbjtcbn0oKSk7XG5FZGl0U2Vzc2lvbi4kdWlkID0gMDtcbkVkaXRTZXNzaW9uLnByb3RvdHlwZS4kbW9kZXMgPSBjb25maWcuJG1vZGVzO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFZhbHVlID0gRWRpdFNlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRkZWZhdWx0VW5kb01hbmFnZXIgPSB7XG4gICAgdW5kbzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlZG86IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBoYXNVbmRvOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgaGFzUmVkbzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgYWRkOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgYWRkU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgc3RhcnROZXdHcm91cDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGFkZFNlc3Npb246IGZ1bmN0aW9uICgpIHsgfVxufTtcbkVkaXRTZXNzaW9uLnByb3RvdHlwZS4kb3ZlcndyaXRlID0gZmFsc2U7XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUuJG1vZGUgPSBudWxsO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRtb2RlSWQgPSBudWxsO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzY3JvbGxUb3AgPSAwO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzY3JvbGxMZWZ0ID0gMDtcbkVkaXRTZXNzaW9uLnByb3RvdHlwZS4kd3JhcExpbWl0ID0gODA7XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHVzZVdyYXBNb2RlID0gZmFsc2U7XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHdyYXBMaW1pdFJhbmdlID0ge1xuICAgIG1pbjogbnVsbCxcbiAgICBtYXg6IG51bGxcbn07XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUubGluZVdpZGdldHMgPSBudWxsO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLmlzRnVsbFdpZHRoID0gaXNGdWxsV2lkdGg7XG5vb3AuaW1wbGVtZW50KEVkaXRTZXNzaW9uLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBDSEFSID0gMSwgQ0hBUl9FWFQgPSAyLCBQTEFDRUhPTERFUl9TVEFSVCA9IDMsIFBMQUNFSE9MREVSX0JPRFkgPSA0LCBQVU5DVFVBVElPTiA9IDksIFNQQUNFID0gMTAsIFRBQiA9IDExLCBUQUJfU1BBQ0UgPSAxMjtcbmZ1bmN0aW9uIGlzRnVsbFdpZHRoKGMpIHtcbiAgICBpZiAoYyA8IDB4MTEwMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjID49IDB4MTEwMCAmJiBjIDw9IDB4MTE1RiB8fFxuICAgICAgICBjID49IDB4MTFBMyAmJiBjIDw9IDB4MTFBNyB8fFxuICAgICAgICBjID49IDB4MTFGQSAmJiBjIDw9IDB4MTFGRiB8fFxuICAgICAgICBjID49IDB4MjMyOSAmJiBjIDw9IDB4MjMyQSB8fFxuICAgICAgICBjID49IDB4MkU4MCAmJiBjIDw9IDB4MkU5OSB8fFxuICAgICAgICBjID49IDB4MkU5QiAmJiBjIDw9IDB4MkVGMyB8fFxuICAgICAgICBjID49IDB4MkYwMCAmJiBjIDw9IDB4MkZENSB8fFxuICAgICAgICBjID49IDB4MkZGMCAmJiBjIDw9IDB4MkZGQiB8fFxuICAgICAgICBjID49IDB4MzAwMCAmJiBjIDw9IDB4MzAzRSB8fFxuICAgICAgICBjID49IDB4MzA0MSAmJiBjIDw9IDB4MzA5NiB8fFxuICAgICAgICBjID49IDB4MzA5OSAmJiBjIDw9IDB4MzBGRiB8fFxuICAgICAgICBjID49IDB4MzEwNSAmJiBjIDw9IDB4MzEyRCB8fFxuICAgICAgICBjID49IDB4MzEzMSAmJiBjIDw9IDB4MzE4RSB8fFxuICAgICAgICBjID49IDB4MzE5MCAmJiBjIDw9IDB4MzFCQSB8fFxuICAgICAgICBjID49IDB4MzFDMCAmJiBjIDw9IDB4MzFFMyB8fFxuICAgICAgICBjID49IDB4MzFGMCAmJiBjIDw9IDB4MzIxRSB8fFxuICAgICAgICBjID49IDB4MzIyMCAmJiBjIDw9IDB4MzI0NyB8fFxuICAgICAgICBjID49IDB4MzI1MCAmJiBjIDw9IDB4MzJGRSB8fFxuICAgICAgICBjID49IDB4MzMwMCAmJiBjIDw9IDB4NERCRiB8fFxuICAgICAgICBjID49IDB4NEUwMCAmJiBjIDw9IDB4QTQ4QyB8fFxuICAgICAgICBjID49IDB4QTQ5MCAmJiBjIDw9IDB4QTRDNiB8fFxuICAgICAgICBjID49IDB4QTk2MCAmJiBjIDw9IDB4QTk3QyB8fFxuICAgICAgICBjID49IDB4QUMwMCAmJiBjIDw9IDB4RDdBMyB8fFxuICAgICAgICBjID49IDB4RDdCMCAmJiBjIDw9IDB4RDdDNiB8fFxuICAgICAgICBjID49IDB4RDdDQiAmJiBjIDw9IDB4RDdGQiB8fFxuICAgICAgICBjID49IDB4RjkwMCAmJiBjIDw9IDB4RkFGRiB8fFxuICAgICAgICBjID49IDB4RkUxMCAmJiBjIDw9IDB4RkUxOSB8fFxuICAgICAgICBjID49IDB4RkUzMCAmJiBjIDw9IDB4RkU1MiB8fFxuICAgICAgICBjID49IDB4RkU1NCAmJiBjIDw9IDB4RkU2NiB8fFxuICAgICAgICBjID49IDB4RkU2OCAmJiBjIDw9IDB4RkU2QiB8fFxuICAgICAgICBjID49IDB4RkYwMSAmJiBjIDw9IDB4RkY2MCB8fFxuICAgICAgICBjID49IDB4RkZFMCAmJiBjIDw9IDB4RkZFNjtcbn1cbnJlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvbi9mb2xkaW5nXCIpLkZvbGRpbmcuY2FsbChFZGl0U2Vzc2lvbi5wcm90b3R5cGUpO1xucmVxdWlyZShcIi4vZWRpdF9zZXNzaW9uL2JyYWNrZXRfbWF0Y2hcIikuQnJhY2tldE1hdGNoLmNhbGwoRWRpdFNlc3Npb24ucHJvdG90eXBlKTtcbmNvbmZpZy5kZWZpbmVPcHRpb25zKEVkaXRTZXNzaW9uLnByb3RvdHlwZSwgXCJzZXNzaW9uXCIsIHtcbiAgICB3cmFwOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09IFwib2ZmXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwiZnJlZVwiKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwicHJpbnRNYXJnaW5cIilcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHdyYXAgPT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy4kd3JhcCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0V3JhcExpbWl0UmFuZ2UoY29sLCBjb2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VXNlV3JhcE1vZGUoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR3cmFwID09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmludE1hcmdpblwiO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRXcmFwTGltaXRSYW5nZSgpLm1pbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnJlZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwib2ZmXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LFxuICAgIHdyYXBNZXRob2Q6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwgPT0gXCJhdXRvXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMuJG1vZGUudHlwZSAhPSBcInRleHRcIlxuICAgICAgICAgICAgICAgIDogdmFsICE9IFwidGV4dFwiO1xuICAgICAgICAgICAgaWYgKHZhbCAhPSB0aGlzLiR3cmFwQXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kd3JhcEFzQ29kZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdXNlV3JhcE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRVc2VXcmFwTW9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogXCJhdXRvXCJcbiAgICB9LFxuICAgIGluZGVudGVkU29mdFdyYXA6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1c2VXcmFwTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgZmlyc3RMaW5lTnVtYmVyOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkgeyB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIpOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IDFcbiAgICB9LFxuICAgIHVzZVdvcmtlcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh1c2VXb3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJHVzZVdvcmtlciA9IHVzZVdvcmtlcjtcbiAgICAgICAgICAgIHRoaXMuJHN0b3BXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmICh1c2VXb3JrZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB1c2VTb2Z0VGFiczogeyBpbml0aWFsVmFsdWU6IHRydWUgfSxcbiAgICB0YWJTaXplOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHRhYlNpemUpIHtcbiAgICAgICAgICAgIHRhYlNpemUgPSBwYXJzZUludCh0YWJTaXplKTtcbiAgICAgICAgICAgIGlmICh0YWJTaXplID4gMCAmJiB0aGlzLiR0YWJTaXplICE9PSB0YWJTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy4kdGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlVGFiU2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiA0LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfSxcbiAgICBuYXZpZ2F0ZVdpdGhpblNvZnRUYWJzOiB7IGluaXRpYWxWYWx1ZTogZmFsc2UgfSxcbiAgICBmb2xkU3R5bGU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuc2V0Rm9sZFN0eWxlKHZhbCk7IH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LFxuICAgIG92ZXJ3cml0ZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fc2lnbmFsKFwiY2hhbmdlT3ZlcndyaXRlXCIpOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICBuZXdMaW5lTW9kZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5kb2Muc2V0TmV3TGluZU1vZGUodmFsKTsgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRvYy5nZXROZXdMaW5lTW9kZSgpOyB9LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfSxcbiAgICBtb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLnNldE1vZGUodmFsKTsgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRtb2RlSWQ7IH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9XG59KTtcbmV4cG9ydHMuRWRpdFNlc3Npb24gPSBFZGl0U2Vzc2lvbjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uvc2VhcmNoXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvb29wXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBTZWFyY2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VhcmNoKCkge1xuICAgICAgICB0aGlzLiRvcHRpb25zID0ge307XG4gICAgfVxuICAgIFNlYXJjaC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb29wLm1peGluKHRoaXMuJG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhbmcuY29weU9iamVjdCh0aGlzLiRvcHRpb25zKTtcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLiRtYXRjaEl0ZXJhdG9yKHNlc3Npb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWl0ZXJhdG9yKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZmlyc3RSYW5nZSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yLmZvckVhY2goZnVuY3Rpb24gKHNyLCBzYywgZXIsIGVjKSB7XG4gICAgICAgICAgICBmaXJzdFJhbmdlID0gbmV3IFJhbmdlKHNyLCBzYywgZXIsIGVjKTtcbiAgICAgICAgICAgIGlmIChzYyA9PSBlYyAmJiBvcHRpb25zLnN0YXJ0ICYmIC8qKkB0eXBle1JhbmdlfSovIChvcHRpb25zLnN0YXJ0KS5zdGFydFxuICAgICAgICAgICAgICAgICYmIG9wdGlvbnMuc2tpcEN1cnJlbnQgIT0gZmFsc2UgJiYgZmlyc3RSYW5nZS5pc0VxdWFsKC8qKkB0eXBle1JhbmdlfSovIChvcHRpb25zLnN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaXJzdFJhbmdlO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS5maW5kQWxsID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMubmVlZGxlKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB0aGlzLiRhc3NlbWJsZVJlZ0V4cChvcHRpb25zKTtcbiAgICAgICAgdmFyIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgdmFyIGxpbmVzID0gcmFuZ2VcbiAgICAgICAgICAgID8gc2Vzc2lvbi5nZXRMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpXG4gICAgICAgICAgICA6IHNlc3Npb24uZG9jLmdldEFsbExpbmVzKCk7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgdmFyIHJlID0gb3B0aW9ucy5yZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlzTXVsdGlMaW5lKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gcmUubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1heFJvdyA9IGxpbmVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgICAgIHZhciBwcmV2UmFuZ2U7XG4gICAgICAgICAgICBvdXRlcjogZm9yICh2YXIgcm93ID0gcmUub2Zmc2V0IHx8IDA7IHJvdyA8PSBtYXhSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzW3JvdyArIGpdLnNlYXJjaChyZVtqXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gbGluZXNbcm93XTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW3JvdyArIGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRMaW5lLmxlbmd0aCAtIHN0YXJ0TGluZS5tYXRjaChyZVswXSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IGxpbmUubWF0Y2gocmVbbGVuIC0gMV0pWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJldlJhbmdlICYmIHByZXZSYW5nZS5lbmQucm93ID09PSByb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJldlJhbmdlLmVuZC5jb2x1bW4gPiBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChwcmV2UmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBzdGFydEluZGV4LCByb3cgKyBsZW4gLSAxLCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAyKVxuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3cgKyBsZW4gLSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGFuZy5nZXRNYXRjaE9mZnNldHMobGluZXNbaV0sIHJlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGksIG1hdGNoLm9mZnNldCwgaSwgbWF0Y2gub2Zmc2V0ICsgbWF0Y2gubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdmFyIGVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGogPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaiAmJiByYW5nZXNbaV0uc3RhcnQuY29sdW1uIDwgc3RhcnRDb2x1bW4gJiYgcmFuZ2VzW2ldLnN0YXJ0LnJvdyA9PSAwKVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIHZhciBlbmRSb3cgPSByYW5nZS5lbmQucm93IC0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBqICYmIHJhbmdlc1tqXS5lbmQuY29sdW1uID4gZW5kQ29sdW1uICYmIHJhbmdlc1tqXS5lbmQucm93ID09IGVuZFJvdylcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICByYW5nZXMgPSByYW5nZXMuc2xpY2UoaSwgaiArIDEpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uc3RhcnQucm93ICs9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uZW5kLnJvdyArPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChpbnB1dCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICB2YXIgcmUgPSB0aGlzLiRhc3NlbWJsZVJlZ0V4cChvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlzTXVsdGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgICAgICBpZiAoIXJlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKGlucHV0KTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXS5sZW5ndGggIT0gaW5wdXQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWdFeHApIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvXFwkL2csIFwiJCQkJFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlbWVudCA9IGlucHV0LnJlcGxhY2UocmUsIHJlcGxhY2VtZW50KTtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlc2VydmVDYXNlKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgaW5wdXQubGVuZ3RoKTsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IGlucHV0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaC50b0xvd2VyQ2FzZSgpICE9IGNoKVxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFtpXSA9IHJlcGxhY2VtZW50W2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFtpXSA9IHJlcGxhY2VtZW50W2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS4kYXNzZW1ibGVSZWdFeHAgPSBmdW5jdGlvbiAob3B0aW9ucywgJGRpc2FibGVGYWtlTXVsdGlsaW5lKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm5lZWRsZSBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gb3B0aW9ucy5uZWVkbGU7XG4gICAgICAgIHZhciBuZWVkbGUgPSBvcHRpb25zLm5lZWRsZTtcbiAgICAgICAgaWYgKCFvcHRpb25zLm5lZWRsZSlcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gZmFsc2U7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWdFeHApXG4gICAgICAgICAgICBuZWVkbGUgPSBsYW5nLmVzY2FwZVJlZ0V4cChuZWVkbGUpO1xuICAgICAgICB2YXIgbW9kaWZpZXIgPSBvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyBcImdtXCIgOiBcImdtaVwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFJlZ0V4cChuZWVkbGUsIFwidVwiKTtcbiAgICAgICAgICAgIG9wdGlvbnMuJHN1cHBvcnRzVW5pY29kZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgbW9kaWZpZXIgKz0gXCJ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuJHN1cHBvcnRzVW5pY29kZUZsYWcgPSBmYWxzZTsgLy9sZWZ0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgdmVyc2lvbnMgZm9yIGNhc2VzIGxpa2UgL2FiXFx7Mn0vZ3VcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aG9sZVdvcmQpXG4gICAgICAgICAgICBuZWVkbGUgPSBhZGRXb3JkQm91bmRhcnkobmVlZGxlLCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy4kaXNNdWx0aUxpbmUgPSAhJGRpc2FibGVGYWtlTXVsdGlsaW5lICYmIC9bXFxuXFxyXS8udGVzdChuZWVkbGUpO1xuICAgICAgICBpZiAob3B0aW9ucy4kaXNNdWx0aUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZSA9IHRoaXMuJGFzc2VtYmxlTXVsdGlsaW5lUmVnRXhwKG5lZWRsZSwgbW9kaWZpZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChuZWVkbGUsIG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5yZSA9IHJlO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS4kYXNzZW1ibGVNdWx0aWxpbmVSZWdFeHAgPSBmdW5jdGlvbiAobmVlZGxlLCBtb2RpZmllcikge1xuICAgICAgICB2YXIgcGFydHMgPSBuZWVkbGUucmVwbGFjZSgvXFxyXFxufFxccnxcXG4vZywgXCIkXFxuXlwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIHJlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlLnB1c2gobmV3IFJlZ0V4cChwYXJ0c1tpXSwgbW9kaWZpZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmU7XG4gICAgfTtcbiAgICBTZWFyY2gucHJvdG90eXBlLiRtYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlID0gdGhpcy4kYXNzZW1ibGVSZWdFeHAob3B0aW9ucyk7XG4gICAgICAgIGlmICghcmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBiYWNrd2FyZHMgPSBvcHRpb25zLmJhY2t3YXJkcyA9PSB0cnVlO1xuICAgICAgICB2YXIgc2tpcEN1cnJlbnQgPSBvcHRpb25zLnNraXBDdXJyZW50ICE9IGZhbHNlO1xuICAgICAgICB2YXIgc3VwcG9ydHNVbmljb2RlRmxhZyA9IHJlLnVuaWNvZGU7XG4gICAgICAgIHZhciByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XG4gICAgICAgIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlID8gcmFuZ2VbYmFja3dhcmRzID8gXCJlbmRcIiA6IFwic3RhcnRcIl0gOiBzZXNzaW9uLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICBpZiAoc3RhcnQuc3RhcnQpXG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0W3NraXBDdXJyZW50ICE9IGJhY2t3YXJkcyA/IFwiZW5kXCIgOiBcInN0YXJ0XCJdO1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSByYW5nZSA/IHJhbmdlLnN0YXJ0LnJvdyA6IDA7XG4gICAgICAgIHZhciBsYXN0Um93ID0gcmFuZ2UgPyByYW5nZS5lbmQucm93IDogc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDE7XG4gICAgICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICBpZiAoZm9yRWFjaEluTGluZShyb3csIHN0YXJ0LmNvbHVtbiwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZm9yIChyb3ctLTsgcm93ID49IGZpcnN0Um93OyByb3ctLSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvckVhY2hJbkxpbmUocm93LCBOdW1iZXIuTUFYX1ZBTFVFLCBjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud3JhcCA9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZvciAocm93ID0gbGFzdFJvdywgZmlyc3RSb3cgPSBzdGFydC5yb3c7IHJvdyA+PSBmaXJzdFJvdzsgcm93LS0pXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JFYWNoSW5MaW5lKHJvdywgTnVtYmVyLk1BWF9WQUxVRSwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICBpZiAoZm9yRWFjaEluTGluZShyb3csIHN0YXJ0LmNvbHVtbiwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZm9yIChyb3cgPSByb3cgKyAxOyByb3cgPD0gbGFzdFJvdzsgcm93KyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JFYWNoSW5MaW5lKHJvdywgMCwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndyYXAgPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IGZpcnN0Um93LCBsYXN0Um93ID0gc3RhcnQucm93OyByb3cgPD0gbGFzdFJvdzsgcm93KyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JFYWNoSW5MaW5lKHJvdywgMCwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy4kaXNNdWx0aUxpbmUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSByZS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZm9yRWFjaEluTGluZSA9IGZ1bmN0aW9uIChyb3csIG9mZnNldCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBiYWNrd2FyZHMgPyByb3cgLSBsZW4gKyAxIDogcm93O1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFJvdyA8IDAgfHwgc3RhcnRSb3cgKyBsZW4gPiBzZXNzaW9uLmdldExlbmd0aCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoc3RhcnRSb3cpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gbGluZS5zZWFyY2gocmVbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghYmFja3dhcmRzICYmIHN0YXJ0SW5kZXggPCBvZmZzZXQgfHwgc3RhcnRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoc3RhcnRSb3cgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc2VhcmNoKHJlW2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gbGluZS5tYXRjaChyZVtsZW4gLSAxXSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrd2FyZHMgJiYgZW5kSW5kZXggPiBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soc3RhcnRSb3csIHN0YXJ0SW5kZXgsIHN0YXJ0Um93ICsgbGVuIC0gMSwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICB2YXIgZm9yRWFjaEluTGluZSA9IGZ1bmN0aW9uIChyb3csIGVuZEluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbSwgbGFzdCA9IDA7XG4gICAgICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSByZS5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPj0gbGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICByZS5sYXN0SW5kZXggPSBsYXN0ICs9IGxhbmcuc2tpcEVtcHR5TWF0Y2gobGluZSwgbGFzdCwgc3VwcG9ydHNVbmljb2RlRmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uaW5kZXggKyBsZW5ndGggPiBlbmRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobS5pbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG1hdGNoZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHJvdywgY29sdW1uLCByb3csIGNvbHVtbiArIGxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvckVhY2hJbkxpbmUgPSBmdW5jdGlvbiAocm93LCBzdGFydEluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3Q7XG4gICAgICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSByZS5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socm93LCBsYXN0LCByb3csIGxhc3QgKyBsZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZS5sYXN0SW5kZXggPSBsYXN0ICs9IGxhbmcuc2tpcEVtcHR5TWF0Y2gobGluZSwgbGFzdCwgc3VwcG9ydHNVbmljb2RlRmxhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA+PSBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvckVhY2g6IGZvckVhY2ggfTtcbiAgICB9O1xuICAgIHJldHVybiBTZWFyY2g7XG59KCkpO1xuZnVuY3Rpb24gYWRkV29yZEJvdW5kYXJ5KG5lZWRsZSwgb3B0aW9ucykge1xuICAgIHZhciBzdXBwb3J0c0xvb2tiZWhpbmQgPSBsYW5nLnN1cHBvcnRzTG9va2JlaGluZCgpO1xuICAgIGZ1bmN0aW9uIHdvcmRCb3VuZGFyeShjLCBmaXJzdENoYXIpIHtcbiAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gdm9pZCAwKSB7IGZpcnN0Q2hhciA9IHRydWU7IH1cbiAgICAgICAgdmFyIHdvcmRSZWdFeHAgPSBzdXBwb3J0c0xvb2tiZWhpbmQgJiYgb3B0aW9ucy4kc3VwcG9ydHNVbmljb2RlRmxhZyA/IG5ldyBSZWdFeHAoXCJbXFxcXHB7TH1cXFxccHtOfV9dXCIsIFwidVwiKSA6IG5ldyBSZWdFeHAoXCJcXFxcd1wiKTtcbiAgICAgICAgaWYgKHdvcmRSZWdFeHAudGVzdChjKSB8fCBvcHRpb25zLnJlZ0V4cCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzTG9va2JlaGluZCAmJiBvcHRpb25zLiRzdXBwb3J0c1VuaWNvZGVGbGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hhcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKD88PV58W15cXFxccHtMfVxcXFxwe059X10pXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiKD89W15cXFxccHtMfVxcXFxwe059X118JClcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBuZWVkbGVBcnJheSA9IEFycmF5LmZyb20obmVlZGxlKTtcbiAgICB2YXIgZmlyc3RDaGFyID0gbmVlZGxlQXJyYXlbMF07XG4gICAgdmFyIGxhc3RDaGFyID0gbmVlZGxlQXJyYXlbbmVlZGxlQXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHdvcmRCb3VuZGFyeShmaXJzdENoYXIpICsgbmVlZGxlICsgd29yZEJvdW5kYXJ5KGxhc3RDaGFyLCBmYWxzZSk7XG59XG5leHBvcnRzLlNlYXJjaCA9IFNlYXJjaDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2tleXNcIixcImFjZS9saWIvdXNlcmFnZW50XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTsgdmFyIGtleVV0aWwgPSByZXF1aXJlKFwiLi4vbGliL2tleXNcIik7XG52YXIgdXNlcmFnZW50ID0gcmVxdWlyZShcIi4uL2xpYi91c2VyYWdlbnRcIik7XG52YXIgS0VZX01PRFMgPSBrZXlVdGlsLktFWV9NT0RTO1xudmFyIE11bHRpSGFzaEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlIYXNoSGFuZGxlcihjb25maWcsIHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuJGluaXQoY29uZmlnLCBwbGF0Zm9ybSwgZmFsc2UpO1xuICAgIH1cbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS4kaW5pdCA9IGZ1bmN0aW9uIChjb25maWcsIHBsYXRmb3JtLCAkc2luZ2xlQ29tbWFuZCkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm0gfHwgKHVzZXJhZ2VudC5pc01hYyA/IFwibWFjXCIgOiBcIndpblwiKTtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nID0ge307XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZHMoY29uZmlnKTtcbiAgICAgICAgdGhpcy4kc2luZ2xlQ29tbWFuZCA9ICRzaW5nbGVDb21tYW5kO1xuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRzW2NvbW1hbmQubmFtZV0pXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIHRoaXMuY29tbWFuZHNbY29tbWFuZC5uYW1lXSA9IGNvbW1hbmQ7XG4gICAgICAgIGlmIChjb21tYW5kLmJpbmRLZXkpXG4gICAgICAgICAgICB0aGlzLl9idWlsZEtleUhhc2goY29tbWFuZCk7XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVDb21tYW5kID0gZnVuY3Rpb24gKGNvbW1hbmQsIGtlZXBDb21tYW5kKSB7XG4gICAgICAgIHZhciBuYW1lID0gY29tbWFuZCAmJiAodHlwZW9mIGNvbW1hbmQgPT09ICdzdHJpbmcnID8gY29tbWFuZCA6IGNvbW1hbmQubmFtZSk7XG4gICAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW25hbWVdO1xuICAgICAgICBpZiAoIWtlZXBDb21tYW5kKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29tbWFuZHNbbmFtZV07XG4gICAgICAgIHZhciBja2IgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nO1xuICAgICAgICBmb3IgKHZhciBrZXlJZCBpbiBja2IpIHtcbiAgICAgICAgICAgIHZhciBjbWRHcm91cCA9IGNrYltrZXlJZF07XG4gICAgICAgICAgICBpZiAoY21kR3JvdXAgPT0gY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBja2Jba2V5SWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjbWRHcm91cCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGNtZEdyb3VwLmluZGV4T2YoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY21kR3JvdXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kR3JvdXAubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBja2Jba2V5SWRdID0gY21kR3JvdXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5iaW5kS2V5ID0gZnVuY3Rpb24gKGtleSwgY29tbWFuZCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJvYmplY3RcIiAmJiBrZXkpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBrZXkucG9zaXRpb247XG4gICAgICAgICAgICBrZXkgPSBrZXlbdGhpcy5wbGF0Zm9ybV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDb21tYW5kKHsgZXhlYzogY29tbWFuZCwgYmluZEtleToga2V5LCBuYW1lOiBjb21tYW5kLm5hbWUgfHwgLyoqQHR5cGV7c3RyaW5nfSovIChrZXkpIH0pOyAoa2V5KS5zcGxpdChcInxcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5UGFydCkge1xuICAgICAgICAgICAgdmFyIGNoYWluID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChrZXlQYXJ0LmluZGV4T2YoXCIgXCIpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5UGFydC5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgIGtleVBhcnQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5wYXJzZUtleXMoa2V5UGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IEtFWV9NT0RTW2JpbmRpbmcuaGFzaElkXSArIGJpbmRpbmcua2V5O1xuICAgICAgICAgICAgICAgICAgICBjaGFpbiArPSAoY2hhaW4gPyBcIiBcIiA6IFwiXCIpICsgaWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENvbW1hbmRUb0JpbmRpbmcoY2hhaW4sIFwiY2hhaW5LZXlzXCIpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNoYWluICs9IFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLnBhcnNlS2V5cyhrZXlQYXJ0KTtcbiAgICAgICAgICAgIHZhciBpZCA9IEtFWV9NT0RTW2JpbmRpbmcuaGFzaElkXSArIGJpbmRpbmcua2V5O1xuICAgICAgICAgICAgdGhpcy5fYWRkQ29tbWFuZFRvQmluZGluZyhjaGFpbiArIGlkLCBjb21tYW5kLCBwb3NpdGlvbik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuX2FkZENvbW1hbmRUb0JpbmRpbmcgPSBmdW5jdGlvbiAoa2V5SWQsIGNvbW1hbmQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBja2IgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nLCBpO1xuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBja2Jba2V5SWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFja2Jba2V5SWRdIHx8IHRoaXMuJHNpbmdsZUNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNrYltrZXlJZF0gPSBjb21tYW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNrYltrZXlJZF0pKSB7XG4gICAgICAgICAgICAgICAgY2tiW2tleUlkXSA9IFtja2Jba2V5SWRdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChpID0gY2tiW2tleUlkXS5pbmRleE9mKGNvbW1hbmQpKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGNrYltrZXlJZF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihjb21tYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21tYW5kcyA9IGNrYltrZXlJZF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSBnZXRQb3NpdGlvbihvdGhlcik7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyUG9zID4gcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tbWFuZHMuc3BsaWNlKGksIDAsIGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5hZGRDb21tYW5kcyA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICBjb21tYW5kcyAmJiBPYmplY3Qua2V5cyhjb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZEtleShjb21tYW5kLCBuYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSB7IGV4ZWM6IGNvbW1hbmQgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWNvbW1hbmQubmFtZSlcbiAgICAgICAgICAgICAgICBjb21tYW5kLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUNvbW1hbmRzID0gZnVuY3Rpb24gKGNvbW1hbmRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbW1hbmQoY29tbWFuZHNbbmFtZV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLmJpbmRLZXlzID0gZnVuY3Rpb24gKGtleUxpc3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5TGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRLZXkoa2V5LCBrZXlMaXN0W2tleV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLl9idWlsZEtleUhhc2ggPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICB0aGlzLmJpbmRLZXkoY29tbWFuZC5iaW5kS2V5LCBjb21tYW5kKTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLnBhcnNlS2V5cyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGtleXMudG9Mb3dlckNhc2UoKS5zcGxpdCgvW1xcLVxcK10oW1xcLVxcK10pPy8pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAgICAgIHZhciBrZXkgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBrZXlVdGlsW2tleV07XG4gICAgICAgIGlmIChrZXlVdGlsLkZVTkNUSU9OX0tFWVNba2V5Q29kZV0pXG4gICAgICAgICAgICBrZXkgPSBrZXlVdGlsLkZVTkNUSU9OX0tFWVNba2V5Q29kZV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZWxzZSBpZiAoIXBhcnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LCBoYXNoSWQ6IC0xIH07XG4gICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSAxICYmIHBhcnRzWzBdID09IFwic2hpZnRcIilcbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnRvVXBwZXJDYXNlKCksIGhhc2hJZDogLTEgfTtcbiAgICAgICAgdmFyIGhhc2hJZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGtleVV0aWwuS0VZX01PRFNbcGFydHNbaV1dO1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImludmFsaWQgbW9kaWZpZXIgXCIgKyBwYXJ0c1tpXSArIFwiIGluIFwiICsga2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzaElkIHw9IG1vZGlmaWVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGtleToga2V5LCBoYXNoSWQ6IGhhc2hJZCB9O1xuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuZmluZEtleUNvbW1hbmQgPSBmdW5jdGlvbiAoaGFzaElkLCBrZXlTdHJpbmcpIHtcbiAgICAgICAgdmFyIGtleSA9IEtFWV9NT0RTW2hhc2hJZF0gKyBrZXlTdHJpbmc7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nW2tleV07XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVLZXlib2FyZCA9IGZ1bmN0aW9uIChkYXRhLCBoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSkge1xuICAgICAgICBpZiAoa2V5Q29kZSA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBrZXkgPSBLRVlfTU9EU1toYXNoSWRdICsga2V5U3RyaW5nO1xuICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZEtleUJpbmRpbmdba2V5XTtcbiAgICAgICAgaWYgKGRhdGEuJGtleUNoYWluKSB7XG4gICAgICAgICAgICBkYXRhLiRrZXlDaGFpbiArPSBcIiBcIiArIGtleTtcbiAgICAgICAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nW2RhdGEuJGtleUNoYWluXSB8fCBjb21tYW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoY29tbWFuZCA9PSBcImNoYWluS2V5c1wiIHx8IGNvbW1hbmRbY29tbWFuZC5sZW5ndGggLSAxXSA9PSBcImNoYWluS2V5c1wiKSB7XG4gICAgICAgICAgICAgICAgZGF0YS4ka2V5Q2hhaW4gPSBkYXRhLiRrZXlDaGFpbiB8fCBrZXk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29tbWFuZDogXCJudWxsXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS4ka2V5Q2hhaW4pIHtcbiAgICAgICAgICAgIGlmICgoIWhhc2hJZCB8fCBoYXNoSWQgPT0gNCkgJiYga2V5U3RyaW5nLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIGRhdGEuJGtleUNoYWluID0gZGF0YS4ka2V5Q2hhaW4uc2xpY2UoMCwgLWtleS5sZW5ndGggLSAxKTsgLy8gd2FpdCBmb3IgaW5wdXRcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc2hJZCA9PSAtMSB8fCBrZXlDb2RlID4gMClcbiAgICAgICAgICAgICAgICBkYXRhLiRrZXlDaGFpbiA9IFwiXCI7IC8vIHJlc2V0IGtleUNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29tbWFuZDogY29tbWFuZCB9O1xuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuZ2V0U3RhdHVzVGV4dCA9IGZ1bmN0aW9uIChlZGl0b3IsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuJGtleUNoYWluIHx8IFwiXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGlIYXNoSGFuZGxlcjtcbn0oKSk7XG5mdW5jdGlvbiBnZXRQb3NpdGlvbihjb21tYW5kKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb21tYW5kID09IFwib2JqZWN0XCIgJiYgY29tbWFuZC5iaW5kS2V5XG4gICAgICAgICYmIGNvbW1hbmQuYmluZEtleS5wb3NpdGlvblxuICAgICAgICB8fCAoY29tbWFuZC5pc0RlZmF1bHQgPyAtMTAwIDogMCk7XG59XG52YXIgSGFzaEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhhc2hIYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhhc2hIYW5kbGVyKGNvbmZpZywgcGxhdGZvcm0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnLCBwbGF0Zm9ybSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuJHNpbmdsZUNvbW1hbmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIYXNoSGFuZGxlcjtcbn0oTXVsdGlIYXNoSGFuZGxlcikpO1xuSGFzaEhhbmRsZXIuY2FsbCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBjb25maWcsIHBsYXRmb3JtKSB7XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuJGluaXQuY2FsbCh0aGlzQXJnLCBjb25maWcsIHBsYXRmb3JtLCB0cnVlKTtcbn07XG5NdWx0aUhhc2hIYW5kbGVyLmNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgY29uZmlnLCBwbGF0Zm9ybSkge1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLiRpbml0LmNhbGwodGhpc0FyZywgY29uZmlnLCBwbGF0Zm9ybSwgZmFsc2UpO1xufTtcbmV4cG9ydHMuSGFzaEhhbmRsZXIgPSBIYXNoSGFuZGxlcjtcbmV4cG9ydHMuTXVsdGlIYXNoSGFuZGxlciA9IE11bHRpSGFzaEhhbmRsZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2NvbW1hbmRzL2NvbW1hbmRfbWFuYWdlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgb29wID0gcmVxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgTXVsdGlIYXNoSGFuZGxlciA9IHJlcXVpcmUoXCIuLi9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIikuTXVsdGlIYXNoSGFuZGxlcjtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIENvbW1hbmRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21tYW5kTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tYW5kTWFuYWdlcihwbGF0Zm9ybSwgY29tbWFuZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tbWFuZHMsIHBsYXRmb3JtKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ieU5hbWUgPSBfdGhpcy5jb21tYW5kcztcbiAgICAgICAgX3RoaXMuc2V0RGVmYXVsdEhhbmRsZXIoXCJleGVjXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIWUuYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmNvbW1hbmQuZXhlYyhlLmVkaXRvciwge30sIGUuZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGUuY29tbWFuZC5leGVjKGUuZWRpdG9yLCBlLmFyZ3MsIGUuZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoY29tbWFuZCwgZWRpdG9yLCBhcmdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmQpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY29tbWFuZC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leGVjKGNvbW1hbmRbaV0sIGVkaXRvciwgYXJncykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW2NvbW1hbmRdO1xuICAgICAgICBpZiAoIXRoaXMuY2FuRXhlY3V0ZShjb21tYW5kLCBlZGl0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGUgPSB7IGVkaXRvcjogZWRpdG9yLCBjb21tYW5kOiBjb21tYW5kLCBhcmdzOiBhcmdzIH07XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSB0aGlzLl9lbWl0KFwiZXhlY1wiLCBlKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJFeGVjXCIsIGUpO1xuICAgICAgICByZXR1cm4gZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuY2FuRXhlY3V0ZSA9IGZ1bmN0aW9uIChjb21tYW5kLCBlZGl0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbY29tbWFuZF07XG4gICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGVkaXRvciAmJiBlZGl0b3IuJHJlYWRPbmx5ICYmICFjb21tYW5kLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kY2hlY2tDb21tYW5kU3RhdGUgIT0gZmFsc2UgJiYgY29tbWFuZC5pc0F2YWlsYWJsZSAmJiAhY29tbWFuZC5pc0F2YWlsYWJsZShlZGl0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS50b2dnbGVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLiRpblJlcGxheSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWRpdG9yICYmIGVkaXRvci5fZW1pdChcImNoYW5nZVN0YXR1c1wiKTtcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1hY3JvLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJleGVjXCIsIHRoaXMuJGFkZENvbW1hbmRUb01hY3JvKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWNyby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5tYWNybyA9IHRoaXMub2xkTWFjcm87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuJGFkZENvbW1hbmRUb01hY3JvKSB7XG4gICAgICAgICAgICB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWNyby5wdXNoKFtlLmNvbW1hbmQsIGUuYXJnc10pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2xkTWFjcm8gPSB0aGlzLm1hY3JvO1xuICAgICAgICB0aGlzLm1hY3JvID0gW107XG4gICAgICAgIHRoaXMub24oXCJleGVjXCIsIHRoaXMuJGFkZENvbW1hbmRUb01hY3JvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLiRpblJlcGxheSB8fCAhdGhpcy5tYWNybylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlUmVjb3JkaW5nKGVkaXRvcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLiRpblJlcGxheSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1hY3JvLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjKHgsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWMoeFswXSwgZWRpdG9yLCB4WzFdKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy4kaW5SZXBsYXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLnRyaW1NYWNybyA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB4WzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgeFswXSA9IHhbMF0ubmFtZTtcbiAgICAgICAgICAgIGlmICgheFsxXSlcbiAgICAgICAgICAgICAgICB4ID0geFswXTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tYW5kTWFuYWdlcjtcbn0oTXVsdGlIYXNoSGFuZGxlcikpO1xub29wLmltcGxlbWVudChDb21tYW5kTWFuYWdlci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gQ29tbWFuZE1hbmFnZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2NvbW1hbmRzL2RlZmF1bHRfY29tbWFuZHNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbmZ1bmN0aW9uIGJpbmRLZXkod2luLCBtYWMpIHtcbiAgICByZXR1cm4geyB3aW46IHdpbiwgbWFjOiBtYWMgfTtcbn1cbmV4cG9ydHMuY29tbWFuZHMgPSBbe1xuICAgICAgICBuYW1lOiBcInNob3dTZXR0aW5nc01lbnVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2hvdyBzZXR0aW5ncyBtZW51XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLSxcIiwgXCJDb21tYW5kLSxcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFwiYWNlL2V4dC9zZXR0aW5nc19tZW51XCIsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdChlZGl0b3IpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5zaG93U2V0dGluZ3NNZW51KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ29Ub05leHRFcnJvclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBuZXh0IGVycm9yXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtRVwiLCBcIkY0XCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBjb25maWcubG9hZE1vZHVsZShcImFjZS9leHQvZXJyb3JfbWFya2VyXCIsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuc2hvd0Vycm9yTWFya2VyKGVkaXRvciwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb1RvUHJldmlvdXNFcnJvclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBwcmV2aW91cyBlcnJvclwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LUVcIiwgXCJTaGlmdC1GNFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L2Vycm9yX21hcmtlclwiLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLnNob3dFcnJvck1hcmtlcihlZGl0b3IsIC0xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdGFsbFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgYWxsXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUFcIiwgXCJDb21tYW5kLUFcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdEFsbCgpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJjZW50ZXJzZWxlY3Rpb25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ2VudGVyIHNlbGVjdGlvblwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiQ3RybC1MXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5jZW50ZXJTZWxlY3Rpb24oKTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b2xpbmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gbGluZS4uLlwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1MXCIsIFwiQ29tbWFuZC1MXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yLCBsaW5lKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKGxpbmUpKVxuICAgICAgICAgICAgICAgIGVkaXRvci5nb3RvTGluZShsaW5lKTtcbiAgICAgICAgICAgIGVkaXRvci5wcm9tcHQoeyAkdHlwZTogXCJnb3RvTGluZVwiIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJmb2xkXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtTHxDdHJsLUYxXCIsIFwiQ29tbWFuZC1BbHQtTHxDb21tYW5kLUYxXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGQoZmFsc2UpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ1bmZvbGRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1MfEN0cmwtU2hpZnQtRjFcIiwgXCJDb21tYW5kLUFsdC1TaGlmdC1MfENvbW1hbmQtU2hpZnQtRjFcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udG9nZ2xlRm9sZCh0cnVlKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG9nZ2xlRm9sZFdpZGdldFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUb2dnbGUgZm9sZCB3aWRnZXRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkYyXCIsIFwiRjJcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udG9nZ2xlRm9sZFdpZGdldCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ0b2dnbGVQYXJlbnRGb2xkV2lkZ2V0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZ2dsZSBwYXJlbnQgZm9sZCB3aWRnZXRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1GMlwiLCBcIkFsdC1GMlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2Vzc2lvbi50b2dnbGVGb2xkV2lkZ2V0KHRydWUpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJmb2xkYWxsXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZvbGQgYWxsXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgXCJDdHJsLUNvbW1hbmQtT3B0aW9uLTBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24uZm9sZEFsbCgpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZm9sZEFsbENvbW1lbnRzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZvbGQgYWxsIGNvbW1lbnRzXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgXCJDdHJsLUNvbW1hbmQtT3B0aW9uLTBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24uZm9sZEFsbENvbW1lbnRzKCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJmb2xkT3RoZXJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRm9sZCBvdGhlclwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LTBcIiwgXCJDb21tYW5kLU9wdGlvbi0wXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5mb2xkQWxsKCk7XG4gICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi51bmZvbGQoZWRpdG9yLnNlbGVjdGlvbi5nZXRBbGxSYW5nZXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ1bmZvbGRhbGxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVW5mb2xkIGFsbFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LTBcIiwgXCJDb21tYW5kLU9wdGlvbi1TaGlmdC0wXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnVuZm9sZCgpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZmluZG5leHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmluZCBuZXh0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUtcIiwgXCJDb21tYW5kLUdcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmZpbmROZXh0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY2VudGVyXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImZpbmRwcmV2aW91c1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGaW5kIHByZXZpb3VzXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUtcIiwgXCJDb21tYW5kLVNoaWZ0LUdcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmZpbmRQcmV2aW91cygpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3RPckZpbmROZXh0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBvciBmaW5kIG5leHRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1LXCIsIFwiQ3RybC1HXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWRpdG9yLmZpbmROZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdE9yRmluZFByZXZpb3VzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBvciBmaW5kIHByZXZpb3VzXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtS1wiLCBcIkN0cmwtU2hpZnQtR1wiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0V29yZCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVkaXRvci5maW5kUHJldmlvdXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZmluZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGaW5kXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUZcIiwgXCJDb21tYW5kLUZcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFwiYWNlL2V4dC9zZWFyY2hib3hcIiwgZnVuY3Rpb24gKGUpIHsgZS5TZWFyY2goZWRpdG9yKTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm92ZXJ3cml0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJPdmVyd3JpdGVcIixcbiAgICAgICAgYmluZEtleTogXCJJbnNlcnRcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IudG9nZ2xlT3ZlcndyaXRlKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHRvc3RhcnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHRvIHN0YXJ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUhvbWVcIiwgXCJDb21tYW5kLVNoaWZ0LUhvbWV8Q29tbWFuZC1TaGlmdC1VcFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RmlsZVN0YXJ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICAgICAgYWNlQ29tbWFuZEdyb3VwOiBcImZpbGVKdW1wXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b3N0YXJ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIHN0YXJ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUhvbWVcIiwgXCJDb21tYW5kLUhvbWV8Q29tbWFuZC1VcFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVGaWxlU3RhcnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICBhY2VDb21tYW5kR3JvdXA6IFwiZmlsZUp1bXBcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3R1cFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgdXBcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIlNoaWZ0LVVwXCIsIFwiU2hpZnQtVXB8Q3RybC1TaGlmdC1QXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RVcCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb2xpbmV1cFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyBsaW5lIHVwXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJVcFwiLCBcIlVwfEN0cmwtUFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgYXJncykgeyBlZGl0b3IubmF2aWdhdGVVcChhcmdzLnRpbWVzKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0dG9lbmRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHRvIGVuZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1FbmRcIiwgXCJDb21tYW5kLVNoaWZ0LUVuZHxDb21tYW5kLVNoaWZ0LURvd25cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdEZpbGVFbmQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICBhY2VDb21tYW5kR3JvdXA6IFwiZmlsZUp1bXBcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3RvZW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIGVuZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1FbmRcIiwgXCJDb21tYW5kLUVuZHxDb21tYW5kLURvd25cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLm5hdmlnYXRlRmlsZUVuZCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgICAgIGFjZUNvbW1hbmRHcm91cDogXCJmaWxlSnVtcFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdGRvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IGRvd25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIlNoaWZ0LURvd25cIiwgXCJTaGlmdC1Eb3dufEN0cmwtU2hpZnQtTlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RG93bigpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb2xpbmVkb3duXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIGxpbmUgZG93blwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiRG93blwiLCBcIkRvd258Q3RybC1OXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yLCBhcmdzKSB7IGVkaXRvci5uYXZpZ2F0ZURvd24oYXJncy50aW1lcyk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHdvcmRsZWZ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCB3b3JkIGxlZnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtTGVmdFwiLCBcIk9wdGlvbi1TaGlmdC1MZWZ0XCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RXb3JkTGVmdCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3Rvd29yZGxlZnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gd29yZCBsZWZ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUxlZnRcIiwgXCJPcHRpb24tTGVmdFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVXb3JkTGVmdCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3R0b2xpbmVzdGFydFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgdG8gbGluZSBzdGFydFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LUxlZnRcIiwgXCJDb21tYW5kLVNoaWZ0LUxlZnR8Q3RybC1TaGlmdC1BXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RMaW5lU3RhcnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b2xpbmVzdGFydFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBsaW5lIHN0YXJ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtTGVmdHxIb21lXCIsIFwiQ29tbWFuZC1MZWZ0fEhvbWV8Q3RybC1BXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZUxpbmVTdGFydCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3RsZWZ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBsZWZ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1MZWZ0XCIsIFwiU2hpZnQtTGVmdHxDdHJsLVNoaWZ0LUJcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExlZnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b2xlZnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gbGVmdFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiTGVmdFwiLCBcIkxlZnR8Q3RybC1CXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yLCBhcmdzKSB7IGVkaXRvci5uYXZpZ2F0ZUxlZnQoYXJncy50aW1lcyk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHdvcmRyaWdodFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3Qgd29yZCByaWdodFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1SaWdodFwiLCBcIk9wdGlvbi1TaGlmdC1SaWdodFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0V29yZFJpZ2h0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG93b3JkcmlnaHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gd29yZCByaWdodFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1SaWdodFwiLCBcIk9wdGlvbi1SaWdodFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVXb3JkUmlnaHQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0dG9saW5lZW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCB0byBsaW5lIGVuZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LVJpZ2h0XCIsIFwiQ29tbWFuZC1TaGlmdC1SaWdodHxTaGlmdC1FbmR8Q3RybC1TaGlmdC1FXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RMaW5lRW5kKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9saW5lZW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIGxpbmUgZW5kXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtUmlnaHR8RW5kXCIsIFwiQ29tbWFuZC1SaWdodHxFbmR8Q3RybC1FXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZUxpbmVFbmQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0cmlnaHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHJpZ2h0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1SaWdodFwiLCBcIlNoaWZ0LVJpZ2h0XCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RSaWdodCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3RvcmlnaHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gcmlnaHRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIlJpZ2h0XCIsIFwiUmlnaHR8Q3RybC1GXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yLCBhcmdzKSB7IGVkaXRvci5uYXZpZ2F0ZVJpZ2h0KGFyZ3MudGltZXMpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3RwYWdlZG93blwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgcGFnZSBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IFwiU2hpZnQtUGFnZURvd25cIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0UGFnZURvd24oKTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicGFnZWRvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUGFnZSBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgXCJPcHRpb24tUGFnZURvd25cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNjcm9sbFBhZ2VEb3duKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9wYWdlZG93blwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBwYWdlIGRvd25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIlBhZ2VEb3duXCIsIFwiUGFnZURvd258Q3RybC1WXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nb3RvUGFnZURvd24oKTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0cGFnZXVwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBwYWdlIHVwXCIsXG4gICAgICAgIGJpbmRLZXk6IFwiU2hpZnQtUGFnZVVwXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdFBhZ2VVcCgpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJwYWdldXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUGFnZSB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiT3B0aW9uLVBhZ2VVcFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2Nyb2xsUGFnZVVwKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9wYWdldXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gcGFnZSB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBcIlBhZ2VVcFwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nb3RvUGFnZVVwKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNjcm9sbHVwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNjcm9sbCB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1VcFwiLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGUpIHsgZS5yZW5kZXJlci5zY3JvbGxCeSgwLCAtMiAqIGUucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNjcm9sbGRvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2Nyb2xsIGRvd25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtRG93blwiLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGUpIHsgZS5yZW5kZXJlci5zY3JvbGxCeSgwLCAyICogZS5yZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0KTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0bGluZXN0YXJ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBsaW5lIHN0YXJ0XCIsXG4gICAgICAgIGJpbmRLZXk6IFwiU2hpZnQtSG9tZVwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RMaW5lU3RhcnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0bGluZWVuZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbGluZSBlbmRcIixcbiAgICAgICAgYmluZEtleTogXCJTaGlmdC1FbmRcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZUVuZCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ0b2dnbGVyZWNvcmRpbmdcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVG9nZ2xlIHJlY29yZGluZ1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1BbHQtRVwiLCBcIkNvbW1hbmQtT3B0aW9uLUVcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVJlY29yZGluZyhlZGl0b3IpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJyZXBsYXltYWNyb1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXBsYXkgbWFjcm9cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRVwiLCBcIkNvbW1hbmQtU2hpZnQtRVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29tbWFuZHMucmVwbGF5KGVkaXRvcik7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImp1bXB0b21hdGNoaW5nXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkp1bXAgdG8gbWF0Y2hpbmdcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtXFxcXHxDdHJsLVBcIiwgXCJDb21tYW5kLVxcXFxcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmp1bXBUb01hdGNoaW5nKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3R0b21hdGNoaW5nXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCB0byBtYXRjaGluZ1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1cXFxcfEN0cmwtU2hpZnQtUFwiLCBcIkNvbW1hbmQtU2hpZnQtXFxcXFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuanVtcFRvTWF0Y2hpbmcodHJ1ZSk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJleHBhbmRUb01hdGNoaW5nXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkV4cGFuZCB0byBtYXRjaGluZ1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1NXCIsIFwiQ3RybC1TaGlmdC1NXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5qdW1wVG9NYXRjaGluZyh0cnVlLCB0cnVlKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInBhc3NLZXlzVG9Ccm93c2VyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlBhc3Mga2V5cyB0byBicm93c2VyXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgcGFzc0V2ZW50OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJjb3B5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNvcHlcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcImN1dFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDdXRcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGN1dExpbmUgPSBlZGl0b3IuJGNvcHlXaXRoRW1wdHlTZWxlY3Rpb24gJiYgZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBjdXRMaW5lID8gZWRpdG9yLnNlbGVjdGlvbi5nZXRMaW5lUmFuZ2UoKSA6IGVkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIGVkaXRvci5fZW1pdChcImN1dFwiLCByYW5nZSk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xuICAgICAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicGFzdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUGFzdGVcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgYXJncykge1xuICAgICAgICAgICAgZWRpdG9yLiRoYW5kbGVQYXN0ZShhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicmVtb3ZlbGluZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgbGluZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1EXCIsIFwiQ29tbWFuZC1EXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZW1vdmVMaW5lcygpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJkdXBsaWNhdGVTZWxlY3Rpb25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRHVwbGljYXRlIHNlbGVjdGlvblwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1EXCIsIFwiQ29tbWFuZC1TaGlmdC1EXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5kdXBsaWNhdGVTZWxlY3Rpb24oKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzb3J0bGluZXNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU29ydCBsaW5lc1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1BbHQtU1wiLCBcIkNvbW1hbmQtQWx0LVNcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNvcnRMaW5lcygpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ0b2dnbGVjb21tZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZ2dsZSBjb21tZW50XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLS9cIiwgXCJDb21tYW5kLS9cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRvZ2dsZUNvbW1lbnRMaW5lcygpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoTGluZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG9nZ2xlQmxvY2tDb21tZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZ2dsZSBibG9jayBjb21tZW50XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LS9cIiwgXCJDb21tYW5kLVNoaWZ0LS9cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRvZ2dsZUJsb2NrQ29tbWVudCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcInNlbGVjdGlvblBhcnRcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJtb2RpZnlOdW1iZXJVcFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJNb2RpZnkgbnVtYmVyIHVwXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LVVwXCIsIFwiQWx0LVNoaWZ0LVVwXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5tb2RpZnlOdW1iZXIoMSk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwibW9kaWZ5TnVtYmVyRG93blwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJNb2RpZnkgbnVtYmVyIGRvd25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRG93blwiLCBcIkFsdC1TaGlmdC1Eb3duXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5tb2RpZnlOdW1iZXIoLTEpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlcGxhY2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVwbGFjZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1IXCIsIFwiQ29tbWFuZC1PcHRpb24tRlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L3NlYXJjaGJveFwiLCBmdW5jdGlvbiAoZSkgeyBlLlNlYXJjaChlZGl0b3IsIHRydWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ1bmRvXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVuZG9cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtWlwiLCBcIkNvbW1hbmQtWlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IudW5kbygpOyB9XG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlZG9cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVkb1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1afEN0cmwtWVwiLCBcIkNvbW1hbmQtU2hpZnQtWnxDb21tYW5kLVlcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnJlZG8oKTsgfVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJjb3B5bGluZXN1cFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDb3B5IGxpbmVzIHVwXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtVXBcIiwgXCJDb21tYW5kLU9wdGlvbi1VcFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29weUxpbmVzVXAoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwibW92ZWxpbmVzdXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTW92ZSBsaW5lcyB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVVwXCIsIFwiT3B0aW9uLVVwXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5tb3ZlTGluZXNVcCgpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJjb3B5bGluZXNkb3duXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNvcHkgbGluZXMgZG93blwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LURvd25cIiwgXCJDb21tYW5kLU9wdGlvbi1Eb3duXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5jb3B5TGluZXNEb3duKCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm1vdmVsaW5lc2Rvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTW92ZSBsaW5lcyBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtRG93blwiLCBcIk9wdGlvbi1Eb3duXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5tb3ZlTGluZXNEb3duKCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImRlbFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWxldGVcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkRlbGV0ZVwiLCBcIkRlbGV0ZXxDdHJsLUR8U2hpZnQtRGVsZXRlXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZW1vdmUoXCJyaWdodFwiKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJiYWNrc3BhY2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQmFja3NwYWNlXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1CYWNrc3BhY2V8QmFja3NwYWNlXCIsIFwiQ3RybC1CYWNrc3BhY2V8U2hpZnQtQmFja3NwYWNlfEJhY2tzcGFjZXxDdHJsLUhcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZShcImxlZnRcIik7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiY3V0X29yX2RlbGV0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDdXQgb3IgZGVsZXRlXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1EZWxldGVcIiwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmUoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlbW92ZXRvbGluZXN0YXJ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbW92ZSB0byBsaW5lIHN0YXJ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtQmFja3NwYWNlXCIsIFwiQ29tbWFuZC1CYWNrc3BhY2VcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVRvTGluZVN0YXJ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicmVtb3ZldG9saW5lZW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbW92ZSB0byBsaW5lIGVuZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LURlbGV0ZVwiLCBcIkN0cmwtS3xDb21tYW5kLURlbGV0ZVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IucmVtb3ZlVG9MaW5lRW5kKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicmVtb3ZldG9saW5lc3RhcnRoYXJkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbW92ZSB0byBsaW5lIHN0YXJ0IGhhcmRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtQmFja3NwYWNlXCIsIG51bGwpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJyZW1vdmV0b2xpbmVlbmRoYXJkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbW92ZSB0byBsaW5lIGVuZCBoYXJkXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LURlbGV0ZVwiLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlbW92ZXdvcmRsZWZ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbW92ZSB3b3JkIGxlZnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtQmFja3NwYWNlXCIsIFwiQWx0LUJhY2tzcGFjZXxDdHJsLUFsdC1CYWNrc3BhY2VcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVdvcmRMZWZ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicmVtb3Zld29yZHJpZ2h0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbW92ZSB3b3JkIHJpZ2h0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLURlbGV0ZVwiLCBcIkFsdC1EZWxldGVcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVdvcmRSaWdodCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm91dGRlbnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiT3V0ZGVudFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtVGFiXCIsIFwiU2hpZnQtVGFiXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5ibG9ja091dGRlbnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiaW5kZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGVudFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiVGFiXCIsIFwiVGFiXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5pbmRlbnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYmxvY2tvdXRkZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkJsb2NrIG91dGRlbnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtW1wiLCBcIkN0cmwtW1wiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuYmxvY2tPdXRkZW50KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hMaW5lXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcInNlbGVjdGlvblBhcnRcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJibG9ja2luZGVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJCbG9jayBpbmRlbnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtXVwiLCBcIkN0cmwtXVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuYmxvY2tJbmRlbnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uUGFydFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImluc2VydHN0cmluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbnNlcnQgc3RyaW5nXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IsIHN0cikgeyBlZGl0b3IuaW5zZXJ0KHN0cik7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiaW5zZXJ0dGV4dFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbnNlcnQgdGV4dFwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yLCBhcmdzKSB7XG4gICAgICAgICAgICBlZGl0b3IuaW5zZXJ0KGxhbmcuc3RyaW5nUmVwZWF0KGFyZ3MudGV4dCB8fCBcIlwiLCBhcmdzLnRpbWVzIHx8IDEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzcGxpdGxpbmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3BsaXQgbGluZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiQ3RybC1PXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zcGxpdExpbmUoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ0cmFuc3Bvc2VsZXR0ZXJzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRyYW5zcG9zZSBsZXR0ZXJzXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtWFwiLCBcIkN0cmwtVFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IudHJhbnNwb3NlTGV0dGVycygpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IudHJhbnNwb3NlU2VsZWN0aW9ucygxKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG91cHBlcmNhc2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVG8gdXBwZXJjYXNlXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVVcIiwgXCJDdHJsLVVcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG9sb3dlcmNhc2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVG8gbG93ZXJjYXNlXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LVVcIiwgXCJDdHJsLVNoaWZ0LVVcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRvTG93ZXJDYXNlKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYXV0b2luZGVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBdXRvIEluZGVudFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIG51bGwpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5hdXRvSW5kZW50KCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJleHBhbmR0b2xpbmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRXhwYW5kIHRvIGxpbmVcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtTFwiLCBcIkNvbW1hbmQtU2hpZnQtTFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICByYW5nZS5lbmQucm93Kys7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJhbmdlKHJhbmdlLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm9wZW5saW5rXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsK0YzXCIsIFwiRjNcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLm9wZW5MaW5rKCk7IH1cbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiam9pbmxpbmVzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkpvaW4gbGluZXNcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShudWxsLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGlzQmFja3dhcmRzID0gZWRpdG9yLnNlbGVjdGlvbi5pc0JhY2t3YXJkcygpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gaXNCYWNrd2FyZHMgPyBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkxlYWQoKSA6IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uQW5jaG9yKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gaXNCYWNrd2FyZHMgPyBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkFuY2hvcigpIDogZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25MZWFkKCk7XG4gICAgICAgICAgICB2YXIgZmlyc3RMaW5lRW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoc2VsZWN0aW9uU3RhcnQucm93KS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRUZXh0ID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldFRleHRSYW5nZShlZGl0b3Iuc2VsZWN0aW9uLmdldFJhbmdlKCkpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkQ291bnQgPSBzZWxlY3RlZFRleHQucmVwbGFjZSgvXFxuXFxzKi8sIFwiIFwiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0TGluZSA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKHNlbGVjdGlvblN0YXJ0LnJvdyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZWN0aW9uU3RhcnQucm93ICsgMTsgaSA8PSBzZWxlY3Rpb25FbmQucm93ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckxpbmUgPSBsYW5nLnN0cmluZ1RyaW1MZWZ0KGxhbmcuc3RyaW5nVHJpbVJpZ2h0KGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKGkpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckxpbmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPSBcIiBcIiArIGN1ckxpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc2VydExpbmUgKz0gY3VyTGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25FbmQucm93ICsgMSA8IChlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGVuZ3RoKCkgLSAxKSkge1xuICAgICAgICAgICAgICAgIGluc2VydExpbmUgKz0gZWRpdG9yLnNlc3Npb24uZG9jLmdldE5ld0xpbmVDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24uZG9jLnJlcGxhY2UobmV3IFJhbmdlKHNlbGVjdGlvblN0YXJ0LnJvdywgMCwgc2VsZWN0aW9uRW5kLnJvdyArIDIsIDApLCBpbnNlcnRMaW5lKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZUN1cnNvclRvKHNlbGVjdGlvblN0YXJ0LnJvdywgc2VsZWN0aW9uU3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFRvKHNlbGVjdGlvblN0YXJ0LnJvdywgc2VsZWN0aW9uU3RhcnQuY29sdW1uICsgc2VsZWN0ZWRDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdExpbmVFbmRDb2wgPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGluZShzZWxlY3Rpb25TdGFydC5yb3cpLmxlbmd0aCA+IGZpcnN0TGluZUVuZENvbCA/IChmaXJzdExpbmVFbmRDb2wgKyAxKSA6IGZpcnN0TGluZUVuZENvbDtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVDdXJzb3JUbyhzZWxlY3Rpb25TdGFydC5yb3csIGZpcnN0TGluZUVuZENvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiaW52ZXJ0U2VsZWN0aW9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkludmVydCBzZWxlY3Rpb25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShudWxsLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMZW5ndGgoKSAtIDE7XG4gICAgICAgICAgICB2YXIgZW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoZW5kUm93KS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gZWRpdG9yLnNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzID0gW2VkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09IChyYW5nZXMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmFuZ2VzW2ldLmVuZC5yb3cgPT09IGVuZFJvdyAmJiByYW5nZXNbaV0uZW5kLmNvbHVtbiA9PT0gZW5kQ29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKHJhbmdlc1tpXS5lbmQucm93LCByYW5nZXNbaV0uZW5kLmNvbHVtbiwgZW5kUm93LCBlbmRDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShyYW5nZXNbaV0uc3RhcnQucm93ID09PSAwICYmIHJhbmdlc1tpXS5zdGFydC5jb2x1bW4gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChuZXcgUmFuZ2UoMCwgMCwgcmFuZ2VzW2ldLnN0YXJ0LnJvdywgcmFuZ2VzW2ldLnN0YXJ0LmNvbHVtbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChuZXcgUmFuZ2UocmFuZ2VzW2kgLSAxXS5lbmQucm93LCByYW5nZXNbaSAtIDFdLmVuZC5jb2x1bW4sIHJhbmdlc1tpXS5zdGFydC5yb3csIHJhbmdlc1tpXS5zdGFydC5jb2x1bW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xuICAgICAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1Jhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uYWRkUmFuZ2UobmV3UmFuZ2VzW2ldLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJub25lXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYWRkTGluZUFmdGVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFkZCBuZXcgbGluZSBhZnRlciB0aGUgY3VycmVudCBsaW5lXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGVkaXRvci5uYXZpZ2F0ZUxpbmVFbmQoKTtcbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnQoXCJcXG5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYWRkTGluZUJlZm9yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBZGQgbmV3IGxpbmUgYmVmb3JlIHRoZSBjdXJyZW50IGxpbmVcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG8oY3Vyc29yLnJvdyAtIDEsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgICAgZWRpdG9yLmluc2VydChcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3Iucm93ID09PSAwKVxuICAgICAgICAgICAgICAgIGVkaXRvci5uYXZpZ2F0ZVVwKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwib3BlbkNvbW1hbmRQYWxsZXRlXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgaXMgYW4gb2Jzb2xldGUgY29tbWFuZC4gUGxlYXNlIHVzZSBgb3BlbkNvbW1hbmRQYWxldHRlYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVkaXRvci5wcm9tcHQoeyAkdHlwZTogXCJjb21tYW5kc1wiIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJvcGVuQ29tbWFuZFBhbGV0dGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiT3BlbiBjb21tYW5kIHBhbGV0dGVcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkYxXCIsIFwiRjFcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5wcm9tcHQoeyAkdHlwZTogXCJjb21tYW5kc1wiIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJtb2RlU2VsZWN0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNoYW5nZSBsYW5ndWFnZSBtb2RlLi4uXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5wcm9tcHQoeyAkdHlwZTogXCJtb2Rlc1wiIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH1dO1xuZm9yICh2YXIgaSA9IDE7IGkgPCA5OyBpKyspIHtcbiAgICBleHBvcnRzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICBuYW1lOiBcImZvbGRUb0xldmVsXCIgKyBpLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGb2xkIFRvIExldmVsIFwiICsgaSxcbiAgICAgICAgbGV2ZWw6IGksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24uZm9sZFRvTGV2ZWwodGhpcy5sZXZlbCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0pO1xufVxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saW5lX3dpZGdldHNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgTGluZVdpZGdldHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZVdpZGdldHMoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLnNlc3Npb24ud2lkZ2V0TWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRSb3dMZW5ndGggPSB0aGlzLmdldFJvd0xlbmd0aDtcbiAgICAgICAgdGhpcy5zZXNzaW9uLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGggPSB0aGlzLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlT25DaGFuZ2UgPSB0aGlzLnVwZGF0ZU9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVuZGVyV2lkZ2V0cyA9IHRoaXMucmVuZGVyV2lkZ2V0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1lYXN1cmVXaWRnZXRzID0gdGhpcy5tZWFzdXJlV2lkZ2V0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlc3Npb24uX2NoYW5nZWRXaWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuJG9uQ2hhbmdlRWRpdG9yID0gdGhpcy4kb25DaGFuZ2VFZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlT25DaGFuZ2UpO1xuICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJjaGFuZ2VGb2xkXCIsIHRoaXMudXBkYXRlT25Gb2xkKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlRWRpdG9yXCIsIHRoaXMuJG9uQ2hhbmdlRWRpdG9yKTtcbiAgICB9XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLmdldFJvd0xlbmd0aCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGg7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgaCA9IHRoaXMubGluZVdpZGdldHNbcm93XSAmJiB0aGlzLmxpbmVXaWRnZXRzW3Jvd10ucm93Q291bnQgfHwgMDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgIGlmICghdGhpc1tcIiR1c2VXcmFwTW9kZVwiXSB8fCAhdGhpc1tcIiR3cmFwRGF0YVwiXVtyb3ddKSB7XG4gICAgICAgICAgICByZXR1cm4gMSArIGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIiR3cmFwRGF0YVwiXVtyb3ddLmxlbmd0aCArIDEgKyBoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5lV2lkZ2V0cy5wcm90b3R5cGUuJGdldFdpZGdldFNjcmVlbkxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcmVlblJvd3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIGlmICh3ICYmIHcucm93Q291bnQgJiYgIXcuaGlkZGVuKVxuICAgICAgICAgICAgICAgIHNjcmVlblJvd3MgKz0gdy5yb3dDb3VudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY3JlZW5Sb3dzO1xuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLiRvbkNoYW5nZUVkaXRvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoKGUuZWRpdG9yKTtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIGlmIChlZGl0b3IgJiYgZWRpdG9yLndpZGdldE1hbmFnZXIgJiYgZWRpdG9yLndpZGdldE1hbmFnZXIgIT0gdGhpcylcbiAgICAgICAgICAgIGVkaXRvci53aWRnZXRNYW5hZ2VyLmRldGFjaCgpO1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IgPT0gZWRpdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLndpZGdldE1hbmFnZXIgPSB0aGlzO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLm9uKFwiYmVmb3JlUmVuZGVyXCIsIHRoaXMubWVhc3VyZVdpZGdldHMpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLm9uKFwiYWZ0ZXJSZW5kZXJcIiwgdGhpcy5yZW5kZXJXaWRnZXRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgaWYgKCFlZGl0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZWRpdG9yID0gbnVsbDtcbiAgICAgICAgZWRpdG9yLndpZGdldE1hbmFnZXIgPSBudWxsO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIub2ZmKFwiYmVmb3JlUmVuZGVyXCIsIHRoaXMubWVhc3VyZVdpZGdldHMpO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIub2ZmKFwiYWZ0ZXJSZW5kZXJcIiwgdGhpcy5yZW5kZXJXaWRnZXRzKTtcbiAgICAgICAgdmFyIGxpbmVXaWRnZXRzID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzO1xuICAgICAgICBsaW5lV2lkZ2V0cyAmJiBsaW5lV2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICBpZiAodyAmJiB3LmVsICYmIHcuZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHcuX2luRG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3LmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQody5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLnVwZGF0ZU9uRm9sZCA9IGZ1bmN0aW9uIChlLCBzZXNzaW9uKSB7XG4gICAgICAgIHZhciBsaW5lV2lkZ2V0cyA9IHNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgIGlmICghbGluZVdpZGdldHMgfHwgIWUuYWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZm9sZCA9IGUuZGF0YTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgIHZhciBlbmQgPSBmb2xkLmVuZC5yb3c7XG4gICAgICAgIHZhciBoaWRlID0gZS5hY3Rpb24gPT0gXCJhZGRcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZGdldHNbaV0pXG4gICAgICAgICAgICAgICAgbGluZVdpZGdldHNbaV0uaGlkZGVuID0gaGlkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVdpZGdldHNbZW5kXSkge1xuICAgICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVXaWRnZXRzW3N0YXJ0XSlcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZGdldHNbc3RhcnRdID0gbGluZVdpZGdldHNbZW5kXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWRnZXRzW2VuZF0uaGlkZGVuID0gaGlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkZ2V0c1tzdGFydF0gPT0gbGluZVdpZGdldHNbZW5kXSlcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZGdldHNbc3RhcnRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxpbmVXaWRnZXRzW2VuZF0uaGlkZGVuID0gaGlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLnVwZGF0ZU9uQ2hhbmdlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHZhciBsaW5lV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cztcbiAgICAgICAgaWYgKCFsaW5lV2lkZ2V0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgICAgICB2YXIgbGVuID0gZGVsdGEuZW5kLnJvdyAtIHN0YXJ0Um93O1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gbGluZVdpZGdldHMuc3BsaWNlKHN0YXJ0Um93ICsgMSwgbGVuKTtcbiAgICAgICAgICAgIGlmICghbGluZVdpZGdldHNbc3RhcnRSb3ddICYmIHJlbW92ZWRbcmVtb3ZlZC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIGxpbmVXaWRnZXRzW3N0YXJ0Um93XSA9IHJlbW92ZWQucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgICAgICB3ICYmIHRoaXMucmVtb3ZlTGluZVdpZGdldCh3KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlUm93cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkZ2V0c1tzdGFydFJvd10gJiYgbGluZVdpZGdldHNbc3RhcnRSb3ddLmNvbHVtbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhLnN0YXJ0LmNvbHVtbiA+IGxpbmVXaWRnZXRzW3N0YXJ0Um93XS5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Um93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoc3RhcnRSb3csIDApO1xuICAgICAgICAgICAgbGluZVdpZGdldHMuc3BsaWNlLmFwcGx5KGxpbmVXaWRnZXRzLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLiR1cGRhdGVSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgIGlmICghbGluZVdpZGdldHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBub1dpZGdldHMgPSB0cnVlO1xuICAgICAgICBsaW5lV2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3LCBpKSB7XG4gICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgIG5vV2lkZ2V0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHcucm93ID0gaTtcbiAgICAgICAgICAgICAgICB3aGlsZSAody4kb2xkV2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHcuJG9sZFdpZGdldC5yb3cgPSBpO1xuICAgICAgICAgICAgICAgICAgICB3ID0gdy4kb2xkV2lkZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChub1dpZGdldHMpXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ubGluZVdpZGdldHMgPSBudWxsO1xuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLiRyZWdpc3RlckxpbmVXaWRnZXQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cyA9IG5ldyBBcnJheSh0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkpO1xuICAgICAgICB2YXIgb2xkID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3cucm93XTtcbiAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgdy4kb2xkV2lkZ2V0ID0gb2xkO1xuICAgICAgICAgICAgaWYgKG9sZC5lbCAmJiBvbGQuZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG9sZC5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9sZC5lbCk7XG4gICAgICAgICAgICAgICAgb2xkLl9pbkRvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3cucm93XSA9IHc7XG4gICAgICAgIHJldHVybiB3O1xuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLmFkZExpbmVXaWRnZXQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB0aGlzLiRyZWdpc3RlckxpbmVXaWRnZXQodyk7XG4gICAgICAgIHcuc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvcilcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmVkaXRvci5yZW5kZXJlcjtcbiAgICAgICAgaWYgKHcuaHRtbCAmJiAhdy5lbCkge1xuICAgICAgICAgICAgdy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdy5lbC5pbm5lckhUTUwgPSB3Lmh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcudGV4dCAmJiAhdy5lbCkge1xuICAgICAgICAgICAgdy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdy5lbC50ZXh0Q29udGVudCA9IHcudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAody5lbCkge1xuICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHcuZWwsIFwiYWNlX2xpbmVXaWRnZXRDb250YWluZXJcIik7XG4gICAgICAgICAgICBpZiAody5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3Mody5lbCwgdy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdy5lbC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIHcuZWwuc3R5bGUuekluZGV4ID0gXCI1XCI7XG4gICAgICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQody5lbCk7XG4gICAgICAgICAgICB3Ll9pbkRvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdy5jb3Zlckd1dHRlcikge1xuICAgICAgICAgICAgICAgIHcuZWwuc3R5bGUuekluZGV4ID0gXCIzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAody5waXhlbEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdy5waXhlbEhlaWdodCA9IHcuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3LnJvd0NvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHcucm93Q291bnQgPSB3LnBpeGVsSGVpZ2h0IC8gcmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQody5yb3csIDApO1xuICAgICAgICB3LiRmb2xkID0gZm9sZDtcbiAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cztcbiAgICAgICAgICAgIGlmICh3LnJvdyA9PSBmb2xkLmVuZC5yb3cgJiYgIWxpbmVXaWRnZXRzW2ZvbGQuc3RhcnQucm93XSlcbiAgICAgICAgICAgICAgICBsaW5lV2lkZ2V0c1tmb2xkLnN0YXJ0LnJvd10gPSB3O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24uX2VtaXQoXCJjaGFuZ2VGb2xkXCIsIHsgZGF0YTogeyBzdGFydDogeyByb3c6IHcucm93IH0gfSB9KTtcbiAgICAgICAgdGhpcy4kdXBkYXRlUm93cygpO1xuICAgICAgICB0aGlzLnJlbmRlcldpZGdldHMobnVsbCwgcmVuZGVyZXIpO1xuICAgICAgICB0aGlzLm9uV2lkZ2V0Q2hhbmdlZCh3KTtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcbiAgICBMaW5lV2lkZ2V0cy5wcm90b3R5cGUucmVtb3ZlTGluZVdpZGdldCA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHcuX2luRG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHcuZWwgJiYgdy5lbC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHcuZWwpO1xuICAgICAgICBpZiAody5lZGl0b3IgJiYgdy5lZGl0b3IuZGVzdHJveSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdy5lZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzKSB7XG4gICAgICAgICAgICB2YXIgdzEgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHNbdy5yb3ddO1xuICAgICAgICAgICAgaWYgKHcxID09IHcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ubGluZVdpZGdldHNbdy5yb3ddID0gdy4kb2xkV2lkZ2V0O1xuICAgICAgICAgICAgICAgIGlmICh3LiRvbGRXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25XaWRnZXRDaGFuZ2VkKHcuJG9sZFdpZGdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodzEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcxLiRvbGRXaWRnZXQgPT0gdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdzEuJG9sZFdpZGdldCA9IHcuJG9sZFdpZGdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHcxID0gdzEuJG9sZFdpZGdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlRm9sZFwiLCB7IGRhdGE6IHsgc3RhcnQ6IHsgcm93OiB3LnJvdyB9IH0gfSk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZVJvd3MoKTtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5nZXRXaWRnZXRzQXRSb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBsaW5lV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cztcbiAgICAgICAgdmFyIHcgPSBsaW5lV2lkZ2V0cyAmJiBsaW5lV2lkZ2V0c1tyb3ddO1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB3aGlsZSAodykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHcpO1xuICAgICAgICAgICAgdyA9IHcuJG9sZFdpZGdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5vbldpZGdldENoYW5nZWQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB0aGlzLnNlc3Npb24uX2NoYW5nZWRXaWRnZXRzLnB1c2godyk7XG4gICAgICAgIHRoaXMuZWRpdG9yICYmIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnVwZGF0ZUZ1bGwoKTtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5tZWFzdXJlV2lkZ2V0cyA9IGZ1bmN0aW9uIChlLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgY2hhbmdlZFdpZGdldHMgPSB0aGlzLnNlc3Npb24uX2NoYW5nZWRXaWRnZXRzO1xuICAgICAgICB2YXIgY29uZmlnID0gcmVuZGVyZXIubGF5ZXJDb25maWc7XG4gICAgICAgIGlmICghY2hhbmdlZFdpZGdldHMgfHwgIWNoYW5nZWRXaWRnZXRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRXaWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGNoYW5nZWRXaWRnZXRzW2ldO1xuICAgICAgICAgICAgaWYgKCF3IHx8ICF3LmVsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHcuc2Vzc2lvbiAhPSB0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXcuX2luRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3cucm93XSAhPSB3KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB3Ll9pbkRvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQody5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3LmggPSB3LmVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIGlmICghdy5maXhlZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdy53ID0gdy5lbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB3LnNjcmVlbldpZHRoID0gTWF0aC5jZWlsKHcudyAvIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSB3LmggLyBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgICAgIGlmICh3LmNvdmVyTGluZSkge1xuICAgICAgICAgICAgICAgIHJvd0NvdW50IC09IHRoaXMuc2Vzc2lvbi5nZXRSb3dMaW5lQ291bnQody5yb3cpO1xuICAgICAgICAgICAgICAgIGlmIChyb3dDb3VudCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3LnJvd0NvdW50ICE9IHJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdy5yb3dDb3VudCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgICAgIGlmICh3LnJvdyA8IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdy5yb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAhPSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlRm9sZFwiLCB7IGRhdGE6IHsgc3RhcnQ6IHsgcm93OiBtaW4gfSB9IH0pO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRXaWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLl9jaGFuZ2VkV2lkZ2V0cyA9IFtdO1xuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLnJlbmRlcldpZGdldHMgPSBmdW5jdGlvbiAoZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlbmRlcmVyLmxheWVyQ29uZmlnO1xuICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgIGlmICghbGluZVdpZGdldHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWluKHRoaXMuZmlyc3RSb3csIGNvbmZpZy5maXJzdFJvdyk7XG4gICAgICAgIHZhciBsYXN0ID0gTWF0aC5tYXgodGhpcy5sYXN0Um93LCBjb25maWcubGFzdFJvdywgbGluZVdpZGdldHMubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGZpcnN0ID4gMCAmJiAhbGluZVdpZGdldHNbZmlyc3RdKVxuICAgICAgICAgICAgZmlyc3QtLTtcbiAgICAgICAgdGhpcy5maXJzdFJvdyA9IGNvbmZpZy5maXJzdFJvdztcbiAgICAgICAgdGhpcy5sYXN0Um93ID0gY29uZmlnLmxhc3RSb3c7XG4gICAgICAgIHJlbmRlcmVyLiRjdXJzb3JMYXllci5jb25maWcgPSBjb25maWc7XG4gICAgICAgIGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gbGluZVdpZGdldHNbaV07XG4gICAgICAgICAgICBpZiAoIXcgfHwgIXcuZWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAody5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLnRvcCA9IC0xMDAgLSAody5waXhlbEhlaWdodCB8fCAwKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdy5faW5Eb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHcuX2luRG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh3LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3AgPSByZW5kZXJlci4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbih7IHJvdzogaSwgY29sdW1uOiAwIH0sIHRydWUpLnRvcDtcbiAgICAgICAgICAgIGlmICghdy5jb3ZlckxpbmUpXG4gICAgICAgICAgICAgICAgdG9wICs9IGNvbmZpZy5saW5lSGVpZ2h0ICogdGhpcy5zZXNzaW9uLmdldFJvd0xpbmVDb3VudCh3LnJvdyk7XG4gICAgICAgICAgICB3LmVsLnN0eWxlLnRvcCA9IHRvcCAtIGNvbmZpZy5vZmZzZXQgKyBcInB4XCI7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHcuY292ZXJHdXR0ZXIgPyAwIDogcmVuZGVyZXIuZ3V0dGVyV2lkdGg7XG4gICAgICAgICAgICBpZiAoIXcuZml4ZWRXaWR0aClcbiAgICAgICAgICAgICAgICBsZWZ0IC09IHJlbmRlcmVyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB3LmVsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgaWYgKHcuZnVsbFdpZHRoICYmIHcuc2NyZWVuV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLm1pbldpZHRoID0gY29uZmlnLndpZHRoICsgMiAqIGNvbmZpZy5wYWRkaW5nICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHcuZml4ZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHcuZWwuc3R5bGUucmlnaHQgPSByZW5kZXJlci5zY3JvbGxCYXIuZ2V0V2lkdGgoKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcuZWwuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGluZVdpZGdldHM7XG59KCkpO1xuZXhwb3J0cy5MaW5lV2lkZ2V0cyA9IExpbmVXaWRnZXRzO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9rZXlib2FyZC9ndXR0ZXJfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9rZXlzXCIsXCJhY2UvbW91c2UvZGVmYXVsdF9ndXR0ZXJfaGFuZGxlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi4vbGliL2tleXMnKTtcbnZhciBHdXR0ZXJUb29sdGlwID0gcmVxdWlyZShcIi4uL21vdXNlL2RlZmF1bHRfZ3V0dGVyX2hhbmRsZXJcIikuR3V0dGVyVG9vbHRpcDtcbnZhciBHdXR0ZXJLZXlib2FyZEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3V0dGVyS2V5Ym9hcmRIYW5kbGVyKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5ndXR0ZXJMYXllciA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyO1xuICAgICAgICB0aGlzLmxpbmVzID0gZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllci4kbGluZXM7XG4gICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZUxhbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Ub29sdGlwID0gbmV3IEd1dHRlclRvb2x0aXAodGhpcy5lZGl0b3IpO1xuICAgIH1cbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4kb25HdXR0ZXJLZXlEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuJGJsdXJHdXR0ZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwibW91c2V3aGVlbFwiLCB0aGlzLiRibHVyR3V0dGVyLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuJG9uR3V0dGVyS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiRibHVyR3V0dGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJtb3VzZXdoZWVsXCIsIHRoaXMuJGJsdXJHdXR0ZXIuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRvbkd1dHRlcktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uVG9vbHRpcC5pc09wZW4pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleXNbXCJlc2NhcGVcIl0pXG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uVG9vbHRpcC5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlICE9IGtleXNbXCJlbnRlclwiXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdztcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IuaXNSb3dWaXNpYmxlKHJvdykpXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2Nyb2xsVG9MaW5lKHJvdywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuJHJvd1RvUm93SW5kZXgodGhpcy5ndXR0ZXJMYXllci4kY3Vyc29yQ2VsbC5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBuZWFyZXN0Rm9sZEluZGV4ID0gdGhpcy4kZmluZE5lYXJlc3RGb2xkV2lkZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgbmVhcmVzdEFubm90YXRpb25JbmRleCA9IHRoaXMuJGZpbmROZWFyZXN0QW5ub3RhdGlvbihpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5lYXJlc3RGb2xkSW5kZXggPT09IG51bGwgJiYgbmVhcmVzdEFubm90YXRpb25JbmRleCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChuZWFyZXN0Rm9sZEluZGV4ID09PSBudWxsICYmIG5lYXJlc3RBbm5vdGF0aW9uSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IG5lYXJlc3RBbm5vdGF0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTGFuZSA9IFwiYW5ub3RhdGlvblwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0Fubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lYXJlc3RGb2xkSW5kZXggIT09IG51bGwgJiYgbmVhcmVzdEFubm90YXRpb25JbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gbmVhcmVzdEZvbGRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVMYW5lID0gXCJmb2xkXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobmVhcmVzdEFubm90YXRpb25JbmRleCAtIGluZGV4KSA8IE1hdGguYWJzKG5lYXJlc3RGb2xkSW5kZXggLSBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IG5lYXJlc3RBbm5vdGF0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTGFuZSA9IFwiYW5ub3RhdGlvblwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0Fubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBuZWFyZXN0Rm9sZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmUgPSBcImZvbGRcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9jdXNGb2xkV2lkZ2V0KHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaGFuZGxlR3V0dGVyS2V5Ym9hcmRJbnRlcmFjdGlvbihlKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5fc2lnbmFsKFwiZ3V0dGVya2V5ZG93blwiLCBuZXcgR3V0dGVyS2V5Ym9hcmRFdmVudChlLCB0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgMTApO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kaGFuZGxlR3V0dGVyS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleXNbXCJ0YWJcIl0pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1wiZXNjYXBlXCJdKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRibHVyR3V0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMubGFuZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5c1tcInVwXCJdKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuYWN0aXZlTGFuZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmb2xkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG1vdmVGb2xkV2lkZ2V0VXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFubm90YXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbW92ZUFubm90YXRpb25VcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1wiZG93blwiXSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZUxhbmUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRtb3ZlRm9sZFdpZGdldERvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFubm90YXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbW92ZUFubm90YXRpb25Eb3duKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleXNbXCJsZWZ0XCJdKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRzd2l0Y2hMYW5lKFwiYW5ub3RhdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1wicmlnaHRcIl0pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuJHN3aXRjaExhbmUoXCJmb2xkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleXNbXCJlbnRlclwiXSB8fCBlLmtleUNvZGUgPT09IGtleXNbXCJzcGFjZVwiXSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZUxhbmUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ndXR0ZXJMYXllci5zZXNzaW9uLmZvbGRXaWRnZXRzW3RoaXMuJHJvd0luZGV4VG9Sb3codGhpcy5hY3RpdmVSb3dJbmRleCldID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93Rm9sZGluZ1dpZGdldCA9IHRoaXMuJHJvd0luZGV4VG9Sb3codGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZXNzaW9uLm9uRm9sZFdpZGdldENsaWNrKHRoaXMuJHJvd0luZGV4VG9Sb3codGhpcy5hY3RpdmVSb3dJbmRleCksIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kcm93SW5kZXhUb1Jvdyh0aGlzLmFjdGl2ZVJvd0luZGV4KSAhPT0gcm93Rm9sZGluZ1dpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRibHVyRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IHRoaXMuJHJvd1RvUm93SW5kZXgocm93Rm9sZGluZ1dpZGdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ3V0dGVyTGF5ZXIuc2Vzc2lvbi5mb2xkV2lkZ2V0c1t0aGlzLiRyb3dJbmRleFRvUm93KHRoaXMuYWN0aXZlUm93SW5kZXgpXSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3V0dGVyRWxlbWVudCA9IHRoaXMubGluZXMuY2VsbHNbdGhpcy5hY3RpdmVSb3dJbmRleF0uZWxlbWVudC5jaGlsZE5vZGVzWzJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGd1dHRlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuYW5ub3RhdGlvblRvb2x0aXAuZ2V0RWxlbWVudCgpLnN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gcmVjdC5yaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudG9wID0gcmVjdC5ib3R0b20gKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvblRvb2x0aXAuc2hvd1Rvb2x0aXAodGhpcy4kcm93SW5kZXhUb1Jvdyh0aGlzLmFjdGl2ZVJvd0luZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRibHVyR3V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVSb3dJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZUxhbmUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRibHVyRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFubm90YXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYmx1ckFubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFubm90YXRpb25Ub29sdGlwLmlzT3BlbilcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvblRvb2x0aXAuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kaXNGb2xkV2lkZ2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaXNSb3dGdWxseVZpc2libGUgPSB0aGlzLmVkaXRvci5pc1Jvd0Z1bGx5VmlzaWJsZSh0aGlzLiRyb3dJbmRleFRvUm93KGluZGV4KSk7XG4gICAgICAgIHZhciBpc0ljb25WaXNpYmxlID0gdGhpcy4kZ2V0Rm9sZFdpZGdldChpbmRleCkuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCI7XG4gICAgICAgIHJldHVybiBpc1Jvd0Z1bGx5VmlzaWJsZSAmJiBpc0ljb25WaXNpYmxlO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kaXNBbm5vdGF0aW9uVmlzaWJsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaXNSb3dGdWxseVZpc2libGUgPSB0aGlzLmVkaXRvci5pc1Jvd0Z1bGx5VmlzaWJsZSh0aGlzLiRyb3dJbmRleFRvUm93KGluZGV4KSk7XG4gICAgICAgIHZhciBpc0ljb25WaXNpYmxlID0gdGhpcy4kZ2V0QW5ub3RhdGlvbihpbmRleCkuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCI7XG4gICAgICAgIHJldHVybiBpc1Jvd0Z1bGx5VmlzaWJsZSAmJiBpc0ljb25WaXNpYmxlO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kZ2V0Rm9sZFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMubGluZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjZWxsLmVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkTm9kZXNbMV07XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRnZXRBbm5vdGF0aW9uID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5saW5lcy5nZXQoaW5kZXgpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGNlbGwuZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2hpbGROb2Rlc1syXTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGZpbmROZWFyZXN0Rm9sZFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy4kaXNGb2xkV2lkZ2V0VmlzaWJsZShpbmRleCkpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IC0gaSA+IDAgfHwgaW5kZXggKyBpIDwgdGhpcy5saW5lcy5nZXRMZW5ndGgoKSAtIDEpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChpbmRleCAtIGkgPj0gMCAmJiB0aGlzLiRpc0ZvbGRXaWRnZXRWaXNpYmxlKGluZGV4IC0gaSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IC0gaTtcbiAgICAgICAgICAgIGlmIChpbmRleCArIGkgPD0gdGhpcy5saW5lcy5nZXRMZW5ndGgoKSAtIDEgJiYgdGhpcy4kaXNGb2xkV2lkZ2V0VmlzaWJsZShpbmRleCArIGkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCArIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRmaW5kTmVhcmVzdEFubm90YXRpb24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzQW5ub3RhdGlvblZpc2libGUoaW5kZXgpKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCAtIGkgPiAwIHx8IGluZGV4ICsgaSA8IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaW5kZXggLSBpID49IDAgJiYgdGhpcy4kaXNBbm5vdGF0aW9uVmlzaWJsZShpbmRleCAtIGkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAtIGk7XG4gICAgICAgICAgICBpZiAoaW5kZXggKyBpIDw9IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCkgLSAxICYmIHRoaXMuJGlzQW5ub3RhdGlvblZpc2libGUoaW5kZXggKyBpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggKyBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kZm9jdXNGb2xkV2lkZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZm9sZFdpZGdldCA9IHRoaXMuJGdldEZvbGRXaWRnZXQoaW5kZXgpO1xuICAgICAgICBmb2xkV2lkZ2V0LmNsYXNzTGlzdC5hZGQodGhpcy5lZGl0b3IucmVuZGVyZXIua2V5Ym9hcmRGb2N1c0NsYXNzTmFtZSk7XG4gICAgICAgIGZvbGRXaWRnZXQuZm9jdXMoKTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGZvY3VzQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGFubm90YXRpb24gPSB0aGlzLiRnZXRBbm5vdGF0aW9uKGluZGV4KTtcbiAgICAgICAgYW5ub3RhdGlvbi5jbGFzc0xpc3QuYWRkKHRoaXMuZWRpdG9yLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICBhbm5vdGF0aW9uLmZvY3VzKCk7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRibHVyRm9sZFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgZm9sZFdpZGdldCA9IHRoaXMuJGdldEZvbGRXaWRnZXQoaW5kZXgpO1xuICAgICAgICBmb2xkV2lkZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5lZGl0b3IucmVuZGVyZXIua2V5Ym9hcmRGb2N1c0NsYXNzTmFtZSk7XG4gICAgICAgIGZvbGRXaWRnZXQuYmx1cigpO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kYmx1ckFubm90YXRpb24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb24gPSB0aGlzLiRnZXRBbm5vdGF0aW9uKGluZGV4KTtcbiAgICAgICAgYW5ub3RhdGlvbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZWRpdG9yLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICBhbm5vdGF0aW9uLmJsdXIoKTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJG1vdmVGb2xkV2lkZ2V0VXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWN0aXZlUm93SW5kZXg7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICBpZiAodGhpcy4kaXNGb2xkV2lkZ2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRibHVyRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9jdXNGb2xkV2lkZ2V0KHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRtb3ZlRm9sZFdpZGdldERvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWN0aXZlUm93SW5kZXg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGlzRm9sZFdpZGdldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYmx1ckZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kbW92ZUFubm90YXRpb25VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5hY3RpdmVSb3dJbmRleDtcbiAgICAgICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRpc0Fubm90YXRpb25WaXNpYmxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGJsdXJBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0Fubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJG1vdmVBbm5vdGF0aW9uRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5hY3RpdmVSb3dJbmRleDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgdGhpcy5saW5lcy5nZXRMZW5ndGgoKSAtIDEpIHtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy4kaXNBbm5vdGF0aW9uVmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRibHVyQW5ub3RhdGlvbih0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9jdXNBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRzd2l0Y2hMYW5lID0gZnVuY3Rpb24gKGRlc2luYXRpb25MYW5lKSB7XG4gICAgICAgIHN3aXRjaCAoZGVzaW5hdGlvbkxhbmUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlTGFuZSA9PT0gXCJhbm5vdGF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uSW5kZXggPSB0aGlzLiRmaW5kTmVhcmVzdEFubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25JbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmUgPSBcImFubm90YXRpb25cIjtcbiAgICAgICAgICAgICAgICB0aGlzLiRibHVyRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gYW5ub3RhdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzQW5ub3RhdGlvbih0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmb2xkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlTGFuZSA9PT0gXCJmb2xkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmb2xkV2lkZ2V0SW5kZXggPSB0aGlzLiRmaW5kTmVhcmVzdEZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRXaWRnZXRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmUgPSBcImZvbGRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLiRibHVyQW5ub3RhdGlvbih0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gZm9sZFdpZGdldEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRyb3dJbmRleFRvUm93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5saW5lcy5nZXQoaW5kZXgpO1xuICAgICAgICBpZiAoY2VsbClcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnJvdztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRyb3dUb1Jvd0luZGV4ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmxpbmVzLmdldChpKTtcbiAgICAgICAgICAgIGlmIChjZWxsLnJvdyA9PSByb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gR3V0dGVyS2V5Ym9hcmRIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuR3V0dGVyS2V5Ym9hcmRIYW5kbGVyID0gR3V0dGVyS2V5Ym9hcmRIYW5kbGVyO1xudmFyIEd1dHRlcktleWJvYXJkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3V0dGVyS2V5Ym9hcmRFdmVudChkb21FdmVudCwgZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyID0gZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyO1xuICAgICAgICB0aGlzLmRvbUV2ZW50ID0gZG9tRXZlbnQ7XG4gICAgfVxuICAgIEd1dHRlcktleWJvYXJkRXZlbnQucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGtleXMua2V5Q29kZVRvU3RyaW5nKHRoaXMuZG9tRXZlbnQua2V5Q29kZSk7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEV2ZW50LnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd1dHRlcktleWJvYXJkSGFuZGxlci4kcm93SW5kZXhUb1Jvdyh0aGlzLmd1dHRlcktleWJvYXJkSGFuZGxlci5hY3RpdmVSb3dJbmRleCk7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEV2ZW50LnByb3RvdHlwZS5pc0luQW5ub3RhdGlvbkxhbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd1dHRlcktleWJvYXJkSGFuZGxlci5hY3RpdmVMYW5lID09PSBcImFubm90YXRpb25cIjtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkRXZlbnQucHJvdG90eXBlLmlzSW5Gb2xkTGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyLmFjdGl2ZUxhbmUgPT09IFwiZm9sZFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEd1dHRlcktleWJvYXJkRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5HdXR0ZXJLZXlib2FyZEV2ZW50ID0gR3V0dGVyS2V5Ym9hcmRFdmVudDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdG9yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi91c2VyYWdlbnRcIixcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcIixcImFjZS9tb3VzZS9tb3VzZV9oYW5kbGVyXCIsXCJhY2UvbW91c2UvZm9sZF9oYW5kbGVyXCIsXCJhY2Uva2V5Ym9hcmQva2V5YmluZGluZ1wiLFwiYWNlL2VkaXRfc2Vzc2lvblwiLFwiYWNlL3NlYXJjaFwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9jb21tYW5kcy9jb21tYW5kX21hbmFnZXJcIixcImFjZS9jb21tYW5kcy9kZWZhdWx0X2NvbW1hbmRzXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvdG9rZW5faXRlcmF0b3JcIixcImFjZS9saW5lX3dpZGdldHNcIixcImFjZS9rZXlib2FyZC9ndXR0ZXJfaGFuZGxlclwiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2NsaXBib2FyZFwiLFwiYWNlL2xpYi9rZXlzXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgdXNlcmFnZW50ID0gcmVxdWlyZShcIi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBUZXh0SW5wdXQgPSByZXF1aXJlKFwiLi9rZXlib2FyZC90ZXh0aW5wdXRcIikuVGV4dElucHV0O1xudmFyIE1vdXNlSGFuZGxlciA9IHJlcXVpcmUoXCIuL21vdXNlL21vdXNlX2hhbmRsZXJcIikuTW91c2VIYW5kbGVyO1xudmFyIEZvbGRIYW5kbGVyID0gcmVxdWlyZShcIi4vbW91c2UvZm9sZF9oYW5kbGVyXCIpLkZvbGRIYW5kbGVyO1xudmFyIEtleUJpbmRpbmcgPSByZXF1aXJlKFwiLi9rZXlib2FyZC9rZXliaW5kaW5nXCIpLktleUJpbmRpbmc7XG52YXIgRWRpdFNlc3Npb24gPSByZXF1aXJlKFwiLi9lZGl0X3Nlc3Npb25cIikuRWRpdFNlc3Npb247XG52YXIgU2VhcmNoID0gcmVxdWlyZShcIi4vc2VhcmNoXCIpLlNlYXJjaDtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBDb21tYW5kTWFuYWdlciA9IHJlcXVpcmUoXCIuL2NvbW1hbmRzL2NvbW1hbmRfbWFuYWdlclwiKS5Db21tYW5kTWFuYWdlcjtcbnZhciBkZWZhdWx0Q29tbWFuZHMgPSByZXF1aXJlKFwiLi9jb21tYW5kcy9kZWZhdWx0X2NvbW1hbmRzXCIpLmNvbW1hbmRzO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbnZhciBUb2tlbkl0ZXJhdG9yID0gcmVxdWlyZShcIi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbnZhciBMaW5lV2lkZ2V0cyA9IHJlcXVpcmUoXCIuL2xpbmVfd2lkZ2V0c1wiKS5MaW5lV2lkZ2V0cztcbnZhciBHdXR0ZXJLZXlib2FyZEhhbmRsZXIgPSByZXF1aXJlKFwiLi9rZXlib2FyZC9ndXR0ZXJfaGFuZGxlclwiKS5HdXR0ZXJLZXlib2FyZEhhbmRsZXI7XG52YXIgbmxzID0gcmVxdWlyZShcIi4vY29uZmlnXCIpLm5scztcbnZhciBjbGlwYm9hcmQgPSByZXF1aXJlKFwiLi9jbGlwYm9hcmRcIik7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMnKTtcbnZhciBFZGl0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRpdG9yKHJlbmRlcmVyLCBzZXNzaW9uLCBvcHRpb25zKSB7IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdGhpcy4kdG9EZXN0cm95ID0gW107XG4gICAgICAgIHZhciBjb250YWluZXIgPSByZW5kZXJlci5nZXRDb250YWluZXJFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaWQgPSBcImVkaXRvclwiICsgKCsrRWRpdG9yLiR1aWQpO1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gbmV3IENvbW1hbmRNYW5hZ2VyKHVzZXJhZ2VudC5pc01hYyA/IFwibWFjXCIgOiBcIndpblwiLCBkZWZhdWx0Q29tbWFuZHMpO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dElucHV0ID0gbmV3IFRleHRJbnB1dChyZW5kZXJlci5nZXRUZXh0QXJlYUNvbnRhaW5lcigpLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dGFyZWEgPSB0aGlzLnRleHRJbnB1dC5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLiRtb3VzZUhhbmRsZXIgPSBuZXcgTW91c2VIYW5kbGVyKHRoaXMpO1xuICAgICAgICAgICAgbmV3IEZvbGRIYW5kbGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5QmluZGluZyA9IG5ldyBLZXlCaW5kaW5nKHRoaXMpO1xuICAgICAgICB0aGlzLiRzZWFyY2ggPSBuZXcgU2VhcmNoKCkuc2V0KHtcbiAgICAgICAgICAgIHdyYXA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGhpc3RvcnlUcmFja2VyID0gdGhpcy4kaGlzdG9yeVRyYWNrZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5vbihcImV4ZWNcIiwgdGhpcy4kaGlzdG9yeVRyYWNrZXIpO1xuICAgICAgICB0aGlzLiRpbml0T3BlcmF0aW9uTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuXyRlbWl0SW5wdXRFdmVudCA9IGxhbmcuZGVsYXllZENhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiaW5wdXRcIiwge30pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiAmJiAhdGhpcy5zZXNzaW9uLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uYmdUb2tlbml6ZXIuc2NoZWR1bGVTdGFydCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChfLCBfc2VsZikge1xuICAgICAgICAgICAgX3NlbGYuXyRlbWl0SW5wdXRFdmVudC5zY2hlZHVsZSgzMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFNlc3Npb24oc2Vzc2lvbiB8fCBvcHRpb25zICYmIG9wdGlvbnMuc2Vzc2lvbiB8fCBuZXcgRWRpdFNlc3Npb24oXCJcIikpO1xuICAgICAgICBjb25maWcucmVzZXRPcHRpb25zKHRoaXMpO1xuICAgICAgICBpZiAob3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uZmlnLl9zaWduYWwoXCJlZGl0b3JcIiwgdGhpcyk7XG4gICAgfVxuICAgIEVkaXRvci5wcm90b3R5cGUuJGluaXRPcGVyYXRpb25MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMub24oXCJleGVjXCIsIHRoaXMuc3RhcnRPcGVyYXRpb24uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tbWFuZHMub24oXCJhZnRlckV4ZWNcIiwgdGhpcy5lbmRPcGVyYXRpb24uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuJG9wUmVzZXRUaW1lciA9IGxhbmcuZGVsYXllZENhbGwodGhpcy5lbmRPcGVyYXRpb24uYmluZCh0aGlzLCB0cnVlKSk7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1ck9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VyT3Auc2VsZWN0aW9uQmVmb3JlID0gdGhpcy4kbGFzdFNlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VyT3AuZG9jQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1ck9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VyT3Auc2VsZWN0aW9uQmVmb3JlID0gdGhpcy4kbGFzdFNlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnN0YXJ0T3BlcmF0aW9uID0gZnVuY3Rpb24gKGNvbW1hbmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5jdXJPcCkge1xuICAgICAgICAgICAgaWYgKCFjb21tYW5kRXZlbnQgfHwgdGhpcy5jdXJPcC5jb21tYW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucHJldk9wID0gdGhpcy5jdXJPcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbW1hbmRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgICAgICAgICAgY29tbWFuZEV2ZW50ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kb3BSZXNldFRpbWVyLnNjaGVkdWxlKCk7XG4gICAgICAgIHRoaXMuY3VyT3AgPSB0aGlzLnNlc3Npb24uY3VyT3AgPSB7XG4gICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kRXZlbnQuY29tbWFuZCB8fCB7fSxcbiAgICAgICAgICAgIGFyZ3M6IGNvbW1hbmRFdmVudC5hcmdzLFxuICAgICAgICAgICAgc2Nyb2xsVG9wOiB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmN1ck9wLnNlbGVjdGlvbkJlZm9yZSA9IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5lbmRPcGVyYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJPcCAmJiB0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChlICYmIGUucmV0dXJuVmFsdWUgPT09IGZhbHNlIHx8ICF0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmN1ck9wID0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoZSA9PSB0cnVlICYmIHRoaXMuY3VyT3AuY29tbWFuZCAmJiB0aGlzLmN1ck9wLmNvbW1hbmQubmFtZSA9PSBcIm1vdXNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYmVmb3JlRW5kT3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1ck9wKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gdGhpcy5jdXJPcC5jb21tYW5kO1xuICAgICAgICAgICAgdmFyIHNjcm9sbEludG9WaWV3ID0gY29tbWFuZCAmJiBjb21tYW5kLnNjcm9sbEludG9WaWV3O1xuICAgICAgICAgICAgaWYgKHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2VudGVyLWFuaW1hdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3ID0gXCJhbmltYXRlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5pbWF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY3Vyc29yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGlvblBhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5yZW5kZXJlci5sYXllckNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPj0gY29uZmlnLmxhc3RSb3cgfHwgcmFuZ2UuZW5kLnJvdyA8PSBjb25maWcuZmlyc3RSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFNlbGVjdGlvbkludG9WaWV3KHRoaXMuc2VsZWN0aW9uLmFuY2hvciwgdGhpcy5zZWxlY3Rpb24ubGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSW50b1ZpZXcgPT0gXCJhbmltYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYW5pbWF0ZVNjcm9sbGluZyh0aGlzLmN1ck9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsID0gdGhpcy5zZWxlY3Rpb24udG9KU09OKCk7XG4gICAgICAgICAgICB0aGlzLmN1ck9wLnNlbGVjdGlvbkFmdGVyID0gc2VsO1xuICAgICAgICAgICAgdGhpcy4kbGFzdFNlbCA9IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuYWRkU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICB0aGlzLnByZXZPcCA9IHRoaXMuY3VyT3A7XG4gICAgICAgICAgICB0aGlzLmN1ck9wID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS4kaGlzdG9yeVRyYWNrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuJG1lcmdlVW5kb0RlbHRhcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZPcDtcbiAgICAgICAgdmFyIG1lcmdlYWJsZUNvbW1hbmRzID0gdGhpcy4kbWVyZ2VhYmxlQ29tbWFuZHM7XG4gICAgICAgIHZhciBzaG91bGRNZXJnZSA9IHByZXYuY29tbWFuZCAmJiAoZS5jb21tYW5kLm5hbWUgPT0gcHJldi5jb21tYW5kLm5hbWUpO1xuICAgICAgICBpZiAoZS5jb21tYW5kLm5hbWUgPT0gXCJpbnNlcnRzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBlLmFyZ3M7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXJnZU5leHRDb21tYW5kID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZU5leHRDb21tYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHNob3VsZE1lcmdlID0gc2hvdWxkTWVyZ2VcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm1lcmdlTmV4dENvbW1hbmQgLy8gcHJldmlvdXMgY29tbWFuZCBhbGxvd3MgdG8gY29hbGVzY2Ugd2l0aFxuICAgICAgICAgICAgICAgICYmICghL1xccy8udGVzdCh0ZXh0KSB8fCAvXFxzLy50ZXN0KHByZXYuYXJncykpOyAvLyBwcmV2aW91cyBpbnNlcnRpb24gd2FzIG9mIHNhbWUgdHlwZVxuICAgICAgICAgICAgdGhpcy5tZXJnZU5leHRDb21tYW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNob3VsZE1lcmdlID0gc2hvdWxkTWVyZ2VcbiAgICAgICAgICAgICAgICAmJiBtZXJnZWFibGVDb21tYW5kcy5pbmRleE9mKGUuY29tbWFuZC5uYW1lKSAhPT0gLTE7IC8vIHRoZSBjb21tYW5kIGlzIG1lcmdlYWJsZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRtZXJnZVVuZG9EZWx0YXMgIT0gXCJhbHdheXNcIlxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHRoaXMuc2VxdWVuY2VTdGFydFRpbWUgPiAyMDAwKSB7XG4gICAgICAgICAgICBzaG91bGRNZXJnZSA9IGZhbHNlOyAvLyB0aGUgc2VxdWVuY2UgaXMgdG9vIGxvbmdcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVyZ2UpXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ubWVyZ2VVbmRvRGVsdGFzID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAobWVyZ2VhYmxlQ29tbWFuZHMuaW5kZXhPZihlLmNvbW1hbmQubmFtZSkgIT09IC0xKVxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uIChrZXlib2FyZEhhbmRsZXIsIGNiKSB7XG4gICAgICAgIGlmIChrZXlib2FyZEhhbmRsZXIgJiYgdHlwZW9mIGtleWJvYXJkSGFuZGxlciA9PT0gXCJzdHJpbmdcIiAmJiBrZXlib2FyZEhhbmRsZXIgIT0gXCJhY2VcIikge1xuICAgICAgICAgICAgdGhpcy4ka2V5YmluZGluZ0lkID0ga2V5Ym9hcmRIYW5kbGVyO1xuICAgICAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFtcImtleWJpbmRpbmdcIiwga2V5Ym9hcmRIYW5kbGVyXSwgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChfc2VsZi4ka2V5YmluZGluZ0lkID09IGtleWJvYXJkSGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYua2V5QmluZGluZy5zZXRLZXlib2FyZEhhbmRsZXIobW9kdWxlICYmIG1vZHVsZS5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRrZXliaW5kaW5nSWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5rZXlCaW5kaW5nLnNldEtleWJvYXJkSGFuZGxlcihrZXlib2FyZEhhbmRsZXIpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUJpbmRpbmcuZ2V0S2V5Ym9hcmRIYW5kbGVyKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uID09IHNlc3Npb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmN1ck9wKVxuICAgICAgICAgICAgdGhpcy5lbmRPcGVyYXRpb24oKTtcbiAgICAgICAgdGhpcy5jdXJPcCA9IHt9O1xuICAgICAgICB2YXIgb2xkU2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKG9sZFNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VcIiwgdGhpcy4kb25Eb2N1bWVudENoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlTW9kZVwiLCB0aGlzLiRvbkNoYW5nZU1vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcInRva2VuaXplclVwZGF0ZVwiLCB0aGlzLiRvblRva2VuaXplclVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlVGFiU2l6ZVwiLCB0aGlzLiRvbkNoYW5nZVRhYlNpemUpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZVdyYXBMaW1pdFwiLCB0aGlzLiRvbkNoYW5nZVdyYXBMaW1pdCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlV3JhcE1vZGVcIiwgdGhpcy4kb25DaGFuZ2VXcmFwTW9kZSk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlRm9sZFwiLCB0aGlzLiRvbkNoYW5nZUZvbGQpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZUZyb250TWFya2VyXCIsIHRoaXMuJG9uQ2hhbmdlRnJvbnRNYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZUJhY2tNYXJrZXJcIiwgdGhpcy4kb25DaGFuZ2VCYWNrTWFya2VyKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHRoaXMuJG9uQ2hhbmdlQnJlYWtwb2ludCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlQW5ub3RhdGlvblwiLCB0aGlzLiRvbkNoYW5nZUFubm90YXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZU92ZXJ3cml0ZVwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlU2Nyb2xsVG9wXCIsIHRoaXMuJG9uU2Nyb2xsVG9wQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VTY3JvbGxMZWZ0XCIsIHRoaXMuJG9uU2Nyb2xsTGVmdENoYW5nZSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZXNzaW9uLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLm9mZihcImNoYW5nZUN1cnNvclwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgICAgICAgICBzZWxlY3Rpb24ub2ZmKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy4kb25Eb2N1bWVudENoYW5nZSA9IHRoaXMub25Eb2N1bWVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbihcImNoYW5nZVwiLCB0aGlzLiRvbkRvY3VtZW50Q2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSA9IHRoaXMub25DaGFuZ2VNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlTW9kZVwiLCB0aGlzLiRvbkNoYW5nZU1vZGUpO1xuICAgICAgICAgICAgdGhpcy4kb25Ub2tlbml6ZXJVcGRhdGUgPSB0aGlzLm9uVG9rZW5pemVyVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwidG9rZW5pemVyVXBkYXRlXCIsIHRoaXMuJG9uVG9rZW5pemVyVXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlVGFiU2l6ZSA9IHRoaXMucmVuZGVyZXIub25DaGFuZ2VUYWJTaXplLmJpbmQodGhpcy5yZW5kZXJlcik7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlVGFiU2l6ZVwiLCB0aGlzLiRvbkNoYW5nZVRhYlNpemUpO1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VXcmFwTGltaXQgPSB0aGlzLm9uQ2hhbmdlV3JhcExpbWl0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlV3JhcExpbWl0XCIsIHRoaXMuJG9uQ2hhbmdlV3JhcExpbWl0KTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlV3JhcE1vZGUgPSB0aGlzLm9uQ2hhbmdlV3JhcE1vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oXCJjaGFuZ2VXcmFwTW9kZVwiLCB0aGlzLiRvbkNoYW5nZVdyYXBNb2RlKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlRm9sZCA9IHRoaXMub25DaGFuZ2VGb2xkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlRm9sZFwiLCB0aGlzLiRvbkNoYW5nZUZvbGQpO1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VGcm9udE1hcmtlciA9IHRoaXMub25DaGFuZ2VGcm9udE1hcmtlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlRnJvbnRNYXJrZXJcIiwgdGhpcy4kb25DaGFuZ2VGcm9udE1hcmtlcik7XG4gICAgICAgICAgICB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIgPSB0aGlzLm9uQ2hhbmdlQmFja01hcmtlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlQmFja01hcmtlclwiLCB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50ID0gdGhpcy5vbkNoYW5nZUJyZWFrcG9pbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZUJyZWFrcG9pbnRcIiwgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50KTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlQW5ub3RhdGlvbiA9IHRoaXMub25DaGFuZ2VBbm5vdGF0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJjaGFuZ2VBbm5vdGF0aW9uXCIsIHRoaXMuJG9uQ2hhbmdlQW5ub3RhdGlvbik7XG4gICAgICAgICAgICB0aGlzLiRvbkN1cnNvckNoYW5nZSA9IHRoaXMub25DdXJzb3JDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZU92ZXJ3cml0ZVwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSA9IHRoaXMub25TY3JvbGxUb3BDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZVNjcm9sbFRvcFwiLCB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLiRvblNjcm9sbExlZnRDaGFuZ2UgPSB0aGlzLm9uU2Nyb2xsTGVmdENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlU2Nyb2xsTGVmdFwiLCB0aGlzLiRvblNjcm9sbExlZnRDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZXNzaW9uLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ub24oXCJjaGFuZ2VDdXJzb3JcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy4kb25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5vbihcImNoYW5nZVNlbGVjdGlvblwiLCB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlTW9kZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkN1cnNvckNoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5vblNjcm9sbFRvcENoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5vblNjcm9sbExlZnRDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VGcm9udE1hcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUJhY2tNYXJrZXIoKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VCcmVha3BvaW50KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVzZVdyYXBNb2RlKCkgJiYgdGhpcy5yZW5kZXJlci5hZGp1c3RXcmFwTGltaXQoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlc3Npb25cIiwge1xuICAgICAgICAgICAgc2Vzc2lvbjogc2Vzc2lvbixcbiAgICAgICAgICAgIG9sZFNlc3Npb246IG9sZFNlc3Npb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VyT3AgPSBudWxsO1xuICAgICAgICBvbGRTZXNzaW9uICYmIG9sZFNlc3Npb24uX3NpZ25hbChcImNoYW5nZUVkaXRvclwiLCB7IG9sZEVkaXRvcjogdGhpcyB9KTtcbiAgICAgICAgc2Vzc2lvbiAmJiBzZXNzaW9uLl9zaWduYWwoXCJjaGFuZ2VFZGl0b3JcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgICAgIGlmIChzZXNzaW9uICYmICFzZXNzaW9uLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHNlc3Npb24uYmdUb2tlbml6ZXIuc2NoZWR1bGVTdGFydCgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIGN1cnNvclBvcykge1xuICAgICAgICB0aGlzLnNlc3Npb24uZG9jLnNldFZhbHVlKHZhbCk7XG4gICAgICAgIGlmICghY3Vyc29yUG9zKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yUG9zID09IDEpXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlRmlsZUVuZCgpO1xuICAgICAgICBlbHNlIGlmIChjdXJzb3JQb3MgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlRmlsZVN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFZhbHVlKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vblJlc2l6ZShmb3JjZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lLCBjYikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFRoZW1lKHRoZW1lLCBjYik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRUaGVtZSgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUudW5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVuc2V0U3R5bGUoc3R5bGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRGb250U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZm9udFNpemVcIikgfHxcbiAgICAgICAgICAgIGRvbS5jb21wdXRlZFN0eWxlKHRoaXMuY29udGFpbmVyKS5mb250U2l6ZTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0Rm9udFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImZvbnRTaXplXCIsIHNpemUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS4kaGlnaGxpZ2h0QnJhY2tldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRQZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRoaWdobGlnaHRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLiRoaWdobGlnaHRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHNlbGYuc2Vzc2lvbjtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCBzZXNzaW9uLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uJGJyYWNrZXRIaWdobGlnaHQubWFya2VySWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLiRicmFja2V0SGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWxmLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHNlbGYuZ2V0S2V5Ym9hcmRIYW5kbGVyKCk7XG4gICAgICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSBoYW5kbGVyICYmIGhhbmRsZXIuJGdldERpcmVjdGlvbkZvckhpZ2hsaWdodCAmJiBoYW5kbGVyLiRnZXREaXJlY3Rpb25Gb3JIaWdobGlnaHQoc2VsZik7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2Vzc2lvbi5nZXRNYXRjaGluZ0JyYWNrZXRSYW5nZXMocG9zLCBpc0JhY2t3YXJkcyk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAmJiAvXFxiKD86dGFnLW9wZW58dGFnLW5hbWUpLy50ZXN0KHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lc1JhbmdlcyA9IHNlc3Npb24uZ2V0TWF0Y2hpbmdUYWdzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lc1Jhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWVzUmFuZ2VzLm9wZW5UYWdOYW1lLmlzRW1wdHkoKSA/IHRhZ05hbWVzUmFuZ2VzLm9wZW5UYWcgOiB0YWdOYW1lc1Jhbmdlcy5vcGVuVGFnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lc1Jhbmdlcy5jbG9zZVRhZ05hbWUuaXNFbXB0eSgpID8gdGFnTmFtZXNSYW5nZXMuY2xvc2VUYWcgOiB0YWdOYW1lc1Jhbmdlcy5jbG9zZVRhZ05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJhbmdlcyAmJiBzZXNzaW9uLiRtb2RlLmdldE1hdGNoaW5nKVxuICAgICAgICAgICAgICAgIHJhbmdlcyA9IHNlc3Npb24uJG1vZGUuZ2V0TWF0Y2hpbmcoc2VsZi5zZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyZXIuJHRleHRMYXllci4kaGlnaGxpZ2h0SW5kZW50R3VpZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWFya2VyVHlwZSA9IFwiYWNlX2JyYWNrZXRcIjtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzID0gW3Jhbmdlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJUeXBlID0gXCJhY2VfZXJyb3JfYnJhY2tldFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChSYW5nZS5jb21wYXJlUG9pbnRzKHJhbmdlc1swXS5lbmQsIHJhbmdlc1sxXS5zdGFydCkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gW1JhbmdlLmZyb21Qb2ludHMocmFuZ2VzWzBdLnN0YXJ0LCByYW5nZXNbMV0uZW5kKV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUmFuZ2UuY29tcGFyZVBvaW50cyhyYW5nZXNbMF0uc3RhcnQsIHJhbmdlc1sxXS5lbmQpID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IFtSYW5nZS5mcm9tUG9pbnRzKHJhbmdlc1sxXS5zdGFydCwgcmFuZ2VzWzBdLmVuZCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCA9IHtcbiAgICAgICAgICAgICAgICByYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgICAgICBtYXJrZXJJZHM6IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgbWFya2VyVHlwZSwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNlbGYuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKCkpXG4gICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJlci4kdGV4dExheWVyLiRoaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRleHRJbnB1dC5mb2N1cygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5pc0ZvY3VzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRJbnB1dC5pc0ZvY3VzZWQoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZXh0SW5wdXQuYmx1cigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzRm9jdXNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaG93Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudmlzdWFsaXplRm9jdXMoKTtcbiAgICAgICAgdGhpcy5fZW1pdChcImZvY3VzXCIsIGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuJGlzRm9jdXNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaGlkZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnZpc3VhbGl6ZUJsdXIoKTtcbiAgICAgICAgdGhpcy5fZW1pdChcImJsdXJcIiwgZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRjdXJzb3JDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMuJGhpZ2hsaWdodEJyYWNrZXRzKCk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25Eb2N1bWVudENoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgd3JhcCA9IHRoaXMuc2Vzc2lvbi4kdXNlV3JhcE1vZGU7XG4gICAgICAgIHZhciBsYXN0Um93ID0gKGRlbHRhLnN0YXJ0LnJvdyA9PSBkZWx0YS5lbmQucm93ID8gZGVsdGEuZW5kLnJvdyA6IEluZmluaXR5KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVMaW5lcyhkZWx0YS5zdGFydC5yb3csIGxhc3RSb3csIHdyYXApO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwgZGVsdGEpO1xuICAgICAgICB0aGlzLiRjdXJzb3JDaGFuZ2UoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25Ub2tlbml6ZXJVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcm93cyA9IGUuZGF0YTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVMaW5lcyhyb3dzLmZpcnN0LCByb3dzLmxhc3QpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vblNjcm9sbFRvcENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1kodGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25TY3JvbGxMZWZ0Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvWCh0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25DdXJzb3JDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGN1cnNvckNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0O1xuICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0QWN0aXZlTGluZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGlvblN0eWxlICE9IFwibGluZVwiIHx8ICF0aGlzLnNlbGVjdGlvbi5pc011bHRpTGluZSgpKVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnRoZW1lICYmIHRoaXMucmVuZGVyZXIudGhlbWUuJHNlbGVjdGlvbkNvbG9yQ29uZmxpY3QgJiYgIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLiRtYXhMaW5lcyAmJiB0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkgPT09IDEgJiYgISh0aGlzLnJlbmRlcmVyLiRtaW5MaW5lcyA+IDEpKVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyICYmICFoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuaWQpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIgJiYgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoaGlnaGxpZ2h0LnJvdywgaGlnaGxpZ2h0LmNvbHVtbiwgaGlnaGxpZ2h0LnJvdywgSW5maW5pdHkpO1xuICAgICAgICAgICAgcmFuZ2UuaWQgPSBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXCJhY2VfYWN0aXZlLWxpbmVcIiwgXCJzY3JlZW5MaW5lXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlciA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlci5zdGFydC5yb3cgPSBoaWdobGlnaHQucm93O1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlci5lbmQucm93ID0gaGlnaGxpZ2h0LnJvdztcbiAgICAgICAgICAgIHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuc3RhcnQuY29sdW1uID0gaGlnaGxpZ2h0LmNvbHVtbjtcbiAgICAgICAgICAgIHNlc3Npb24uX3NpZ25hbChcImNoYW5nZUJhY2tNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25TZWxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGUoKTtcbiAgICAgICAgICAgIHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlciA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9zZWxlY3Rpb25cIiwgc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlSGlnaGxpZ2h0QWN0aXZlTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZSA9IHRoaXMuJGhpZ2hsaWdodFNlbGVjdGVkV29yZCAmJiB0aGlzLiRnZXRTZWxlY3Rpb25IaWdoTGlnaHRSZWdleHAoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmhpZ2hsaWdodChyZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGdldFNlbGVjdGlvbkhpZ2hMaWdodFJlZ2V4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uaXNFbXB0eSgpIHx8IHNlbGVjdGlvbi5pc011bHRpTGluZSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBzZWxlY3Rpb24uc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2VsZWN0aW9uLmVuZC5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHNlbGVjdGlvbi5zdGFydC5yb3cpO1xuICAgICAgICB2YXIgbmVlZGxlID0gbGluZS5zdWJzdHJpbmcoc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgICAgIGlmIChuZWVkbGUubGVuZ3RoID4gNTAwMCB8fCAhL1tcXHdcXGRdLy50ZXN0KG5lZWRsZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByZSA9IHRoaXMuJHNlYXJjaC4kYXNzZW1ibGVSZWdFeHAoe1xuICAgICAgICAgICAgd2hvbGVXb3JkOiB0cnVlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5lZWRsZTogbmVlZGxlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgd29yZFdpdGhCb3VuZGFyeSA9IGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uIC0gMSwgZW5kQ29sdW1uICsgMSk7XG4gICAgICAgIGlmICghcmUudGVzdCh3b3JkV2l0aEJvdW5kYXJ5KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHJlO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZUZyb250TWFya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUZyb250TWFya2VycygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZUJhY2tNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25DaGFuZ2VCcmVha3BvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJyZWFrcG9pbnRzKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ2hhbmdlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbm5vdGF0aW9ucyh0aGlzLnNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ2hhbmdlTW9kZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlTW9kZVwiLCBlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25DaGFuZ2VXcmFwTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZVdyYXBNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uUmVzaXplKHRydWUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZUZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVGdWxsKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0Q29weVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICAgICAgdmFyIG5sID0gdGhpcy5zZXNzaW9uLmRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCk7XG4gICAgICAgIHZhciBjb3B5TGluZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRleHQgJiYgdGhpcy4kY29weVdpdGhFbXB0eVNlbGVjdGlvbikge1xuICAgICAgICAgICAgY29weUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgJiYgcmFuZ2VzW2kgLSAxXS5zdGFydC5yb3cgPT0gcmFuZ2Uuc3RhcnQucm93KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdykgKyBubDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZSA9IHsgdGV4dDogdGV4dCB9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjb3B5XCIsIGUpO1xuICAgICAgICBjbGlwYm9hcmQubGluZU1vZGUgPSBjb3B5TGluZSA/IGUudGV4dCA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gZS50ZXh0O1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImNvcHlcIiwgdGhpcyk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJjdXRcIiwgdGhpcyk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uUGFzdGUgPSBmdW5jdGlvbiAodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGUgPSB7IHRleHQ6IHRleHQsIGV2ZW50OiBldmVudCB9O1xuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJwYXN0ZVwiLCB0aGlzLCBlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGhhbmRsZVBhc3RlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBlID0geyB0ZXh0OiBlIH07XG4gICAgICAgIHRoaXMuX3NpZ25hbChcInBhc3RlXCIsIGUpO1xuICAgICAgICB2YXIgdGV4dCA9IGUudGV4dDtcbiAgICAgICAgdmFyIGxpbmVNb2RlID0gdGV4dCA9PT0gY2xpcGJvYXJkLmxpbmVNb2RlO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKCF0aGlzLmluTXVsdGlTZWxlY3RNb2RlIHx8IHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgaWYgKGxpbmVNb2RlKVxuICAgICAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHsgcm93OiB0aGlzLnNlbGVjdGlvbi5sZWFkLnJvdywgY29sdW1uOiAwIH0sIHRleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQoeyByb3c6IHJhbmdlLnN0YXJ0LnJvdywgY29sdW1uOiAwIH0sIHRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZXM7XG4gICAgICAgICAgICB2YXIgaXNGdWxsTGluZSA9IGxpbmVzLmxlbmd0aCA9PSAyICYmICghbGluZXNbMF0gfHwgIWxpbmVzWzFdKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggIT0gcmFuZ2VzLmxlbmd0aCB8fCBpc0Z1bGxMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRzdHJpbmdcIiwgdGhpcywgdGV4dCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHJhbmdlLnN0YXJ0LCBsaW5lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5leGVjKGNvbW1hbmQsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodGV4dCwgcGFzdGVkKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgbW9kZSA9IHNlc3Npb24uZ2V0TW9kZSgpO1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5nZXRCZWhhdmlvdXJzRW5hYmxlZCgpICYmICFwYXN0ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtb2RlLnRyYW5zZm9ybUFjdGlvbihzZXNzaW9uLmdldFN0YXRlKGN1cnNvci5yb3cpLCAnaW5zZXJ0aW9uJywgdGhpcywgc2Vzc2lvbiwgdGV4dCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQgIT09IHRyYW5zZm9ybS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ubWVyZ2VVbmRvRGVsdGFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlTmV4dENvbW1hbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdHJhbnNmb3JtLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQgPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlc3Npb24uZ2V0T3ZlcndyaXRlKCkgJiYgdGV4dC5pbmRleE9mKFwiXFxuXCIpID09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGN1cnNvciwgY3Vyc29yKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCA9PSBcIlxcblwiIHx8IHRleHQgPT0gXCJcXHJcXG5cIikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLmNvbHVtbiA+IGxpbmUuc2VhcmNoKC9cXFN8JC8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBsaW5lLnN1YnN0cihjdXJzb3IuY29sdW1uKS5zZWFyY2goL1xcU3wkLyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5kb2MucmVtb3ZlSW5MaW5lKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBzdGFydCA9IGN1cnNvci5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lU3RhdGUgPSBzZXNzaW9uLmdldFN0YXRlKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgdmFyIHNob3VsZE91dGRlbnQgPSBtb2RlLmNoZWNrT3V0ZGVudChsaW5lU3RhdGUsIGxpbmUsIHRleHQpO1xuICAgICAgICBzZXNzaW9uLmluc2VydChjdXJzb3IsIHRleHQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0uc2VsZWN0aW9uLmxlbmd0aCA9PSAyKSB7IC8vIFRyYW5zZm9ybSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjb2x1bW5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShuZXcgUmFuZ2UoY3Vyc29yLnJvdywgc3RhcnQgKyB0cmFuc2Zvcm0uc2VsZWN0aW9uWzBdLCBjdXJzb3Iucm93LCBzdGFydCArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBUcmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm93LlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKG5ldyBSYW5nZShjdXJzb3Iucm93ICsgdHJhbnNmb3JtLnNlbGVjdGlvblswXSwgdHJhbnNmb3JtLnNlbGVjdGlvblsxXSwgY3Vyc29yLnJvdyArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMl0sIHRyYW5zZm9ybS5zZWxlY3Rpb25bM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kZW5hYmxlQXV0b0luZGVudCkge1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uZ2V0RG9jdW1lbnQoKS5pc05ld0xpbmUodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZUluZGVudCA9IG1vZGUuZ2V0TmV4dExpbmVJbmRlbnQobGluZVN0YXRlLCBsaW5lLnNsaWNlKDAsIGN1cnNvci5jb2x1bW4pLCBzZXNzaW9uLmdldFRhYlN0cmluZygpKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmluc2VydCh7IHJvdzogY3Vyc29yLnJvdyArIDEsIGNvbHVtbjogMCB9LCBsaW5lSW5kZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRPdXRkZW50KVxuICAgICAgICAgICAgICAgIG1vZGUuYXV0b091dGRlbnQobGluZVN0YXRlLCBzZXNzaW9uLCBjdXJzb3Iucm93KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5hdXRvSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIG1vZGUgPSBzZXNzaW9uLmdldE1vZGUoKTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKVxuICAgICAgICAgICAgPyBbbmV3IFJhbmdlKDAsIDAsIHNlc3Npb24uZG9jLmdldExlbmd0aCgpIC0gMSwgMCldXG4gICAgICAgICAgICA6IHRoaXMuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpO1xuICAgICAgICB2YXIgcHJldkxpbmVTdGF0ZSA9IFwiXCI7XG4gICAgICAgIHZhciBwcmV2TGluZSA9IFwiXCI7XG4gICAgICAgIHZhciBsaW5lSW5kZW50ID0gXCJcIjtcbiAgICAgICAgdmFyIHRhYiA9IHNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSByYW5nZXNbaV0uc3RhcnQucm93O1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHJhbmdlc1tpXS5lbmQucm93O1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnRSb3c7IHJvdyA8PSBlbmRSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkxpbmVTdGF0ZSA9IHNlc3Npb24uZ2V0U3RhdGUocm93IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZMaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lSW5kZW50ID0gbW9kZS5nZXROZXh0TGluZUluZGVudChwcmV2TGluZVN0YXRlLCBwcmV2TGluZSwgdGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckluZGVudCA9IG1vZGUuJGdldEluZGVudChsaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUluZGVudCAhPT0gY3VyckluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckluZGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCAwLCByb3csIGN1cnJJbmRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUluZGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmluc2VydCh7IHJvdzogcm93LCBjb2x1bW46IDAgfSwgbGluZUluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kZS5hdXRvT3V0ZGVudChwcmV2TGluZVN0YXRlLCBzZXNzaW9uLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uVGV4dElucHV0ID0gZnVuY3Rpb24gKHRleHQsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghY29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlCaW5kaW5nLm9uVGV4dElucHV0KHRleHQpO1xuICAgICAgICB0aGlzLnN0YXJ0T3BlcmF0aW9uKHsgY29tbWFuZDogeyBuYW1lOiBcImluc2VydHN0cmluZ1wiIH0gfSk7XG4gICAgICAgIHZhciBhcHBseUNvbXBvc2l0aW9uID0gdGhpcy5hcHBseUNvbXBvc2l0aW9uLmJpbmQodGhpcywgdGV4dCwgY29tcG9zaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24ucmFuZ2VDb3VudClcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaFNlbGVjdGlvbihhcHBseUNvbXBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXBwbHlDb21wb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmVuZE9wZXJhdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5hcHBseUNvbXBvc2l0aW9uID0gZnVuY3Rpb24gKHRleHQsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGlvbi5leHRlbmRMZWZ0IHx8IGNvbXBvc2l0aW9uLmV4dGVuZFJpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiAtPSBjb21wb3NpdGlvbi5leHRlbmRMZWZ0O1xuICAgICAgICAgICAgci5lbmQuY29sdW1uICs9IGNvbXBvc2l0aW9uLmV4dGVuZFJpZ2h0O1xuICAgICAgICAgICAgaWYgKHIuc3RhcnQuY29sdW1uIDwgMCkge1xuICAgICAgICAgICAgICAgIHIuc3RhcnQucm93LS07XG4gICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gKz0gdGhpcy5zZXNzaW9uLmdldExpbmUoci5zdGFydC5yb3cpLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyKTtcbiAgICAgICAgICAgIGlmICghdGV4dCAmJiAhci5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCB8fCAhdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5pbnNlcnQodGV4dCwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb21wb3NpdGlvbi5yZXN0b3JlU3RhcnQgfHwgY29tcG9zaXRpb24ucmVzdG9yZUVuZCkge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gLT0gY29tcG9zaXRpb24ucmVzdG9yZVN0YXJ0O1xuICAgICAgICAgICAgci5lbmQuY29sdW1uIC09IGNvbXBvc2l0aW9uLnJlc3RvcmVFbmQ7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvbW1hbmRLZXkgPSBmdW5jdGlvbiAoZSwgaGFzaElkLCBrZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUJpbmRpbmcub25Db21tYW5kS2V5KGUsIGhhc2hJZCwga2V5Q29kZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChvdmVyd3JpdGUpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldE92ZXJ3cml0ZShvdmVyd3JpdGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRPdmVyd3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0T3ZlcndyaXRlKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRvZ2dsZU92ZXJ3cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnRvZ2dsZU92ZXJ3cml0ZSgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInNjcm9sbFNwZWVkXCIsIHNwZWVkKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0U2Nyb2xsU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNjcm9sbFNwZWVkXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXREcmFnRGVsYXkgPSBmdW5jdGlvbiAoZHJhZ0RlbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZHJhZ0RlbGF5XCIsIGRyYWdEZWxheSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldERyYWdEZWxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZHJhZ0RlbGF5XCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25TdHlsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzZWxlY3Rpb25TdHlsZVwiLCB2YWwpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25TdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwic2VsZWN0aW9uU3R5bGVcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBmdW5jdGlvbiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiaGlnaGxpZ2h0QWN0aXZlTGluZVwiLCBzaG91bGRIaWdobGlnaHQpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRIaWdobGlnaHRBY3RpdmVMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJoaWdobGlnaHRBY3RpdmVMaW5lXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRIaWdobGlnaHRHdXR0ZXJMaW5lID0gZnVuY3Rpb24gKHNob3VsZEhpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhpZ2hsaWdodEd1dHRlckxpbmVcIiwgc2hvdWxkSGlnaGxpZ2h0KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0R3V0dGVyTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiaGlnaGxpZ2h0R3V0dGVyTGluZVwiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0U2VsZWN0ZWRXb3JkID0gZnVuY3Rpb24gKHNob3VsZEhpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhpZ2hsaWdodFNlbGVjdGVkV29yZFwiLCBzaG91bGRIaWdobGlnaHQpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRIaWdobGlnaHRTZWxlY3RlZFdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoaWdobGlnaHRTZWxlY3RlZFdvcmQ7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEFuaW1hdGVkU2Nyb2xsID0gZnVuY3Rpb24gKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbmltYXRlZFNjcm9sbChzaG91bGRBbmltYXRlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0QW5pbWF0ZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldEFuaW1hdGVkU2Nyb2xsKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24gKHNob3dJbnZpc2libGVzKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2hvd0ludmlzaWJsZXMoc2hvd0ludmlzaWJsZXMpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTaG93SW52aXNpYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0U2hvd0ludmlzaWJsZXMoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RGlzcGxheUluZGVudEd1aWRlcyhkaXNwbGF5KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0RGlzcGxheUluZGVudEd1aWRlcygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRIaWdobGlnaHRJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKGhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEhpZ2hsaWdodEluZGVudEd1aWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNob3dQcmludE1hcmdpbiA9IGZ1bmN0aW9uIChzaG93UHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaG93UHJpbnRNYXJnaW4oc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0U2hvd1ByaW50TWFyZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRTaG93UHJpbnRNYXJnaW4oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbiAoc2hvd1ByaW50TWFyZ2luKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJpbnRNYXJnaW5Db2x1bW4oc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFByaW50TWFyZ2luQ29sdW1uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFJlYWRPbmx5ID0gZnVuY3Rpb24gKHJlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgcmVhZE9ubHkpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRSZWFkT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwicmVhZE9ubHlcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJiZWhhdmlvdXJzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0QmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImJlaGF2aW91cnNFbmFibGVkXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcIndyYXBCZWhhdmlvdXJzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0V3JhcEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJ3cmFwQmVoYXZpb3Vyc0VuYWJsZWRcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNob3dGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwic2hvd0ZvbGRXaWRnZXRzXCIsIHNob3cpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dGb2xkV2lkZ2V0c1wiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0RmFkZUZvbGRXaWRnZXRzID0gZnVuY3Rpb24gKGZhZGUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJmYWRlRm9sZFdpZGdldHNcIiwgZmFkZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEZhZGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZmFkZUZvbGRXaWRnZXRzXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gXCJsZWZ0XCIpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0TGVmdCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAodGhpcy5nZXRCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNlc3Npb24uZ2V0U3RhdGUocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgIHZhciBuZXdfcmFuZ2UgPSBzZXNzaW9uLmdldE1vZGUoKS50cmFuc2Zvcm1BY3Rpb24oc3RhdGUsICdkZWxldGlvbicsIHRoaXMsIHNlc3Npb24sIHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmQuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRbdGV4dC5sZW5ndGggLSAxXSA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJhbmdlLmVuZC5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld19yYW5nZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ld19yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVXb3JkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RXb3JkUmlnaHQoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlbW92ZVdvcmRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0V29yZExlZnQoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlbW92ZVRvTGluZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0TGluZVN0YXJ0KCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RMZWZ0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVUb0xpbmVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RMaW5lRW5kKCk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LmNvbHVtbiA9PSByYW5nZS5lbmQuY29sdW1uICYmIHJhbmdlLnN0YXJ0LnJvdyA9PSByYW5nZS5lbmQucm93KSB7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gMDtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3crKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zcGxpdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoXCJcXG5cIik7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oY3Vyc29yKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0R2hvc3RUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uLndpZGdldE1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi53aWRnZXRNYW5hZ2VyID0gbmV3IExpbmVXaWRnZXRzKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ud2lkZ2V0TWFuYWdlci5hdHRhY2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRHaG9zdFRleHQodGV4dCwgcG9zaXRpb24pO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVHaG9zdFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uLndpZGdldE1hbmFnZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlR2hvc3RUZXh0KCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRyYW5zcG9zZUxldHRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGN1cnNvci5jb2x1bW47XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgIHZhciBzd2FwLCByYW5nZTtcbiAgICAgICAgaWYgKGNvbHVtbiA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2FwID0gbGluZS5jaGFyQXQoY29sdW1uKSArIGxpbmUuY2hhckF0KGNvbHVtbiAtIDEpO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLnJvdywgY29sdW1uIC0gMSwgY3Vyc29yLnJvdywgY29sdW1uICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2FwID0gbGluZS5jaGFyQXQoY29sdW1uIC0gMSkgKyBsaW5lLmNoYXJBdChjb2x1bW4gLSAyKTtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5yb3csIGNvbHVtbiAtIDIsIGN1cnNvci5yb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHN3YXApO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHJhbmdlLmVuZCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRvTG93ZXJDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxSYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0V29yZCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHRleHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKG9yaWdpbmFsUmFuZ2UpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS50b1VwcGVyQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsUmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCB0ZXh0LnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShvcmlnaW5hbFJhbmdlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93IDwgcmFuZ2UuZW5kLnJvdykge1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgICAgIHNlc3Npb24uaW5kZW50Um93cyhyb3dzLmZpcnN0LCByb3dzLmxhc3QsIFwiXFx0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhbmdlLnN0YXJ0LmNvbHVtbiA8IHJhbmdlLmVuZC5jb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKCEvXlxccyskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmluZGVudFJvd3Mocm93cy5maXJzdCwgcm93cy5sYXN0LCBcIlxcdFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHZhciBzaXplID0gc2Vzc2lvbi5nZXRUYWJTaXplKCk7XG4gICAgICAgIHZhciBjb2x1bW4gPSBzZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Db2x1bW4ocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmdldFVzZVNvZnRUYWJzKCkpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IChzaXplIC0gY29sdW1uICUgc2l6ZSk7XG4gICAgICAgICAgICB2YXIgaW5kZW50U3RyaW5nID0gbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGNvbHVtbiAlIHNpemU7XG4gICAgICAgICAgICB3aGlsZSAobGluZVtyYW5nZS5zdGFydC5jb2x1bW4gLSAxXSA9PSBcIiBcIiAmJiBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbi0tO1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpbmRlbnRTdHJpbmcgPSBcIlxcdFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChpbmRlbnRTdHJpbmcpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5ibG9ja0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmluZGVudFJvd3Mocm93cy5maXJzdCwgcm93cy5sYXN0LCBcIlxcdFwiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuYmxvY2tPdXRkZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZXNzaW9uLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNlc3Npb24ub3V0ZGVudFJvd3Moc2VsZWN0aW9uLmdldFJhbmdlKCkpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zb3J0TGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJvd3MuZmlyc3Q7IGkgPD0gcm93cy5sYXN0OyBpKyspXG4gICAgICAgICAgICBsaW5lcy5wdXNoKHNlc3Npb24uZ2V0TGluZShpKSk7XG4gICAgICAgIGxpbmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGEudG9Mb3dlckNhc2UoKSA+IGIudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlbGV0ZVJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIDAsIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gcm93cy5maXJzdDsgaSA8PSByb3dzLmxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoaSk7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5zdGFydC5yb3cgPSBpO1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2UuZW5kLnJvdyA9IGk7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQuY29sdW1uID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBzZXNzaW9uLnJlcGxhY2UoZGVsZXRlUmFuZ2UsIGxpbmVzW2kgLSByb3dzLmZpcnN0XSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUudG9nZ2xlQ29tbWVudExpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNlc3Npb24uZ2V0U3RhdGUodGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdyk7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRNb2RlKCkudG9nZ2xlQ29tbWVudExpbmVzKHN0YXRlLCB0aGlzLnNlc3Npb24sIHJvd3MuZmlyc3QsIHJvd3MubGFzdCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRvZ2dsZUJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zZXNzaW9uLmdldFN0YXRlKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRNb2RlKCkudG9nZ2xlQmxvY2tDb21tZW50KHN0YXRlLCB0aGlzLnNlc3Npb24sIHJhbmdlLCBjdXJzb3IpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXROdW1iZXJBdCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgX251bWJlclJ4ID0gL1tcXC1dP1swLTldKyg/OlxcLlswLTldKyk/L2c7XG4gICAgICAgIF9udW1iZXJSeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHdoaWxlIChfbnVtYmVyUngubGFzdEluZGV4IDwgY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgbSA9IF9udW1iZXJSeC5leGVjKHMpO1xuICAgICAgICAgICAgaWYgKG0uaW5kZXggPD0gY29sdW1uICYmIG0uaW5kZXggKyBtWzBdLmxlbmd0aCA+PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbVswXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG0uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbS5pbmRleCArIG1bMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5tb2RpZnlOdW1iZXIgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKS5yb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKS5jb2x1bW47XG4gICAgICAgIHZhciBjaGFyUmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4gLSAxLCByb3csIGNvbHVtbik7XG4gICAgICAgIHZhciBjID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShjaGFyUmFuZ2UpO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQoYykpICYmIGlzRmluaXRlKGMpKSB7XG4gICAgICAgICAgICB2YXIgbnIgPSB0aGlzLmdldE51bWJlckF0KHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChucikge1xuICAgICAgICAgICAgICAgIHZhciBmcCA9IG5yLnZhbHVlLmluZGV4T2YoXCIuXCIpID49IDAgPyBuci5zdGFydCArIG5yLnZhbHVlLmluZGV4T2YoXCIuXCIpICsgMSA6IG5yLmVuZDtcbiAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBuci5zdGFydCArIG5yLnZhbHVlLmxlbmd0aCAtIGZwO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gcGFyc2VGbG9hdChuci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdCAqPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIGlmIChmcCAhPT0gbnIuZW5kICYmIGNvbHVtbiA8IGZwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudCAqPSBNYXRoLnBvdygxMCwgbnIuZW5kIC0gY29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQgKj0gTWF0aC5wb3coMTAsIG5yLmVuZCAtIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgKz0gYW1vdW50O1xuICAgICAgICAgICAgICAgIHQgLz0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICB2YXIgbm5yID0gdC50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZVJhbmdlID0gbmV3IFJhbmdlKHJvdywgbnIuc3RhcnQsIHJvdywgbnIuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVwbGFjZShyZXBsYWNlUmFuZ2UsIG5ucik7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBNYXRoLm1heChuci5zdGFydCArIDEsIGNvbHVtbiArIG5uci5sZW5ndGggLSBuci52YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlV29yZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRvZ2dsZVdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKS5yb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKS5jb2x1bW47XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuZ2V0U2VsZWN0ZWRUZXh0KCk7XG4gICAgICAgIHZhciBjdXJyV29yZFN0YXJ0ID0gdGhpcy5zZWxlY3Rpb24uZ2V0V29yZFJhbmdlKCkuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgd29yZFBhcnRzID0gY3VycmVudFN0YXRlLnJlcGxhY2UoLyhbYS16XSt8W0EtWl0rKSg/PVtBLVpfXXwkKS9nLCAnJDEgJykuc3BsaXQoL1xccy8pO1xuICAgICAgICB2YXIgZGVsdGEgPSBjb2x1bW4gLSBjdXJyV29yZFN0YXJ0IC0gMTtcbiAgICAgICAgaWYgKGRlbHRhIDwgMClcbiAgICAgICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgdmFyIGN1ckxlbmd0aCA9IDAsIGl0TGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlLm1hdGNoKC9bQS1aYS16MC05X10rLykpIHtcbiAgICAgICAgICAgIHdvcmRQYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgaXRMZW5ndGggPSBjdXJMZW5ndGggKyBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPj0gY3VyTGVuZ3RoICYmIGRlbHRhIDw9IGl0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubW92ZUN1cnNvclRvKHJvdywgY3VyTGVuZ3RoICsgY3VycldvcmRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLnNlbGVjdFRvKHJvdywgaXRMZW5ndGggKyBjdXJyV29yZFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyTGVuZ3RoID0gaXRMZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd29yZFBhaXJzID0gdGhpcy4kdG9nZ2xlV29yZFBhaXJzO1xuICAgICAgICB2YXIgcmVnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB3b3JkUGFpcnNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRlID0gKyFqO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdENvbmRpdGlvbiA9IGN1cnJlbnRTdGF0ZS5tYXRjaChuZXcgUmVnRXhwKCdeXFxcXHM/Xz8oJyArIGxhbmcuZXNjYXBlUmVnRXhwKGl0ZW1bal0pICsgJylcXFxccz8kJywgJ2knKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRDb25kaXRpb24gPSBjdXJyZW50U3RhdGUubWF0Y2gobmV3IFJlZ0V4cCgnKFtfXXxefFxcXFxzKSgnICsgbGFuZy5lc2NhcGVSZWdFeHAoZmlyc3RDb25kaXRpb25bMV0pICsgJykoJHxcXFxccyknLCAnZycpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnID0gY3VycmVudFN0YXRlLnJlcGxhY2UobmV3IFJlZ0V4cChsYW5nLmVzY2FwZVJlZ0V4cChpdGVtW2pdKSwgJ2knKSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBpdGVtW25lZ2F0ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50b1VwcGVyQ2FzZSgpID09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpID09IHJlc3VsdC5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1YnN0cigwLCAwKSArIGl0ZW1bbmVnYXRlXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJlcy5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHJlZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWcgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmZpbmRMaW5rQXQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgdmFyIHdvcmRQYXJ0cyA9IGxpbmUuc3BsaXQoLygoPzpodHRwcz98ZnRwKTpcXC9cXC9bXFxTXSspLyk7XG4gICAgICAgIHZhciBjb2x1bW5Qb3NpdGlvbiA9IGNvbHVtbjtcbiAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uIDwgMClcbiAgICAgICAgICAgIGNvbHVtblBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIHByZXZpb3VzUG9zaXRpb24gPSAwLCBjdXJyZW50UG9zaXRpb24gPSAwLCBtYXRjaDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHdvcmRQYXJ0c18xID0gX192YWx1ZXMod29yZFBhcnRzKSwgd29yZFBhcnRzXzFfMSA9IHdvcmRQYXJ0c18xLm5leHQoKTsgIXdvcmRQYXJ0c18xXzEuZG9uZTsgd29yZFBhcnRzXzFfMSA9IHdvcmRQYXJ0c18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gd29yZFBhcnRzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBwcmV2aW91c1Bvc2l0aW9uICsgaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uID49IHByZXZpb3VzUG9zaXRpb24gJiYgY29sdW1uUG9zaXRpb24gPD0gY3VycmVudFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm1hdGNoKC8oKD86aHR0cHM/fGZ0cCk6XFwvXFwvW1xcU10rKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGl0ZW0ucmVwbGFjZSgvW1xcczouLCdcIjt9XFxdXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c1Bvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAod29yZFBhcnRzXzFfMSAmJiAhd29yZFBhcnRzXzFfMS5kb25lICYmIChfYSA9IHdvcmRQYXJ0c18xLnJldHVybikpIF9hLmNhbGwod29yZFBhcnRzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub3BlbkxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuZmluZExpbmtBdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgaWYgKHVybClcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xuICAgICAgICByZXR1cm4gdXJsICE9IG51bGw7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlbW92ZUxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRnVsbExpbmVzKHJvd3MuZmlyc3QsIHJvd3MubGFzdCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZHVwbGljYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciByYW5nZSA9IHNlbC5nZXRSYW5nZSgpO1xuICAgICAgICB2YXIgcmV2ZXJzZSA9IHNlbC5pc0JhY2t3YXJkcygpO1xuICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgZG9jLmR1cGxpY2F0ZUxpbmVzKHJvdywgcm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyByYW5nZS5zdGFydCA6IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIHZhciBlbmRQb2ludCA9IGRvYy5pbnNlcnQocG9pbnQsIGRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gcG9pbnQ7XG4gICAgICAgICAgICByYW5nZS5lbmQgPSBlbmRQb2ludDtcbiAgICAgICAgICAgIHNlbC5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgcmV2ZXJzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubW92ZUxpbmVzRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZUxpbmVzKDEsIGZhbHNlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubW92ZUxpbmVzVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygtMSwgZmFsc2UpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5tb3ZlVGV4dCA9IGZ1bmN0aW9uIChyYW5nZSwgdG9Qb3NpdGlvbiwgY29weSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLm1vdmVUZXh0KHJhbmdlLCB0b1Bvc2l0aW9uLCBjb3B5KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuY29weUxpbmVzVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygtMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmNvcHlMaW5lc0Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygxLCB0cnVlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJG1vdmVMaW5lcyA9IGZ1bmN0aW9uIChkaXIsIGNvcHkpIHtcbiAgICAgICAgdmFyIHJvd3MsIG1vdmVkO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmICghc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlIHx8IHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cyhyYW5nZSk7XG4gICAgICAgICAgICBtb3ZlZCA9IHRoaXMuc2Vzc2lvbi4kbW92ZUxpbmVzKHJvd3MuZmlyc3QsIHJvd3MubGFzdCwgY29weSA/IDAgOiBkaXIpO1xuICAgICAgICAgICAgaWYgKGNvcHkgJiYgZGlyID09IC0xKVxuICAgICAgICAgICAgICAgIG1vdmVkID0gMDtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVCeShtb3ZlZCwgMCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnJhbmdlTGlzdC5kZXRhY2godGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWxEaWZmID0gMDtcbiAgICAgICAgICAgIHZhciBsID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHJhbmdlc1tpXS5tb3ZlQnkoZGlmZiwgMCk7XG4gICAgICAgICAgICAgICAgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cyhyYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHJvd3MuZmlyc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSByb3dzLmxhc3Q7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsRGlmZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlc1tpXS5tb3ZlQnkodG90YWxEaWZmLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgJiYgc3ViUm93cy5maXJzdCAhPSBsYXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb3B5ICYmIHN1YlJvd3MuZmlyc3QgPiBsYXN0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gc3ViUm93cy5sYXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuc2Vzc2lvbi4kbW92ZUxpbmVzKGZpcnN0LCBsYXN0LCBjb3B5ID8gMCA6IGRpcik7XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkgJiYgZGlyID09IC0xKVxuICAgICAgICAgICAgICAgICAgICByYW5nZUluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlSW5kZXggPD0gaSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZXNbcmFuZ2VJbmRleF0ubW92ZUJ5KGRpZmYsIDApO1xuICAgICAgICAgICAgICAgICAgICByYW5nZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IDA7XG4gICAgICAgICAgICAgICAgdG90YWxEaWZmICs9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2Uoc2VsZWN0aW9uLnJhbmdlc1swXSk7XG4gICAgICAgICAgICBzZWxlY3Rpb24ucmFuZ2VMaXN0LmF0dGFjaCh0aGlzLnNlc3Npb24pO1xuICAgICAgICAgICAgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGdldFNlbGVjdGVkUm93cyA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByYW5nZSA9IChyYW5nZSB8fCB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpLmNvbGxhcHNlUm93cygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMuc2Vzc2lvbi5nZXRSb3dGb2xkU3RhcnQocmFuZ2Uuc3RhcnQucm93KSxcbiAgICAgICAgICAgIGxhc3Q6IHRoaXMuc2Vzc2lvbi5nZXRSb3dGb2xkRW5kKHJhbmdlLmVuZC5yb3cpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ29tcG9zaXRpb25TdGFydCA9IGZ1bmN0aW9uIChjb21wb3NpdGlvblN0YXRlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hvd0NvbXBvc2l0aW9uKGNvbXBvc2l0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvbXBvc2l0aW9uVXBkYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDb21wb3NpdGlvblRleHQodGV4dCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaGlkZUNvbXBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEZpcnN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0Rmlyc3RWaXNpYmxlUm93KCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldExhc3RWaXNpYmxlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRMYXN0VmlzaWJsZVJvdygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5pc1Jvd1Zpc2libGUgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiAocm93ID49IHRoaXMuZ2V0Rmlyc3RWaXNpYmxlUm93KCkgJiYgcm93IDw9IHRoaXMuZ2V0TGFzdFZpc2libGVSb3coKSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmlzUm93RnVsbHlWaXNpYmxlID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gKHJvdyA+PSB0aGlzLnJlbmRlcmVyLmdldEZpcnN0RnVsbHlWaXNpYmxlUm93KCkgJiYgcm93IDw9IHRoaXMucmVuZGVyZXIuZ2V0TGFzdEZ1bGx5VmlzaWJsZVJvdygpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGdldFZpc2libGVSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0U2Nyb2xsQm90dG9tUm93KCkgLSB0aGlzLnJlbmRlcmVyLmdldFNjcm9sbFRvcFJvdygpICsgMTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJG1vdmVCeVBhZ2UgPSBmdW5jdGlvbiAoZGlyLCBzZWxlY3QpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMucmVuZGVyZXIubGF5ZXJDb25maWc7XG4gICAgICAgIHZhciByb3dzID0gZGlyICogTWF0aC5mbG9vcihjb25maWcuaGVpZ2h0IC8gY29uZmlnLmxpbmVIZWlnaHQpO1xuICAgICAgICBpZiAoc2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi4kbW92ZVNlbGVjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkocm93cywgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yQnkocm93cywgMCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSByZW5kZXJlci5zY3JvbGxUb3A7XG4gICAgICAgIHJlbmRlcmVyLnNjcm9sbEJ5KDAsIHJvd3MgKiBjb25maWcubGluZUhlaWdodCk7XG4gICAgICAgIGlmIChzZWxlY3QgIT0gbnVsbClcbiAgICAgICAgICAgIHJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG4gICAgICAgIHJlbmRlcmVyLmFuaW1hdGVTY3JvbGxpbmcoc2Nyb2xsVG9wKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2VsZWN0UGFnZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNlbGVjdFBhZ2VVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZUJ5UGFnZSgtMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdvdG9QYWdlRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZUJ5UGFnZSgxLCBmYWxzZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdvdG9QYWdlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoLTEsIGZhbHNlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2Nyb2xsUGFnZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoMSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNjcm9sbFBhZ2VVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZUJ5UGFnZSgtMSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNjcm9sbFRvUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvUm93KHJvdyk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNjcm9sbFRvTGluZSA9IGZ1bmN0aW9uIChsaW5lLCBjZW50ZXIsIGFuaW1hdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsVG9MaW5lKGxpbmUsIGNlbnRlciwgYW5pbWF0ZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5jZW50ZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgICAgIHJvdzogTWF0aC5mbG9vcihyYW5nZS5zdGFydC5yb3cgKyAocmFuZ2UuZW5kLnJvdyAtIHJhbmdlLnN0YXJ0LnJvdykgLyAyKSxcbiAgICAgICAgICAgIGNvbHVtbjogTWF0aC5mbG9vcihyYW5nZS5zdGFydC5jb2x1bW4gKyAocmFuZ2UuZW5kLmNvbHVtbiAtIHJhbmdlLnN0YXJ0LmNvbHVtbikgLyAyKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFsaWduQ3Vyc29yKHBvcywgMC41KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0Q3Vyc29yUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0Q3Vyc29yUG9zaXRpb25TY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RBbGwoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm1vdmVDdXJzb3JUbyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvclRvUG9zaXRpb24ocG9zKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuanVtcFRvTWF0Y2hpbmcgPSBmdW5jdGlvbiAoc2VsZWN0LCBleHBhbmQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcy5zZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgdmFyIHByZXZUb2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB2YXIgdG9rZW5Db3VudCA9IDA7XG4gICAgICAgIGlmIChwcmV2VG9rZW4gJiYgcHJldlRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHByZXZUb2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IHByZXZUb2tlbiB8fCBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbWF0Y2hUeXBlO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlcHRoID0ge307XG4gICAgICAgIHZhciBpID0gY3Vyc29yLmNvbHVtbiAtIHRva2VuLnN0YXJ0O1xuICAgICAgICB2YXIgYnJhY2tldFR5cGU7XG4gICAgICAgIHZhciBicmFja2V0cyA9IHtcbiAgICAgICAgICAgIFwiKVwiOiBcIihcIixcbiAgICAgICAgICAgIFwiKFwiOiBcIihcIixcbiAgICAgICAgICAgIFwiXVwiOiBcIltcIixcbiAgICAgICAgICAgIFwiW1wiOiBcIltcIixcbiAgICAgICAgICAgIFwie1wiOiBcIntcIixcbiAgICAgICAgICAgIFwifVwiOiBcIntcIlxuICAgICAgICB9O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUubWF0Y2goL1t7fSgpXFxbXFxdXS9nKSkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgdG9rZW4udmFsdWUubGVuZ3RoICYmICFmb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnJhY2tldHNbdG9rZW4udmFsdWVbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmFja2V0VHlwZSA9IGJyYWNrZXRzW3Rva2VuLnZhbHVlW2ldXSArICcuJyArIHRva2VuLnR5cGUucmVwbGFjZShcInJwYXJlblwiLCBcImxwYXJlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRlcHRoW2JyYWNrZXRUeXBlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoW2JyYWNrZXRUeXBlXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoW2JyYWNrZXRUeXBlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoW2JyYWNrZXRUeXBlXS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aFticmFja2V0VHlwZV0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoVHlwZSA9ICdicmFja2V0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGVwdGhbdG9rZW4udmFsdWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aFt0b2tlbi52YWx1ZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcgJiYgdG9rZW5Db3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhbdG9rZW4udmFsdWVdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJzwvJykge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aFt0b2tlbi52YWx1ZV0tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoW3Rva2VuLnZhbHVlXSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hUeXBlID0gJ3RhZyc7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcHJldlRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdG9rZW5Db3VudCsrO1xuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgIWZvdW5kKTtcbiAgICAgICAgaWYgKCFtYXRjaFR5cGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByYW5nZSwgcG9zO1xuICAgICAgICBpZiAobWF0Y2hUeXBlID09PSAnYnJhY2tldCcpIHtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5zZXNzaW9uLmdldEJyYWNrZXRSYW5nZShjdXJzb3IpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIGkgLSAxLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpIC0gMSk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZCB8fCBwb3Mucm93ID09PSBjdXJzb3Iucm93ICYmIE1hdGguYWJzKHBvcy5jb2x1bW4gLSBjdXJzb3IuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICA8IDIpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5zZXNzaW9uLmdldEJyYWNrZXRSYW5nZShwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoVHlwZSA9PT0gJ3RhZycpIHtcbiAgICAgICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgLSAyLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgLSAyKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZ3NSYW5nZXMgPSB0aGlzLnNlc3Npb24uZ2V0TWF0Y2hpbmdUYWdzKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ3NSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ3NSYW5nZXMub3BlblRhZy5jb250YWlucyhjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0YWdzUmFuZ2VzLmNsb3NlVGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRhZ3NSYW5nZXMub3BlblRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdzUmFuZ2VzLmNsb3NlVGFnLnN0YXJ0LnJvdyA9PT0gY3Vyc29yLnJvdyAmJiB0YWdzUmFuZ2VzLmNsb3NlVGFnLnN0YXJ0LmNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID09PSBjdXJzb3IuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHBvcyB8fCByYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSByYW5nZSAmJiByYW5nZS5jdXJzb3IgfHwgcG9zO1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIGV4cGFuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlICYmIHJhbmdlLmlzRXF1YWwodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RUbyhwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlVG8ocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ290b0xpbmUgPSBmdW5jdGlvbiAobGluZU51bWJlciwgY29sdW1uLCBhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi51bmZvbGQoeyByb3c6IGxpbmVOdW1iZXIgLSAxLCBjb2x1bW46IGNvbHVtbiB8fCAwIH0pO1xuICAgICAgICB0aGlzLmV4aXRNdWx0aVNlbGVjdE1vZGUgJiYgdGhpcy5leGl0TXVsdGlTZWxlY3RNb2RlKCk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGxpbmVOdW1iZXIgLSAxLCBjb2x1bW4gfHwgMCk7XG4gICAgICAgIGlmICghdGhpcy5pc1Jvd0Z1bGx5VmlzaWJsZShsaW5lTnVtYmVyIC0gMSkpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvTGluZShsaW5lTnVtYmVyIC0gMSwgdHJ1ZSwgYW5pbWF0ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlVG8gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZVRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubmF2aWdhdGVVcCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNNdWx0aUxpbmUoKSAmJiAhdGhpcy5zZWxlY3Rpb24uaXNCYWNrd2FyZHMoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb24uYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckJ5KC10aW1lcyB8fCAtMSwgMCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlRG93biA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNNdWx0aUxpbmUoKSAmJiB0aGlzLnNlbGVjdGlvbi5pc0JhY2t3YXJkcygpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb24uYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JCeSh0aW1lcyB8fCAxLCAwKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubmF2aWdhdGVMZWZ0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVzID0gdGltZXMgfHwgMTtcbiAgICAgICAgICAgIHdoaWxlICh0aW1lcy0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckxlZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlUmlnaHQgPSBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkuZW5kO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZXMgPSB0aW1lcyB8fCAxO1xuICAgICAgICAgICAgd2hpbGUgKHRpbWVzLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yUmlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlTGluZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yTGluZVN0YXJ0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubmF2aWdhdGVMaW5lRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yTGluZUVuZCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlRmlsZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckZpbGVFbmQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZUZpbGVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckZpbGVTdGFydCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlV29yZFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yV29yZFJpZ2h0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubmF2aWdhdGVXb3JkTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvcldvcmRMZWZ0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChyZXBsYWNlbWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaC5zZXQob3B0aW9ucyk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuJHNlYXJjaC5maW5kKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IDA7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZWQ7XG4gICAgICAgIGlmICh0aGlzLiR0cnlSZXBsYWNlKHJhbmdlLCByZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgIHJlcGxhY2VkID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgIHJldHVybiByZXBsYWNlZDtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChyZXBsYWNlbWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy4kc2VhcmNoLmZpbmRBbGwodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gMDtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0cnlSZXBsYWNlKHJhbmdlc1tpXSwgcmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVwbGFjZWQ7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiR0cnlSZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCByZXBsYWNlbWVudCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSB0aGlzLiRzZWFyY2gucmVwbGFjZShpbnB1dCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICBpZiAocmVwbGFjZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZCA9IHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRMYXN0U2VhcmNoT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNlYXJjaC5nZXRPcHRpb25zKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAobmVlZGxlLCBvcHRpb25zLCBhbmltYXRlKSB7XG4gICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZWVkbGUgPT0gXCJzdHJpbmdcIiB8fCBuZWVkbGUgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgICAgICBvcHRpb25zLm5lZWRsZSA9IG5lZWRsZTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5lZWRsZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgb29wLm1peGluKG9wdGlvbnMsIG5lZWRsZSk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLm5lZWRsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZWVkbGUgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuJHNlYXJjaC4kb3B0aW9ucy5uZWVkbGU7XG4gICAgICAgICAgICBpZiAoIW5lZWRsZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5zZXNzaW9uLmdldFdvcmRSYW5nZShyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgbmVlZGxlID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzZWFyY2guc2V0KHsgbmVlZGxlOiBuZWVkbGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2VhcmNoLnNldChvcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0YXJ0KVxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldCh7IHN0YXJ0OiByYW5nZSB9KTtcbiAgICAgICAgdmFyIG5ld1JhbmdlID0gdGhpcy4kc2VhcmNoLmZpbmQodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJldmVudFNjcm9sbClcbiAgICAgICAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICAgICAgaWYgKG5ld1JhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnJldmVhbFJhbmdlKG5ld1JhbmdlLCBhbmltYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrd2FyZHMpXG4gICAgICAgICAgICByYW5nZS5zdGFydCA9IHJhbmdlLmVuZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2UuZW5kID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKHJhbmdlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZmluZE5leHQgPSBmdW5jdGlvbiAob3B0aW9ucywgYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLmZpbmQoeyBza2lwQ3VycmVudDogdHJ1ZSwgYmFja3dhcmRzOiBmYWxzZSB9LCBvcHRpb25zLCBhbmltYXRlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZmluZFByZXZpb3VzID0gZnVuY3Rpb24gKG9wdGlvbnMsIGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5maW5kKG9wdGlvbnMsIHsgc2tpcEN1cnJlbnQ6IHRydWUsIGJhY2t3YXJkczogdHJ1ZSB9LCBhbmltYXRlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUucmV2ZWFsUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnVuZm9sZChyYW5nZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlKTtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucmVuZGVyZXIuc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFNlbGVjdGlvbkludG9WaWV3KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIDAuNSk7XG4gICAgICAgIGlmIChhbmltYXRlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYW5pbWF0ZVNjcm9sbGluZyhzY3JvbGxUb3ApO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24uZ2V0VW5kb01hbmFnZXIoKS51bmRvKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkucmVkbyh0aGlzLnNlc3Npb24pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLiR0b0Rlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuJHRvRGVzdHJveS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kdG9EZXN0cm95ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kbW91c2VIYW5kbGVyKVxuICAgICAgICAgICAgdGhpcy4kbW91c2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImRlc3Ryb3lcIiwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fJGVtaXRJbnB1dEV2ZW50KVxuICAgICAgICAgICAgdGhpcy5fJGVtaXRJbnB1dEV2ZW50LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRBdXRvU2Nyb2xsRWRpdG9ySW50b1ZpZXcgPSBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gICAgICAgIGlmICghZW5hYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2hvdWxkU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy4kc2Nyb2xsQW5jaG9yKVxuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIHNjcm9sbEFuY2hvciA9IHRoaXMuJHNjcm9sbEFuY2hvcjtcbiAgICAgICAgc2Nyb2xsQW5jaG9yLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlXCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShzY3JvbGxBbmNob3IsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB2YXIgb25DaGFuZ2VTZWxlY3Rpb24gPSB0aGlzLm9uKFwiY2hhbmdlU2VsZWN0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb25CZWZvcmVSZW5kZXIgPSB0aGlzLnJlbmRlcmVyLm9uKFwiYmVmb3JlUmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHNlbGYucmVuZGVyZXIuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9uQWZ0ZXJSZW5kZXIgPSB0aGlzLnJlbmRlcmVyLm9uKFwiYWZ0ZXJSZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiByZWN0ICYmIChzZWxmLmlzRm9jdXNlZCgpXG4gICAgICAgICAgICAgICAgfHwgc2VsZi5zZWFyY2hCb3ggJiYgc2VsZi5zZWFyY2hCb3guaXNGb2N1c2VkKCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gc2VsZi5yZW5kZXJlcjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gcmVuZGVyZXIuJGN1cnNvckxheWVyLiRwaXhlbFBvcztcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gcmVuZGVyZXIubGF5ZXJDb25maWc7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHBvcy50b3AgLSBjb25maWcub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MudG9wID49IDAgJiYgdG9wICsgcmVjdC50b3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvcy50b3AgPCBjb25maWcuaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIHBvcy50b3AgKyByZWN0LnRvcCArIGNvbmZpZy5saW5lSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvci5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvci5zdHlsZS5oZWlnaHQgPSBjb25maWcubGluZUhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yLnNjcm9sbEludG9WaWV3KHNob3VsZFNjcm9sbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsRWRpdG9ySW50b1ZpZXcgPSBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldEF1dG9TY3JvbGxFZGl0b3JJbnRvVmlldztcbiAgICAgICAgICAgIHRoaXMub2ZmKFwiY2hhbmdlU2VsZWN0aW9uXCIsIG9uQ2hhbmdlU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIub2ZmKFwiYWZ0ZXJSZW5kZXJcIiwgb25BZnRlclJlbmRlcik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLm9mZihcImJlZm9yZVJlbmRlclwiLCBvbkJlZm9yZVJlbmRlcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRyZXNldEN1cnNvclN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLiRjdXJzb3JTdHlsZSB8fCBcImFjZVwiO1xuICAgICAgICB2YXIgY3Vyc29yTGF5ZXIgPSB0aGlzLnJlbmRlcmVyLiRjdXJzb3JMYXllcjtcbiAgICAgICAgaWYgKCFjdXJzb3JMYXllcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3Vyc29yTGF5ZXIuc2V0U21vb3RoQmxpbmtpbmcoL3Ntb290aC8udGVzdChzdHlsZSkpO1xuICAgICAgICBjdXJzb3JMYXllci5pc0JsaW5raW5nID0gIXRoaXMuJHJlYWRPbmx5ICYmIHN0eWxlICE9IFwid2lkZVwiO1xuICAgICAgICBkb20uc2V0Q3NzQ2xhc3MoY3Vyc29yTGF5ZXIuZWxlbWVudCwgXCJhY2Vfc2xpbS1jdXJzb3JzXCIsIC9zbGltLy50ZXN0KHN0eWxlKSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnByb21wdCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcztcbiAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L3Byb21wdFwiLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICBtb2R1bGUucHJvbXB0KGVkaXRvciwgbWVzc2FnZSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFZGl0b3I7XG59KCkpO1xuRWRpdG9yLiR1aWQgPSAwO1xuRWRpdG9yLnByb3RvdHlwZS5jdXJPcCA9IG51bGw7XG5FZGl0b3IucHJvdG90eXBlLnByZXZPcCA9IHt9O1xuRWRpdG9yLnByb3RvdHlwZS4kbWVyZ2VhYmxlQ29tbWFuZHMgPSBbXCJiYWNrc3BhY2VcIiwgXCJkZWxcIiwgXCJpbnNlcnRzdHJpbmdcIl07XG5FZGl0b3IucHJvdG90eXBlLiR0b2dnbGVXb3JkUGFpcnMgPSBbXG4gICAgW1wiZmlyc3RcIiwgXCJsYXN0XCJdLFxuICAgIFtcInRydWVcIiwgXCJmYWxzZVwiXSxcbiAgICBbXCJ5ZXNcIiwgXCJub1wiXSxcbiAgICBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgICBbXCJ0b3BcIiwgXCJib3R0b21cIl0sXG4gICAgW1wicmlnaHRcIiwgXCJsZWZ0XCJdLFxuICAgIFtcIm9uXCIsIFwib2ZmXCJdLFxuICAgIFtcInhcIiwgXCJ5XCJdLFxuICAgIFtcImdldFwiLCBcInNldFwiXSxcbiAgICBbXCJtYXhcIiwgXCJtaW5cIl0sXG4gICAgW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLFxuICAgIFtcInNob3dcIiwgXCJoaWRlXCJdLFxuICAgIFtcImFkZFwiLCBcInJlbW92ZVwiXSxcbiAgICBbXCJ1cFwiLCBcImRvd25cIl0sXG4gICAgW1wiYmVmb3JlXCIsIFwiYWZ0ZXJcIl0sXG4gICAgW1wiZXZlblwiLCBcIm9kZFwiXSxcbiAgICBbXCJpblwiLCBcIm91dFwiXSxcbiAgICBbXCJpbnNpZGVcIiwgXCJvdXRzaWRlXCJdLFxuICAgIFtcIm5leHRcIiwgXCJwcmV2aW91c1wiXSxcbiAgICBbXCJpbmNyZWFzZVwiLCBcImRlY3JlYXNlXCJdLFxuICAgIFtcImF0dGFjaFwiLCBcImRldGFjaFwiXSxcbiAgICBbXCImJlwiLCBcInx8XCJdLFxuICAgIFtcIj09XCIsIFwiIT1cIl1cbl07XG5vb3AuaW1wbGVtZW50KEVkaXRvci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5jb25maWcuZGVmaW5lT3B0aW9ucyhFZGl0b3IucHJvdG90eXBlLCBcImVkaXRvclwiLCB7XG4gICAgc2VsZWN0aW9uU3R5bGU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlbGVjdGlvblN0eWxlXCIsIHsgZGF0YTogc3R5bGUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogXCJsaW5lXCJcbiAgICB9LFxuICAgIGhpZ2hsaWdodEFjdGl2ZUxpbmU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7IHRoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBoaWdobGlnaHRTZWxlY3RlZFdvcmQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2hvdWxkSGlnaGxpZ2h0KSB7IHRoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKCk7IH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgcmVhZE9ubHk6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dElucHV0LnNldFJlYWRPbmx5KHJlYWRPbmx5KTtcbiAgICAgICAgICAgIHRoaXMuJHJlc2V0Q3Vyc29yU3R5bGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgY29weVdpdGhFbXB0eVNlbGVjdGlvbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0SW5wdXQuc2V0Q29weVdpdGhFbXB0eVNlbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIGN1cnNvclN0eWxlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLiRyZXNldEN1cnNvclN0eWxlKCk7IH0sXG4gICAgICAgIHZhbHVlczogW1wiYWNlXCIsIFwic2xpbVwiLCBcInNtb290aFwiLCBcIndpZGVcIl0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogXCJhY2VcIlxuICAgIH0sXG4gICAgbWVyZ2VVbmRvRGVsdGFzOiB7XG4gICAgICAgIHZhbHVlczogW2ZhbHNlLCB0cnVlLCBcImFsd2F5c1wiXSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBiZWhhdmlvdXJzRW5hYmxlZDogeyBpbml0aWFsVmFsdWU6IHRydWUgfSxcbiAgICB3cmFwQmVoYXZpb3Vyc0VuYWJsZWQ6IHsgaW5pdGlhbFZhbHVlOiB0cnVlIH0sXG4gICAgZW5hYmxlQXV0b0luZGVudDogeyBpbml0aWFsVmFsdWU6IHRydWUgfSxcbiAgICBhdXRvU2Nyb2xsRWRpdG9ySW50b1ZpZXc6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3KHZhbCk7IH1cbiAgICB9LFxuICAgIGtleWJvYXJkSGFuZGxlcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5zZXRLZXlib2FyZEhhbmRsZXIodmFsKTsgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRrZXliaW5kaW5nSWQ7IH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLnNlc3Npb24uc2V0VmFsdWUodmFsKTsgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdldFZhbHVlKCk7IH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWUsXG4gICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0sXG4gICAgc2Vzc2lvbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5zZXRTZXNzaW9uKHZhbCk7IH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zZXNzaW9uOyB9LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlLFxuICAgICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHNob3dMaW5lTnVtYmVyczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXJMYXllci5zZXRTaG93TGluZU51bWJlcnMoc2hvdyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRsb29wLnNjaGVkdWxlKHRoaXMucmVuZGVyZXIuQ0hBTkdFX0dVVFRFUik7XG4gICAgICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLiRyZWxhdGl2ZUxpbmVOdW1iZXJzKVxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTnVtYmVyUmVuZGVyZXIuYXR0YWNoKHRoaXMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTnVtYmVyUmVuZGVyZXIuZGV0YWNoKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHJlbGF0aXZlTGluZU51bWJlcnM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaG93TGluZU51bWJlcnMgJiYgdmFsdWUpXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVOdW1iZXJSZW5kZXJlci5hdHRhY2godGhpcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVOdW1iZXJSZW5kZXJlci5kZXRhY2godGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kdXBkYXRlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1ZhbHVlID0gdGhpcy5zZXNzaW9uICYmICh0aGlzLnJlbmRlcmVyLiRjb21wb3NpdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpID4gMSB8fCB0aGlzLnNlc3Npb24uZ2V0TGluZSgwKS5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlICYmIHRoaXMucmVuZGVyZXIucGxhY2Vob2xkZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLm9mZihcImFmdGVyUmVuZGVyXCIsIHRoaXMuJHVwZGF0ZVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJhY2VfaGFzUGxhY2Vob2xkZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnBsYWNlaG9sZGVyTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucGxhY2Vob2xkZXJOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaGFzVmFsdWUgJiYgIXRoaXMucmVuZGVyZXIucGxhY2Vob2xkZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLm9uKFwiYWZ0ZXJSZW5kZXJcIiwgdGhpcy4kdXBkYXRlUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9oYXNQbGFjZWhvbGRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJhY2VfcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy4kcGxhY2Vob2xkZXIgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucGxhY2Vob2xkZXJOb2RlID0gZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5wbGFjZWhvbGRlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFoYXNWYWx1ZSAmJiB0aGlzLnJlbmRlcmVyLnBsYWNlaG9sZGVyTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wbGFjZWhvbGRlck5vZGUudGV4dENvbnRlbnQgPSB0aGlzLiRwbGFjZWhvbGRlciB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMub24oXCJpbnB1dFwiLCB0aGlzLiR1cGRhdGVQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVQbGFjZWhvbGRlcigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbmFibGVLZXlib2FyZEFjY2Vzc2liaWxpdHk6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBibHVyQ29tbWFuZCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImJsdXJUZXh0SW5wdXRcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTZXQgZm9jdXMgdG8gdGhlIGVkaXRvciBjb250ZW50IGRpdiB0byBhbGxvdyB0YWJiaW5nIHRocm91Z2ggdGhlIHBhZ2VcIixcbiAgICAgICAgICAgICAgICBiaW5kS2V5OiBcIkVzY1wiLFxuICAgICAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmb2N1c09uRW50ZXJLZXl1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIgJiYgZS5rZXlDb2RlID09PSBrZXlzWydlbnRlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKS5yb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jvd1Zpc2libGUocm93KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9MaW5lKHJvdywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGd1dHRlcktleWJvYXJkSGFuZGxlcjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZW5hYmxlS2V5Ym9hcmRBY2Nlc3NpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUgPSBcImFjZV9rZXlib2FyZC1mb2N1c1wiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dElucHV0LmdldEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAtMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0SW5wdXQuc2V0TnVtYmVyT2ZFeHRyYUxpbmVzKHVzZXJhZ2VudC5pc1dpbiA/IDMgOiAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImdyb3VwXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgbmxzKFwiZWRpdG9yLnNjcm9sbGVyLmFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIFwiZWRpdG9yXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLmNsYXNzTGlzdC5hZGQodGhpcy5yZW5kZXJlci5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbmxzKFwiZWRpdG9yLnNjcm9sbGVyLmFyaWEtbGFiZWxcIiwgXCJFZGl0b3IgY29udGVudCwgcHJlc3MgRW50ZXIgdG8gc3RhcnQgZWRpdGluZywgcHJlc3MgRXNjYXBlIHRvIGV4aXRcIikpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZvY3VzT25FbnRlcktleXVwLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMuYWRkQ29tbWFuZChibHVyQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncm91cFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgbmxzKFwiZWRpdG9yLmd1dHRlci5hcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcImVkaXRvclwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbmxzKFwiZWRpdG9yLmd1dHRlci5hcmlhLWxhYmVsXCIsIFwiRWRpdG9yIGd1dHRlciwgcHJlc3MgRW50ZXIgdG8gaW50ZXJhY3Qgd2l0aCBjb250cm9scyB1c2luZyBhcnJvdyBrZXlzLCBwcmVzcyBFc2NhcGUgdG8gZXhpdFwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLmNsYXNzTGlzdC5hZGQodGhpcy5yZW5kZXJlci5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmNvbnRlbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFndXR0ZXJLZXlib2FyZEhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcktleWJvYXJkSGFuZGxlciA9IG5ldyBHdXR0ZXJLZXlib2FyZEhhbmRsZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyLmFkZExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0SW5wdXQuc2V0QXJpYU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICBzZXRMYWJlbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5lbmFibGVLZXlib2FyZEFjY2Vzc2liaWxpdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJbnB1dC5nZXRFbGVtZW50KCkuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0SW5wdXQuc2V0TnVtYmVyT2ZFeHRyYUxpbmVzKDApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgLTEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmb2N1c09uRW50ZXJLZXl1cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnJlbW92ZUNvbW1hbmQoYmx1ckNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuY29udGVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgLTEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5yZW5kZXJlci5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyKVxuICAgICAgICAgICAgICAgICAgICBndXR0ZXJLZXlib2FyZEhhbmRsZXIucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgdGV4dElucHV0QXJpYUxhYmVsOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLiR0ZXh0SW5wdXRBcmlhTGFiZWwgPSB2YWw7IH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogXCJcIlxuICAgIH0sXG4gICAgZW5hYmxlTW9iaWxlTWVudToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy4kZW5hYmxlTW9iaWxlTWVudSA9IHZhbDsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBjdXN0b21TY3JvbGxiYXI6IFwicmVuZGVyZXJcIixcbiAgICBoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTogXCJyZW5kZXJlclwiLFxuICAgIHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiBcInJlbmRlcmVyXCIsXG4gICAgaGlnaGxpZ2h0R3V0dGVyTGluZTogXCJyZW5kZXJlclwiLFxuICAgIGFuaW1hdGVkU2Nyb2xsOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0ludmlzaWJsZXM6IFwicmVuZGVyZXJcIixcbiAgICBzaG93UHJpbnRNYXJnaW46IFwicmVuZGVyZXJcIixcbiAgICBwcmludE1hcmdpbkNvbHVtbjogXCJyZW5kZXJlclwiLFxuICAgIHByaW50TWFyZ2luOiBcInJlbmRlcmVyXCIsXG4gICAgZmFkZUZvbGRXaWRnZXRzOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0ZvbGRXaWRnZXRzOiBcInJlbmRlcmVyXCIsXG4gICAgZGlzcGxheUluZGVudEd1aWRlczogXCJyZW5kZXJlclwiLFxuICAgIGhpZ2hsaWdodEluZGVudEd1aWRlczogXCJyZW5kZXJlclwiLFxuICAgIHNob3dHdXR0ZXI6IFwicmVuZGVyZXJcIixcbiAgICBmb250U2l6ZTogXCJyZW5kZXJlclwiLFxuICAgIGZvbnRGYW1pbHk6IFwicmVuZGVyZXJcIixcbiAgICBtYXhMaW5lczogXCJyZW5kZXJlclwiLFxuICAgIG1pbkxpbmVzOiBcInJlbmRlcmVyXCIsXG4gICAgc2Nyb2xsUGFzdEVuZDogXCJyZW5kZXJlclwiLFxuICAgIGZpeGVkV2lkdGhHdXR0ZXI6IFwicmVuZGVyZXJcIixcbiAgICB0aGVtZTogXCJyZW5kZXJlclwiLFxuICAgIGhhc0Nzc1RyYW5zZm9ybXM6IFwicmVuZGVyZXJcIixcbiAgICBtYXhQaXhlbEhlaWdodDogXCJyZW5kZXJlclwiLFxuICAgIHVzZVRleHRhcmVhRm9ySU1FOiBcInJlbmRlcmVyXCIsXG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IFwicmVuZGVyZXJcIixcbiAgICB1c2VTdmdHdXR0ZXJJY29uczogXCJyZW5kZXJlclwiLFxuICAgIHNob3dGb2xkZWRBbm5vdGF0aW9uczogXCJyZW5kZXJlclwiLFxuICAgIHNjcm9sbFNwZWVkOiBcIiRtb3VzZUhhbmRsZXJcIixcbiAgICBkcmFnRGVsYXk6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIGRyYWdFbmFibGVkOiBcIiRtb3VzZUhhbmRsZXJcIixcbiAgICBmb2N1c1RpbWVvdXQ6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIHRvb2x0aXBGb2xsb3dzTW91c2U6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIGZpcnN0TGluZU51bWJlcjogXCJzZXNzaW9uXCIsXG4gICAgb3ZlcndyaXRlOiBcInNlc3Npb25cIixcbiAgICBuZXdMaW5lTW9kZTogXCJzZXNzaW9uXCIsXG4gICAgdXNlV29ya2VyOiBcInNlc3Npb25cIixcbiAgICB1c2VTb2Z0VGFiczogXCJzZXNzaW9uXCIsXG4gICAgbmF2aWdhdGVXaXRoaW5Tb2Z0VGFiczogXCJzZXNzaW9uXCIsXG4gICAgdGFiU2l6ZTogXCJzZXNzaW9uXCIsXG4gICAgd3JhcDogXCJzZXNzaW9uXCIsXG4gICAgaW5kZW50ZWRTb2Z0V3JhcDogXCJzZXNzaW9uXCIsXG4gICAgZm9sZFN0eWxlOiBcInNlc3Npb25cIixcbiAgICBtb2RlOiBcInNlc3Npb25cIlxufSk7XG52YXIgcmVsYXRpdmVOdW1iZXJSZW5kZXJlciA9IHtcbiAgICBnZXRUZXh0OiBmdW5jdGlvbiAoLyoqQHR5cGV7RWRpdFNlc3Npb259Ki8gc2Vzc2lvbiwgLyoqQHR5cGV7bnVtYmVyfSovIHJvdykge1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKHNlc3Npb24uc2VsZWN0aW9uLmxlYWQucm93IC0gcm93KSB8fCAocm93ICsgMSArIChyb3cgPCA5ID8gXCJcXHhiN1wiIDogXCJcIikpKSArIFwiXCI7XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKHNlc3Npb24sIC8qKkB0eXBle251bWJlcn0qLyBsYXN0TGluZU51bWJlciwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChsYXN0TGluZU51bWJlci50b1N0cmluZygpLmxlbmd0aCwgKGNvbmZpZy5sYXN0Um93ICsgMSkudG9TdHJpbmcoKS5sZW5ndGgsIDIpICogY29uZmlnLmNoYXJhY3RlcldpZHRoO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZSwgLyoqQHR5cGV7RWRpdG9yfSovIGVkaXRvcikge1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuJGxvb3Auc2NoZWR1bGUoZWRpdG9yLnJlbmRlcmVyLkNIQU5HRV9HVVRURVIpO1xuICAgIH0sXG4gICAgYXR0YWNoOiBmdW5jdGlvbiAoLyoqQHR5cGV7RWRpdG9yfSovIGVkaXRvcikge1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLiRyZW5kZXJlciA9IHRoaXM7XG4gICAgICAgIGVkaXRvci5vbihcImNoYW5nZVNlbGVjdGlvblwiLCB0aGlzLnVwZGF0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlKG51bGwsIGVkaXRvcik7XG4gICAgfSxcbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgvKipAdHlwZXtFZGl0b3J9Ki8gZWRpdG9yKSB7XG4gICAgICAgIGlmIChlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLiRyZW5kZXJlciA9PSB0aGlzKVxuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllci4kcmVuZGVyZXIgPSBudWxsO1xuICAgICAgICBlZGl0b3Iub2ZmKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMudXBkYXRlKTtcbiAgICAgICAgdGhpcy51cGRhdGUobnVsbCwgZWRpdG9yKTtcbiAgICB9XG59O1xuZXhwb3J0cy5FZGl0b3IgPSBFZGl0b3I7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xheWVyL2xpbmVzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBMaW5lcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5lcyhlbGVtZW50LCBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQgfHwgNTAwMDAwO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuY2FudmFzSGVpZ2h0ICogMikgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2VsbHMgPSBbXTtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy4kb2Zmc2V0Q29lZmZpY2llbnQgPSAwO1xuICAgIH1cbiAgICBMaW5lcy5wcm90b3R5cGUubW92ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgZG9tLnRyYW5zbGF0ZSh0aGlzLmVsZW1lbnQsIDAsIC0oKGNvbmZpZy5maXJzdFJvd1NjcmVlbiAqIGNvbmZpZy5saW5lSGVpZ2h0KSAlIHRoaXMuY2FudmFzSGVpZ2h0KSAtIGNvbmZpZy5vZmZzZXQgKiB0aGlzLiRvZmZzZXRDb2VmZmljaWVudCk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUucGFnZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkQ29uZmlnLCBuZXdDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKChvbGRDb25maWcuZmlyc3RSb3dTY3JlZW4gKiBvbGRDb25maWcubGluZUhlaWdodCkgLyB0aGlzLmNhbnZhc0hlaWdodCkgIT09XG4gICAgICAgICAgICBNYXRoLmZsb29yKChuZXdDb25maWcuZmlyc3RSb3dTY3JlZW4gKiBuZXdDb25maWcubGluZUhlaWdodCkgLyB0aGlzLmNhbnZhc0hlaWdodCkpO1xuICAgIH07XG4gICAgTGluZXMucHJvdG90eXBlLmNvbXB1dGVMaW5lVG9wID0gZnVuY3Rpb24gKHJvdywgY29uZmlnLCBzZXNzaW9uKSB7XG4gICAgICAgIHZhciBzY3JlZW5Ub3AgPSBjb25maWcuZmlyc3RSb3dTY3JlZW4gKiBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgdmFyIHNjcmVlblBhZ2UgPSBNYXRoLmZsb29yKHNjcmVlblRvcCAvIHRoaXMuY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgdmFyIGxpbmVUb3AgPSBzZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Sb3cocm93LCAwKSAqIGNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICByZXR1cm4gbGluZVRvcCAtIChzY3JlZW5QYWdlICogdGhpcy5jYW52YXNIZWlnaHQpO1xuICAgIH07XG4gICAgTGluZXMucHJvdG90eXBlLmNvbXB1dGVMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKHJvdywgY29uZmlnLCBzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubGluZUhlaWdodCAqIHNlc3Npb24uZ2V0Um93TGluZUNvdW50KHJvdyk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxscy5sZW5ndGg7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzW2luZGV4XTtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kY2FjaGVDZWxsKHRoaXMuY2VsbHMuc2hpZnQoKSk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRjYWNoZUNlbGwodGhpcy5jZWxscy5wb3AoKSk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNlbGwpKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxzLnB1c2guYXBwbHkodGhpcy5jZWxscywgY2VsbCk7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb20uY3JlYXRlRnJhZ21lbnQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNlbGxbaV0uZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNlbGwuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbHMudW5zaGlmdC5hcHBseSh0aGlzLmNlbGxzLCBjZWxsKTtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGRvbS5jcmVhdGVGcmFnbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2VsbFtpXS5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCB0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbHMudW5zaGlmdChjZWxsKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGNlbGwuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxscy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsc1t0aGlzLmNlbGxzLmxlbmd0aCAtIDFdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS4kY2FjaGVDZWxsID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjZWxsLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLnB1c2goY2VsbCk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUuY3JlYXRlQ2VsbCA9IGZ1bmN0aW9uIChyb3csIGNvbmZpZywgc2Vzc2lvbiwgaW5pdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxDYWNoZS5wb3AoKTtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgaWYgKGluaXRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGluaXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgY2VsbCA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2VsbC5yb3cgPSByb3c7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVzO1xufSgpKTtcbmV4cG9ydHMuTGluZXMgPSBMaW5lcztcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvZ3V0dGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvbGF5ZXIvbGluZXNcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgb29wID0gcmVxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi9saWIvbGFuZ1wiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIExpbmVzID0gcmVxdWlyZShcIi4vbGluZXNcIikuTGluZXM7XG52YXIgbmxzID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKS5ubHM7XG52YXIgR3V0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd1dHRlcihwYXJlbnRFbCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX2xheWVyIGFjZV9ndXR0ZXItbGF5ZXJcIjtcbiAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy5zZXRTaG93Rm9sZFdpZGdldHModGhpcy4kc2hvd0ZvbGRXaWRnZXRzKTtcbiAgICAgICAgdGhpcy5ndXR0ZXJXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuJGFubm90YXRpb25zID0gW107XG4gICAgICAgIHRoaXMuJHVwZGF0ZUFubm90YXRpb25zID0gdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4kbGluZXMgPSBuZXcgTGluZXModGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy4kbGluZXMuJG9mZnNldENvZWZmaWNpZW50ID0gMTtcbiAgICB9XG4gICAgR3V0dGVyLnByb3RvdHlwZS5zZXRTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VcIiwgdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbilcbiAgICAgICAgICAgIHNlc3Npb24ub24oXCJjaGFuZ2VcIiwgdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMpO1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS5hZGRHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24gKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSlcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oXCJkZXByZWNhdGVkIHVzZSBzZXNzaW9uLmFkZEd1dHRlckRlY29yYXRpb25cIik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uIChyb3csIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKFwiZGVwcmVjYXRlZCB1c2Ugc2Vzc2lvbi5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uXCIpO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbihyb3csIGNsYXNzTmFtZSk7XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLnNldEFubm90YXRpb25zID0gZnVuY3Rpb24gKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuJGFubm90YXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgcm93ID0gYW5ub3RhdGlvbi5yb3c7XG4gICAgICAgICAgICB2YXIgcm93SW5mbyA9IHRoaXMuJGFubm90YXRpb25zW3Jvd107XG4gICAgICAgICAgICBpZiAoIXJvd0luZm8pXG4gICAgICAgICAgICAgICAgcm93SW5mbyA9IHRoaXMuJGFubm90YXRpb25zW3Jvd10gPSB7IHRleHQ6IFtdLCB0eXBlOiBbXSwgZGlzcGxheVRleHQ6IFtdIH07XG4gICAgICAgICAgICB2YXIgYW5ub1RleHQgPSBhbm5vdGF0aW9uLnRleHQ7XG4gICAgICAgICAgICB2YXIgZGlzcGxheUFubm9UZXh0ID0gYW5ub3RhdGlvbi50ZXh0O1xuICAgICAgICAgICAgdmFyIGFubm9UeXBlID0gYW5ub3RhdGlvbi50eXBlO1xuICAgICAgICAgICAgYW5ub1RleHQgPSBhbm5vVGV4dCA/IGxhbmcuZXNjYXBlSFRNTChhbm5vVGV4dCkgOiBhbm5vdGF0aW9uLmh0bWwgfHwgXCJcIjtcbiAgICAgICAgICAgIGRpc3BsYXlBbm5vVGV4dCA9IGRpc3BsYXlBbm5vVGV4dCA/IGRpc3BsYXlBbm5vVGV4dCA6IGFubm90YXRpb24uaHRtbCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHJvd0luZm8udGV4dC5pbmRleE9mKGFubm9UZXh0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByb3dJbmZvLnRleHQucHVzaChhbm5vVGV4dCk7XG4gICAgICAgICAgICAgICAgcm93SW5mby50eXBlLnB1c2goYW5ub1R5cGUpO1xuICAgICAgICAgICAgICAgIHJvd0luZm8uZGlzcGxheVRleHQucHVzaChkaXNwbGF5QW5ub1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGFubm90YXRpb24uY2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICByb3dJbmZvLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGFubm9UeXBlID09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByb3dJbmZvLmNsYXNzTmFtZSA9IFwiIGFjZV9lcnJvclwiO1xuICAgICAgICAgICAgZWxzZSBpZiAoYW5ub1R5cGUgPT0gXCJ3YXJuaW5nXCIgJiYgcm93SW5mby5jbGFzc05hbWUgIT0gXCIgYWNlX2Vycm9yXCIpXG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBcIiBhY2Vfd2FybmluZ1wiO1xuICAgICAgICAgICAgZWxzZSBpZiAoYW5ub1R5cGUgPT0gXCJpbmZvXCIgJiYgKCFyb3dJbmZvLmNsYXNzTmFtZSkpXG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBcIiBhY2VfaW5mb1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLiR1cGRhdGVBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICBpZiAoIXRoaXMuJGFubm90YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgICAgICB2YXIgbGVuID0gZGVsdGEuZW5kLnJvdyAtIGZpcnN0Um93O1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICB0aGlzLiRhbm5vdGF0aW9ucy5zcGxpY2UoZmlyc3RSb3csIGxlbiArIDEsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoZmlyc3RSb3csIDEpO1xuICAgICAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMuc3BsaWNlLmFwcGx5KHRoaXMuJGFubm90YXRpb25zLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gY29uZmlnLmZpcnN0Um93O1xuICAgICAgICB2YXIgbGFzdFJvdyA9IE1hdGgubWluKGNvbmZpZy5sYXN0Um93ICsgY29uZmlnLmd1dHRlck9mZnNldCwgLy8gbmVlZGVkIHRvIGNvbXBlbnNhdGUgZm9yIGhvciBzY29sbGJhclxuICAgICAgICBzZXNzaW9uLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIHRoaXMub2xkTGFzdFJvdyA9IGxhc3RSb3c7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLiRsaW5lcy5tb3ZlQ29udGFpbmVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUN1cnNvclJvdygpO1xuICAgICAgICB2YXIgZm9sZCA9IHNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKGZpcnN0Um93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGQgPyBmb2xkLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICB2YXIgY2VsbCA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgcm93ID0gZmlyc3RSb3c7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcm93ID0gZm9sZC5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICBmb2xkID0gc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93LCBmb2xkKTtcbiAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkID8gZm9sZC5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPiBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuJGxpbmVzLmdldExlbmd0aCgpID4gaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLiRsaW5lcy5nZXQoKytpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIGNlbGwucm93ID0gcm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IHRoaXMuJGxpbmVzLmNyZWF0ZUNlbGwocm93LCBjb25maWcsIHRoaXMuc2Vzc2lvbiwgb25DcmVhdGVDZWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2VsbChjZWxsLCBjb25maWcsIGZvbGQsIHJvdyk7XG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWwoXCJhZnRlclJlbmRlclwiKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlR3V0dGVyV2lkdGgoY29uZmlnKTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuJHVwZGF0ZUd1dHRlcldpZHRoID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGd1dHRlclJlbmRlcmVyID0gc2Vzc2lvbi5ndXR0ZXJSZW5kZXJlciB8fCB0aGlzLiRyZW5kZXJlcjtcbiAgICAgICAgdmFyIGZpcnN0TGluZU51bWJlciA9IHNlc3Npb24uJGZpcnN0TGluZU51bWJlcjtcbiAgICAgICAgdmFyIGxhc3RMaW5lVGV4dCA9IHRoaXMuJGxpbmVzLmxhc3QoKSA/IHRoaXMuJGxpbmVzLmxhc3QoKS50ZXh0IDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuJGZpeGVkV2lkdGggfHwgc2Vzc2lvbi4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICBsYXN0TGluZVRleHQgPSBzZXNzaW9uLmdldExlbmd0aCgpICsgZmlyc3RMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgdmFyIGd1dHRlcldpZHRoID0gZ3V0dGVyUmVuZGVyZXJcbiAgICAgICAgICAgID8gZ3V0dGVyUmVuZGVyZXIuZ2V0V2lkdGgoc2Vzc2lvbiwgbGFzdExpbmVUZXh0LCBjb25maWcpXG4gICAgICAgICAgICA6IGxhc3RMaW5lVGV4dC50b1N0cmluZygpLmxlbmd0aCAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLiRwYWRkaW5nIHx8IHRoaXMuJGNvbXB1dGVQYWRkaW5nKCk7XG4gICAgICAgIGd1dHRlcldpZHRoICs9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgIGlmIChndXR0ZXJXaWR0aCAhPT0gdGhpcy5ndXR0ZXJXaWR0aCAmJiAhaXNOYU4oZ3V0dGVyV2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmd1dHRlcldpZHRoID0gZ3V0dGVyV2lkdGg7ICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IE1hdGguY2VpbCh0aGlzLmd1dHRlcldpZHRoKSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUd1dHRlcldpZHRoXCIsIGd1dHRlcldpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS4kdXBkYXRlQ3Vyc29yUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGhpZ2hsaWdodEd1dHRlckxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmICh0aGlzLiRjdXJzb3JSb3cgPT09IHBvc2l0aW9uLnJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kY3Vyc29yUm93ID0gcG9zaXRpb24ucm93O1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS51cGRhdGVMaW5lSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGhpZ2hsaWdodEd1dHRlckxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvci5yb3c7XG4gICAgICAgIHRoaXMuJGN1cnNvclJvdyA9IHJvdztcbiAgICAgICAgaWYgKHRoaXMuJGN1cnNvckNlbGwgJiYgdGhpcy4kY3Vyc29yQ2VsbC5yb3cgPT0gcm93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kY3Vyc29yQ2VsbClcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckNlbGwuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLiRjdXJzb3JDZWxsLmVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoXCJhY2VfZ3V0dGVyLWFjdGl2ZS1saW5lIFwiLCBcIlwiKTtcbiAgICAgICAgdmFyIGNlbGxzID0gdGhpcy4kbGluZXMuY2VsbHM7XG4gICAgICAgIHRoaXMuJGN1cnNvckNlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgICAgICAgaWYgKGNlbGwucm93ID49IHRoaXMuJGN1cnNvclJvdykge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnJvdyA+IHRoaXMuJGN1cnNvclJvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkTGluZSh0aGlzLiRjdXJzb3JSb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgZm9sZCAmJiBmb2xkLnN0YXJ0LnJvdyA9PSBjZWxsc1tpIC0gMV0ucm93KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IGNlbGxzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9ndXR0ZXItYWN0aXZlLWxpbmUgXCIgKyBjZWxsLmVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuJGN1cnNvckNlbGwgPSBjZWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLnNjcm9sbExpbmVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgb2xkQ29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLiR1cGRhdGVDdXJzb3JSb3coKTtcbiAgICAgICAgaWYgKHRoaXMuJGxpbmVzLnBhZ2VDaGFuZ2VkKG9sZENvbmZpZywgY29uZmlnKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICB0aGlzLiRsaW5lcy5tb3ZlQ29udGFpbmVyKGNvbmZpZyk7XG4gICAgICAgIHZhciBsYXN0Um93ID0gTWF0aC5taW4oY29uZmlnLmxhc3RSb3cgKyBjb25maWcuZ3V0dGVyT2Zmc2V0LCAvLyBuZWVkZWQgdG8gY29tcGVuc2F0ZSBmb3IgaG9yIHNjb2xsYmFyXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICB2YXIgb2xkTGFzdFJvdyA9IHRoaXMub2xkTGFzdFJvdztcbiAgICAgICAgdGhpcy5vbGRMYXN0Um93ID0gbGFzdFJvdztcbiAgICAgICAgaWYgKCFvbGRDb25maWcgfHwgb2xkTGFzdFJvdyA8IGNvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICBpZiAobGFzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICBpZiAob2xkQ29uZmlnLmZpcnN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KG9sZENvbmZpZy5maXJzdFJvdywgY29uZmlnLmZpcnN0Um93IC0gMSk7IHJvdyA+IDA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvbGRMYXN0Um93ID4gbGFzdFJvdylcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkZWRSb3dDb3VudChsYXN0Um93ICsgMSwgb2xkTGFzdFJvdyk7IHJvdyA+IDA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpbmVzLnBvcCgpO1xuICAgICAgICBpZiAoY29uZmlnLmZpcnN0Um93IDwgb2xkQ29uZmlnLmZpcnN0Um93KSB7XG4gICAgICAgICAgICB0aGlzLiRsaW5lcy51bnNoaWZ0KHRoaXMuJHJlbmRlckxpbmVzKGNvbmZpZywgY29uZmlnLmZpcnN0Um93LCBvbGRDb25maWcuZmlyc3RSb3cgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSb3cgPiBvbGRMYXN0Um93KSB7XG4gICAgICAgICAgICB0aGlzLiRsaW5lcy5wdXNoKHRoaXMuJHJlbmRlckxpbmVzKGNvbmZpZywgb2xkTGFzdFJvdyArIDEsIGxhc3RSb3cpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUxpbmVIaWdobGlnaHQoKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUd1dHRlcldpZHRoKGNvbmZpZyk7XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLiRyZW5kZXJMaW5lcyA9IGZ1bmN0aW9uIChjb25maWcsIGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IFtdO1xuICAgICAgICB2YXIgcm93ID0gZmlyc3RSb3c7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcm93ID0gZm9sZExpbmUuZW5kLnJvdyArIDE7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdywgZm9sZExpbmUpO1xuICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93ID4gbGFzdFJvdylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy4kbGluZXMuY3JlYXRlQ2VsbChyb3csIGNvbmZpZywgdGhpcy5zZXNzaW9uLCBvbkNyZWF0ZUNlbGwpO1xuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2VsbChjZWxsLCBjb25maWcsIGZvbGRMaW5lLCByb3cpO1xuICAgICAgICAgICAgZnJhZ21lbnQucHVzaChjZWxsKTtcbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuJHJlbmRlckNlbGwgPSBmdW5jdGlvbiAoY2VsbCwgY29uZmlnLCBmb2xkLCByb3cpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjZWxsLmVsZW1lbnQ7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBlbGVtZW50LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIHZhciBmb2xkV2lkZ2V0ID0gZWxlbWVudC5jaGlsZE5vZGVzWzFdO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbk5vZGUgPSBlbGVtZW50LmNoaWxkTm9kZXNbMl07XG4gICAgICAgIHZhciBhbm5vdGF0aW9uSWNvbk5vZGUgPSBhbm5vdGF0aW9uTm9kZS5maXJzdENoaWxkO1xuICAgICAgICB2YXIgZmlyc3RMaW5lTnVtYmVyID0gc2Vzc2lvbi4kZmlyc3RMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgYnJlYWtwb2ludHMgPSBzZXNzaW9uLiRicmVha3BvaW50cztcbiAgICAgICAgdmFyIGRlY29yYXRpb25zID0gc2Vzc2lvbi4kZGVjb3JhdGlvbnM7XG4gICAgICAgIHZhciBndXR0ZXJSZW5kZXJlciA9IHNlc3Npb24uZ3V0dGVyUmVuZGVyZXIgfHwgdGhpcy4kcmVuZGVyZXI7XG4gICAgICAgIHZhciBmb2xkV2lkZ2V0cyA9IHRoaXMuJHNob3dGb2xkV2lkZ2V0cyAmJiBzZXNzaW9uLmZvbGRXaWRnZXRzO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBjb25maWcubGluZUhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuJHVzZVN2Z0d1dHRlckljb25zID8gXCJhY2VfZ3V0dGVyLWNlbGxfc3ZnLWljb25zIFwiIDogXCJhY2VfZ3V0dGVyLWNlbGwgXCI7XG4gICAgICAgIHZhciBpY29uQ2xhc3NOYW1lID0gdGhpcy4kdXNlU3ZnR3V0dGVySWNvbnMgPyBcImFjZV9pY29uX3N2Z1wiIDogXCJhY2VfaWNvblwiO1xuICAgICAgICB2YXIgcm93VGV4dCA9IChndXR0ZXJSZW5kZXJlclxuICAgICAgICAgICAgPyBndXR0ZXJSZW5kZXJlci5nZXRUZXh0KHNlc3Npb24sIHJvdylcbiAgICAgICAgICAgIDogcm93ICsgZmlyc3RMaW5lTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0R3V0dGVyTGluZSkge1xuICAgICAgICAgICAgaWYgKHJvdyA9PSB0aGlzLiRjdXJzb3JSb3cgfHwgKGZvbGQgJiYgcm93IDwgdGhpcy4kY3Vyc29yUm93ICYmIHJvdyA+PSBmb2xkU3RhcnQgJiYgdGhpcy4kY3Vyc29yUm93IDw9IGZvbGQuZW5kLnJvdykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gXCJhY2VfZ3V0dGVyLWFjdGl2ZS1saW5lIFwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJzb3JDZWxsICE9IGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJGN1cnNvckNlbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJzb3JDZWxsLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy4kY3Vyc29yQ2VsbC5lbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFwiYWNlX2d1dHRlci1hY3RpdmUtbGluZSBcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1cnNvckNlbGwgPSBjZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtwb2ludHNbcm93XSlcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBicmVha3BvaW50c1tyb3ddO1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnNbcm93XSlcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBkZWNvcmF0aW9uc1tyb3ddO1xuICAgICAgICBpZiAodGhpcy4kYW5ub3RhdGlvbnNbcm93XSAmJiByb3cgIT09IGZvbGRTdGFydClcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSB0aGlzLiRhbm5vdGF0aW9uc1tyb3ddLmNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGZvbGRXaWRnZXRzKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGZvbGRXaWRnZXRzW3Jvd107XG4gICAgICAgICAgICBpZiAoYyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGMgPSBmb2xkV2lkZ2V0c1tyb3ddID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0KHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIHZhciBmb2xkQ2xhc3MgPSBcImFjZV9mb2xkLXdpZGdldCBhY2VfXCIgKyBjO1xuICAgICAgICAgICAgdmFyIGlzQ2xvc2VkRm9sZCA9IGMgPT0gXCJzdGFydFwiICYmIHJvdyA9PSBmb2xkU3RhcnQgJiYgcm93IDwgZm9sZC5lbmQucm93O1xuICAgICAgICAgICAgaWYgKGlzQ2xvc2VkRm9sZCkge1xuICAgICAgICAgICAgICAgIGZvbGRDbGFzcyArPSBcIiBhY2VfY2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRBbm5vdGF0aW9uQ2xhc3MgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluRm9sZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSByb3cgKyAxOyBpIDw9IGZvbGQuZW5kLnJvdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4kYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJGFubm90YXRpb25zW2ldLmNsYXNzTmFtZSA9PT0gXCIgYWNlX2Vycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25JbkZvbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZEFubm90YXRpb25DbGFzcyA9IFwiIGFjZV9lcnJvcl9mb2xkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kYW5ub3RhdGlvbnNbaV0uY2xhc3NOYW1lID09PSBcIiBhY2Vfd2FybmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uSW5Gb2xkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRBbm5vdGF0aW9uQ2xhc3MgPSBcIiBhY2Vfd2FybmluZ19mb2xkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gZm9sZEFubm90YXRpb25DbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb2xkQ2xhc3MgKz0gXCIgYWNlX29wZW5cIjtcbiAgICAgICAgICAgIGlmIChmb2xkV2lkZ2V0LmNsYXNzTmFtZSAhPSBmb2xkQ2xhc3MpXG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5jbGFzc05hbWUgPSBmb2xkQ2xhc3M7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoZm9sZFdpZGdldC5zdHlsZSwgXCJoZWlnaHRcIiwgbGluZUhlaWdodCk7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoZm9sZFdpZGdldC5zdHlsZSwgXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpO1xuICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICAgICAgICAgICAgdmFyIGZvbGRSYW5nZSA9IHNlc3Npb24uZ2V0Rm9sZFdpZGdldFJhbmdlKHJvdyk7XG4gICAgICAgICAgICBpZiAoZm9sZFJhbmdlKVxuICAgICAgICAgICAgICAgIGZvbGRXaWRnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBubHMoXCJndXR0ZXIuY29kZS1mb2xkaW5nLnJhbmdlLmFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgY29kZSBmb2xkaW5nLCByb3dzICQwIHRocm91Z2ggJDFcIiwgW2ZvbGRSYW5nZS5zdGFydC5yb3cgKyAxLCBmb2xkUmFuZ2UuZW5kLnJvdyArIDFdKSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZClcbiAgICAgICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG5scyhcImd1dHRlci5jb2RlLWZvbGRpbmcuY2xvc2VkLmFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgY29kZSBmb2xkaW5nLCByb3dzICQwIHRocm91Z2ggJDFcIiwgW2ZvbGQuc3RhcnQucm93ICsgMSwgZm9sZC5lbmQucm93ICsgMV0pKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvbGRXaWRnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBubHMoXCJndXR0ZXIuY29kZS1mb2xkaW5nLm9wZW4uYXJpYS1sYWJlbFwiLCBcIlRvZ2dsZSBjb2RlIGZvbGRpbmcsIHJvdyAkMFwiLCBbcm93ICsgMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Nsb3NlZEZvbGQpIHtcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIG5scyhcImd1dHRlci5jb2RlLWZvbGRpbmcuY2xvc2VkLnRpdGxlXCIsIFwiVW5mb2xkIGNvZGVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIG5scyhcImd1dHRlci5jb2RlLWZvbGRpbmcub3Blbi50aXRsZVwiLCBcIkZvbGQgY29kZVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9sZFdpZGdldCkge1xuICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShmb2xkV2lkZ2V0LnN0eWxlLCBcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICAgICAgICAgIGZvbGRXaWRnZXQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIGZvbGRXaWRnZXQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKTtcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb25JbkZvbGQgJiYgdGhpcy4kc2hvd0ZvbGRlZEFubm90YXRpb25zKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uTm9kZS5jbGFzc05hbWUgPSBcImFjZV9ndXR0ZXJfYW5ub3RhdGlvblwiO1xuICAgICAgICAgICAgYW5ub3RhdGlvbkljb25Ob2RlLmNsYXNzTmFtZSA9IGljb25DbGFzc05hbWU7XG4gICAgICAgICAgICBhbm5vdGF0aW9uSWNvbk5vZGUuY2xhc3NOYW1lICs9IGZvbGRBbm5vdGF0aW9uQ2xhc3M7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbkljb25Ob2RlLnN0eWxlLCBcImhlaWdodFwiLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShhbm5vdGF0aW9uTm9kZS5zdHlsZSwgXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbk5vZGUuc3R5bGUsIFwiaGVpZ2h0XCIsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGFyaWFMYWJlbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZm9sZEFubm90YXRpb25DbGFzcykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIgYWNlX2Vycm9yX2ZvbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsID0gbmxzKFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC5lcnJvclwiLCBcIlJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsIFtyb3dUZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIgYWNlX3dhcm5pbmdfZm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICBhcmlhTGFiZWwgPSBubHMoXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLndhcm5pbmdcIiwgXCJSZWFkIGFubm90YXRpb25zIHJvdyAkMFwiLCBbcm93VGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgYXJpYUxhYmVsKTtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgICAgICAgICBhbm5vdGF0aW9uTm9kZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJGFubm90YXRpb25zW3Jvd10pIHtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLmNsYXNzTmFtZSA9IFwiYWNlX2d1dHRlcl9hbm5vdGF0aW9uXCI7XG4gICAgICAgICAgICBhbm5vdGF0aW9uSWNvbk5vZGUuY2xhc3NOYW1lID0gaWNvbkNsYXNzTmFtZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VTdmdHdXR0ZXJJY29ucylcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uSWNvbk5vZGUuY2xhc3NOYW1lICs9IHRoaXMuJGFubm90YXRpb25zW3Jvd10uY2xhc3NOYW1lO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLiRhbm5vdGF0aW9uc1tyb3ddLmNsYXNzTmFtZS5yZXBsYWNlKFwiIFwiLCBcIlwiKSk7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbkljb25Ob2RlLnN0eWxlLCBcImhlaWdodFwiLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShhbm5vdGF0aW9uTm9kZS5zdHlsZSwgXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbk5vZGUuc3R5bGUsIFwiaGVpZ2h0XCIsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGFyaWFMYWJlbDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy4kYW5ub3RhdGlvbnNbcm93XS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiIGFjZV9lcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBhcmlhTGFiZWwgPSBubHMoXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLmVycm9yXCIsIFwiUmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIiwgW3Jvd1RleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiBhY2Vfd2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBhcmlhTGFiZWwgPSBubHMoXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLndhcm5pbmdcIiwgXCJSZWFkIGFubm90YXRpb25zIHJvdyAkMFwiLCBbcm93VGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiIGFjZV9pbmZvXCI6XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IG5scyhcImd1dHRlci5hbm5vdGF0aW9uLmFyaWEtbGFiZWwuaW5mb1wiLCBcIlJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsIFtyb3dUZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbk5vZGUuc3R5bGUsIFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICBhbm5vdGF0aW9uTm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKTtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm93VGV4dCAhPT0gdGV4dE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgdGV4dE5vZGUuZGF0YSA9IHJvd1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lICE9IGNsYXNzTmFtZSlcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICBkb20uc2V0U3R5bGUoY2VsbC5lbGVtZW50LnN0eWxlLCBcImhlaWdodFwiLCB0aGlzLiRsaW5lcy5jb21wdXRlTGluZUhlaWdodChyb3csIGNvbmZpZywgc2Vzc2lvbikgKyBcInB4XCIpO1xuICAgICAgICBkb20uc2V0U3R5bGUoY2VsbC5lbGVtZW50LnN0eWxlLCBcInRvcFwiLCB0aGlzLiRsaW5lcy5jb21wdXRlTGluZVRvcChyb3csIGNvbmZpZywgc2Vzc2lvbikgKyBcInB4XCIpO1xuICAgICAgICBjZWxsLnRleHQgPSByb3dUZXh0O1xuICAgICAgICBpZiAoYW5ub3RhdGlvbk5vZGUuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgJiYgZm9sZFdpZGdldC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIilcbiAgICAgICAgICAgIGNlbGwuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2VsbC5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodEd1dHRlckxpbmUgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0R3V0dGVyTGluZSkge1xuICAgICAgICB0aGlzLiRoaWdobGlnaHRHdXR0ZXJMaW5lID0gaGlnaGxpZ2h0R3V0dGVyTGluZTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuc2V0U2hvd0xpbmVOdW1iZXJzID0gZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgdGhpcy4kcmVuZGVyZXIgPSAhc2hvdyAmJiB7XG4gICAgICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCI7IH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuZ2V0U2hvd0xpbmVOdW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2hvd0xpbmVOdW1iZXJzO1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS5zZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICBpZiAoc2hvdylcbiAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2ZvbGRpbmctZW5hYmxlZFwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfZm9sZGluZy1lbmFibGVkXCIpO1xuICAgICAgICB0aGlzLiRzaG93Rm9sZFdpZGdldHMgPSBzaG93O1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gbnVsbDtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuZ2V0U2hvd0ZvbGRXaWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2hvd0ZvbGRXaWRnZXRzO1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS4kY29tcHV0ZVBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBkb20uY29tcHV0ZWRTdHlsZSgvKipAdHlwZXtFbGVtZW50fSovICh0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZCkpO1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0ge307XG4gICAgICAgIHRoaXMuJHBhZGRpbmcubGVmdCA9IChwYXJzZUludChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDApXG4gICAgICAgICAgICArIChwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCkgfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLiRwYWRkaW5nLnJpZ2h0ID0gKHBhcnNlSW50KHN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpIHx8IDApXG4gICAgICAgICAgICArIChwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDApO1xuICAgICAgICByZXR1cm4gdGhpcy4kcGFkZGluZztcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuZ2V0UmVnaW9uID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZyB8fCB0aGlzLiRjb21wdXRlUGFkZGluZygpO1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHBvaW50LnggPCBwYWRkaW5nLmxlZnQgKyByZWN0LmxlZnQpXG4gICAgICAgICAgICByZXR1cm4gXCJtYXJrZXJzXCI7XG4gICAgICAgIGlmICh0aGlzLiRzaG93Rm9sZFdpZGdldHMgJiYgcG9pbnQueCA+IHJlY3QucmlnaHQgLSBwYWRkaW5nLnJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIFwiZm9sZFdpZGdldHNcIjtcbiAgICB9O1xuICAgIHJldHVybiBHdXR0ZXI7XG59KCkpO1xuR3V0dGVyLnByb3RvdHlwZS4kZml4ZWRXaWR0aCA9IGZhbHNlO1xuR3V0dGVyLnByb3RvdHlwZS4kaGlnaGxpZ2h0R3V0dGVyTGluZSA9IHRydWU7XG5HdXR0ZXIucHJvdG90eXBlLiRyZW5kZXJlciA9IFwiXCI7XG5HdXR0ZXIucHJvdG90eXBlLiRzaG93TGluZU51bWJlcnMgPSB0cnVlO1xuR3V0dGVyLnByb3RvdHlwZS4kc2hvd0ZvbGRXaWRnZXRzID0gdHJ1ZTtcbm9vcC5pbXBsZW1lbnQoR3V0dGVyLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uIG9uQ3JlYXRlQ2VsbChlbGVtZW50KSB7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIHZhciBmb2xkV2lkZ2V0ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9sZFdpZGdldCk7XG4gICAgdmFyIGFubm90YXRpb25Ob2RlID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYW5ub3RhdGlvbk5vZGUpO1xuICAgIHZhciBhbm5vdGF0aW9uSWNvbk5vZGUgPSBkb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYW5ub3RhdGlvbk5vZGUuYXBwZW5kQ2hpbGQoYW5ub3RhdGlvbkljb25Ob2RlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmV4cG9ydHMuR3V0dGVyID0gR3V0dGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci9tYXJrZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgTWFya2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtlcihwYXJlbnRFbCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX2xheWVyIGFjZV9tYXJrZXItbGF5ZXJcIjtcbiAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgTWFya2VyLnByb3RvdHlwZS5zZXRQYWRkaW5nID0gZnVuY3Rpb24gKHBhZGRpbmcpIHtcbiAgICAgICAgdGhpcy4kcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5zZXRNYXJrZXJzID0gZnVuY3Rpb24gKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUuZWx0ID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgY3NzKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5pICE9IC0xICYmIHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzW3RoaXMuaV07XG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoeCk7XG4gICAgICAgICAgICB0aGlzLmkgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSsrO1xuICAgICAgICB9XG4gICAgICAgIHguc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgeC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKCFjb25maWcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB2YXIgaHRtbDtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubWFya2Vycykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMubWFya2Vyc1trZXldO1xuICAgICAgICAgICAgaWYgKCFtYXJrZXIucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIudXBkYXRlKGh0bWwsIHRoaXMsIHRoaXMuc2Vzc2lvbiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5nZSA9IG1hcmtlci5yYW5nZS5jbGlwUm93cyhjb25maWcuZmlyc3RSb3csIGNvbmZpZy5sYXN0Um93KTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByYW5nZSA9IHJhbmdlLnRvU2NyZWVuUmFuZ2UodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuJHBhZGRpbmcgKyByYW5nZS5zdGFydC5jb2x1bW4gKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcmVyKGh0bWwsIHJhbmdlLCBsZWZ0LCB0b3AsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXJrZXIudHlwZSA9PSBcImZ1bGxMaW5lXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdGdWxsTGluZU1hcmtlcihodG1sLCByYW5nZSwgbWFya2VyLmNsYXp6LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFya2VyLnR5cGUgPT0gXCJzY3JlZW5MaW5lXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTY3JlZW5MaW5lTWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci50eXBlID09IFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdUZXh0TWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdNdWx0aUxpbmVNYXJrZXIoaHRtbCwgcmFuZ2UsIG1hcmtlci5jbGF6eiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIoaHRtbCwgcmFuZ2UsIG1hcmtlci5jbGF6eiArIFwiIGFjZV9zdGFydFwiICsgXCIgYWNlX2JyMTVcIiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pICE9IC0xKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pIDwgdGhpcy5lbGVtZW50LmNoaWxkRWxlbWVudENvdW50KVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS4kZ2V0VG9wID0gZnVuY3Rpb24gKHJvdywgbGF5ZXJDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIChyb3cgLSBsYXllckNvbmZpZy5maXJzdFJvd1NjcmVlbikgKiBsYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5kcmF3VGV4dE1hcmtlciA9IGZ1bmN0aW9uIChzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGxheWVyQ29uZmlnLCBleHRyYVN0eWxlKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQucm93O1xuICAgICAgICB2YXIgcm93ID0gc3RhcnQ7XG4gICAgICAgIHZhciBwcmV2ID0gMDtcbiAgICAgICAgdmFyIGN1cnIgPSAwO1xuICAgICAgICB2YXIgbmV4dCA9IHNlc3Npb24uZ2V0U2NyZWVuTGFzdFJvd0NvbHVtbihyb3cpO1xuICAgICAgICB2YXIgbGluZVJhbmdlID0gbmV3IFJhbmdlKHJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLCByb3csIGN1cnIpO1xuICAgICAgICBmb3IgKDsgcm93IDw9IGVuZDsgcm93KyspIHtcbiAgICAgICAgICAgIGxpbmVSYW5nZS5zdGFydC5yb3cgPSBsaW5lUmFuZ2UuZW5kLnJvdyA9IHJvdztcbiAgICAgICAgICAgIGxpbmVSYW5nZS5zdGFydC5jb2x1bW4gPSByb3cgPT0gc3RhcnQgPyByYW5nZS5zdGFydC5jb2x1bW4gOiBzZXNzaW9uLmdldFJvd1dyYXBJbmRlbnQocm93KTtcbiAgICAgICAgICAgIGxpbmVSYW5nZS5lbmQuY29sdW1uID0gbmV4dDtcbiAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gcm93ICsgMSA8IGVuZCA/IHNlc3Npb24uZ2V0U2NyZWVuTGFzdFJvd0NvbHVtbihyb3cgKyAxKSA6IHJvdyA9PSBlbmQgPyAwIDogcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIoc3RyaW5nQnVpbGRlciwgbGluZVJhbmdlLCBjbGF6eiArIChyb3cgPT0gc3RhcnQgPyBcIiBhY2Vfc3RhcnRcIiA6IFwiXCIpICsgXCIgYWNlX2JyXCJcbiAgICAgICAgICAgICAgICArIGdldEJvcmRlckNsYXNzKHJvdyA9PSBzdGFydCB8fCByb3cgPT0gc3RhcnQgKyAxICYmIHJhbmdlLnN0YXJ0LmNvbHVtbiwgcHJldiA8IGN1cnIsIGN1cnIgPiBuZXh0LCByb3cgPT0gZW5kKSwgbGF5ZXJDb25maWcsIHJvdyA9PSBlbmQgPyAwIDogMSwgZXh0cmFTdHlsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUuZHJhd011bHRpTGluZU1hcmtlciA9IGZ1bmN0aW9uIChzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuJHBhZGRpbmc7XG4gICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBsZWZ0ID0gcGFkZGluZyArIHJhbmdlLnN0YXJ0LmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgZXh0cmFTdHlsZSA9IGV4dHJhU3R5bGUgfHwgXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuaXNCaWRpUm93KHJhbmdlLnN0YXJ0LnJvdykpIHtcbiAgICAgICAgICAgIHZhciByYW5nZTEgPSByYW5nZS5jbG9uZSgpO1xuICAgICAgICAgICAgcmFuZ2UxLmVuZC5yb3cgPSByYW5nZTEuc3RhcnQucm93O1xuICAgICAgICAgICAgcmFuZ2UxLmVuZC5jb2x1bW4gPSB0aGlzLnNlc3Npb24uZ2V0TGluZShyYW5nZTEuc3RhcnQucm93KS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRyYXdCaWRpU2luZ2xlTGluZU1hcmtlcihzdHJpbmdCdWlsZGVyLCByYW5nZTEsIGNsYXp6ICsgXCIgYWNlX2JyMSBhY2Vfc3RhcnRcIiwgY29uZmlnLCBudWxsLCBleHRyYVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWx0KGNsYXp6ICsgXCIgYWNlX2JyMSBhY2Vfc3RhcnRcIiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICsgXCJyaWdodDowO1wiICsgXCJ0b3A6XCIgKyB0b3AgKyBcInB4O2xlZnQ6XCIgKyBsZWZ0ICsgXCJweDtcIiArIChleHRyYVN0eWxlIHx8IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5pc0JpZGlSb3cocmFuZ2UuZW5kLnJvdykpIHtcbiAgICAgICAgICAgIHZhciByYW5nZTEgPSByYW5nZS5jbG9uZSgpO1xuICAgICAgICAgICAgcmFuZ2UxLnN0YXJ0LnJvdyA9IHJhbmdlMS5lbmQucm93O1xuICAgICAgICAgICAgcmFuZ2UxLnN0YXJ0LmNvbHVtbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmRyYXdCaWRpU2luZ2xlTGluZU1hcmtlcihzdHJpbmdCdWlsZGVyLCByYW5nZTEsIGNsYXp6ICsgXCIgYWNlX2JyMTJcIiwgY29uZmlnLCBudWxsLCBleHRyYVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5lbmQucm93LCBjb25maWcpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmFuZ2UuZW5kLmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWx0KGNsYXp6ICsgXCIgYWNlX2JyMTJcIiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcIndpZHRoOlwiICsgd2lkdGggKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcInRvcDpcIiArIHRvcCArIFwicHg7XCIgK1xuICAgICAgICAgICAgICAgIFwibGVmdDpcIiArIHBhZGRpbmcgKyBcInB4O1wiICsgKGV4dHJhU3R5bGUgfHwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCA9IChyYW5nZS5lbmQucm93IC0gcmFuZ2Uuc3RhcnQucm93IC0gMSkgKiBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgaWYgKGhlaWdodCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93ICsgMSwgY29uZmlnKTtcbiAgICAgICAgdmFyIHJhZGl1c0NsYXNzID0gKHJhbmdlLnN0YXJ0LmNvbHVtbiA/IDEgOiAwKSB8IChyYW5nZS5lbmQuY29sdW1uID8gMCA6IDgpO1xuICAgICAgICB0aGlzLmVsdChjbGF6eiArIChyYWRpdXNDbGFzcyA/IFwiIGFjZV9iclwiICsgcmFkaXVzQ2xhc3MgOiBcIlwiKSwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwicmlnaHQ6MDtcIiArXG4gICAgICAgICAgICBcInRvcDpcIiArIHRvcCArIFwicHg7XCIgK1xuICAgICAgICAgICAgXCJsZWZ0OlwiICsgcGFkZGluZyArIFwicHg7XCIgKyAoZXh0cmFTdHlsZSB8fCBcIlwiKSk7XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLmRyYXdTaW5nbGVMaW5lTWFya2VyID0gZnVuY3Rpb24gKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYUxlbmd0aCwgZXh0cmFTdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5pc0JpZGlSb3cocmFuZ2Uuc3RhcnQucm93KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdCaWRpU2luZ2xlTGluZU1hcmtlcihzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFMZW5ndGgsIGV4dHJhU3R5bGUpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IChyYW5nZS5lbmQuY29sdW1uICsgKGV4dHJhTGVuZ3RoIHx8IDApIC0gcmFuZ2Uuc3RhcnQuY29sdW1uKSAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy4kcGFkZGluZyArIHJhbmdlLnN0YXJ0LmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdGhpcy5lbHQoY2xhenosIFwiaGVpZ2h0OlwiICsgaGVpZ2h0ICsgXCJweDtcIiArXG4gICAgICAgICAgICBcIndpZHRoOlwiICsgd2lkdGggKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICBcImxlZnQ6XCIgKyBsZWZ0ICsgXCJweDtcIiArIChleHRyYVN0eWxlIHx8IFwiXCIpKTtcbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUuZHJhd0JpZGlTaW5nbGVMaW5lTWFya2VyID0gZnVuY3Rpb24gKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYUxlbmd0aCwgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQsIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyksIHBhZGRpbmcgPSB0aGlzLiRwYWRkaW5nO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuZ2V0U2VsZWN0aW9ucyhyYW5nZS5zdGFydC5jb2x1bW4sIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5lbHQoY2xhenosIFwiaGVpZ2h0OlwiICsgaGVpZ2h0ICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgXCJ3aWR0aDpcIiArIChzZWxlY3Rpb24ud2lkdGggKyAoZXh0cmFMZW5ndGggfHwgMCkpICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgXCJ0b3A6XCIgKyB0b3AgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcImxlZnQ6XCIgKyAocGFkZGluZyArIHNlbGVjdGlvbi5sZWZ0KSArIFwicHg7XCIgKyAoZXh0cmFTdHlsZSB8fCBcIlwiKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5kcmF3RnVsbExpbmVNYXJrZXIgPSBmdW5jdGlvbiAoc3RyaW5nQnVpbGRlciwgcmFuZ2UsIGNsYXp6LCBjb25maWcsIGV4dHJhU3R5bGUpIHtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyAhPSByYW5nZS5lbmQucm93KVxuICAgICAgICAgICAgaGVpZ2h0ICs9IHRoaXMuJGdldFRvcChyYW5nZS5lbmQucm93LCBjb25maWcpIC0gdG9wO1xuICAgICAgICB0aGlzLmVsdChjbGF6eiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICBcImxlZnQ6MDtyaWdodDowO1wiICsgKGV4dHJhU3R5bGUgfHwgXCJcIikpO1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5kcmF3U2NyZWVuTGluZU1hcmtlciA9IGZ1bmN0aW9uIChzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmVsdChjbGF6eiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICBcImxlZnQ6MDtyaWdodDowO1wiICsgKGV4dHJhU3R5bGUgfHwgXCJcIikpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtlcjtcbn0oKSk7XG5NYXJrZXIucHJvdG90eXBlLiRwYWRkaW5nID0gMDtcbmZ1bmN0aW9uIGdldEJvcmRlckNsYXNzKHRsLCB0ciwgYnIsIGJsKSB7XG4gICAgcmV0dXJuICh0bCA/IDEgOiAwKSB8ICh0ciA/IDIgOiAwKSB8IChiciA/IDQgOiAwKSB8IChibCA/IDggOiAwKTtcbn1cbmV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci90ZXh0X3V0aWxcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7Ly8gVG9rZW5zIGZvciB3aGljaCBBY2UganVzdCB1c2VzIGEgc2ltcGxlIFRleHROb2RlIGFuZCBkb2VzIG5vdCBhZGQgYW55IHNwZWNpYWwgY2xhc3NOYW1lLlxudmFyIHRleHRUb2tlbnMgPSBuZXcgU2V0KFtcInRleHRcIiwgXCJycGFyZW5cIiwgXCJscGFyZW5cIl0pO1xuZXhwb3J0cy5pc1RleHRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlblR5cGUpIHtcbiAgICByZXR1cm4gdGV4dFRva2Vucy5oYXModG9rZW5UeXBlKTtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xheWVyL3RleHRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGF5ZXIvbGluZXNcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2xheWVyL3RleHRfdXRpbFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIExpbmVzID0gcmVxdWlyZShcIi4vbGluZXNcIikuTGluZXM7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBubHMgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpLm5scztcbnZhciBpc1RleHRUb2tlbiA9IHJlcXVpcmUoXCIuL3RleHRfdXRpbFwiKS5pc1RleHRUb2tlbjtcbnZhciBUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHQocGFyZW50RWwpIHtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9sYXllciBhY2VfdGV4dC1sYXllclwiO1xuICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLiR1cGRhdGVFb2xDaGFyID0gdGhpcy4kdXBkYXRlRW9sQ2hhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiRsaW5lcyA9IG5ldyBMaW5lcyh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS4kdXBkYXRlRW9sQ2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuc2Vzc2lvbi5kb2M7XG4gICAgICAgIHZhciB1bml4TW9kZSA9IGRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkgPT0gXCJcXG5cIiAmJiBkb2MuZ2V0TmV3TGluZU1vZGUoKSAhPSBcIndpbmRvd3NcIjtcbiAgICAgICAgdmFyIEVPTF9DSEFSID0gdW5peE1vZGUgPyB0aGlzLkVPTF9DSEFSX0xGIDogdGhpcy5FT0xfQ0hBUl9DUkxGO1xuICAgICAgICBpZiAodGhpcy5FT0xfQ0hBUiAhPSBFT0xfQ0hBUikge1xuICAgICAgICAgICAgdGhpcy5FT0xfQ0hBUiA9IEVPTF9DSEFSO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbiA9IFwiMCBcIiArIHBhZGRpbmcgKyBcInB4XCI7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5nZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZm9udE1ldHJpY3MuJGNoYXJhY3RlclNpemUuaGVpZ2h0IHx8IDA7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5nZXRDaGFyYWN0ZXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvbnRNZXRyaWNzLiRjaGFyYWN0ZXJTaXplLndpZHRoIHx8IDA7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kc2V0Rm9udE1ldHJpY3MgPSBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgICB0aGlzLiRmb250TWV0cmljcyA9IG1lYXN1cmU7XG4gICAgICAgIHRoaXMuJGZvbnRNZXRyaWNzLm9uKFwiY2hhbmdlQ2hhcmFjdGVyU2l6ZVwiLCBcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUNoYXJhY3RlclNpemVcIiwgZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuJHBvbGxTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuY2hlY2tGb3JTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kZm9udE1ldHJpY3MuY2hlY2tGb3JTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHBvbGxTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyID0gdGhpcy4kZm9udE1ldHJpY3MuJHBvbGxTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbiAoc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMgPT0gc2hvd0ludmlzaWJsZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvd0ludmlzaWJsZXMgPSBzaG93SW52aXNpYmxlcztcbiAgICAgICAgaWYgKHR5cGVvZiBzaG93SW52aXNpYmxlcyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dTcGFjZXMgPSAvdGFiL2kudGVzdChzaG93SW52aXNpYmxlcyk7XG4gICAgICAgICAgICB0aGlzLnNob3dUYWJzID0gL3NwYWNlL2kudGVzdChzaG93SW52aXNpYmxlcyk7XG4gICAgICAgICAgICB0aGlzLnNob3dFT0wgPSAvZW9sL2kudGVzdChzaG93SW52aXNpYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3dTcGFjZXMgPSB0aGlzLnNob3dUYWJzID0gdGhpcy5zaG93RU9MID0gc2hvd0ludmlzaWJsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgICBpZiAodGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzID09IGRpc3BsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGxheUluZGVudEd1aWRlcyA9IGRpc3BsYXk7XG4gICAgICAgIHRoaXMuJGNvbXB1dGVUYWJTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5zZXRIaWdobGlnaHRJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZXMgPT09IGhpZ2hsaWdodClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVzID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0O1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJGNvbXB1dGVUYWJTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTsgdmFyIHRhYlN0ciA9IHRoaXMuJHRhYlN0cmluZ3MgPSBbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGFiU2l6ZSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1RhYnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfdGFiXCI7XG4gICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KHRoaXMuVEFCX0NIQVIsIGkpO1xuICAgICAgICAgICAgICAgIHRhYlN0ci5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiU3RyLnB1c2godGhpcy5kb20uY3JlYXRlVGV4dE5vZGUobGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIGkpLCB0aGlzLmVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzKSB7XG4gICAgICAgICAgICB0aGlzLiRpbmRlbnRHdWlkZVJlID0gL1xcc1xcU3wgXFx0fFxcdCB8XFxzJC87XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJhY2VfaW5kZW50LWd1aWRlXCI7XG4gICAgICAgICAgICB2YXIgc3BhY2VDbGFzcyA9IHRoaXMuc2hvd1NwYWNlcyA/IFwiIGFjZV9pbnZpc2libGUgYWNlX2ludmlzaWJsZV9zcGFjZVwiIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBzcGFjZUNvbnRlbnQgPSB0aGlzLnNob3dTcGFjZXNcbiAgICAgICAgICAgICAgICA/IGxhbmcuc3RyaW5nUmVwZWF0KHRoaXMuU1BBQ0VfQ0hBUiwgdGhpcy50YWJTaXplKVxuICAgICAgICAgICAgICAgIDogbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIHRoaXMudGFiU2l6ZSk7XG4gICAgICAgICAgICB2YXIgdGFiQ2xhc3MgPSB0aGlzLnNob3dUYWJzID8gXCIgYWNlX2ludmlzaWJsZSBhY2VfaW52aXNpYmxlX3RhYlwiIDogXCJcIjtcbiAgICAgICAgICAgIHZhciB0YWJDb250ZW50ID0gdGhpcy5zaG93VGFic1xuICAgICAgICAgICAgICAgID8gbGFuZy5zdHJpbmdSZXBlYXQodGhpcy5UQUJfQ0hBUiwgdGhpcy50YWJTaXplKVxuICAgICAgICAgICAgICAgIDogc3BhY2VDb250ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmRvbS5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgc3BhY2VDbGFzcztcbiAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBzcGFjZUNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLiR0YWJTdHJpbmdzW1wiIFwiXSA9IHNwYW47XG4gICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyB0YWJDbGFzcztcbiAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0YWJDb250ZW50O1xuICAgICAgICAgICAgdGhpcy4kdGFiU3RyaW5nc1tcIlxcdFwiXSA9IHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnVwZGF0ZUxpbmVzID0gZnVuY3Rpb24gKGNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxhc3RSb3cgIT0gY29uZmlnLmxhc3RSb3cgfHxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmZpcnN0Um93ICE9IGNvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWF4KGZpcnN0Um93LCBjb25maWcuZmlyc3RSb3cpO1xuICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWluKGxhc3RSb3csIGNvbmZpZy5sYXN0Um93KTtcbiAgICAgICAgdmFyIGxpbmVFbGVtZW50cyA9IHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgbGluZUVsZW1lbnRzSWR4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gY29uZmlnLmZpcnN0Um93OyByb3cgPCBmaXJzdDsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkTGluZShyb3cpO1xuICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lLmNvbnRhaW5zUm93KGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVFbGVtZW50c0lkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciByb3cgPSBmaXJzdDtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3cpO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93LCBmb2xkTGluZSk7XG4gICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPiBsYXN0KVxuICAgICAgICAgICAgICAgIGJyZWFrOyB2YXIgbGluZUVsZW1lbnQgPSBsaW5lRWxlbWVudHNbbGluZUVsZW1lbnRzSWR4KytdO1xuICAgICAgICAgICAgaWYgKGxpbmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2hpbGRyZW4obGluZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlbmRlckxpbmUobGluZUVsZW1lbnQsIHJvdywgcm93ID09IGZvbGRTdGFydCA/IGZvbGRMaW5lIDogZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRDaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBsaW5lRWxlbWVudC5zdHlsZS50b3AgPSB0aGlzLiRsaW5lcy5jb21wdXRlTGluZVRvcChyb3csIGNvbmZpZywgdGhpcy5zZXNzaW9uKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGNvbmZpZy5saW5lSGVpZ2h0ICogdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBpZiAobGluZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB3aGlsZSAobGluZUVsZW1lbnRzSWR4IDwgdGhpcy4kbGluZXMuY2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLiRsaW5lcy5jZWxsc1tsaW5lRWxlbWVudHNJZHgrK107XG4gICAgICAgICAgICAgICAgY2VsbC5lbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMuJGxpbmVzLmNvbXB1dGVMaW5lVG9wKGNlbGwucm93LCBjb25maWcsIHRoaXMuc2Vzc2lvbikgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNjcm9sbExpbmVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgb2xkQ29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAodGhpcy4kbGluZXMucGFnZUNoYW5nZWQob2xkQ29uZmlnLCBjb25maWcpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuJGxpbmVzLm1vdmVDb250YWluZXIoY29uZmlnKTtcbiAgICAgICAgdmFyIGxhc3RSb3cgPSBjb25maWcubGFzdFJvdztcbiAgICAgICAgdmFyIG9sZExhc3RSb3cgPSBvbGRDb25maWcgPyBvbGRDb25maWcubGFzdFJvdyA6IC0xO1xuICAgICAgICBpZiAoIW9sZENvbmZpZyB8fCBvbGRMYXN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIGlmIChsYXN0Um93IDwgb2xkQ29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIGlmICghb2xkQ29uZmlnIHx8IG9sZENvbmZpZy5sYXN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcubGFzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICBpZiAob2xkQ29uZmlnLmZpcnN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KG9sZENvbmZpZy5maXJzdFJvdywgY29uZmlnLmZpcnN0Um93IC0gMSk7IHJvdyA+IDA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvbGRDb25maWcubGFzdFJvdyA+IGNvbmZpZy5sYXN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KGNvbmZpZy5sYXN0Um93ICsgMSwgb2xkQ29uZmlnLmxhc3RSb3cpOyByb3cgPiAwOyByb3ctLSlcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wb3AoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5maXJzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgdGhpcy4kbGluZXMudW5zaGlmdCh0aGlzLiRyZW5kZXJMaW5lc0ZyYWdtZW50KGNvbmZpZywgY29uZmlnLmZpcnN0Um93LCBvbGRDb25maWcuZmlyc3RSb3cgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5sYXN0Um93ID4gb2xkQ29uZmlnLmxhc3RSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuJGxpbmVzLnB1c2godGhpcy4kcmVuZGVyTGluZXNGcmFnbWVudChjb25maWcsIG9sZENvbmZpZy5sYXN0Um93ICsgMSwgY29uZmlnLmxhc3RSb3cpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlckxpbmVzRnJhZ21lbnQgPSBmdW5jdGlvbiAoY29uZmlnLCBmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBbXTtcbiAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3RSb3cpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuJGxpbmVzLmNyZWF0ZUNlbGwocm93LCBjb25maWcsIHRoaXMuc2Vzc2lvbik7XG4gICAgICAgICAgICB2YXIgbGluZUVsID0gbGluZS5lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2hpbGRyZW4obGluZUVsKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShsaW5lRWwuc3R5bGUsIFwiaGVpZ2h0XCIsIHRoaXMuJGxpbmVzLmNvbXB1dGVMaW5lSGVpZ2h0KHJvdywgY29uZmlnLCB0aGlzLnNlc3Npb24pICsgXCJweFwiKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShsaW5lRWwuc3R5bGUsIFwidG9wXCIsIHRoaXMuJGxpbmVzLmNvbXB1dGVMaW5lVG9wKHJvdywgY29uZmlnLCB0aGlzLnNlc3Npb24pICsgXCJweFwiKTtcbiAgICAgICAgICAgIHRoaXMuJHJlbmRlckxpbmUobGluZUVsLCByb3csIHJvdyA9PSBmb2xkU3RhcnQgPyBmb2xkTGluZSA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VMaW5lR3JvdXBzKCkpIHtcbiAgICAgICAgICAgICAgICBsaW5lRWwuY2xhc3NOYW1lID0gXCJhY2VfbGluZV9ncm91cFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZUVsLmNsYXNzTmFtZSA9IFwiYWNlX2xpbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWdtZW50LnB1c2gobGluZSk7XG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuJGxpbmVzLm1vdmVDb250YWluZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IGNvbmZpZy5maXJzdFJvdztcbiAgICAgICAgdmFyIGxhc3RSb3cgPSBjb25maWcubGFzdFJvdztcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy4kbGluZXM7XG4gICAgICAgIHdoaWxlIChsaW5lcy5nZXRMZW5ndGgoKSlcbiAgICAgICAgICAgIGxpbmVzLnBvcCgpO1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMuJHJlbmRlckxpbmVzRnJhZ21lbnQoY29uZmlnLCBmaXJzdFJvdywgbGFzdFJvdykpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlclRva2VuID0gZnVuY3Rpb24gKHBhcmVudCwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmUgPSAvKFxcdCl8KCArKXwoW1xceDAwLVxceDFmXFx4ODAtXFx4YTBcXHhhZFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkNcXHUyMDY2XFx1MjA2N1xcdTIwNjhcXHUyMDJBXFx1MjAyQlxcdTIwMkRcXHUyMDJFXFx1MjAyQ1xcdTIwNjldKyl8KFxcdTMwMDApfChbXFx1MTEwMC1cXHUxMTVGXFx1MTFBMy1cXHUxMUE3XFx1MTFGQS1cXHUxMUZGXFx1MjMyOS1cXHUyMzJBXFx1MkU4MC1cXHUyRTk5XFx1MkU5Qi1cXHUyRUYzXFx1MkYwMC1cXHUyRkQ1XFx1MkZGMC1cXHUyRkZCXFx1MzAwMS1cXHUzMDNFXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzE5MC1cXHUzMUJBXFx1MzFDMC1cXHUzMUUzXFx1MzFGMC1cXHUzMjFFXFx1MzIyMC1cXHUzMjQ3XFx1MzI1MC1cXHUzMkZFXFx1MzMwMC1cXHU0REJGXFx1NEUwMC1cXHVBNDhDXFx1QTQ5MC1cXHVBNEM2XFx1QTk2MC1cXHVBOTdDXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQUZGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTY2XFx1RkU2OC1cXHVGRTZCXFx1RkYwMS1cXHVGRjYwXFx1RkZFMC1cXHVGRkU2XXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKS9nO1xuICAgICAgICB2YXIgdmFsdWVGcmFnbWVudCA9IHRoaXMuZG9tLmNyZWF0ZUZyYWdtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciB0YWIgPSBtWzFdO1xuICAgICAgICAgICAgdmFyIHNpbXBsZVNwYWNlID0gbVsyXTtcbiAgICAgICAgICAgIHZhciBjb250cm9sQ2hhcmFjdGVyID0gbVszXTtcbiAgICAgICAgICAgIHZhciBjamtTcGFjZSA9IG1bNF07XG4gICAgICAgICAgICB2YXIgY2prID0gbVs1XTtcbiAgICAgICAgICAgIGlmICghc2VsZi5zaG93U3BhY2VzICYmIHNpbXBsZVNwYWNlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGkgIT0gbS5pbmRleCA/IHZhbHVlLnNsaWNlKGksIG0uaW5kZXgpIDogXCJcIjtcbiAgICAgICAgICAgIGkgPSBtLmluZGV4ICsgbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jcmVhdGVUZXh0Tm9kZShiZWZvcmUsIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhYikge1xuICAgICAgICAgICAgICAgIHZhciB0YWJTaXplID0gc2VsZi5zZXNzaW9uLmdldFNjcmVlblRhYlNpemUoc2NyZWVuQ29sdW1uICsgbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLiR0YWJTdHJpbmdzW3RhYlNpemVdLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IHRhYlNpemUgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2ltcGxlU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaG93U3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KHNlbGYuU1BBQ0VfQ0hBUiwgc2ltcGxlU3BhY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20uY3JlYXRlVGV4dE5vZGUoc2ltcGxlU3BhY2UsIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2UgYWNlX2ludmFsaWRcIjtcbiAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gbGFuZy5zdHJpbmdSZXBlYXQoc2VsZi5TUEFDRV9DSEFSLCBjb250cm9sQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNqa1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmRvbS5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gKHNlbGYuY29uZmlnLmNoYXJhY3RlcldpZHRoICogMikgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBzZWxmLnNob3dTcGFjZXMgPyBcImFjZV9jamsgYWNlX2ludmlzaWJsZSBhY2VfaW52aXNpYmxlX3NwYWNlXCIgOiBcImFjZV9jamtcIjtcbiAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gc2VsZi5zaG93U3BhY2VzID8gc2VsZi5TUEFDRV9DSEFSIDogY2prU3BhY2U7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNqaykge1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xuICAgICAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IChzZWxmLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aCAqIDIpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfY2prXCI7XG4gICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGNqaztcbiAgICAgICAgICAgICAgICB2YWx1ZUZyYWdtZW50LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlRnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20uY3JlYXRlVGV4dE5vZGUoaSA/IHZhbHVlLnNsaWNlKGkpIDogdmFsdWUsIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICBpZiAoIWlzVGV4dFRva2VuKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFwiYWNlX1wiICsgdG9rZW4udHlwZS5yZXBsYWNlKC9cXC4vZywgXCIgYWNlX1wiKTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PSBcImZvbGRcIikge1xuICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUud2lkdGggPSAodG9rZW4udmFsdWUubGVuZ3RoICogdGhpcy5jb25maWcuY2hhcmFjdGVyV2lkdGgpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgbmxzKFwiaW5saW5lLWZvbGQuY2xvc2VkLnRpdGxlXCIsIFwiVW5mb2xkIGNvZGVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjbGFzc2VzO1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZCh2YWx1ZUZyYWdtZW50KTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh2YWx1ZUZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NyZWVuQ29sdW1uICsgdmFsdWUubGVuZ3RoO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUucmVuZGVySW5kZW50R3VpZGUgPSBmdW5jdGlvbiAocGFyZW50LCB2YWx1ZSwgbWF4KSB7XG4gICAgICAgIHZhciBjb2xzID0gdmFsdWUuc2VhcmNoKHRoaXMuJGluZGVudEd1aWRlUmUpO1xuICAgICAgICBpZiAoY29scyA8PSAwIHx8IGNvbHMgPj0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWVbMF0gPT0gXCIgXCIpIHtcbiAgICAgICAgICAgIGNvbHMgLT0gY29scyAlIHRoaXMudGFiU2l6ZTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGNvbHMgLyB0aGlzLnRhYlNpemU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy4kdGFiU3RyaW5nc1tcIiBcIl0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGNvbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuJHRhYlN0cmluZ3NbXCJcXHRcIl0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGNvbHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRoaWdobGlnaHRJbmRlbnRHdWlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZXMgfHwgIXRoaXMuZGlzcGxheUluZGVudEd1aWRlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIgPSB7XG4gICAgICAgICAgICBpbmRlbnRMZXZlbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGlyOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zZXNzaW9uLmRvYy4kbGluZXM7XG4gICAgICAgIGlmICghbGluZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgaW5pdGlhbEluZGVudCA9IC9eXFxzKi8uZXhlYyh0aGlzLnNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdykpWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIGVsZW1lbnRJbmRlbnRMZXZlbCA9IE1hdGguZmxvb3IoaW5pdGlhbEluZGVudCAvIHRoaXMudGFiU2l6ZSk7XG4gICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyID0ge1xuICAgICAgICAgICAgaW5kZW50TGV2ZWw6IGVsZW1lbnRJbmRlbnRMZXZlbCxcbiAgICAgICAgICAgIHN0YXJ0OiBjdXJzb3Iucm93XG4gICAgICAgIH07XG4gICAgICAgIHZhciBicmFja2V0SGlnaGxpZ2h0ID0gdGhpcy5zZXNzaW9uLiRicmFja2V0SGlnaGxpZ2h0O1xuICAgICAgICBpZiAoYnJhY2tldEhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodC5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3Iucm93ICE9PSByYW5nZXNbaV0uc3RhcnQucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmVuZCA9IHJhbmdlc1tpXS5zdGFydC5yb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3Iucm93ID4gcmFuZ2VzW2ldLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZGlyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5kaXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmVuZCkge1xuICAgICAgICAgICAgaWYgKGxpbmVzW2N1cnNvci5yb3ddICE9PSAnJyAmJiBjdXJzb3IuY29sdW1uID09PSBsaW5lc1tjdXJzb3Iucm93XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5kaXIgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjdXJzb3Iucm93ICsgMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPD0gaW5pdGlhbEluZGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRyZW5kZXJIaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJGNsZWFyQWN0aXZlSW5kZW50R3VpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxscyA9IHRoaXMuJGxpbmVzLmNlbGxzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBjZWxsLmVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbal0uY2xhc3NMaXN0ICYmIGNoaWxkTm9kZXNbal0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWNlX2luZGVudC1ndWlkZS1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNbal0uY2xhc3NMaXN0LnJlbW92ZShcImFjZV9pbmRlbnQtZ3VpZGUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRzZXRJbmRlbnRHdWlkZUFjdGl2ZSA9IGZ1bmN0aW9uIChjZWxsLCBpbmRlbnRMZXZlbCkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5kb2MuZ2V0TGluZShjZWxsLnJvdyk7XG4gICAgICAgIGlmIChsaW5lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGNlbGwuZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkTm9kZXNbaW5kZW50TGV2ZWwgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmNsYXNzTGlzdCAmJiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhcImFjZV9pbmRlbnQtZ3VpZGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChcImFjZV9pbmRlbnQtZ3VpZGUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVySGlnaGxpZ2h0SW5kZW50R3VpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kbGluZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjZWxscyA9IHRoaXMuJGxpbmVzLmNlbGxzO1xuICAgICAgICB0aGlzLiRjbGVhckFjdGl2ZUluZGVudEd1aWRlKCk7XG4gICAgICAgIHZhciBpbmRlbnRMZXZlbCA9IHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmluZGVudExldmVsO1xuICAgICAgICBpZiAoaW5kZW50TGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5kaXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gY2VsbHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5lbmQgJiYgY2VsbC5yb3cgPj0gdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwucm93ID49IHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldEluZGVudEd1aWRlQWN0aXZlKGNlbGwsIGluZGVudExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjZWxscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZW5kICYmIGNlbGwucm93IDwgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnJvdyA8PSB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXRJbmRlbnRHdWlkZUFjdGl2ZShjZWxsLCBpbmRlbnRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRjcmVhdGVMaW5lRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGxpbmVFbCA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGxpbmVFbC5jbGFzc05hbWUgPSBcImFjZV9saW5lXCI7XG4gICAgICAgIGxpbmVFbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmNvbmZpZy5saW5lSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gbGluZUVsO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlcldyYXBwZWRMaW5lID0gZnVuY3Rpb24gKHBhcmVudCwgdG9rZW5zLCBzcGxpdHMpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gMDtcbiAgICAgICAgdmFyIHNwbGl0ID0gMDtcbiAgICAgICAgdmFyIHNwbGl0Q2hhcnMgPSBzcGxpdHNbMF07XG4gICAgICAgIHZhciBzY3JlZW5Db2x1bW4gPSAwO1xuICAgICAgICB2YXIgbGluZUVsID0gdGhpcy4kY3JlYXRlTGluZUVsZW1lbnQoKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmVFbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpID09IDAgJiYgdGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzKSB7XG4gICAgICAgICAgICAgICAgY2hhcnMgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlbmRlckluZGVudEd1aWRlKGxpbmVFbCwgdmFsdWUsIHNwbGl0Q2hhcnMpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNoYXJzIC09IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFycyArIHZhbHVlLmxlbmd0aCA8IHNwbGl0Q2hhcnMpIHtcbiAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihsaW5lRWwsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjaGFycyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hhcnMgKyB2YWx1ZS5sZW5ndGggPj0gc3BsaXRDaGFycykge1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihsaW5lRWwsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlLnN1YnN0cmluZygwLCBzcGxpdENoYXJzIC0gY2hhcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3BsaXRDaGFycyAtIGNoYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBzcGxpdENoYXJzO1xuICAgICAgICAgICAgICAgICAgICBsaW5lRWwgPSB0aGlzLiRjcmVhdGVMaW5lRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobGluZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUVsLmFwcGVuZENoaWxkKHRoaXMuZG9tLmNyZWF0ZVRleHROb2RlKGxhbmcuc3RyaW5nUmVwZWF0KFwiXFx4YTBcIiwgc3BsaXRzLmluZGVudCksIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCsrO1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdENoYXJzID0gc3BsaXRzW3NwbGl0XSB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihsaW5lRWwsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV0gPiB0aGlzLk1BWF9MSU5FX0xFTkdUSClcbiAgICAgICAgICAgIHRoaXMuJHJlbmRlck92ZXJmbG93TWVzc2FnZShsaW5lRWwsIHNjcmVlbkNvbHVtbiwgbnVsbCwgXCJcIiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVyU2ltcGxlTGluZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHRva2Vucykge1xuICAgICAgICB2YXIgc2NyZWVuQ29sdW1uID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCAmJiB0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVuZGVySW5kZW50R3VpZGUocGFyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NyZWVuQ29sdW1uICsgdmFsdWUubGVuZ3RoID4gdGhpcy5NQVhfTElORV9MRU5HVEgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHJlbmRlck92ZXJmbG93TWVzc2FnZShwYXJlbnQsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJHJlbmRlclRva2VuKHBhcmVudCwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVyT3ZlcmZsb3dNZXNzYWdlID0gZnVuY3Rpb24gKHBhcmVudCwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUsIGhpZGUpIHtcbiAgICAgICAgdG9rZW4gJiYgdGhpcy4kcmVuZGVyVG9rZW4ocGFyZW50LCBzY3JlZW5Db2x1bW4sIHRva2VuLCB2YWx1ZS5zbGljZSgwLCB0aGlzLk1BWF9MSU5FX0xFTkdUSCAtIHNjcmVlbkNvbHVtbikpO1xuICAgICAgICB2YXIgb3ZlcmZsb3dFbCA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBvdmVyZmxvd0VsLmNsYXNzTmFtZSA9IFwiYWNlX2lubGluZV9idXR0b24gYWNlX2tleXdvcmQgYWNlX3RvZ2dsZV93cmFwXCI7XG4gICAgICAgIG92ZXJmbG93RWwudGV4dENvbnRlbnQgPSBoaWRlID8gXCI8aGlkZT5cIiA6IFwiPGNsaWNrIHRvIHNlZSBtb3JlLi4uPlwiO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQob3ZlcmZsb3dFbCk7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVyTGluZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHJvdywgZm9sZExpbmUpIHtcbiAgICAgICAgaWYgKCFmb2xkTGluZSAmJiBmb2xkTGluZSAhPSBmYWxzZSlcbiAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIGlmIChmb2xkTGluZSlcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLiRnZXRGb2xkTGluZVRva2Vucyhyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuc2Vzc2lvbi5nZXRUb2tlbnMocm93KTtcbiAgICAgICAgdmFyIGxhc3RMaW5lRWwgPSBwYXJlbnQ7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRzID0gdGhpcy5zZXNzaW9uLmdldFJvd1NwbGl0RGF0YShyb3cpO1xuICAgICAgICAgICAgaWYgKHNwbGl0cyAmJiBzcGxpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVuZGVyV3JhcHBlZExpbmUocGFyZW50LCB0b2tlbnMsIHNwbGl0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lRWwgPSBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lRWwgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHVzZUxpbmVHcm91cHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZUVsID0gdGhpcy4kY3JlYXRlTGluZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxhc3RMaW5lRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRyZW5kZXJTaW1wbGVMaW5lKGxhc3RMaW5lRWwsIHRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kdXNlTGluZUdyb3VwcygpKSB7XG4gICAgICAgICAgICBsYXN0TGluZUVsID0gdGhpcy4kY3JlYXRlTGluZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChsYXN0TGluZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG93RU9MICYmIGxhc3RMaW5lRWwpIHtcbiAgICAgICAgICAgIGlmIChmb2xkTGluZSlcbiAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICAgICAgdmFyIGludmlzaWJsZUVsID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBpbnZpc2libGVFbC5jbGFzc05hbWUgPSBcImFjZV9pbnZpc2libGUgYWNlX2ludmlzaWJsZV9lb2xcIjtcbiAgICAgICAgICAgIGludmlzaWJsZUVsLnRleHRDb250ZW50ID0gcm93ID09IHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDEgPyB0aGlzLkVPRl9DSEFSIDogdGhpcy5FT0xfQ0hBUjtcbiAgICAgICAgICAgIGxhc3RMaW5lRWwuYXBwZW5kQ2hpbGQoaW52aXNpYmxlRWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kZ2V0Rm9sZExpbmVUb2tlbnMgPSBmdW5jdGlvbiAocm93LCBmb2xkTGluZSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHJlbmRlclRva2VucyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRUb2tlbnModG9rZW5zLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDAsIGNvbCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGNvbCArIHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aCkgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgY29sICs9IHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID09IHRva2Vucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgIT0gZnJvbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpZHhdLnZhbHVlLnN1YnN0cmluZyhmcm9tIC0gY29sKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gKHRvIC0gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyVG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbnNbaWR4XS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2wgPSBmcm9tICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IHRvICYmIGlkeCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnNbaWR4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICsgY29sID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5zW2lkeF0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zdWJzdHJpbmcoMCwgdG8gLSBjb2wpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHRva2Vuc1tpZHhdKTtcbiAgICAgICAgICAgICAgICBjb2wgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICBmb2xkTGluZS53YWxrKGZ1bmN0aW9uIChwbGFjZWhvbGRlciwgcm93LCBjb2x1bW4sIGxhc3RDb2x1bW4sIGlzTmV3Um93KSB7XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmb2xkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3Um93KVxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRUb2tlbnModG9rZW5zLCBsYXN0Q29sdW1uLCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmb2xkTGluZS5lbmQucm93LCB0aGlzLnNlc3Npb24uZ2V0TGluZShmb2xkTGluZS5lbmQucm93KS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVuZGVyVG9rZW5zO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHVzZUxpbmVHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcblRleHQucHJvdG90eXBlLkVPRl9DSEFSID0gXCJcXHhCNlwiO1xuVGV4dC5wcm90b3R5cGUuRU9MX0NIQVJfTEYgPSBcIlxceEFDXCI7XG5UZXh0LnByb3RvdHlwZS5FT0xfQ0hBUl9DUkxGID0gXCJcXHhhNFwiO1xuVGV4dC5wcm90b3R5cGUuRU9MX0NIQVIgPSBUZXh0LnByb3RvdHlwZS5FT0xfQ0hBUl9MRjtcblRleHQucHJvdG90eXBlLlRBQl9DSEFSID0gXCJcXHUyMDE0XCI7IC8vXCJcXHUyMUU1XCI7XG5UZXh0LnByb3RvdHlwZS5TUEFDRV9DSEFSID0gXCJcXHhCN1wiO1xuVGV4dC5wcm90b3R5cGUuJHBhZGRpbmcgPSAwO1xuVGV4dC5wcm90b3R5cGUuTUFYX0xJTkVfTEVOR1RIID0gMTAwMDA7XG5UZXh0LnByb3RvdHlwZS5zaG93SW52aXNpYmxlcyA9IGZhbHNlO1xuVGV4dC5wcm90b3R5cGUuc2hvd1NwYWNlcyA9IGZhbHNlO1xuVGV4dC5wcm90b3R5cGUuc2hvd1RhYnMgPSBmYWxzZTtcblRleHQucHJvdG90eXBlLnNob3dFT0wgPSBmYWxzZTtcblRleHQucHJvdG90eXBlLmRpc3BsYXlJbmRlbnRHdWlkZXMgPSB0cnVlO1xuVGV4dC5wcm90b3R5cGUuJGhpZ2hsaWdodEluZGVudEd1aWRlcyA9IHRydWU7XG5UZXh0LnByb3RvdHlwZS4kdGFiU3RyaW5ncyA9IFtdO1xuVGV4dC5wcm90b3R5cGUuZGVzdHJveSA9IHt9O1xuVGV4dC5wcm90b3R5cGUub25DaGFuZ2VUYWJTaXplID0gVGV4dC5wcm90b3R5cGUuJGNvbXB1dGVUYWJTdHJpbmc7XG5vb3AuaW1wbGVtZW50KFRleHQucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5UZXh0ID0gVGV4dDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvY3Vyc29yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBDdXJzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3Vyc29yKHBhcmVudEVsKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXCJhY2VfbGF5ZXIgYWNlX2N1cnNvci1sYXllclwiO1xuICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQmxpbmtpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSAxMDAwO1xuICAgICAgICB0aGlzLnNtb290aEJsaW5raW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29ycyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuYWRkQ3Vyc29yKCk7XG4gICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLiR1cGRhdGVDdXJzb3JzID0gdGhpcy4kdXBkYXRlT3BhY2l0eS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBDdXJzb3IucHJvdG90eXBlLiR1cGRhdGVPcGFjaXR5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgY3Vyc29ycyA9IHRoaXMuY3Vyc29ycztcbiAgICAgICAgZm9yICh2YXIgaSA9IGN1cnNvcnMubGVuZ3RoOyBpLS07KVxuICAgICAgICAgICAgZG9tLnNldFN0eWxlKGN1cnNvcnNbaV0uc3R5bGUsIFwib3BhY2l0eVwiLCB2YWwgPyBcIlwiIDogXCIwXCIpO1xuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS4kc3RhcnRDc3NBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3JzID0gdGhpcy5jdXJzb3JzO1xuICAgICAgICBmb3IgKHZhciBpID0gY3Vyc29ycy5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICBjdXJzb3JzW2ldLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gdGhpcy5ibGlua0ludGVydmFsICsgXCJtc1wiO1xuICAgICAgICB0aGlzLiRpc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGlzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfYW5pbWF0ZS1ibGlua2luZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuJHN0b3BDc3NBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2FuaW1hdGUtYmxpbmtpbmdcIik7XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLnNldEJsaW5raW5nID0gZnVuY3Rpb24gKGJsaW5raW5nKSB7XG4gICAgICAgIGlmIChibGlua2luZyAhPSB0aGlzLmlzQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCbGlua2luZyA9IGJsaW5raW5nO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5zZXRCbGlua0ludGVydmFsID0gZnVuY3Rpb24gKGJsaW5rSW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKGJsaW5rSW50ZXJ2YWwgIT0gdGhpcy5ibGlua0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSBibGlua0ludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5zZXRTbW9vdGhCbGlua2luZyA9IGZ1bmN0aW9uIChzbW9vdGhCbGlua2luZykge1xuICAgICAgICBpZiAoc21vb3RoQmxpbmtpbmcgIT0gdGhpcy5zbW9vdGhCbGlua2luZykge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhCbGlua2luZyA9IHNtb290aEJsaW5raW5nO1xuICAgICAgICAgICAgZG9tLnNldENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2Vfc21vb3RoLWJsaW5raW5nXCIsIHNtb290aEJsaW5raW5nKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1cnNvcnModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmFkZEN1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiYWNlX2N1cnNvclwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB0aGlzLmN1cnNvcnMucHVzaChlbCk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUucmVtb3ZlQ3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuY3Vyc29ycy5wb3AoKTtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmhpZGVDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5zaG93Q3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5yZXN0YXJ0VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSB0aGlzLiR1cGRhdGVDdXJzb3JzO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuJHN0b3BDc3NBbmltYXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuc21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJGlzU21vb3RoQmxpbmtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX3Ntb290aC1ibGlua2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pc0JsaW5raW5nIHx8ICF0aGlzLmJsaW5rSW50ZXJ2YWwgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLiRzdG9wQ3NzQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJGlzU21vb3RoQmxpbmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGlzU21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2Vfc21vb3RoLWJsaW5raW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbS5IQVNfQ1NTX0FOSU1BVElPTikge1xuICAgICAgICAgICAgdGhpcy4kc3RhcnRDc3NBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBibGluayA9IC8qKkB0aGlze0N1cnNvcn0qLyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LCAwLjYgKiB0aGlzLmJsaW5rSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBibGluaygpO1xuICAgICAgICAgICAgfSwgdGhpcy5ibGlua0ludGVydmFsKTtcbiAgICAgICAgICAgIGJsaW5rKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuZ2V0UGl4ZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgb25TY3JlZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZyB8fCAhdGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIGlmICghcG9zaXRpb24pXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGN1cnNvckxlZnQgPSB0aGlzLiRwYWRkaW5nICsgKHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuaXNCaWRpUm93KHBvcy5yb3csIHBvc2l0aW9uLnJvdylcbiAgICAgICAgICAgID8gdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5nZXRQb3NMZWZ0KHBvcy5jb2x1bW4pXG4gICAgICAgICAgICA6IHBvcy5jb2x1bW4gKiB0aGlzLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aCk7XG4gICAgICAgIHZhciBjdXJzb3JUb3AgPSAocG9zLnJvdyAtIChvblNjcmVlbiA/IHRoaXMuY29uZmlnLmZpcnN0Um93U2NyZWVuIDogMCkpICpcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGN1cnNvckxlZnQsIHRvcDogY3Vyc29yVG9wIH07XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmlzQ3Vyc29ySW5WaWV3ID0gZnVuY3Rpb24gKHBpeGVsUG9zLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHBpeGVsUG9zLnRvcCA+PSAwICYmIHBpeGVsUG9zLnRvcCA8IGNvbmZpZy5tYXhIZWlnaHQ7XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzO1xuICAgICAgICB2YXIgaSA9IDAsIGN1cnNvckluZGV4ID0gMDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IFt7IGN1cnNvcjogbnVsbCB9XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNlbGVjdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGl4ZWxQb3MgPSB0aGlzLmdldFBpeGVsUG9zaXRpb24oc2VsZWN0aW9uc1tpXS5jdXJzb3IsIHRydWUpO1xuICAgICAgICAgICAgaWYgKChwaXhlbFBvcy50b3AgPiBjb25maWcuaGVpZ2h0ICsgY29uZmlnLm9mZnNldCB8fFxuICAgICAgICAgICAgICAgIHBpeGVsUG9zLnRvcCA8IDApICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3Vyc29yc1tjdXJzb3JJbmRleCsrXSB8fCB0aGlzLmFkZEN1cnNvcigpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmF3Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ3Vyc29ySW5WaWV3KHBpeGVsUG9zLCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvbS50cmFuc2xhdGUoZWxlbWVudCwgcGl4ZWxQb3MubGVmdCwgcGl4ZWxQb3MudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKHN0eWxlLCBcIndpZHRoXCIsIE1hdGgucm91bmQoY29uZmlnLmNoYXJhY3RlcldpZHRoKSArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJoZWlnaHRcIiwgY29uZmlnLmxpbmVIZWlnaHQgKyBcInB4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0N1cnNvcihlbGVtZW50LCBwaXhlbFBvcywgY29uZmlnLCBzZWxlY3Rpb25zW2ldLCB0aGlzLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnNvcnMubGVuZ3RoID4gY3Vyc29ySW5kZXgpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUN1cnNvcigpO1xuICAgICAgICB2YXIgb3ZlcndyaXRlID0gdGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpO1xuICAgICAgICB0aGlzLiRzZXRPdmVyd3JpdGUob3ZlcndyaXRlKTtcbiAgICAgICAgdGhpcy4kcGl4ZWxQb3MgPSBwaXhlbFBvcztcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuJHNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChvdmVyd3JpdGUpIHtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSAhPSB0aGlzLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdGhpcy5vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX292ZXJ3cml0ZS1jdXJzb3JzXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX292ZXJ3cml0ZS1jdXJzb3JzXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXJzb3I7XG59KCkpO1xuQ3Vyc29yLnByb3RvdHlwZS4kcGFkZGluZyA9IDA7XG5DdXJzb3IucHJvdG90eXBlLmRyYXdDdXJzb3IgPSBudWxsO1xuZXhwb3J0cy5DdXJzb3IgPSBDdXJzb3I7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3Njcm9sbGJhclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgTUFYX1NDUk9MTF9IID0gMHg4MDAwO1xudmFyIFNjcm9sbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIocGFyZW50LCBjbGFzc1N1ZmZpeCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGJhciBhY2Vfc2Nyb2xsYmFyXCIgKyBjbGFzc1N1ZmZpeDtcbiAgICAgICAgdGhpcy5pbm5lciA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmlubmVyLmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGJhci1pbm5lclwiO1xuICAgICAgICB0aGlzLmlubmVyLnRleHRDb250ZW50ID0gXCJcXHhhMFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lcik7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICB0aGlzLnNraXBFdmVudCA9IGZhbHNlO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZXZlbnQucHJldmVudERlZmF1bHQpO1xuICAgIH1cbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaXNWaXNpYmxlID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICAgICAgdGhpcy5jb2VmZiA9IDE7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsYmFyO1xufSgpKTtcbm9vcC5pbXBsZW1lbnQoU2Nyb2xsYmFyLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBWU2Nyb2xsQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWU2Nyb2xsQmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZTY3JvbGxCYXIocGFyZW50LCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsICctdicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIF90aGlzLnNjcm9sbEhlaWdodCA9IDA7XG4gICAgICAgIHJlbmRlcmVyLiRzY3JvbGxiYXJXaWR0aCA9XG4gICAgICAgICAgICBfdGhpcy53aWR0aCA9IGRvbS5zY3JvbGxiYXJXaWR0aChwYXJlbnQub3duZXJEb2N1bWVudCk7XG4gICAgICAgIF90aGlzLmlubmVyLnN0eWxlLndpZHRoID1cbiAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAoX3RoaXMud2lkdGggfHwgMTUpICsgNSArIFwicHhcIjtcbiAgICAgICAgX3RoaXMuJG1pbldpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWU2Nyb2xsQmFyLnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNraXBFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29lZmYgIT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy5lbGVtZW50LmNsaWVudEhlaWdodCAvIHRoaXMuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3AgKiAoMSAtIGgpIC8gKHRoaXMuY29lZmYgLSBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiB0aGlzLnNjcm9sbFRvcCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBFdmVudCA9IGZhbHNlO1xuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmlzVmlzaWJsZSA/IHRoaXMud2lkdGggOiAwLCB0aGlzLiRtaW5XaWR0aCB8fCAwKTtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChoZWlnaHQgPiBNQVhfU0NST0xMX0gpIHtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBNQVhfU0NST0xMX0ggLyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSBNQVhfU0NST0xMX0g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb2VmZiAhPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvZWZmID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wICE9IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5za2lwRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICogdGhpcy5jb2VmZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZTY3JvbGxCYXI7XG59KFNjcm9sbGJhcikpO1xuVlNjcm9sbEJhci5wcm90b3R5cGUuc2V0SW5uZXJIZWlnaHQgPSBWU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRTY3JvbGxIZWlnaHQ7XG52YXIgSFNjcm9sbEJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFNjcm9sbEJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIU2Nyb2xsQmFyKHBhcmVudCwgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCAnLWgnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gcmVuZGVyZXIuJHNjcm9sbGJhcldpZHRoO1xuICAgICAgICBfdGhpcy5pbm5lci5zdHlsZS5oZWlnaHQgPVxuICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoX3RoaXMuaGVpZ2h0IHx8IDE1KSArIDUgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUub25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcInNjcm9sbFwiLCB7IGRhdGE6IHRoaXMuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBFdmVudCA9IGZhbHNlO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPyB0aGlzLmhlaWdodCA6IDA7XG4gICAgfTtcbiAgICBIU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9O1xuICAgIEhTY3JvbGxCYXIucHJvdG90eXBlLnNldElubmVyV2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsV2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChzY3JvbGxMZWZ0KSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgIT0gc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgdGhpcy5za2lwRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSFNjcm9sbEJhcjtcbn0oU2Nyb2xsYmFyKSk7XG5leHBvcnRzLlNjcm9sbEJhciA9IFZTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuU2Nyb2xsQmFyViA9IFZTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuU2Nyb2xsQmFySCA9IEhTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuVlNjcm9sbEJhciA9IFZTY3JvbGxCYXI7XG5leHBvcnRzLkhTY3JvbGxCYXIgPSBIU2Nyb2xsQmFyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9zY3JvbGxiYXJfY3VzdG9tXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIGV2ZW50ID0gcmVxdWlyZShcIi4vbGliL2V2ZW50XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbmRvbS5pbXBvcnRDc3NTdHJpbmcoXCIuYWNlX2VkaXRvcj4uYWNlX3NiLXYgZGl2LCAuYWNlX2VkaXRvcj4uYWNlX3NiLWggZGl2e1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjYpO1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNiYmI7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB6LWluZGV4OiA4O1xcbn1cXG4uYWNlX2VkaXRvcj4uYWNlX3NiLXYsIC5hY2VfZWRpdG9yPi5hY2Vfc2ItaCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA2O1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIG92ZXJmbG93OiBoaWRkZW4haW1wb3J0YW50O1xcbn1cXG4uYWNlX2VkaXRvcj4uYWNlX3NiLXYge1xcbiAgei1pbmRleDogNjtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEycHg7XFxufVxcbi5hY2VfZWRpdG9yPi5hY2Vfc2ItdiBkaXYge1xcbiAgei1pbmRleDogODtcXG4gIHJpZ2h0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5hY2VfZWRpdG9yPi5hY2Vfc2ItaCB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgaGVpZ2h0OiAxMnB4O1xcbn1cXG4uYWNlX2VkaXRvcj4uYWNlX3NiLWggZGl2IHtcXG4gIGJvdHRvbTogMDtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLmFjZV9lZGl0b3I+LmFjZV9zYl9ncmFiYmVkIHtcXG4gIHotaW5kZXg6IDg7XFxuICBiYWNrZ3JvdW5kOiAjMDAwO1xcbn1cIiwgXCJhY2Vfc2Nyb2xsYmFyLmNzc1wiLCBmYWxzZSk7XG52YXIgU2Nyb2xsQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbEJhcihwYXJlbnQsIGNsYXNzU3VmZml4KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXCJhY2Vfc2JcIiArIGNsYXNzU3VmZml4O1xuICAgICAgICB0aGlzLmlubmVyID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuaW5uZXIuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW5uZXIpO1xuICAgICAgICB0aGlzLlZTY3JvbGxXaWR0aCA9IDEyO1xuICAgICAgICB0aGlzLkhTY3JvbGxIZWlnaHQgPSAxMjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGV2ZW50LmFkZE11bHRpTW91c2VEb3duTGlzdGVuZXIodGhpcy5lbGVtZW50LCBbNTAwLCAzMDAsIDMwMF0sIHRoaXMsIFwib25Nb3VzZURvd25cIik7XG4gICAgfVxuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChpc1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBpc1Zpc2libGUgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgICAgICB0aGlzLmNvZWZmID0gMTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxCYXI7XG59KCkpO1xub29wLmltcGxlbWVudChTY3JvbGxCYXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xudmFyIFZTY3JvbGxCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZTY3JvbGxCYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVlNjcm9sbEJhcihwYXJlbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgJy12JykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgX3RoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBfdGhpcy53aWR0aCA9IF90aGlzLlZTY3JvbGxXaWR0aDtcbiAgICAgICAgX3RoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgX3RoaXMuaW5uZXIuc3R5bGUud2lkdGggPSBfdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKF90aGlzLndpZHRoIHx8IDE1KSArIFwicHhcIjtcbiAgICAgICAgX3RoaXMuJG1pbldpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWU2Nyb2xsQmFyLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChlVHlwZSwgZSkge1xuICAgICAgICBpZiAoZVR5cGUgIT09IFwibW91c2Vkb3duXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldmVudC5nZXRCdXR0b24oZSkgIT09IDAgfHwgZS5kZXRhaWwgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBtb3VzZVBhZ2VZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgdmFyIG9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBtb3VzZVBhZ2VZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VG9wID0gdGhpcy50aHVtYlRvcDtcbiAgICAgICAgICAgIHZhciBvblNjcm9sbEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBhZ2VZID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gc2VsZi5zY3JvbGxUb3BGcm9tVGh1bWJUb3Aoc3RhcnRUb3AgKyBtb3VzZVBhZ2VZIC0gc3RhcnRZKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBzZWxmLnNjcm9sbFRvcClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiBzY3JvbGxUb3AgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuY2FwdHVyZSh0aGlzLmlubmVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZVVwKTtcbiAgICAgICAgICAgIHZhciB0aW1lcklkID0gc2V0SW50ZXJ2YWwob25TY3JvbGxJbnRlcnZhbCwgMjApO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3AgPSBlLmNsaWVudFkgLSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy50aHVtYkhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiB0aGlzLnNjcm9sbFRvcEZyb21UaHVtYlRvcCh0b3ApIH0pO1xuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgfTtcbiAgICBWU2Nyb2xsQmFyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNjcm9sbFRvcEZyb21UaHVtYlRvcCA9IGZ1bmN0aW9uICh0aHVtYlRvcCkge1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGh1bWJUb3AgKiAodGhpcy5wYWdlSGVpZ2h0IC0gdGhpcy52aWV3SGVpZ2h0KSAvICh0aGlzLnNsaWRlSGVpZ2h0IC0gdGhpcy50aHVtYkhlaWdodCk7XG4gICAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCA+PiAwO1xuICAgICAgICBpZiAoc2Nyb2xsVG9wIDwgMCkge1xuICAgICAgICAgICAgc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JvbGxUb3AgPiB0aGlzLnBhZ2VIZWlnaHQgLSB0aGlzLnZpZXdIZWlnaHQpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IHRoaXMucGFnZUhlaWdodCAtIHRoaXMudmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmlzVmlzaWJsZSA/IHRoaXMud2lkdGggOiAwLCB0aGlzLiRtaW5XaWR0aCB8fCAwKTtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCgwLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnNsaWRlSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMudmlld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnNldFNjcm9sbEhlaWdodCh0aGlzLnBhZ2VIZWlnaHQsIHRydWUpO1xuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgZm9yY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGFnZUhlaWdodCA9PT0gaGVpZ2h0ICYmICFmb3JjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wYWdlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnRodW1iSGVpZ2h0ID0gdGhpcy5zbGlkZUhlaWdodCAqIHRoaXMudmlld0hlaWdodCAvIHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJIZWlnaHQgPiB0aGlzLnNsaWRlSGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy50aHVtYkhlaWdodCA9IHRoaXMuc2xpZGVIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnRodW1iSGVpZ2h0IDwgMTUpXG4gICAgICAgICAgICB0aGlzLnRodW1iSGVpZ2h0ID0gMTU7XG4gICAgICAgIHRoaXMuaW5uZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy50aHVtYkhlaWdodCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID4gKHRoaXMucGFnZUhlaWdodCAtIHRoaXMudmlld0hlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gKHRoaXMucGFnZUhlaWdodCAtIHRoaXMudmlld0hlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiB0aGlzLnNjcm9sbFRvcCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgaWYgKHNjcm9sbFRvcCA8IDApXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLnRodW1iVG9wID0gc2Nyb2xsVG9wICogKHRoaXMuc2xpZGVIZWlnaHQgLSB0aGlzLnRodW1iSGVpZ2h0KSAvICh0aGlzLnBhZ2VIZWlnaHQgLSB0aGlzLnZpZXdIZWlnaHQpO1xuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLnRvcCA9IHRoaXMudGh1bWJUb3AgKyBcInB4XCI7XG4gICAgfTtcbiAgICByZXR1cm4gVlNjcm9sbEJhcjtcbn0oU2Nyb2xsQmFyKSk7XG5WU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRJbm5lckhlaWdodCA9IFZTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbEhlaWdodDtcbnZhciBIU2Nyb2xsQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIU2Nyb2xsQmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhTY3JvbGxCYXIocGFyZW50LCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsICctaCcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICBfdGhpcy5zY3JvbGxXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLmhlaWdodCA9IF90aGlzLkhTY3JvbGxIZWlnaHQ7XG4gICAgICAgIF90aGlzLmlubmVyLnN0eWxlLmhlaWdodCA9IF90aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKF90aGlzLmhlaWdodCB8fCAxMikgKyBcInB4XCI7XG4gICAgICAgIF90aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZVR5cGUsIGUpIHtcbiAgICAgICAgaWYgKGVUeXBlICE9PSBcIm1vdXNlZG93blwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQuZ2V0QnV0dG9uKGUpICE9PSAwIHx8IGUuZGV0YWlsID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbW91c2VQYWdlWCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIHZhciBvbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbW91c2VQYWdlWCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25Nb3VzZVVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIHZhciBzdGFydExlZnQgPSB0aGlzLnRodW1iTGVmdDtcbiAgICAgICAgICAgIHZhciBvblNjcm9sbEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBhZ2VYID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHNlbGYuc2Nyb2xsTGVmdEZyb21UaHVtYkxlZnQoc3RhcnRMZWZ0ICsgbW91c2VQYWdlWCAtIHN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbExlZnQgPT09IHNlbGYuc2Nyb2xsTGVmdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiBzY3JvbGxMZWZ0IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LmNhcHR1cmUodGhpcy5pbm5lciwgb25Nb3VzZU1vdmUsIG9uTW91c2VVcCk7XG4gICAgICAgICAgICB2YXIgdGltZXJJZCA9IHNldEludGVydmFsKG9uU2Nyb2xsSW50ZXJ2YWwsIDIwKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IGUuY2xpZW50WCAtIHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gdGhpcy50aHVtYldpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5fZW1pdChcInNjcm9sbFwiLCB7IGRhdGE6IHRoaXMuc2Nyb2xsTGVmdEZyb21UaHVtYkxlZnQobGVmdCkgfSk7XG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICB9O1xuICAgIEhTY3JvbGxCYXIucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID8gdGhpcy5oZWlnaHQgOiAwO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2Nyb2xsTGVmdEZyb21UaHVtYkxlZnQgPSBmdW5jdGlvbiAodGh1bWJMZWZ0KSB7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gdGh1bWJMZWZ0ICogKHRoaXMucGFnZVdpZHRoIC0gdGhpcy52aWV3V2lkdGgpIC8gKHRoaXMuc2xpZGVXaWR0aCAtIHRoaXMudGh1bWJXaWR0aCk7XG4gICAgICAgIHNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0ID4+IDA7XG4gICAgICAgIGlmIChzY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsTGVmdCA+IHRoaXMucGFnZVdpZHRoIC0gdGhpcy52aWV3V2lkdGgpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB0aGlzLnBhZ2VXaWR0aCAtIHRoaXMudmlld1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY3JvbGxMZWZ0O1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5zbGlkZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy52aWV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFdpZHRoKHRoaXMucGFnZVdpZHRoLCB0cnVlKTtcbiAgICB9O1xuICAgIEhTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5wYWdlV2lkdGggPT09IHdpZHRoICYmICFmb3JjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wYWdlV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy50aHVtYldpZHRoID0gdGhpcy5zbGlkZVdpZHRoICogdGhpcy52aWV3V2lkdGggLyB0aGlzLnBhZ2VXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJXaWR0aCA+IHRoaXMuc2xpZGVXaWR0aClcbiAgICAgICAgICAgIHRoaXMudGh1bWJXaWR0aCA9IHRoaXMuc2xpZGVXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJXaWR0aCA8IDE1KVxuICAgICAgICAgICAgdGhpcy50aHVtYldpZHRoID0gMTU7XG4gICAgICAgIHRoaXMuaW5uZXIuc3R5bGUud2lkdGggPSB0aGlzLnRodW1iV2lkdGggKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgPiAodGhpcy5wYWdlV2lkdGggLSB0aGlzLnZpZXdXaWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9ICh0aGlzLnBhZ2VXaWR0aCAtIHRoaXMudmlld1dpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwic2Nyb2xsXCIsIHsgZGF0YTogdGhpcy5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHNjcm9sbExlZnQgPCAwKVxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHRoaXMudGh1bWJMZWZ0ID0gc2Nyb2xsTGVmdCAqICh0aGlzLnNsaWRlV2lkdGggLSB0aGlzLnRodW1iV2lkdGgpIC8gKHRoaXMucGFnZVdpZHRoIC0gdGhpcy52aWV3V2lkdGgpO1xuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLmxlZnQgPSAodGhpcy50aHVtYkxlZnQpICsgXCJweFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEhTY3JvbGxCYXI7XG59KFNjcm9sbEJhcikpO1xuSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0SW5uZXJXaWR0aCA9IEhTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbFdpZHRoO1xuZXhwb3J0cy5TY3JvbGxCYXIgPSBWU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnRzLlNjcm9sbEJhclYgPSBWU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnRzLlNjcm9sbEJhckggPSBIU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnRzLlZTY3JvbGxCYXIgPSBWU2Nyb2xsQmFyO1xuZXhwb3J0cy5IU2Nyb2xsQmFyID0gSFNjcm9sbEJhcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcmVuZGVybG9vcFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBSZW5kZXJMb29wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlckxvb3Aob25SZW5kZXIsIHdpbikge1xuICAgICAgICB0aGlzLm9uUmVuZGVyID0gb25SZW5kZXI7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLiRyZWN1cnNpb25MaW1pdCA9IDI7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luIHx8IHdpbmRvdztcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fZmx1c2ggPSBmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgICAgIF9zZWxmLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gX3NlbGYuY2hhbmdlcztcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYmxvY2tJZGxlKDEwMCk7XG4gICAgICAgICAgICAgICAgX3NlbGYuY2hhbmdlcyA9IDA7XG4gICAgICAgICAgICAgICAgX3NlbGYub25SZW5kZXIoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3NlbGYuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChfc2VsZi4kcmVjdXJzaW9uTGltaXQtLSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBfc2VsZi5zY2hlZHVsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuJHJlY3Vyc2lvbkxpbWl0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUmVuZGVyTG9vcC5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyB8IGNoYW5nZTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlcyAmJiAhdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBldmVudC5uZXh0RnJhbWUodGhpcy5fZmx1c2gpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyTG9vcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSAwO1xuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJMb29wO1xufSgpKTtcbmV4cG9ydHMuUmVuZGVyTG9vcCA9IFJlbmRlckxvb3A7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xheWVyL2ZvbnRfbWV0cmljc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7dmFyIG9vcCA9IHJlcXVpcmUoXCIuLi9saWIvb29wXCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgQ0hBUl9DT1VOVCA9IDUxMjtcbnZhciBVU0VfT0JTRVJWRVIgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiO1xudmFyIEwgPSAyMDA7XG52YXIgRm9udE1ldHJpY3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9udE1ldHJpY3MocGFyZW50RWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyh0aGlzLmVsLnN0eWxlLCB0cnVlKTtcbiAgICAgICAgdGhpcy4kbWFpbiA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyh0aGlzLiRtYWluLnN0eWxlKTtcbiAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy4kc2V0TWVhc3VyZU5vZGVTdHlsZXModGhpcy4kbWVhc3VyZU5vZGUuc3R5bGUpO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1haW4pO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1lYXN1cmVOb2RlKTtcbiAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuJG1lYXN1cmVOb2RlLnRleHRDb250ZW50ID0gbGFuZy5zdHJpbmdSZXBlYXQoXCJYXCIsIENIQVJfQ09VTlQpO1xuICAgICAgICB0aGlzLiRjaGFyYWN0ZXJTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgIGlmIChVU0VfT0JTRVJWRVIpXG4gICAgICAgICAgICB0aGlzLiRhZGRPYnNlcnZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yU2l6ZUNoYW5nZXMoKTtcbiAgICB9XG4gICAgRm9udE1ldHJpY3MucHJvdG90eXBlLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZSwgaXNSb290KSB7XG4gICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSBcInByZVwiO1xuICAgICAgICBpZiAodXNlcmFnZW50LmlzSUUgPCA4KSB7XG4gICAgICAgICAgICBzdHlsZVtcImZvbnQtZmFtaWx5XCJdID0gXCJpbmhlcml0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5mb250ID0gXCJpbmhlcml0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBpc1Jvb3QgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuY2hlY2tGb3JTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzaXplID0gdGhpcy4kbWVhc3VyZVNpemVzKCk7XG4gICAgICAgIGlmIChzaXplICYmICh0aGlzLiRjaGFyYWN0ZXJTaXplLndpZHRoICE9PSBzaXplLndpZHRoIHx8IHRoaXMuJGNoYXJhY3RlclNpemUuaGVpZ2h0ICE9PSBzaXplLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuJG1lYXN1cmVOb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgICAgIHZhciBib2xkU2l6ZSA9IHRoaXMuJG1lYXN1cmVTaXplcygpO1xuICAgICAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUuc3R5bGUuZm9udFdlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLiRjaGFyYWN0ZXJTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhclNpemVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dCb2xkRm9udHMgPSBib2xkU2l6ZSAmJiBib2xkU2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBib2xkU2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZUNoYXJhY3RlclNpemVcIiwgeyBkYXRhOiBzaXplIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuJGFkZE9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuJG9ic2VydmVyID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRvYnNlcnZlci5vYnNlcnZlKHRoaXMuJG1lYXN1cmVOb2RlKTtcbiAgICB9O1xuICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS4kcG9sbFNpemVDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIgfHwgdGhpcy4kb2JzZXJ2ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyID0gZXZlbnQub25JZGxlKGZ1bmN0aW9uIGNiKCkge1xuICAgICAgICAgICAgc2VsZi5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgICAgICAgICBldmVudC5vbklkbGUoY2IsIDUwMCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuc2V0UG9sbGluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuJG1lYXN1cmVTaXplcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiAobm9kZSB8fCB0aGlzLiRtZWFzdXJlTm9kZSkuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IChub2RlIHx8IHRoaXMuJG1lYXN1cmVOb2RlKS5jbGllbnRXaWR0aCAvIENIQVJfQ09VTlRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpemUud2lkdGggPT09IDAgfHwgc2l6ZS5oZWlnaHQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuJG1lYXN1cmVDaGFyV2lkdGggPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdGhpcy4kbWFpbi50ZXh0Q29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KGNoLCBDSEFSX0NPVU5UKTtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLiRtYWluLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gcmVjdC53aWR0aCAvIENIQVJfQ09VTlQ7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuZ2V0Q2hhcmFjdGVyV2lkdGggPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNoYXJTaXplc1tjaF07XG4gICAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHcgPSB0aGlzLmNoYXJTaXplc1tjaF0gPSB0aGlzLiRtZWFzdXJlQ2hhcldpZHRoKGNoKSAvIHRoaXMuJGNoYXJhY3RlclNpemUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLiRwb2xsU2l6ZUNoYW5nZXNUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLiRvYnNlcnZlcilcbiAgICAgICAgICAgIHRoaXMuJG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH07XG4gICAgRm9udE1ldHJpY3MucHJvdG90eXBlLiRnZXRab29tID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIChOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbXCJ6b29tXCJdKSB8fCAxKSAqIHRoaXMuJGdldFpvb20oZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS4kaW5pdFRyYW5zZm9ybU1lYXN1cmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbiAodCwgbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInBvc2l0aW9uOiBhYnNvbHV0ZTt0b3A6XCIgKyB0ICsgXCJweDtsZWZ0OlwiICsgbCArIFwicHg7XCJcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbHMgPSBkb20uYnVpbGREb20oW3QoMCwgMCksIHQoTCwgMCksIHQoMCwgTCksIHQoTCwgTCldLCB0aGlzLmVsKTtcbiAgICB9O1xuICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChjbGllbnRQb3MsIGVsUG9zKSB7XG4gICAgICAgIGlmIChjbGllbnRQb3MpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy4kZ2V0Wm9vbSh0aGlzLmVsKTtcbiAgICAgICAgICAgIGNsaWVudFBvcyA9IG11bCgxIC8gem9vbSwgY2xpZW50UG9zKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb2x2ZShsMSwgbDIsIHIpIHtcbiAgICAgICAgICAgIHZhciBkZXQgPSBsMVsxXSAqIGwyWzBdIC0gbDFbMF0gKiBsMlsxXTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKC1sMlsxXSAqIHJbMF0gKyBsMlswXSAqIHJbMV0pIC8gZGV0LFxuICAgICAgICAgICAgICAgICgrbDFbMV0gKiByWzBdIC0gbDFbMF0gKiByWzFdKSAvIGRldFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdWIoYSwgYikgeyByZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXV07IH1cbiAgICAgICAgZnVuY3Rpb24gYWRkKGEsIGIpIHsgcmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV1dOyB9XG4gICAgICAgIGZ1bmN0aW9uIG11bChhLCBiKSB7IHJldHVybiBbYSAqIGJbMF0sIGEgKiBiWzFdXTsgfVxuICAgICAgICBpZiAoIXRoaXMuZWxzKVxuICAgICAgICAgICAgdGhpcy4kaW5pdFRyYW5zZm9ybU1lYXN1cmVOb2RlcygpO1xuICAgICAgICBmdW5jdGlvbiBwKGVsKSB7XG4gICAgICAgICAgICB2YXIgciA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIFtyLmxlZnQsIHIudG9wXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHAodGhpcy5lbHNbMF0pO1xuICAgICAgICB2YXIgYiA9IHAodGhpcy5lbHNbMV0pO1xuICAgICAgICB2YXIgYyA9IHAodGhpcy5lbHNbMl0pO1xuICAgICAgICB2YXIgZCA9IHAodGhpcy5lbHNbM10pO1xuICAgICAgICB2YXIgaCA9IHNvbHZlKHN1YihkLCBiKSwgc3ViKGQsIGMpLCBzdWIoYWRkKGIsIGMpLCBhZGQoZCwgYSkpKTtcbiAgICAgICAgdmFyIG0xID0gbXVsKDEgKyBoWzBdLCBzdWIoYiwgYSkpO1xuICAgICAgICB2YXIgbTIgPSBtdWwoMSArIGhbMV0sIHN1YihjLCBhKSk7XG4gICAgICAgIGlmIChlbFBvcykge1xuICAgICAgICAgICAgdmFyIHggPSBlbFBvcztcbiAgICAgICAgICAgIHZhciBrID0gaFswXSAqIHhbMF0gLyBMICsgaFsxXSAqIHhbMV0gLyBMICsgMTtcbiAgICAgICAgICAgIHZhciB1dCA9IGFkZChtdWwoeFswXSwgbTEpLCBtdWwoeFsxXSwgbTIpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGQobXVsKDEgLyBrIC8gTCwgdXQpLCBhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSA9IHN1YihjbGllbnRQb3MsIGEpO1xuICAgICAgICB2YXIgZiA9IHNvbHZlKHN1YihtMSwgbXVsKGhbMF0sIHUpKSwgc3ViKG0yLCBtdWwoaFsxXSwgdSkpLCB1KTtcbiAgICAgICAgcmV0dXJuIG11bChMLCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBGb250TWV0cmljcztcbn0oKSk7XG5Gb250TWV0cmljcy5wcm90b3R5cGUuJGNoYXJhY3RlclNpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbm9vcC5pbXBsZW1lbnQoRm9udE1ldHJpY3MucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5Gb250TWV0cmljcyA9IEZvbnRNZXRyaWNzO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jc3MvZWRpdG9yLWNzc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXsvKlxuc3R5bGVzID0gW11cbmZvciAodmFyIGkgPSAxOyBpIDwgMTY7IGkrKykge1xuICAgIHN0eWxlcy5wdXNoKFwiLmFjZV9iclwiICsgaSArIFwie1wiICsgKFxuICAgICAgICBbXCJ0b3AtbGVmdFwiLCBcInRvcC1yaWdodFwiLCBcImJvdHRvbS1yaWdodFwiLCBcImJvdHRvbS1sZWZ0XCJdXG4gICAgKS5tYXAoZnVuY3Rpb24oeCwgaikge1xuICAgICAgICByZXR1cm4gaSAmICgxPDxqKSA/IFwiYm9yZGVyLVwiICsgeCArIFwiLXJhZGl1czogM3B4O1wiIDogXCJcIlxuICAgIH0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKSArIFwifVwiKVxufVxuc3R5bGVzLmpvaW4oXCJcXFxcblwiKVxuKi9cbm1vZHVsZS5leHBvcnRzID0gXCJcXG4uYWNlX2JyMSB7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1cyAgICA6IDNweDt9XFxuLmFjZV9icjIge2JvcmRlci10b3AtcmlnaHQtcmFkaXVzICAgOiAzcHg7fVxcbi5hY2VfYnIzIHtib3JkZXItdG9wLWxlZnQtcmFkaXVzICAgIDogM3B4OyBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogICAgM3B4O31cXG4uYWNlX2JyNCB7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDt9XFxuLmFjZV9icjUge2JvcmRlci10b3AtbGVmdC1yYWRpdXMgICAgOiAzcHg7IGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7fVxcbi5hY2VfYnI2IHtib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyAgIDogM3B4OyBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4O31cXG4uYWNlX2JyNyB7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1cyAgICA6IDNweDsgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6ICAgIDNweDsgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDt9XFxuLmFjZV9icjgge2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMgOiAzcHg7fVxcbi5hY2VfYnI5IHtib3JkZXItdG9wLWxlZnQtcmFkaXVzICAgIDogM3B4OyBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAgM3B4O31cXG4uYWNlX2JyMTB7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXMgICA6IDNweDsgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogIDNweDt9XFxuLmFjZV9icjExe2JvcmRlci10b3AtbGVmdC1yYWRpdXMgICAgOiAzcHg7IGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAgICAzcHg7IGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6ICAzcHg7fVxcbi5hY2VfYnIxMntib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAgM3B4O31cXG4uYWNlX2JyMTN7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1cyAgICA6IDNweDsgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogIDNweDt9XFxuLmFjZV9icjE0e2JvcmRlci10b3AtcmlnaHQtcmFkaXVzICAgOiAzcHg7IGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6ICAzcHg7fVxcbi5hY2VfYnIxNXtib3JkZXItdG9wLWxlZnQtcmFkaXVzICAgIDogM3B4OyBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogICAgM3B4OyBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7fVxcblxcblxcbi5hY2VfZWRpdG9yIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250OiAxMnB4L25vcm1hbCAnTW9uYWNvJywgJ01lbmxvJywgJ1VidW50dSBNb25vJywgJ0NvbnNvbGFzJywgJ1NvdXJjZSBDb2RlIFBybycsICdzb3VyY2UtY29kZS1wcm8nLCBtb25vc3BhY2U7XFxuICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcblxcbi5hY2Vfc2Nyb2xsZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICBjdXJzb3I6IHRleHQ7XFxufVxcblxcbi5hY2VfY29udGVudCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgbWluLXdpZHRoOiAxMDAlO1xcbiAgICBjb250YWluOiBzdHlsZSBzaXplIGxheW91dDtcXG4gICAgZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm8tY29tbW9uLWxpZ2F0dXJlcztcXG59XFxuXFxuLmFjZV9rZXlib2FyZC1mb2N1czpmb2N1cyB7XFxuICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDJweCAjNUU5RUQ2O1xcbiAgICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4uYWNlX2RyYWdnaW5nIC5hY2Vfc2Nyb2xsZXI6YmVmb3Jle1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjUwLCAyNTAsIDI1MCwgMC4wMSk7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxufVxcbi5hY2VfZHJhZ2dpbmcuYWNlX2RhcmsgLmFjZV9zY3JvbGxlcjpiZWZvcmV7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wMSk7XFxufVxcblxcbi5hY2VfZ3V0dGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvdmVyZmxvdyA6IGhpZGRlbjtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxuICAgIHotaW5kZXg6IDQ7XFxuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIGNvbnRhaW46IHN0eWxlIHNpemUgbGF5b3V0O1xcbn1cXG5cXG4uYWNlX2d1dHRlci1hY3RpdmUtbGluZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxufVxcblxcbi5hY2Vfc2Nyb2xsZXIuYWNlX3Njcm9sbC1sZWZ0OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBib3gtc2hhZG93OiAxN3B4IDAgMTZweCAtMTZweCByZ2JhKDAsIDAsIDAsIDAuNCkgaW5zZXQ7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsLCAuYWNlX2d1dHRlci1jZWxsX3N2Zy1pY29ucyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgcGFkZGluZy1sZWZ0OiAxOXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA2cHg7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5hY2VfZ3V0dGVyLWNlbGxfc3ZnLWljb25zIC5hY2VfZ3V0dGVyX2Fubm90YXRpb24ge1xcbiAgICBtYXJnaW4tbGVmdDogLTE0cHg7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsIC5hY2VfZ3V0dGVyX2Fubm90YXRpb24ge1xcbiAgICBtYXJnaW4tbGVmdDogLTE5cHg7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsLmFjZV9lcnJvciwgLmFjZV9pY29uLmFjZV9lcnJvciwgLmFjZV9pY29uLmFjZV9lcnJvcl9mb2xkIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFCT0ZCTVZFWC8vLy8vLy8vL1FSc3dGQWIvVWk0d0ZBWXdGQVl3RkFhV0dBZkRSeW16T1NIL1B4c3dGQWIvU2lVd0ZBWXdGQWJVUFJ2alFpRGxsb2c1SGhIZFJ5YnNUaTMvVHl2OVRpcitTeWovVUMzLy8vL1h1cmViTUJJd0ZBYi9SU0hiUHgvZ1V6ZmR3TDNrek1pdktCQXdGQWJidmJuaFB4NjZOaG93RkFZd0ZBYVpKZzh3RkFheEtCRFp1cmYvUkI2bU14Yi9TQ013RkFZd0ZBYnhRQjMrUkI0d0ZBYi9RaHk0T2grNFFpZmJOUmN3RkFZd0ZBWXdGQWIvUVJ6ZE5oZ3dGQVl3RkFiYXY3di9VeTdvYUU2OE1CSzVMeExld3IvcjJOWGV3THN3RkFheEp3NHdGQWJrUFJ5MlB5WXdGQWF4S2hMbTF0TXdGQWF6UGlRd0ZBYVVHQWIvUUJyZk94M2J2cnYvVkMvbWFFNHdGQWJSUEJxNk1STzhReW5ldzhEcDJ0amZ3YjB3RkFieDZlanU1K2J5NnVuczR1SDkvZjM2K3ZyL0drSGpBQUFBWW5SU1RsTUFHdCs2NHJuV3UvYm84ZUFBNEluSDMrRHdvTjdqNGVMaTR4UDk5TmZnNCtiKy91OUIvZURzMU1EMW1PNys0UEhnMk1YYTM0N2c3dkRpek1MTjRlRytQdjdpNWV2cy92Nzl5dTdTMy9EVjcvNDk4WXYyNGVIKzR1ZlEzT3p1L3Y3K3kxM3NScXdBQUFETFNVUkJWSGphWmMvWERzRmdHSUJodERyc2hsaXRtazJJcmJIRnFMMnB2WGYvKzc4RFBva2o3K0Z6OXFwVS85VVhKSWxobVBhVGFRNlFQYXowbW0rNWd3a2dvdmNWNkdaemQ1SnRDUXdnc3hvSE92Sk8xNWtsZVJMQW5NZ0hGSUVTVUVQbWF3QjluZ21lbFR0aXB3d2ZBU2lseE9MeWlWNVVWVXlWQWZiRzBjQ1BIaWcrR0JrekFFTkhTMEFzdFZGNmJhY1pJT3pnTG14c0hidDJPZWNOZ0pDODNKRVJtZVBVWXE4QVJHa0p4Nlh0RnNkZGRCUWdaRTJuUFI2Q0lDWmhhd2pBNEZiL2NodiszOTlrZlIrTU1NREdPUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAycHggY2VudGVyO1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsLmFjZV93YXJuaW5nLCAuYWNlX2ljb24uYWNlX3dhcm5pbmcsIC5hY2VfaWNvbi5hY2Vfd2FybmluZ19mb2xkIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBbVZCTVZFWC8vLzhBQUFELy8vOEFBQUFBQUFCUFN6Yi81c0FBQUFCL2JsSC83M3ovdWxrQUFBQUFBQUQ4NXBrQUFBQUFBQUFDQWdQL3ZHei9ya0RlckdiR3JWNy9wa1FJQ0FmLy8vL2UwSXNBQUFEL29FRC9xVHZocm5VQUFBRC95SEQvbmpjQUFBRHV2MnIvbnovL29Uai9wMDY0b0dmL3pIQUFBQUE5TmlyL3RGSUFBQUQvdGxUaXVXZi90a0lBQUFDeW5YRUFBQUFBQUFBdElSVzd6QnBCQUFBQU0zUlNUbE1BQUJSMW03UlhPOExuMzFaMzZ6VCtuZVhlNU96b29SRGZuK1RaNHAzaDJoVGY0dDNrM3VjeXJOMUs1K1hha3M1MlNmczlDWGdyQUFBQWprbEVRVlI0Mm8zUGJRK0NJQlFGWUV3Ym9QaFNZZ29ZdW5JcXFMbjYvejh1WWRIOFZtZG51OXZ6NFd3WGdOL3hUUFJEMitzZ09jWmpzZ2Uvd2hYWmdVYVlZdlQ4UW51SmFVcmpySFVRcmVHY3p1RWFmUUNPL1NKVHVmVGJyb1dzUGdzbGxWaHEzd0pFazJqVVN6WDNDVUVESkM4NDcwN2RqUmM1TVRBUXhvTGd1cFdSd1c2VUI1ZlMrK05WOEFiT1pnbnNDN0JwRUFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMnB4IGNlbnRlcjtcXG59XFxuXFxuLmFjZV9ndXR0ZXItY2VsbC5hY2VfaW5mbywgLmFjZV9pY29uLmFjZV9pbmZvIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQUFBQUFBNm1LQzlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUFKMFVrNVRBQUIyazgwNEFBQUFQa2xFUVZRWTAyTmdJQjY4UXVPM3RpTHpuakF3cEtUZ055RGJNZWd3aXNDSFpVRVRVWlYwWnFPcXVCcFhqMnJ0bnBTSlQxQUVublJtTDJPZ0dnQUFJS2tSUWFwMmh0Z0FBQUFBU1VWT1JLNUNZSUk9XFxcIik7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IDJweCBjZW50ZXI7XFxufVxcbi5hY2VfZGFyayAuYWNlX2d1dHRlci1jZWxsLmFjZV9pbmZvLCAuYWNlX2RhcmsgLmFjZV9pY29uLmFjZV9pbmZvIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFCQU1BQUFEdDNlSlNBQUFBSkZCTVZFVUFBQUNob2FHQWdJQXFLaXErdnI2dHJhMVpXVm1VbEpTYm01czhQRHh1Ym01NmVucmRnemczQUFBQUFYUlNUbE1BUU9iWVpnQUFBQ2xKUkVGVWVOcGpZTUFQZHNNWUhlZ3lKWkZRQmxzVWxNRlZDV1VZS2tBWk14WkFHZHhsRE1RQkFHK1RCUDRCNlJ5SkFBQUFBRWxGVGtTdVFtQ0NcXFwiKTtcXG59XFxuXFxuLmFjZV9pY29uX3N2Zy5hY2VfZXJyb3Ige1xcbiAgICAtd2Via2l0LW1hc2staW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F4TmlJK0NqeG5JSE4wY205clpTMTNhV1IwYUQwaU1pSWdjM1J5YjJ0bFBTSnlaV1FpSUhOb1lYQmxMWEpsYm1SbGNtbHVaejBpWjJWdmJXVjBjbWxqVUhKbFkybHphVzl1SWo0S1BHTnBjbU5zWlNCbWFXeHNQU0p1YjI1bElpQmplRDBpT0NJZ1kzazlJamdpSUhJOUlqY2lJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUx6NEtQR3hwYm1VZ2VERTlJakV4SWlCNU1UMGlOU0lnZURJOUlqVWlJSGt5UFNJeE1TSXZQZ284YkdsdVpTQjRNVDBpTVRFaUlIa3hQU0l4TVNJZ2VESTlJalVpSUhreVBTSTFJaTgrQ2p3dlp6NEtQQzl6ZG1jK1xcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjcmltc29uO1xcbn1cXG4uYWNlX2ljb25fc3ZnLmFjZV93YXJuaW5nIHtcXG4gICAgLXdlYmtpdC1tYXNrLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeE5pSStDanhuSUhOMGNtOXJaUzEzYVdSMGFEMGlNaUlnYzNSeWIydGxQU0prWVhKcmIzSmhibWRsSWlCemFHRndaUzF5Wlc1a1pYSnBibWM5SW1kbGIyMWxkSEpwWTFCeVpXTnBjMmx2YmlJK0NqeHdiMng1WjI5dUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdacGJHdzlJbTV2Ym1VaUlIQnZhVzUwY3owaU9DQXhJREUxSURFMUlERWdNVFVnT0NBeElpOCtDanh5WldOMElIZzlJamdpSUhrOUlqRXlJaUIzYVdSMGFEMGlNQzR3TVNJZ2FHVnBaMmgwUFNJd0xqQXhJaTgrQ2p4c2FXNWxJSGd4UFNJNElpQjVNVDBpTmlJZ2VESTlJamdpSUhreVBTSXhNQ0l2UGdvOEwyYytDand2YzNablBnPT1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogZGFya29yYW5nZTtcXG59XFxuLmFjZV9pY29uX3N2Zy5hY2VfaW5mbyB7XFxuICAgIC13ZWJraXQtbWFzay1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXhOaUkrQ2p4bklITjBjbTlyWlMxM2FXUjBhRDBpTWlJZ2MzUnliMnRsUFNKaWJIVmxJaUJ6YUdGd1pTMXlaVzVrWlhKcGJtYzlJbWRsYjIxbGRISnBZMUJ5WldOcGMybHZiaUkrQ2p4amFYSmpiR1VnWm1sc2JEMGlibTl1WlNJZ1kzZzlJamdpSUdONVBTSTRJaUJ5UFNJM0lpQnpkSEp2YTJVdGJHbHVaV3B2YVc0OUluSnZkVzVrSWk4K0NqeHdiMng1YkdsdVpTQndiMmx1ZEhNOUlqZ2dNVEVnT0NBNElpOCtDanh3YjJ4NWJHbHVaU0J3YjJsdWRITTlJamtnT0NBMklEZ2lMejRLUEd4cGJtVWdlREU5SWpFd0lpQjVNVDBpTVRFaUlIZ3lQU0kySWlCNU1qMGlNVEVpTHo0S1BISmxZM1FnZUQwaU9DSWdlVDBpTlNJZ2QybGtkR2c5SWpBdU1ERWlJR2hsYVdkb2REMGlNQzR3TVNJdlBnbzhMMmMrQ2p3dmMzWm5QZz09XFxcIik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJveWFsYmx1ZTtcXG59XFxuXFxuLmFjZV9pY29uX3N2Zy5hY2VfZXJyb3JfZm9sZCB7XFxuICAgIC13ZWJraXQtbWFzay1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXhOaUlnWm1sc2JEMGlibTl1WlNJK0NpQWdQSEJoZEdnZ1pEMGliU0F4T0M0NU1qazROVEVzTnk0NE1qazRNRGMySUdNZ01DNHhORFl6TlRNc05pNHpNemMwTmpBMElDMDJMak15TXpFME55dzNMamMzTnpnME5EUWdMVGN1TkRjM09URXlMRGN1TnpjM09EUTBOQ0F0TWk0eE1EY3lOekkyTEMwd0xqRXlPRGMxSURVdU1URTNOamM0TERBdU16VTJNalE1SURVdU1EVXhOams0TEMwM0xqZzNNREEyTVRnZ0xUQXVOakEwTmpjeUxDMDRMakF3TXprM016UTVJQzAzTGpBM056STNNRFlzTFRjdU5UWXpNVEU0T1NBdE5DNDROVGN6TEMwM0xqUXpNRE01TlRVMklERXVOakEyTEMwd0xqRXhOVEUwTWpJMUlEWXVPRGszTkRnMUxERXVNall5TlRRMU9UWWdOeTR5T0RNMU1UUXNOeTQxTWpJMk1USTVOaUI2SWlCbWFXeHNQU0pqY21sdGMyOXVJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqSWlMejRLSUNBOGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGliU0E0TGpFeE5EYzFOaklzTWk0d05USTVPREk0SUdNZ015NHpORGt4TmprNExEQWdOaTR3TmpReE16STRMREl1TmpjMk9EWXlOeUEyTGpBMk5ERXpNamdzTlM0NU56ZzVOVE1nTUN3ekxqTXdNakV4TWpJZ0xUSXVOekUwT1RZekxEVXVPVGM0T1RJd01pQXROaTR3TmpReE16STRMRFV1T1RjNE9USXdNaUF0TXk0ek5Ea3hORGN6TERBZ0xUWXVNRFkwTVRjM01pd3RNaTQyTnpZNE1EZ2dMVFl1TURZME1UYzNNaXd0TlM0NU56ZzVNakF5SURBdU1EQTFNemtzTFRNdU1qazVPRGcyTVNBeUxqY3hOekkyTlRZc0xUVXVPVGN6TmpRd09DQTJMakEyTkRFM056SXNMVFV1T1RjNE9UVXpJSG9nYlNBd0xDMHhMamN6TlRneU56RTVJR01nTFRRdU16SXhORGd6Tml3d0lDMDNMamd5TkRjME1ETTRMRE11TkRVME1ERTRORGtnTFRjdU9ESTBOelF3TXpnc055NDNNVFEzT0RBeE9TQXdMRFF1TWpZd056STRNaUF6TGpVd016STFOamM0TERjdU56RTBOelExTWlBM0xqZ3lORGMwTURNNExEY3VOekUwTnpRMU1pQTBMak15TVRRME9UZ3NNQ0EzTGpneU5EWTVPVGdzTFRNdU5EVTBNREUzSURjdU9ESTBOams1T0N3dE55NDNNVFEzTkRVeUlEQXNMVEl1TURRMk1Ea3hOQ0F0TUM0NE1qUXpPVElzTFRRdU1EQTRNelkzTWlBdE1pNHlPVEUzTlRZc0xUVXVORFUxTVRjME5pQkRJREV5TGpFNE1ESXlOU3d4TGpFeU9UazJORGdnTVRBdU1Ua3dNREV6TERBdU16RTNNVFUxTmpFZ09DNHhNVFEzTlRZeUxEQXVNekUzTVRVMU5qRWdXaUJOSURZdU9UTTNORFUyTXl3NExqSTBNRFU1T0RVZ05DNDJOekU0TmpnMUxERXdMalE0TlRnMU1pQTJMakF3T0RZNE1UUXNNVEV1T0RjMk56STRJRGd1TXpFM01EQXpOU3c1TGpZd01EYzVNVEVnTVRBdU5qSTFNek0zTERFeExqZzNOamN5T0NBeE1TNDVOakl4TXpnc01UQXVORGcxT0RVeUlEa3VOamsyTlRVd09DdzRMakkwTURVNU9EVWdNVEV1T1RZeU1UTTRMRFl1TURBMk9EQTJOaUF4TUM0MU56TXlORFlzTkM0Mk16YzBNek0xSURndU16RTNNREF6TlN3MkxqZzNNelF5T1RjZ05pNHdOakEzTmpBM0xEUXVOak0zTkRNek5TQTBMalkzTVRnMk9EVXNOaTR3TURZNE1EWTJJRm9pSUdacGJHdzlJbU55YVcxemIyNGlJSE4wY205clpTMTNhV1IwYUQwaU1pSXZQZ284TDNOMlp6ND1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogY3JpbXNvbjtcXG59XFxuLmFjZV9pY29uX3N2Zy5hY2Vfd2FybmluZ19mb2xkIHtcXG4gICAgLXdlYmtpdC1tYXNrLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNVFlpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F4TmlJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE5DNDNOelk1SURFMExqY3pNemRNT0M0Mk5URTVNaUF5TGpRNE16WTVRemd1TXpJNU5EWWdNUzQ0TXpnM055QTNMalF3T1RFeklERXVPRE00TnpjZ055NHdPRFkyTnlBeUxqUTRNelk1VERBdU9UWXhOalk1SURFMExqY3pNemRETUM0Mk56QTNOelVnTVRVdU16RTFOU0F4TGpBNU16Z3pJREUySURFdU56UTBNamtnTVRaSU1UTXVPVGswTTBNeE5DNDJORFE0SURFMklERTFMakEyTnpnZ01UVXVNekUxTlNBeE5DNDNOelk1SURFMExqY3pNemRhVFRNdU1UWXdNRGNnTVRRdU1qVk1OeTQ0TmpreU9TQTBMamd6TVRVMlRERXlMalUzT0RVZ01UUXVNalZJTXk0eE5qQXdOMXBOT0M0M05EUXlPU0F4TVM0Mk1qVldNVE11TXpjMVNEWXVPVGswTWpsV01URXVOakkxU0RndU56UTBNamxhVFRZdU9UazBNamtnTVRBdU56VldOeTR5TlVnNExqYzBOREk1VmpFd0xqYzFTRFl1T1RrME1qbGFJaUJtYVd4c1BTSWpSVU0zTWpFeElpOCtDanh3WVhSb0lHUTlJazB4TVM0eE9Ua3hJREl1T1RVeU16aERNVEF1T0Rnd09TQXlMak14TkRZM0lERXdMak0xTXpjZ01TNDRNRFV5TmlBNUxqY3dOVFVnTVM0MU1EbE1NVEV1TURReElERXVNRFk1TnpoRE1URXVOamc0TXlBd0xqazBPVGd4TkNBeE1pNHpNemNnTVM0eU56STJNeUF4TWk0Mk16RTNJREV1T0RZeE5ERk1NVGN1TmpFek5pQXhNUzQ0TVRZeFF6RTRMak0xTWpjZ01UTXVNamt5T1NBeE55NDFPVE00SURFMUxqQTRNRFFnTVRZdU1ERTRJREUxTGpVM05EVkRNVFl1TkRBME5DQXhOQzQwTlRBM0lERTJMak15TXpFZ01UTXVNakU0T0NBeE5TNDNPVEkwSURFeUxqRTFOVFZNTVRFdU1UazVNU0F5TGprMU1qTTRXaUlnWm1sc2JEMGlJMFZETnpJeE1TSXZQZ284TDNOMlp6ND1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogZGFya29yYW5nZTtcXG59XFxuXFxuLmFjZV9zY3JvbGxiYXIge1xcbiAgICBjb250YWluOiBzdHJpY3Q7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgei1pbmRleDogNjtcXG59XFxuXFxuLmFjZV9zY3JvbGxiYXItaW5uZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGN1cnNvcjogdGV4dDtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbn1cXG5cXG4uYWNlX3Njcm9sbGJhci12e1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcXG4gICAgdG9wOiAwO1xcbn1cXG5cXG4uYWNlX3Njcm9sbGJhci1oIHtcXG4gICAgb3ZlcmZsb3cteDogc2Nyb2xsO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICAgIGxlZnQ6IDA7XFxufVxcblxcbi5hY2VfcHJpbnQtbWFyZ2luIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5hY2VfdGV4dC1pbnB1dCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMDtcXG4gICAgd2lkdGg6IDAuNWVtO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICByZXNpemU6IG5vbmU7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGZvbnQ6IGluaGVyaXQ7XFxuICAgIHBhZGRpbmc6IDAgMXB4O1xcbiAgICBtYXJnaW46IDAgLTFweDtcXG4gICAgY29udGFpbjogc3RyaWN0O1xcbiAgICAtbXMtdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgICAvKndpdGggYHByZS1saW5lYCBjaHJvbWUgaW5zZXJ0cyAmbmJzcDsgaW5zdGVhZCBvZiBzcGFjZSovXFxuICAgIHdoaXRlLXNwYWNlOiBwcmUhaW1wb3J0YW50O1xcbn1cXG4uYWNlX3RleHQtaW5wdXQuYWNlX2NvbXBvc2l0aW9uIHtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICB6LWluZGV4OiAxMDAwO1xcbiAgICBvcGFjaXR5OiAxO1xcbn1cXG4uYWNlX2NvbXBvc2l0aW9uX3BsYWNlaG9sZGVyIHsgY29sb3I6IHRyYW5zcGFyZW50IH1cXG4uYWNlX2NvbXBvc2l0aW9uX21hcmtlciB7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQ7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgbWFyZ2luLXRvcDogMXB4O1xcbn1cXG5cXG5bYWNlX25vY29udGV4dD10cnVlXSB7XFxuICAgIHRyYW5zZm9ybTogbm9uZSFpbXBvcnRhbnQ7XFxuICAgIGZpbHRlcjogbm9uZSFpbXBvcnRhbnQ7XFxuICAgIGNsaXAtcGF0aDogbm9uZSFpbXBvcnRhbnQ7XFxuICAgIG1hc2sgOiBub25lIWltcG9ydGFudDtcXG4gICAgY29udGFpbjogbm9uZSFpbXBvcnRhbnQ7XFxuICAgIHBlcnNwZWN0aXZlOiBub25lIWltcG9ydGFudDtcXG4gICAgbWl4LWJsZW5kLW1vZGU6IGluaXRpYWwhaW1wb3J0YW50O1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbn1cXG5cXG4uYWNlX2xheWVyIHtcXG4gICAgei1pbmRleDogMTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAvKiB3b3JrYXJvdW5kIGZvciBjaHJvbWUgYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL2FjZS9pc3N1ZXMvMjMxMiovXFxuICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAvKiBzZXR0aW5nIHBvaW50ZXItZXZlbnRzOiBhdXRvOyBvbiBub2RlIHVuZGVyIHRoZSBtb3VzZSwgd2hpY2ggY2hhbmdlc1xcbiAgICAgICAgZHVyaW5nIHNjcm9sbCwgd2lsbCBicmVhayBtb3VzZSB3aGVlbCBzY3JvbGxpbmcgaW4gU2FmYXJpICovXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYWNlX2d1dHRlci1sYXllciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gICAgaGVpZ2h0OiAxMDAwMDAwcHg7XFxuICAgIGNvbnRhaW46IHN0eWxlIHNpemUgbGF5b3V0O1xcbn1cXG5cXG4uYWNlX3RleHQtbGF5ZXIge1xcbiAgICBmb250OiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgaGVpZ2h0OiAxMDAwMDAwcHg7XFxuICAgIHdpZHRoOiAxMDAwMDAwcHg7XFxuICAgIGNvbnRhaW46IHN0eWxlIHNpemUgbGF5b3V0O1xcbn1cXG5cXG4uYWNlX3RleHQtbGF5ZXIgPiAuYWNlX2xpbmUsIC5hY2VfdGV4dC1sYXllciA+IC5hY2VfbGluZV9ncm91cCB7XFxuICAgIGNvbnRhaW46IHN0eWxlIHNpemUgbGF5b3V0O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxufVxcblxcbi5hY2VfaGlkcGkgLmFjZV90ZXh0LWxheWVyLFxcbi5hY2VfaGlkcGkgLmFjZV9ndXR0ZXItbGF5ZXIsXFxuLmFjZV9oaWRwaSAuYWNlX2NvbnRlbnQsXFxuLmFjZV9oaWRwaSAuYWNlX2d1dHRlciB7XFxuICAgIGNvbnRhaW46IHN0cmljdDtcXG59XFxuLmFjZV9oaWRwaSAuYWNlX3RleHQtbGF5ZXIgPiAuYWNlX2xpbmUsIFxcbi5hY2VfaGlkcGkgLmFjZV90ZXh0LWxheWVyID4gLmFjZV9saW5lX2dyb3VwIHtcXG4gICAgY29udGFpbjogc3RyaWN0O1xcbn1cXG5cXG4uYWNlX2NqayB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uYWNlX2N1cnNvci1sYXllciB7XFxuICAgIHotaW5kZXg6IDQ7XFxufVxcblxcbi5hY2VfY3Vyc29yIHtcXG4gICAgei1pbmRleDogNDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBib3JkZXItbGVmdDogMnB4IHNvbGlkO1xcbiAgICAvKiB3b3JrYXJvdW5kIGZvciBzbW9vdGggY3Vyc29yIHJlcGFpbnRuZyB3aG9sZSBzY3JlZW4gaW4gY2hyb21lICovXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRleigwKTtcXG59XFxuXFxuLmFjZV9tdWx0aXNlbGVjdCAuYWNlX2N1cnNvciB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxufVxcblxcbi5hY2Vfc2xpbS1jdXJzb3JzIC5hY2VfY3Vyc29yIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG59XFxuXFxuLmFjZV9vdmVyd3JpdGUtY3Vyc29ycyAuYWNlX2N1cnNvciB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQ7XFxufVxcblxcbi5hY2VfaGlkZGVuLWN1cnNvcnMgLmFjZV9jdXJzb3Ige1xcbiAgICBvcGFjaXR5OiAwLjI7XFxufVxcblxcbi5hY2VfaGFzUGxhY2Vob2xkZXIgLmFjZV9oaWRkZW4tY3Vyc29ycyAuYWNlX2N1cnNvciB7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hY2Vfc21vb3RoLWJsaW5raW5nIC5hY2VfY3Vyc29yIHtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjE4cztcXG59XFxuXFxuLmFjZV9hbmltYXRlLWJsaW5raW5nIC5hY2VfY3Vyc29yIHtcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxMDAwbXM7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IHN0ZXAtZW5kO1xcbiAgICBhbmltYXRpb24tbmFtZTogYmxpbmstYWNlLWFuaW1hdGU7XFxuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbn1cXG5cXG4uYWNlX2FuaW1hdGUtYmxpbmtpbmcuYWNlX3Ntb290aC1ibGlua2luZyAuYWNlX2N1cnNvciB7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMTAwMG1zO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXG4gICAgYW5pbWF0aW9uLW5hbWU6IGJsaW5rLWFjZS1hbmltYXRlLXNtb290aDtcXG59XFxuICAgIFxcbkBrZXlmcmFtZXMgYmxpbmstYWNlLWFuaW1hdGUge1xcbiAgICBmcm9tLCB0byB7IG9wYWNpdHk6IDE7IH1cXG4gICAgNjAlIHsgb3BhY2l0eTogMDsgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIGJsaW5rLWFjZS1hbmltYXRlLXNtb290aCB7XFxuICAgIGZyb20sIHRvIHsgb3BhY2l0eTogMTsgfVxcbiAgICA0NSUgeyBvcGFjaXR5OiAxOyB9XFxuICAgIDYwJSB7IG9wYWNpdHk6IDA7IH1cXG4gICAgODUlIHsgb3BhY2l0eTogMDsgfVxcbn1cXG5cXG4uYWNlX21hcmtlci1sYXllciAuYWNlX3N0ZXAsIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc3RhY2sge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDM7XFxufVxcblxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0aW9uIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiA1O1xcbn1cXG5cXG4uYWNlX21hcmtlci1sYXllciAuYWNlX2JyYWNrZXQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDY7XFxufVxcblxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2VfZXJyb3JfYnJhY2tldCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNERTU1NTU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxufVxcblxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2VfYWN0aXZlLWxpbmUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDI7XFxufVxcblxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0ZWQtd29yZCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogNDtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuLmFjZV9saW5lIC5hY2VfZm9sZCB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgaGVpZ2h0OiAxMXB4O1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcblxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOlxcbiAgICAgICAgdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJFQUFBQUpDQVlBQUFEVTZNY01BQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUpwSlJFRlVlTnBpL1AvL1B3T2xnQVhHWUdSa2xBVlNva0Q4R21qd1kxd2FzS2xqUXBZQUN0cENGZUFEY0hWUWZReU1RQXd6d0FaSTN3Skt2Q0xrZktCYU1TQ2xCbFI3Qk9RaWtDRkdRRUVySUgwVnFrYWJpR0NBcXdVYWRBelpKUnhRci8wZ3dpWElhbDh6UVFQbk5WVGdKMVRkYXdMMFQ1Z0JJUDFNVUpOaEJ2MkhLb1FISGpxTnJBNFdPNHpZMGdseU5LTFQyS0lmSU1BQVFzZGdHaVh2Z25ZQUFBQUFTVVZPUks1Q1lJST1cXFwiKSxcXG4gICAgICAgIHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUEzQ0FZQUFBRE5OaUE1QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFDSkpSRUZVZU5waStQLy9meGdUQXdQREJ4RHhEMDc4UlNYK1llRXlERk1DSU1BQUkzSU5tWGl3ZjJZQUFBQUFTVVZPUks1Q1lJST1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdCwgcmVwZWF0LXg7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXIsIHRvcCBsZWZ0O1xcbiAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XFxuXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XFxuXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XFxufVxcblxcbi5hY2VfZGFyayAuYWNlX2ZvbGQge1xcbn1cXG5cXG4uYWNlX2ZvbGQ6aG92ZXJ7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6XFxuICAgICAgICB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkVBQUFBSkNBWUFBQURVNk1jTUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSnBKUkVGVWVOcGkvUC8vUHdPbGdBWEdZR1JrbEFWU29rRDhHbWp3WTF3YXNLbGpRcFlBQ3RwQ0ZlQURjSFZRZlF5TVFBd3p3QVpJM3dKS3ZDTGtmS0JhTVNDbEJsUjdCT1Fpa0NGR1FFRXJJSDBWcWthYmlHQ0Fxd1VhZEF6WkpSeFFyLzBnd2lYSWFsOHpRUVBuTlZUZ0oxVGRhd0wwVDVnQklQMU1VSk5oQnYySEtvUUhIanFOckE0V080elkwZ2x5TktMVDJLSWZJTUFBUXNkZ0dpWHZnbllBQUFBQVNVVk9SSzVDWUlJPVxcXCIpLFxcbiAgICAgICAgdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQTNDQVlBQUFETk5pQTVBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUNCSlJFRlVlTnBpK1AvL2Z6NFRBd1BEWnhEeEQ1WDRpNWZMTUV3SmdBQURBRVBWRGJqTnc4N1pBQUFBQUVsRlRrU3VRbUNDXFxcIik7XFxufVxcblxcbi5hY2VfdG9vbHRpcCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGdyYXk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDFweDtcXG4gICAgYm94LXNoYWRvdzogMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gICAgY29sb3I6IGJsYWNrO1xcbiAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgIHBhZGRpbmc6IDNweCA0cHg7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgei1pbmRleDogOTk5OTk5O1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gICAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICAgIGxldHRlci1zcGFjaW5nOiBub3JtYWw7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgbWF4LXdpZHRoOiBtaW4oNjBlbSwgNjZ2dyk7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW47XFxufVxcbi5hY2VfdG9vbHRpcCBwcmUge1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxufVxcblxcbi5hY2VfdG9vbHRpcC5hY2VfZGFyayB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM2MzYzNjM7XFxuICAgIGNvbG9yOiAjZmZmO1xcbn1cXG5cXG4uYWNlX3Rvb2x0aXA6Zm9jdXMge1xcbiAgICBvdXRsaW5lOiAxcHggc29saWQgIzVFOUVENjtcXG59XFxuXFxuLmFjZV9pY29uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDogMThweDtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG59XFxuXFxuLmFjZV9pY29uX3N2ZyB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IDEycHg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAgIC13ZWJraXQtbWFzay1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgLXdlYmtpdC1tYXNrLXNpemU6IDEycHg7XFxuICAgIC13ZWJraXQtbWFzay1wb3NpdGlvbjogY2VudGVyO1xcbn1cXG5cXG4uYWNlX2ZvbGRpbmctZW5hYmxlZCA+IC5hY2VfZ3V0dGVyLWNlbGwsIC5hY2VfZm9sZGluZy1lbmFibGVkID4gLmFjZV9ndXR0ZXItY2VsbF9zdmctaWNvbnMge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxM3B4O1xcbn1cXG5cXG4uYWNlX2ZvbGQtd2lkZ2V0IHtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gICAgbWFyZ2luOiAwIC0xMnB4IDAgMXB4O1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICB3aWR0aDogMTFweDtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG5cXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBTkVsRVFWUjQybVdLc1EwQU1BekM4aXhMbHJ6UWp6bUJpRWpwMEE2V3dCQ1NQZ0tBWG9Ma3FTb3Q3bk4zeU13UjdwWjMyTnpwS2tWb0RCVXhLQUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxuXFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5hY2VfZm9sZGluZy1lbmFibGVkIC5hY2VfZm9sZC13aWRnZXQge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7ICAgXFxufVxcblxcbi5hY2VfZm9sZC13aWRnZXQuYWNlX2VuZCB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQU5FbEVRVlI0Mm0zSHdRa0FNQWhEMFl6c1JjaEZLSTdzQWlrZVdrcnh3U2NFQjBuaDVlN0tUUFdpbVpraTR0WWZWYlgrTU5sNHB5WlhlalVPMVFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTtcXG59XFxuXFxuLmFjZV9mb2xkLXdpZGdldC5hY2VfY2xvc2VkIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFNQUFBQUdDQVlBQUFBRzVTUU1BQUFBT1VsRVFWUjQyalhLd1FrQU1BZ0R3S3dxS0Q0RXdRMjZzU09rVldqZ0lJSEF6UGlDZ2FxaXFuSkhabktJQ0JFUkhOMTk0TzViOXZiTHVBVlJMK2wwWVduWkFBQUFBRWxGVGtTdVFtQ0NYQT09XFxcIik7XFxufVxcblxcbi5hY2VfZm9sZC13aWRnZXQ6aG92ZXIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMyk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gICAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcXG59XFxuXFxuLmFjZV9mb2xkLXdpZGdldDphY3RpdmUge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XFxufVxcbi8qKlxcbiAqIERhcmsgdmVyc2lvbiBmb3IgZm9sZCB3aWRnZXRzXFxuICovXFxuLmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFIa2xFUVZRSVcyUDQvLzgvQXpvR0VRN29HQ2FMTEFoV2lTd0IxNDZCQVFDU1RQWW9jcVQwQUFBQUFFbEZUa1N1UW1DQ1xcXCIpO1xcbn1cXG4uYWNlX2RhcmsgLmFjZV9mb2xkLXdpZGdldC5hY2VfZW5kIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSDBsRVFWUUlXMlA0Ly84L0F4UTd3TmpJQWpETWdDNEF4akNWS0JpcklBQUYwa3oycmxoeHBBQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxufVxcbi5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0LmFjZV9jbG9zZWQge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQU1BQUFBRkNBWUFBQUNBY1ZhaUFBQUFIRWxFUVZRSVcyUDQvLysvQXhBemdEQURsT09Bem5IQUtnUFdBd0FSamk4VUlEVGZRUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpO1xcbn1cXG4uYWNlX2RhcmsgLmFjZV9mb2xkLXdpZGdldDpob3ZlciB7XFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcXG59XFxuLmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQ6YWN0aXZlIHtcXG4gICAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG59XFxuXFxuLmFjZV9pbmxpbmVfYnV0dG9uIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgbGlnaHRncmF5O1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIG1hcmdpbjogLTFweCA4cHg7XFxuICAgIHBhZGRpbmc6IDAgNXB4O1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uYWNlX2lubGluZV9idXR0b246aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IGdyYXk7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjAwLDIwMCwyMDAsMC4yKTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG59XFxuXFxuLmFjZV9mb2xkLXdpZGdldC5hY2VfaW52YWxpZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkI0QjQ7XFxuICAgIGJvcmRlci1jb2xvcjogI0RFNTU1NTtcXG59XFxuXFxuLmFjZV9mYWRlLWZvbGQtd2lkZ2V0cyAuYWNlX2ZvbGQtd2lkZ2V0IHtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjRzIGVhc2UgMC4wNXM7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hY2VfZmFkZS1mb2xkLXdpZGdldHM6aG92ZXIgLmFjZV9mb2xkLXdpZGdldCB7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4wNXMgZWFzZSAwLjA1cztcXG4gICAgb3BhY2l0eToxO1xcbn1cXG5cXG4uYWNlX3VuZGVybGluZSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4uYWNlX2JvbGQge1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLmFjZV9ub2JvbGQgLmFjZV9ib2xkIHtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG59XFxuXFxuLmFjZV9pdGFsaWMge1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcblxcbi5hY2VfZXJyb3ItbWFya2VyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDAsIDAsMC4yKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiA5O1xcbn1cXG5cXG4uYWNlX2hpZ2hsaWdodC1tYXJrZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAwLDAuMik7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogODtcXG59XFxuXFxuLmFjZV9tb2JpbGUtbWVudSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgYm94LXNoYWRvdzogMXB4IDNweCAycHggZ3JleTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2RjZGNkYztcXG4gICAgY29sb3I6IGJsYWNrO1xcbn1cXG4uYWNlX2RhcmsgPiAuYWNlX21vYmlsZS1tZW51IHtcXG4gICAgYmFja2dyb3VuZDogIzMzMztcXG4gICAgY29sb3I6ICNjY2M7XFxuICAgIGJveC1zaGFkb3c6IDFweCAzcHggMnB4IGdyZXk7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM0NDQ7XFxuXFxufVxcbi5hY2VfbW9iaWxlLWJ1dHRvbiB7XFxuICAgIHBhZGRpbmc6IDJweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG4uYWNlX21vYmlsZS1idXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgICBvcGFjaXR5OjE7XFxufVxcbi5hY2VfbW9iaWxlLWJ1dHRvbjphY3RpdmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xcbn1cXG5cXG4uYWNlX3BsYWNlaG9sZGVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmb250LWZhbWlseTogYXJpYWw7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45KTtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdDtcXG4gICAgd2hpdGUtc3BhY2U6IHByZTtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgICBtYXJnaW46IDAgMTBweDtcXG4gICAgei1pbmRleDogMTtcXG59XFxuXFxuLmFjZV9naG9zdF90ZXh0IHtcXG4gICAgb3BhY2l0eTogMC41O1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi5hY2VfZ2hvc3RfdGV4dF9jb250YWluZXIgPiBkaXYge1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xcbn1cXG5cXG4uZ2hvc3RfdGV4dF9saW5lX3dyYXBwZWQ6OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcdTIxQTlcXFwiO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5hY2VfbGluZVdpZGdldENvbnRhaW5lci5hY2VfZ2hvc3RfdGV4dCB7XFxuICAgIG1hcmdpbjogMHB4IDRweFxcbn1cXG5cXG4uYWNlX3NjcmVlbnJlYWRlci1vbmx5IHtcXG4gICAgcG9zaXRpb246YWJzb2x1dGU7XFxuICAgIGxlZnQ6LTEwMDAwcHg7XFxuICAgIHRvcDphdXRvO1xcbiAgICB3aWR0aDoxcHg7XFxuICAgIGhlaWdodDoxcHg7XFxuICAgIG92ZXJmbG93OmhpZGRlbjtcXG59XFxuXFxuLmFjZV9oaWRkZW5fdG9rZW4ge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cIjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvZGVjb3JhdG9yc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgb29wID0gcmVxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBEZWNvcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb3JhdG9yKHBhcmVudCwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb20uY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgICAgICB0aGlzLm1heEhlaWdodCA9IHJlbmRlcmVyLmxheWVyQ29uZmlnLm1heEhlaWdodDtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gcmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXNIZWlnaHQgPSBwYXJlbnQucGFyZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHRSYXRpbyA9IHRoaXMuY2FudmFzSGVpZ2h0IC8gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzV2lkdGggPSBwYXJlbnQud2lkdGg7XG4gICAgICAgIHRoaXMubWluRGVjb3JhdGlvbkhlaWdodCA9ICgyICogdGhpcy5waXhlbFJhdGlvKSB8IDA7XG4gICAgICAgIHRoaXMuaGFsZk1pbkRlY29yYXRpb25IZWlnaHQgPSAodGhpcy5taW5EZWNvcmF0aW9uSGVpZ2h0IC8gMikgfCAwO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAwICsgXCJweFwiO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9IDAgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9IDcgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbG9ycy5kYXJrID0ge1xuICAgICAgICAgICAgXCJlcnJvclwiOiBcInJnYmEoMjU1LCAxOCwgMTgsIDEpXCIsXG4gICAgICAgICAgICBcIndhcm5pbmdcIjogXCJyZ2JhKDE4LCAxMzYsIDE4LCAxKVwiLFxuICAgICAgICAgICAgXCJpbmZvXCI6IFwicmdiYSgxOCwgMTgsIDEzNiwgMSlcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbG9ycy5saWdodCA9IHtcbiAgICAgICAgICAgIFwiZXJyb3JcIjogXCJyZ2IoMjU1LDUxLDUxKVwiLFxuICAgICAgICAgICAgXCJ3YXJuaW5nXCI6IFwicmdiKDMyLDEzMyw3MilcIixcbiAgICAgICAgICAgIFwiaW5mb1wiOiBcInJnYigzNSw2OCwxMzgpXCJcbiAgICAgICAgfTtcbiAgICAgICAgcGFyZW50LmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgIH1cbiAgICBEZWNvcmF0b3IucHJvdG90eXBlLiR1cGRhdGVEZWNvcmF0b3JzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgY29sb3JzID0gKHRoaXMucmVuZGVyZXIudGhlbWUuaXNEYXJrID09PSB0cnVlKSA/IHRoaXMuY29sb3JzLmRhcmsgOiB0aGlzLmNvbG9ycy5saWdodDtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSBjb25maWcubWF4SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgYWxsTGluZUhlaWdodCA9IChjb25maWcubGFzdFJvdyArIDEpICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGFsbExpbmVIZWlnaHQgPCB0aGlzLmNhbnZhc0hlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0UmF0aW8gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRSYXRpbyA9IHRoaXMuY2FudmFzSGVpZ2h0IC8gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5wcmlvcml0eSA8IGIucHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGEucHJpb3JpdHkgPiBiLnByaW9yaXR5KVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy5yZW5kZXJlci5zZXNzaW9uLiRhbm5vdGF0aW9ucztcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGllcyA9IHtcbiAgICAgICAgICAgICAgICBcImluZm9cIjogMSxcbiAgICAgICAgICAgICAgICBcIndhcm5pbmdcIjogMixcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IDNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5wcmlvcml0eSA9IHByaW9yaXRpZXNbaXRlbS50eXBlXSB8fCBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLnJlbmRlcmVyLnNlc3Npb24uJGZvbGREYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBhbm5vdGF0aW9uc1tpXS5yb3c7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBlbnNhdGVGb2xkID0gdGhpcy5jb21wZW5zYXRlRm9sZFJvd3Mocm93LCBmb2xkRGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRZID0gTWF0aC5yb3VuZCgocm93IC0gY29tcGVuc2F0ZUZvbGQpICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5oZWlnaHRSYXRpbyk7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5yb3VuZCgoKHJvdyAtIGNvbXBlbnNhdGVGb2xkKSAqIHRoaXMubGluZUhlaWdodCAqIHRoaXMuaGVpZ2h0UmF0aW8pKTtcbiAgICAgICAgICAgICAgICB2YXIgeTIgPSBNYXRoLnJvdW5kKCgoKHJvdyAtIGNvbXBlbnNhdGVGb2xkKSAqIHRoaXMubGluZUhlaWdodCArIHRoaXMubGluZUhlaWdodCkgKiB0aGlzLmhlaWdodFJhdGlvKSk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHkyIC0geTE7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCA8IHRoaXMubWluRGVjb3JhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUNlbnRlciA9ICgoeTEgKyB5MikgLyAyKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5Q2VudGVyIDwgdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeUNlbnRlciA9IHRoaXMuaGFsZk1pbkRlY29yYXRpb25IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeUNlbnRlciArIHRoaXMuaGFsZk1pbkRlY29yYXRpb25IZWlnaHQgPiB0aGlzLmNhbnZhc0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeUNlbnRlciA9IHRoaXMuY2FudmFzSGVpZ2h0IC0gdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5MSA9IE1hdGgucm91bmQoeUNlbnRlciAtIHRoaXMuaGFsZk1pbkRlY29yYXRpb25IZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IE1hdGgucm91bmQoeUNlbnRlciArIHRoaXMuaGFsZk1pbkRlY29yYXRpb25IZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JzW2Fubm90YXRpb25zW2ldLnR5cGVdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIGN1cnJlbnRZLCB0aGlzLmNhbnZhc1dpZHRoLCB5MiAtIHkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5yZW5kZXJlci5zZXNzaW9uLnNlbGVjdGlvbi5nZXRDdXJzb3IoKTtcbiAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgdmFyIGNvbXBlbnNhdGVGb2xkID0gdGhpcy5jb21wZW5zYXRlRm9sZFJvd3MoY3Vyc29yLnJvdywgZm9sZERhdGEpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRZID0gTWF0aC5yb3VuZCgoY3Vyc29yLnJvdyAtIGNvbXBlbnNhdGVGb2xkKSAqIHRoaXMubGluZUhlaWdodCAqIHRoaXMuaGVpZ2h0UmF0aW8pO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwLjUpXCI7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgY3VycmVudFksIHRoaXMuY2FudmFzV2lkdGgsIDIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWNvcmF0b3IucHJvdG90eXBlLmNvbXBlbnNhdGVGb2xkUm93cyA9IGZ1bmN0aW9uIChyb3csIGZvbGREYXRhKSB7XG4gICAgICAgIHZhciBjb21wZW5zYXRlRm9sZCA9IDA7XG4gICAgICAgIGlmIChmb2xkRGF0YSAmJiBmb2xkRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvbGREYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGREYXRhW2pdLnN0YXJ0LnJvdyAmJiByb3cgPCBmb2xkRGF0YVtqXS5lbmQucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBlbnNhdGVGb2xkICs9IHJvdyAtIGZvbGREYXRhW2pdLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93ID49IGZvbGREYXRhW2pdLmVuZC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGVuc2F0ZUZvbGQgKz0gZm9sZERhdGFbal0uZW5kLnJvdyAtIGZvbGREYXRhW2pdLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBlbnNhdGVGb2xkO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29yYXRvcjtcbn0oKSk7XG5vb3AuaW1wbGVtZW50KERlY29yYXRvci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLkRlY29yYXRvciA9IERlY29yYXRvcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9jb25maWdcIixcImFjZS9sYXllci9ndXR0ZXJcIixcImFjZS9sYXllci9tYXJrZXJcIixcImFjZS9sYXllci90ZXh0XCIsXCJhY2UvbGF5ZXIvY3Vyc29yXCIsXCJhY2Uvc2Nyb2xsYmFyXCIsXCJhY2Uvc2Nyb2xsYmFyXCIsXCJhY2Uvc2Nyb2xsYmFyX2N1c3RvbVwiLFwiYWNlL3Njcm9sbGJhcl9jdXN0b21cIixcImFjZS9yZW5kZXJsb29wXCIsXCJhY2UvbGF5ZXIvZm9udF9tZXRyaWNzXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9jc3MvZWRpdG9yLWNzc1wiLFwiYWNlL2xheWVyL2RlY29yYXRvcnNcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbGF5ZXIvdGV4dF91dGlsXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIEd1dHRlckxheWVyID0gcmVxdWlyZShcIi4vbGF5ZXIvZ3V0dGVyXCIpLkd1dHRlcjtcbnZhciBNYXJrZXJMYXllciA9IHJlcXVpcmUoXCIuL2xheWVyL21hcmtlclwiKS5NYXJrZXI7XG52YXIgVGV4dExheWVyID0gcmVxdWlyZShcIi4vbGF5ZXIvdGV4dFwiKS5UZXh0O1xudmFyIEN1cnNvckxheWVyID0gcmVxdWlyZShcIi4vbGF5ZXIvY3Vyc29yXCIpLkN1cnNvcjtcbnZhciBIU2Nyb2xsQmFyID0gcmVxdWlyZShcIi4vc2Nyb2xsYmFyXCIpLkhTY3JvbGxCYXI7XG52YXIgVlNjcm9sbEJhciA9IHJlcXVpcmUoXCIuL3Njcm9sbGJhclwiKS5WU2Nyb2xsQmFyO1xudmFyIEhTY3JvbGxCYXJDdXN0b20gPSByZXF1aXJlKFwiLi9zY3JvbGxiYXJfY3VzdG9tXCIpLkhTY3JvbGxCYXI7XG52YXIgVlNjcm9sbEJhckN1c3RvbSA9IHJlcXVpcmUoXCIuL3Njcm9sbGJhcl9jdXN0b21cIikuVlNjcm9sbEJhcjtcbnZhciBSZW5kZXJMb29wID0gcmVxdWlyZShcIi4vcmVuZGVybG9vcFwiKS5SZW5kZXJMb29wO1xudmFyIEZvbnRNZXRyaWNzID0gcmVxdWlyZShcIi4vbGF5ZXIvZm9udF9tZXRyaWNzXCIpLkZvbnRNZXRyaWNzO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBlZGl0b3JDc3MgPSByZXF1aXJlKFwiLi9jc3MvZWRpdG9yLWNzc1wiKTtcbnZhciBEZWNvcmF0b3IgPSByZXF1aXJlKFwiLi9sYXllci9kZWNvcmF0b3JzXCIpLkRlY29yYXRvcjtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIGlzVGV4dFRva2VuID0gcmVxdWlyZShcIi4vbGF5ZXIvdGV4dF91dGlsXCIpLmlzVGV4dFRva2VuO1xuZG9tLmltcG9ydENzc1N0cmluZyhlZGl0b3JDc3MsIFwiYWNlX2VkaXRvci5jc3NcIiwgZmFsc2UpO1xudmFyIFZpcnR1YWxSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaXJ0dWFsUmVuZGVyZXIoY29udGFpbmVyLCB0aGVtZSkge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9lZGl0b3JcIik7XG4gICAgICAgIGlmIChkb20uSElfRFBJKVxuICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9oaWRwaVwiKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIGlmIChjb25maWcuZ2V0KFwidXNlU3RyaWN0Q1NQXCIpID09IG51bGwpXG4gICAgICAgICAgICBjb25maWcuc2V0KFwidXNlU3RyaWN0Q1NQXCIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy4kZ3V0dGVyID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuJGd1dHRlci5jbGFzc05hbWUgPSBcImFjZV9ndXR0ZXJcIjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kZ3V0dGVyKTtcbiAgICAgICAgdGhpcy4kZ3V0dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlciA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbGVyLmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGVyXCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsZXIpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5jb250ZW50LmNsYXNzTmFtZSA9IFwiYWNlX2NvbnRlbnRcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxlci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllciA9IG5ldyBHdXR0ZXJMYXllcih0aGlzLiRndXR0ZXIpO1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5vbihcImNoYW5nZUd1dHRlcldpZHRoXCIsIHRoaXMub25HdXR0ZXJSZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuJG1hcmtlckJhY2sgPSBuZXcgTWFya2VyTGF5ZXIodGhpcy5jb250ZW50KTtcbiAgICAgICAgdmFyIHRleHRMYXllciA9IHRoaXMuJHRleHRMYXllciA9IG5ldyBUZXh0TGF5ZXIodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0ZXh0TGF5ZXIuZWxlbWVudDtcbiAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQgPSBuZXcgTWFya2VyTGF5ZXIodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIgPSBuZXcgQ3Vyc29yTGF5ZXIodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy4kaG9yaXpTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kdlNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjcm9sbEJhciA9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYgPSBuZXcgVlNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFySCA9IG5ldyBIU2Nyb2xsQmFyKHRoaXMuY29udGFpbmVyLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJWLm9uKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIV9zZWxmLiRzY3JvbGxBbmltYXRpb24pXG4gICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoZS5kYXRhIC0gX3NlbGYuc2Nyb2xsTWFyZ2luLnRvcCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbEJhckgub24oXCJzY3JvbGxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbExlZnQoZS5kYXRhIC0gX3NlbGYuc2Nyb2xsTWFyZ2luLmxlZnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHtcbiAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgIGNvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiRmb250TWV0cmljcyA9IG5ldyBGb250TWV0cmljcyh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJHRleHRMYXllci4kc2V0Rm9udE1ldHJpY3ModGhpcy4kZm9udE1ldHJpY3MpO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIub24oXCJjaGFuZ2VDaGFyYWN0ZXJTaXplXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfc2VsZi51cGRhdGVDaGFyYWN0ZXJTaXplKCk7XG4gICAgICAgICAgICBfc2VsZi5vblJlc2l6ZSh0cnVlLCBfc2VsZi5ndXR0ZXJXaWR0aCwgX3NlbGYuJHNpemUud2lkdGgsIF9zZWxmLiRzaXplLmhlaWdodCk7XG4gICAgICAgICAgICBfc2VsZi5fc2lnbmFsKFwiY2hhbmdlQ2hhcmFjdGVyU2l6ZVwiLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJHNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0OiAwLFxuICAgICAgICAgICAgc2Nyb2xsZXJXaWR0aDogMCxcbiAgICAgICAgICAgICRkaXJ0eTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxheWVyQ29uZmlnID0ge1xuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgZmlyc3RSb3c6IDAsXG4gICAgICAgICAgICBmaXJzdFJvd1NjcmVlbjogMCxcbiAgICAgICAgICAgIGxhc3RSb3c6IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAwLFxuICAgICAgICAgICAgY2hhcmFjdGVyV2lkdGg6IDAsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IDEsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IDEsXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICBndXR0ZXJPZmZzZXQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxNYXJnaW4gPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICB2OiAwLFxuICAgICAgICAgICAgaDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcmdpbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIHY6IDAsXG4gICAgICAgICAgICBoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID0gIXVzZXJhZ2VudC5pc0lPUztcbiAgICAgICAgdGhpcy4kbG9vcCA9IG5ldyBSZW5kZXJMb29wKHRoaXMuJHJlbmRlckNoYW5nZXMuYmluZCh0aGlzKSwgdGhpcy5jb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hhcmFjdGVyU2l6ZSgpO1xuICAgICAgICB0aGlzLnNldFBhZGRpbmcoNCk7XG4gICAgICAgIHRoaXMuJGFkZFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgICAgIGNvbmZpZy5yZXNldE9wdGlvbnModGhpcyk7XG4gICAgICAgIGNvbmZpZy5fc2lnbmFsKFwicmVuZGVyZXJcIiwgdGhpcyk7XG4gICAgfVxuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQ2hhcmFjdGVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHRleHRMYXllci5hbGxvd0JvbGRGb250cyAhPSB0aGlzLiRhbGxvd0JvbGRGb250cykge1xuICAgICAgICAgICAgdGhpcy4kYWxsb3dCb2xkRm9udHMgPSB0aGlzLiR0ZXh0TGF5ZXIuYWxsb3dCb2xkRm9udHM7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKFwiYWNlX25vYm9sZFwiLCAhdGhpcy4kYWxsb3dCb2xkRm9udHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJDb25maWcuY2hhcmFjdGVyV2lkdGggPVxuICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXJXaWR0aCA9IHRoaXMuJHRleHRMYXllci5nZXRDaGFyYWN0ZXJXaWR0aCgpO1xuICAgICAgICB0aGlzLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQgPVxuICAgICAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gdGhpcy4kdGV4dExheWVyLmdldExpbmVIZWlnaHQoKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTtcbiAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwibGluZS1oZWlnaHRcIiwgdGhpcy5saW5lSGVpZ2h0ICsgXCJweFwiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZG9jLm9mZihcImNoYW5nZU5ld0xpbmVNb2RlXCIsIHRoaXMub25DaGFuZ2VOZXdMaW5lTW9kZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uICYmIHRoaXMuc2Nyb2xsTWFyZ2luLnRvcCAmJiBzZXNzaW9uLmdldFNjcm9sbFRvcCgpIDw9IDApXG4gICAgICAgICAgICBzZXNzaW9uLnNldFNjcm9sbFRvcCgtdGhpcy5zY3JvbGxNYXJnaW4udG9wKTtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB0aGlzLnNlc3Npb24uJHNldEZvbnRNZXRyaWNzKHRoaXMuJGZvbnRNZXRyaWNzKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJILnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbEJhclYuc2Nyb2xsVG9wID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlID0gdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VOZXdMaW5lTW9kZSgpO1xuICAgICAgICB0aGlzLnNlc3Npb24uZG9jLm9uKFwiY2hhbmdlTmV3TGluZU1vZGVcIiwgdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlTGluZXMgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3csIGZvcmNlKSB7XG4gICAgICAgIGlmIChsYXN0Um93ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBsYXN0Um93ID0gSW5maW5pdHk7XG4gICAgICAgIGlmICghdGhpcy4kY2hhbmdlZExpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMgPSB7XG4gICAgICAgICAgICAgICAgZmlyc3RSb3c6IGZpcnN0Um93LFxuICAgICAgICAgICAgICAgIGxhc3RSb3c6IGxhc3RSb3dcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kY2hhbmdlZExpbmVzLmZpcnN0Um93ID4gZmlyc3RSb3cpXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzLmZpcnN0Um93ID0gZmlyc3RSb3c7XG4gICAgICAgICAgICBpZiAodGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPCBsYXN0Um93KVxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZWRMaW5lcy5sYXN0Um93ID0gbGFzdFJvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPCB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93KSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UpXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPSB0aGlzLmxheWVyQ29uZmlnLmxhc3RSb3c7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3cgPiB0aGlzLmxheWVyQ29uZmlnLmxhc3RSb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfTElORVMpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5vbkNoYW5nZU5ld0xpbmVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQpO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuJHVwZGF0ZUVvbENoYXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5zZXRFb2xDaGFyKHRoaXMuJHRleHRMYXllci5FT0xfQ0hBUik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLm9uQ2hhbmdlVGFiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9URVhUIHwgdGhpcy5DSEFOR0VfTUFSS0VSKTtcbiAgICAgICAgdGhpcy4kdGV4dExheWVyLm9uQ2hhbmdlVGFiU2l6ZSgpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVGdWxsID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSlcbiAgICAgICAgICAgIHRoaXMuJHJlbmRlckNoYW5nZXModGhpcy5DSEFOR0VfRlVMTCwgdHJ1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUZvbnRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuY2hlY2tGb3JTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlU2l6ZUFzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kbG9vcC5wZW5kaW5nKVxuICAgICAgICAgICAgdGhpcy4kc2l6ZS4kZGlydHkgPSB0cnVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGZvcmNlLCBndXR0ZXJXaWR0aCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemluZyA+IDIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXppbmcgPiAwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemluZysrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnJlc2l6aW5nID0gZm9yY2UgPyAxIDogMDtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICghaGVpZ2h0KVxuICAgICAgICAgICAgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0IHx8IGVsLnNjcm9sbEhlaWdodDtcbiAgICAgICAgaWYgKCFoZWlnaHQgJiYgdGhpcy4kbWF4TGluZXMgJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSkge1xuICAgICAgICAgICAgaWYgKCFlbC5zdHlsZS5oZWlnaHQgfHwgZWwuc3R5bGUuaGVpZ2h0ID09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodCB8fCBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aWR0aClcbiAgICAgICAgICAgIHdpZHRoID0gZWwuY2xpZW50V2lkdGggfHwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZShmb3JjZSwgZ3V0dGVyV2lkdGgsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy4kcmVzaXplVGltZXIpXG4gICAgICAgICAgICB0aGlzLiRyZXNpemVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgaWYgKCF0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IHx8ICghd2lkdGggJiYgIWhlaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNpemluZyA9IDA7XG4gICAgICAgIGlmIChmb3JjZSlcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLiRwYWRkaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKGZvcmNlKVxuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2hhbmdlcyhjaGFuZ2VzIHwgdGhpcy4kY2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUoY2hhbmdlcyB8IHRoaXMuJGNoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemluZylcbiAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEJhckguc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQmFyVi5zY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy4kY3VzdG9tU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVDdXN0b21TY3JvbGxiYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJHVwZGF0ZUNhY2hlZFNpemUgPSBmdW5jdGlvbiAoZm9yY2UsIGd1dHRlcldpZHRoLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodCAtPSAodGhpcy4kZXh0cmFIZWlnaHQgfHwgMCk7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gMDtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLiRzaXplO1xuICAgICAgICB2YXIgb2xkU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0OiBzaXplLnNjcm9sbGVySGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsZXJXaWR0aDogc2l6ZS5zY3JvbGxlcldpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWlnaHQgJiYgKGZvcmNlIHx8IHNpemUuaGVpZ2h0ICE9IGhlaWdodCkpIHtcbiAgICAgICAgICAgIHNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLkNIQU5HRV9TSVpFO1xuICAgICAgICAgICAgc2l6ZS5zY3JvbGxlckhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHRoaXMuJGhvcml6U2Nyb2xsKVxuICAgICAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJIZWlnaHQgLT0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLnNldEhlaWdodChzaXplLnNjcm9sbGVySGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5lbGVtZW50LnN0eWxlLmJvdHRvbSA9IHRoaXMuc2Nyb2xsQmFySC5nZXRIZWlnaHQoKSArIFwicHhcIjtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHwgdGhpcy5DSEFOR0VfU0NST0xMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCAmJiAoZm9yY2UgfHwgc2l6ZS53aWR0aCAhPSB3aWR0aCkpIHtcbiAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy5DSEFOR0VfU0laRTtcbiAgICAgICAgICAgIHNpemUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGlmIChndXR0ZXJXaWR0aCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGd1dHRlcldpZHRoID0gdGhpcy4kc2hvd0d1dHRlciA/IHRoaXMuJGd1dHRlci5vZmZzZXRXaWR0aCA6IDA7XG4gICAgICAgICAgICB0aGlzLmd1dHRlcldpZHRoID0gZ3V0dGVyV2lkdGg7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5zY3JvbGxCYXJILmVsZW1lbnQuc3R5bGUsIFwibGVmdFwiLCBndXR0ZXJXaWR0aCArIFwicHhcIik7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5zY3JvbGxlci5zdHlsZSwgXCJsZWZ0XCIsIGd1dHRlcldpZHRoICsgdGhpcy5tYXJnaW4ubGVmdCArIFwicHhcIik7XG4gICAgICAgICAgICBzaXplLnNjcm9sbGVyV2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIGd1dHRlcldpZHRoIC0gdGhpcy5zY3JvbGxCYXJWLmdldFdpZHRoKCkgLSB0aGlzLm1hcmdpbi5oKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLiRndXR0ZXIuc3R5bGUsIFwibGVmdFwiLCB0aGlzLm1hcmdpbi5sZWZ0ICsgXCJweFwiKTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuc2Nyb2xsQmFyVi5nZXRXaWR0aCgpICsgXCJweFwiO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsQmFySC5lbGVtZW50LnN0eWxlLCBcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLnNjcm9sbGVyLnN0eWxlLCBcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLnNjcm9sbGVyLnN0eWxlLCBcImJvdHRvbVwiLCB0aGlzLnNjcm9sbEJhckguZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJILnNldFdpZHRoKHNpemUuc2Nyb2xsZXJXaWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi5nZXRVc2VXcmFwTW9kZSgpICYmIHRoaXMuYWRqdXN0V3JhcExpbWl0KCkgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzIHw9IHRoaXMuQ0hBTkdFX0ZVTEw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZS4kZGlydHkgPSAhd2lkdGggfHwgIWhlaWdodDtcbiAgICAgICAgaWYgKGNoYW5nZXMpXG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJyZXNpemVcIiwgb2xkU2l6ZSk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5vbkd1dHRlclJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICB2YXIgZ3V0dGVyV2lkdGggPSB0aGlzLiRzaG93R3V0dGVyID8gd2lkdGggOiAwO1xuICAgICAgICBpZiAoZ3V0dGVyV2lkdGggIT0gdGhpcy5ndXR0ZXJXaWR0aClcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgfD0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSh0cnVlLCBndXR0ZXJXaWR0aCwgdGhpcy4kc2l6ZS53aWR0aCwgdGhpcy4kc2l6ZS5oZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmdldFVzZVdyYXBNb2RlKCkgJiYgdGhpcy5hZGp1c3RXcmFwTGltaXQoKSkge1xuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRzaXplLiRkaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbXB1dGVMYXllckNvbmZpZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmFkanVzdFdyYXBMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIC0gdGhpcy4kcGFkZGluZyAqIDI7XG4gICAgICAgIHZhciBsaW1pdCA9IE1hdGguZmxvb3IoYXZhaWxhYmxlV2lkdGggLyB0aGlzLmNoYXJhY3RlcldpZHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5hZGp1c3RXcmFwTGltaXQobGltaXQsIHRoaXMuJHNob3dQcmludE1hcmdpbiAmJiB0aGlzLiRwcmludE1hcmdpbkNvbHVtbik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldEFuaW1hdGVkU2Nyb2xsID0gZnVuY3Rpb24gKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJhbmltYXRlZFNjcm9sbFwiLCBzaG91bGRBbmltYXRlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0QW5pbWF0ZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhbmltYXRlZFNjcm9sbDtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbiAoc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzaG93SW52aXNpYmxlc1wiLCBzaG93SW52aXNpYmxlcyk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuc2V0U2hvd0ludmlzaWJsZXMoc2hvd0ludmlzaWJsZXMpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaG93SW52aXNpYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwic2hvd0ludmlzaWJsZXNcIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImRpc3BsYXlJbmRlbnRHdWlkZXNcIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImRpc3BsYXlJbmRlbnRHdWlkZXNcIiwgZGlzcGxheSk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldEhpZ2hsaWdodEluZGVudEd1aWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiaGlnaGxpZ2h0SW5kZW50R3VpZGVzXCIpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRIaWdobGlnaHRJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiaGlnaGxpZ2h0SW5kZW50R3VpZGVzXCIsIGhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFNob3dQcmludE1hcmdpbiA9IGZ1bmN0aW9uIChzaG93UHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzaG93UHJpbnRNYXJnaW5cIiwgc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hvd1ByaW50TWFyZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJzaG93UHJpbnRNYXJnaW5cIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFByaW50TWFyZ2luQ29sdW1uID0gZnVuY3Rpb24gKHByaW50TWFyZ2luQ29sdW1uKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwicHJpbnRNYXJnaW5Db2x1bW5cIiwgcHJpbnRNYXJnaW5Db2x1bW4pO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRQcmludE1hcmdpbkNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwicHJpbnRNYXJnaW5Db2x1bW5cIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldFNob3dHdXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dHdXR0ZXJcIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFNob3dHdXR0ZXIgPSBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRPcHRpb24oXCJzaG93R3V0dGVyXCIsIHNob3cpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRGYWRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImZhZGVGb2xkV2lkZ2V0c1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0RmFkZUZvbGRXaWRnZXRzID0gZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJmYWRlRm9sZFdpZGdldHNcIiwgc2hvdyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodEd1dHRlckxpbmUgPSBmdW5jdGlvbiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiaGlnaGxpZ2h0R3V0dGVyTGluZVwiLCBzaG91bGRIaWdobGlnaHQpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRHdXR0ZXJMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJoaWdobGlnaHRHdXR0ZXJMaW5lXCIpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlUHJpbnRNYXJnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kc2hvd1ByaW50TWFyZ2luICYmICF0aGlzLiRwcmludE1hcmdpbkVsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuJHByaW50TWFyZ2luRWwpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgY29udGFpbmVyRWwuY2xhc3NOYW1lID0gXCJhY2VfbGF5ZXIgYWNlX3ByaW50LW1hcmdpbi1sYXllclwiO1xuICAgICAgICAgICAgdGhpcy4kcHJpbnRNYXJnaW5FbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy4kcHJpbnRNYXJnaW5FbC5jbGFzc05hbWUgPSBcImFjZV9wcmludC1tYXJnaW5cIjtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHRoaXMuJHByaW50TWFyZ2luRWwpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50Lmluc2VydEJlZm9yZShjb250YWluZXJFbCwgdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuJHByaW50TWFyZ2luRWwuc3R5bGU7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBNYXRoLnJvdW5kKHRoaXMuY2hhcmFjdGVyV2lkdGggKiB0aGlzLiRwcmludE1hcmdpbkNvbHVtbiArIHRoaXMuJHBhZGRpbmcpICsgXCJweFwiO1xuICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gdGhpcy4kc2hvd1ByaW50TWFyZ2luID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi4kd3JhcCA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0V3JhcExpbWl0KCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldENvbnRhaW5lckVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TW91c2VFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsZXI7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldFRleHRBcmVhQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiRtb3ZlVGV4dEFyZWFUb0N1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnRleHRhcmVhLnN0eWxlO1xuICAgICAgICB2YXIgY29tcG9zaXRpb24gPSB0aGlzLiRjb21wb3NpdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLiRrZWVwVGV4dEFyZWFBdEN1cnNvciAmJiAhY29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGRvbS50cmFuc2xhdGUodGhpcy50ZXh0YXJlYSwgLTEwMCwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpeGVsUG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuJHBpeGVsUG9zO1xuICAgICAgICBpZiAoIXBpeGVsUG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ubWFya2VyUmFuZ2UpXG4gICAgICAgICAgICBwaXhlbFBvcyA9IHRoaXMuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oY29tcG9zaXRpb24ubWFya2VyUmFuZ2Uuc3RhcnQsIHRydWUpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcbiAgICAgICAgdmFyIHBvc1RvcCA9IHBpeGVsUG9zLnRvcDtcbiAgICAgICAgdmFyIHBvc0xlZnQgPSBwaXhlbFBvcy5sZWZ0O1xuICAgICAgICBwb3NUb3AgLT0gY29uZmlnLm9mZnNldDtcbiAgICAgICAgdmFyIGggPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi51c2VUZXh0YXJlYUZvcklNRSB8fCB1c2VyYWdlbnQuaXNNb2JpbGUgPyB0aGlzLmxpbmVIZWlnaHQgOiAxO1xuICAgICAgICBpZiAocG9zVG9wIDwgMCB8fCBwb3NUb3AgPiBjb25maWcuaGVpZ2h0IC0gaCkge1xuICAgICAgICAgICAgZG9tLnRyYW5zbGF0ZSh0aGlzLnRleHRhcmVhLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdyA9IDE7XG4gICAgICAgIHZhciBtYXhUb3AgPSB0aGlzLiRzaXplLmhlaWdodCAtIGg7XG4gICAgICAgIGlmICghY29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvc1RvcCArPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy50ZXh0YXJlYS52YWx1ZTtcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5jaGFyYWN0ZXJXaWR0aCAqICh0aGlzLnNlc3Npb24uJGdldFN0cmluZ1NjcmVlbldpZHRoKHZhbClbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zVG9wICs9IHRoaXMubGluZUhlaWdodCArIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zTGVmdCAtPSB0aGlzLnNjcm9sbExlZnQ7XG4gICAgICAgIGlmIChwb3NMZWZ0ID4gdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIC0gdylcbiAgICAgICAgICAgIHBvc0xlZnQgPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB3O1xuICAgICAgICBwb3NMZWZ0ICs9IHRoaXMuZ3V0dGVyV2lkdGggKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICBkb20uc2V0U3R5bGUoc3R5bGUsIFwiaGVpZ2h0XCIsIGggKyBcInB4XCIpO1xuICAgICAgICBkb20uc2V0U3R5bGUoc3R5bGUsIFwid2lkdGhcIiwgdyArIFwicHhcIik7XG4gICAgICAgIGRvbS50cmFuc2xhdGUodGhpcy50ZXh0YXJlYSwgTWF0aC5taW4ocG9zTGVmdCwgdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIC0gdyksIE1hdGgubWluKHBvc1RvcCwgbWF4VG9wKSk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldEZpcnN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3c7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldEZpcnN0RnVsbHlWaXNpYmxlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdyArICh0aGlzLmxheWVyQ29uZmlnLm9mZnNldCA9PT0gMCA/IDAgOiAxKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFzdEZ1bGx5VmlzaWJsZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG4gICAgICAgIHZhciBsYXN0Um93ID0gY29uZmlnLmxhc3RSb3c7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhsYXN0Um93LCAwKSAqIGNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICBpZiAodG9wIC0gdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpID4gY29uZmlnLmhlaWdodCAtIGNvbmZpZy5saW5lSGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSb3cgLSAxO1xuICAgICAgICByZXR1cm4gbGFzdFJvdztcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFzdFZpc2libGVSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyQ29uZmlnLmxhc3RSb3c7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgdGhpcy4kdGV4dExheWVyLnNldFBhZGRpbmcocGFkZGluZyk7XG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnNldFBhZGRpbmcocGFkZGluZyk7XG4gICAgICAgIHRoaXMuJG1hcmtlckZyb250LnNldFBhZGRpbmcocGFkZGluZyk7XG4gICAgICAgIHRoaXMuJG1hcmtlckJhY2suc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0U2Nyb2xsTWFyZ2luID0gZnVuY3Rpb24gKHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc20gPSB0aGlzLnNjcm9sbE1hcmdpbjtcbiAgICAgICAgc20udG9wID0gdG9wIHwgMDtcbiAgICAgICAgc20uYm90dG9tID0gYm90dG9tIHwgMDtcbiAgICAgICAgc20ucmlnaHQgPSByaWdodCB8IDA7XG4gICAgICAgIHNtLmxlZnQgPSBsZWZ0IHwgMDtcbiAgICAgICAgc20udiA9IHNtLnRvcCArIHNtLmJvdHRvbTtcbiAgICAgICAgc20uaCA9IHNtLmxlZnQgKyBzbS5yaWdodDtcbiAgICAgICAgaWYgKHNtLnRvcCAmJiB0aGlzLnNjcm9sbFRvcCA8PSAwICYmIHRoaXMuc2Vzc2lvbilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoLXNtLnRvcCk7XG4gICAgICAgIHRoaXMudXBkYXRlRnVsbCgpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRNYXJnaW4gPSBmdW5jdGlvbiAodG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBzbSA9IHRoaXMubWFyZ2luO1xuICAgICAgICBzbS50b3AgPSB0b3AgfCAwO1xuICAgICAgICBzbS5ib3R0b20gPSBib3R0b20gfCAwO1xuICAgICAgICBzbS5yaWdodCA9IHJpZ2h0IHwgMDtcbiAgICAgICAgc20ubGVmdCA9IGxlZnQgfCAwO1xuICAgICAgICBzbS52ID0gc20udG9wICsgc20uYm90dG9tO1xuICAgICAgICBzbS5oID0gc20ubGVmdCArIHNtLnJpZ2h0O1xuICAgICAgICB0aGlzLiR1cGRhdGVDYWNoZWRTaXplKHRydWUsIHRoaXMuZ3V0dGVyV2lkdGgsIHRoaXMuJHNpemUud2lkdGgsIHRoaXMuJHNpemUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy51cGRhdGVGdWxsKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldEhTY3JvbGxCYXJBbHdheXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaFNjcm9sbEJhckFsd2F5c1Zpc2libGU7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldEhTY3JvbGxCYXJBbHdheXNWaXNpYmxlID0gZnVuY3Rpb24gKGFsd2F5c1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZVwiLCBhbHdheXNWaXNpYmxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0VlNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0VlNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbiAoYWx3YXlzVmlzaWJsZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInZTY3JvbGxCYXJBbHdheXNWaXNpYmxlXCIsIGFsd2F5c1Zpc2libGUpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlU2Nyb2xsQmFyViA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMubGF5ZXJDb25maWcubWF4SGVpZ2h0O1xuICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0O1xuICAgICAgICBpZiAoIXRoaXMuJG1heExpbmVzICYmIHRoaXMuJHNjcm9sbFBhc3RFbmQpIHtcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCAtPSAoc2Nyb2xsZXJIZWlnaHQgLSB0aGlzLmxpbmVIZWlnaHQpICogdGhpcy4kc2Nyb2xsUGFzdEVuZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCA+IHNjcm9sbEhlaWdodCAtIHNjcm9sbGVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5zY3JvbGxUb3AgKyBzY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2Nyb2xsVG9wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0U2Nyb2xsSGVpZ2h0KHNjcm9sbEhlaWdodCArIHRoaXMuc2Nyb2xsTWFyZ2luLnYpO1xuICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0U2Nyb2xsVG9wKHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5zY3JvbGxNYXJnaW4udG9wKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJHVwZGF0ZVNjcm9sbEJhckggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFySC5zZXRTY3JvbGxXaWR0aCh0aGlzLmxheWVyQ29uZmlnLndpZHRoICsgMiAqIHRoaXMuJHBhZGRpbmcgKyB0aGlzLnNjcm9sbE1hcmdpbi5oKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJILnNldFNjcm9sbExlZnQodGhpcy5zY3JvbGxMZWZ0ICsgdGhpcy5zY3JvbGxNYXJnaW4ubGVmdCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kZnJvemVuID0gdHJ1ZTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudW5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGZyb3plbiA9IGZhbHNlO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kcmVuZGVyQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy4kY2hhbmdlcykge1xuICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLiRjaGFuZ2VzO1xuICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdGhpcy5zZXNzaW9uIHx8ICF0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCB0aGlzLiRmcm96ZW4pIHx8ICghY2hhbmdlcyAmJiAhZm9yY2UpKSB7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VzIHw9IGNoYW5nZXM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHNpemUuJGRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VzIHw9IGNoYW5nZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblJlc2l6ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubGluZUhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLmNoZWNrRm9yU2l6ZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWwoXCJiZWZvcmVSZW5kZXJcIiwgY2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlcilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIudXBkYXRlQ2hhcmFjdGVyV2lkdGhzKHRoaXMuJGZvbnRNZXRyaWNzKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG4gICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfRlVMTCB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1NJWkUgfHxcbiAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9URVhUIHx8XG4gICAgICAgICAgICBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfTElORVMgfHxcbiAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9TQ1JPTEwgfHxcbiAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9IX1NDUk9MTCkge1xuICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLiRjb21wdXRlTGF5ZXJDb25maWcoKSB8IHRoaXMuJGxvb3AuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuZmlyc3RSb3cgIT0gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdyAmJiBjb25maWcuZmlyc3RSb3dTY3JlZW4gPT0gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvd1NjcmVlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXMuc2Nyb2xsVG9wICsgKGNvbmZpZy5maXJzdFJvdyAtIE1hdGgubWF4KHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3csIDApKSAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHwgdGhpcy5DSEFOR0VfU0NST0xMO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzIHw9IHRoaXMuJGNvbXB1dGVMYXllckNvbmZpZygpIHwgdGhpcy4kbG9vcC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVTY3JvbGxCYXJWKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0hfU0NST0xMKVxuICAgICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVNjcm9sbEJhckgoKTtcbiAgICAgICAgICAgIGRvbS50cmFuc2xhdGUodGhpcy5jb250ZW50LCAtdGhpcy5zY3JvbGxMZWZ0LCAtY29uZmlnLm9mZnNldCk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjb25maWcud2lkdGggKyAyICogdGhpcy4kcGFkZGluZyArIFwicHhcIjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubWluSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuY29udGVudC5zdHlsZSwgXCJ3aWR0aFwiLCB3aWR0aCk7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5jb250ZW50LnN0eWxlLCBcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfSF9TQ1JPTEwpIHtcbiAgICAgICAgICAgIGRvbS50cmFuc2xhdGUodGhpcy5jb250ZW50LCAtdGhpcy5zY3JvbGxMZWZ0LCAtY29uZmlnLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmNsYXNzTmFtZSA9IHRoaXMuc2Nyb2xsTGVmdCA8PSAwID8gXCJhY2Vfc2Nyb2xsZXIgXCIgOiBcImFjZV9zY3JvbGxlciBhY2Vfc2Nyb2xsLWxlZnQgXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVLZXlib2FyZEFjY2Vzc2liaWxpdHkpXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5jbGFzc05hbWUgKz0gdGhpcy5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfRlVMTCkge1xuICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1c3RvbVNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbERlY29yYXRvci4kdXBkYXRlRGVjb3JhdG9ycyhjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kbWFya2VyQmFjay51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJG1hcmtlckZyb250LnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJSZW5kZXJcIiwgY2hhbmdlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9TQ1JPTEwpIHtcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZWRMaW5lcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHwgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0xJTkVTKVxuICAgICAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuc2Nyb2xsTGluZXMoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9HVVRURVIgfHwgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0xJTkVTKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnNjcm9sbExpbmVzKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kY3VzdG9tU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yLiR1cGRhdGVEZWNvcmF0b3JzKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJCYWNrLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRjdXJzb3JMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJhZnRlclJlbmRlclwiLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZWRMaW5lcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2hvd0d1dHRlcilcbiAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjdXN0b21TY3JvbGxiYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxEZWNvcmF0b3IuJHVwZGF0ZURlY29yYXRvcnMoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfTElORVMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1cGRhdGVMaW5lcygpIHx8IChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfR1VUVEVSKSAmJiB0aGlzLiRzaG93R3V0dGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1c3RvbVNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbERlY29yYXRvci4kdXBkYXRlRGVjb3JhdG9ycyhjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9URVhUIHx8IGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9HVVRURVIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1c3RvbVNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbERlY29yYXRvci4kdXBkYXRlRGVjb3JhdG9ycyhjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9DVVJTT1IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRHdXR0ZXJMaW5lKVxuICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZUxpbmVIaWdobGlnaHQoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjdXN0b21TY3JvbGxiYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxEZWNvcmF0b3IuJHVwZGF0ZURlY29yYXRvcnMoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0NVUlNPUikge1xuICAgICAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgKHRoaXMuQ0hBTkdFX01BUktFUiB8IHRoaXMuQ0hBTkdFX01BUktFUl9GUk9OVCkpIHtcbiAgICAgICAgICAgIHRoaXMuJG1hcmtlckZyb250LnVwZGF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgKHRoaXMuQ0hBTkdFX01BUktFUiB8IHRoaXMuQ0hBTkdFX01BUktFUl9CQUNLKSkge1xuICAgICAgICAgICAgdGhpcy4kbWFya2VyQmFjay51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWwoXCJhZnRlclJlbmRlclwiLCBjaGFuZ2VzKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGF1dG9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxlbmd0aCgpICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy4kbWF4TGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBkZXNpcmVkSGVpZ2h0ID0gTWF0aC5taW4obWF4SGVpZ2h0LCBNYXRoLm1heCgodGhpcy4kbWluTGluZXMgfHwgMSkgKiB0aGlzLmxpbmVIZWlnaHQsIGhlaWdodCkpICsgdGhpcy5zY3JvbGxNYXJnaW4udiArICh0aGlzLiRleHRyYUhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKHRoaXMuJGhvcml6U2Nyb2xsKVxuICAgICAgICAgICAgZGVzaXJlZEhlaWdodCArPSB0aGlzLnNjcm9sbEJhckguZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGlmICh0aGlzLiRtYXhQaXhlbEhlaWdodCAmJiBkZXNpcmVkSGVpZ2h0ID4gdGhpcy4kbWF4UGl4ZWxIZWlnaHQpXG4gICAgICAgICAgICBkZXNpcmVkSGVpZ2h0ID0gdGhpcy4kbWF4UGl4ZWxIZWlnaHQ7XG4gICAgICAgIHZhciBoaWRlU2Nyb2xsYmFycyA9IGRlc2lyZWRIZWlnaHQgPD0gMiAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIHZTY3JvbGwgPSAhaGlkZVNjcm9sbGJhcnMgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0O1xuICAgICAgICBpZiAoZGVzaXJlZEhlaWdodCAhPSB0aGlzLmRlc2lyZWRIZWlnaHQgfHxcbiAgICAgICAgICAgIHRoaXMuJHNpemUuaGVpZ2h0ICE9IHRoaXMuZGVzaXJlZEhlaWdodCB8fCB2U2Nyb2xsICE9IHRoaXMuJHZTY3JvbGwpIHtcbiAgICAgICAgICAgIGlmICh2U2Nyb2xsICE9IHRoaXMuJHZTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR2U2Nyb2xsID0gdlNjcm9sbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0VmlzaWJsZSh2U2Nyb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ID0gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBkZXNpcmVkSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSh0cnVlLCB0aGlzLiRndXR0ZXJXaWR0aCwgdywgZGVzaXJlZEhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRIZWlnaHQgPSBkZXNpcmVkSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYXV0b3NpemVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGNvbXB1dGVMYXllckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzaXplID0gdGhpcy4kc2l6ZTtcbiAgICAgICAgdmFyIGhpZGVTY3JvbGxiYXJzID0gc2l6ZS5oZWlnaHQgPD0gMiAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIHNjcmVlbkxpbmVzID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxlbmd0aCgpO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gc2NyZWVuTGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBsb25nZXN0TGluZSA9IHRoaXMuJGdldExvbmdlc3RMaW5lKCk7XG4gICAgICAgIHZhciBob3JpelNjcm9sbCA9ICFoaWRlU2Nyb2xsYmFycyAmJiAodGhpcy4kaFNjcm9sbEJhckFsd2F5c1Zpc2libGUgfHxcbiAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJXaWR0aCAtIGxvbmdlc3RMaW5lIC0gMiAqIHRoaXMuJHBhZGRpbmcgPCAwKTtcbiAgICAgICAgdmFyIGhTY3JvbGxDaGFuZ2VkID0gdGhpcy4kaG9yaXpTY3JvbGwgIT09IGhvcml6U2Nyb2xsO1xuICAgICAgICBpZiAoaFNjcm9sbENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuJGhvcml6U2Nyb2xsID0gaG9yaXpTY3JvbGw7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0VmlzaWJsZShob3JpelNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZTY3JvbGxCZWZvcmUgPSB0aGlzLiR2U2Nyb2xsOyAvLyBhdXRvc2l6ZSBjYW4gY2hhbmdlIHZzY3JvbGwgdmFsdWUgaW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvIHVwZGF0ZSBsb25nZXN0TGluZVxuICAgICAgICBpZiAodGhpcy4kbWF4TGluZXMgJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSlcbiAgICAgICAgICAgIHRoaXMuJGF1dG9zaXplKCk7XG4gICAgICAgIHZhciBtaW5IZWlnaHQgPSBzaXplLnNjcm9sbGVySGVpZ2h0ICsgdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgc2Nyb2xsUGFzdEVuZCA9ICF0aGlzLiRtYXhMaW5lcyAmJiB0aGlzLiRzY3JvbGxQYXN0RW5kXG4gICAgICAgICAgICA/IChzaXplLnNjcm9sbGVySGVpZ2h0IC0gdGhpcy5saW5lSGVpZ2h0KSAqIHRoaXMuJHNjcm9sbFBhc3RFbmRcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgbWF4SGVpZ2h0ICs9IHNjcm9sbFBhc3RFbmQ7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2Nyb2xsTWFyZ2luO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKE1hdGgubWF4KC1zbS50b3AsIE1hdGgubWluKHRoaXMuc2Nyb2xsVG9wLCBtYXhIZWlnaHQgLSBzaXplLnNjcm9sbGVySGVpZ2h0ICsgc20uYm90dG9tKSkpO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdChNYXRoLm1heCgtc20ubGVmdCwgTWF0aC5taW4odGhpcy5zY3JvbGxMZWZ0LCBsb25nZXN0TGluZSArIDIgKiB0aGlzLiRwYWRkaW5nIC0gc2l6ZS5zY3JvbGxlcldpZHRoICsgc20ucmlnaHQpKSk7XG4gICAgICAgIHZhciB2U2Nyb2xsID0gIWhpZGVTY3JvbGxiYXJzICYmICh0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSB8fFxuICAgICAgICAgICAgc2l6ZS5zY3JvbGxlckhlaWdodCAtIG1heEhlaWdodCArIHNjcm9sbFBhc3RFbmQgPCAwIHx8IHRoaXMuc2Nyb2xsVG9wID4gc20udG9wKTtcbiAgICAgICAgdmFyIHZTY3JvbGxDaGFuZ2VkID0gdlNjcm9sbEJlZm9yZSAhPT0gdlNjcm9sbDtcbiAgICAgICAgaWYgKHZTY3JvbGxDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLiR2U2Nyb2xsID0gdlNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRWaXNpYmxlKHZTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnNjcm9sbFRvcCAlIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGxpbmVDb3VudCA9IE1hdGguY2VpbChtaW5IZWlnaHQgLyB0aGlzLmxpbmVIZWlnaHQpIC0gMTtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgodGhpcy5zY3JvbGxUb3AgLSBvZmZzZXQpIC8gdGhpcy5saW5lSGVpZ2h0KSk7XG4gICAgICAgIHZhciBsYXN0Um93ID0gZmlyc3RSb3cgKyBsaW5lQ291bnQ7XG4gICAgICAgIHZhciBmaXJzdFJvd1NjcmVlbiwgZmlyc3RSb3dIZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBmaXJzdFJvdyA9IHNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFJvdyhmaXJzdFJvdywgMCk7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHNlc3Npb24uZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xuICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgIGZpcnN0Um93ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Um93U2NyZWVuID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KGZpcnN0Um93LCAwKTtcbiAgICAgICAgZmlyc3RSb3dIZWlnaHQgPSBzZXNzaW9uLmdldFJvd0xlbmd0aChmaXJzdFJvdykgKiBsaW5lSGVpZ2h0O1xuICAgICAgICBsYXN0Um93ID0gTWF0aC5taW4oc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50Um93KGxhc3RSb3csIDApLCBzZXNzaW9uLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIG1pbkhlaWdodCA9IHNpemUuc2Nyb2xsZXJIZWlnaHQgKyBzZXNzaW9uLmdldFJvd0xlbmd0aChsYXN0Um93KSAqIGxpbmVIZWlnaHQgK1xuICAgICAgICAgICAgZmlyc3RSb3dIZWlnaHQ7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuc2Nyb2xsVG9wIC0gZmlyc3RSb3dTY3JlZW4gKiBsaW5lSGVpZ2h0O1xuICAgICAgICB2YXIgY2hhbmdlcyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxheWVyQ29uZmlnLndpZHRoICE9IGxvbmdlc3RMaW5lIHx8IGhTY3JvbGxDaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlcyA9IHRoaXMuQ0hBTkdFX0hfU0NST0xMO1xuICAgICAgICBpZiAoaFNjcm9sbENoYW5nZWQgfHwgdlNjcm9sbENoYW5nZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSh0cnVlLCB0aGlzLmd1dHRlcldpZHRoLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJzY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZFwiKTtcbiAgICAgICAgICAgIGlmICh2U2Nyb2xsQ2hhbmdlZClcbiAgICAgICAgICAgICAgICBsb25nZXN0TGluZSA9IHRoaXMuJGdldExvbmdlc3RMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllckNvbmZpZyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBsb25nZXN0TGluZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRoaXMuJHBhZGRpbmcsXG4gICAgICAgICAgICBmaXJzdFJvdzogZmlyc3RSb3csXG4gICAgICAgICAgICBmaXJzdFJvd1NjcmVlbjogZmlyc3RSb3dTY3JlZW4sXG4gICAgICAgICAgICBsYXN0Um93OiBsYXN0Um93LFxuICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgIGNoYXJhY3RlcldpZHRoOiB0aGlzLmNoYXJhY3RlcldpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiBtaW5IZWlnaHQsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgZ3V0dGVyT2Zmc2V0OiBsaW5lSGVpZ2h0ID8gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChvZmZzZXQgKyBzaXplLmhlaWdodCAtIHNpemUuc2Nyb2xsZXJIZWlnaHQpIC8gbGluZUhlaWdodCkpIDogMCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlcilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuc2V0Q29udGVudFdpZHRoKGxvbmdlc3RMaW5lIC0gdGhpcy4kcGFkZGluZyk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kY2hhbmdlZExpbmVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSB0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3c7XG4gICAgICAgIHZhciBsYXN0Um93ID0gdGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3c7XG4gICAgICAgIHRoaXMuJGNoYW5nZWRMaW5lcyA9IG51bGw7XG4gICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG4gICAgICAgIGlmIChmaXJzdFJvdyA+IGxheWVyQ29uZmlnLmxhc3RSb3cgKyAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSb3cgPCBsYXllckNvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Um93ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGxheWVyQ29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUobGF5ZXJDb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGVMaW5lcyhsYXllckNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGdldExvbmdlc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhckNvdW50ID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbldpZHRoKCk7XG4gICAgICAgIGlmICh0aGlzLnNob3dJbnZpc2libGVzICYmICF0aGlzLnNlc3Npb24uJHVzZVdyYXBNb2RlKVxuICAgICAgICAgICAgY2hhckNvdW50ICs9IDE7XG4gICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIgJiYgY2hhckNvdW50ID4gdGhpcy4kdGV4dExheWVyLk1BWF9MSU5FX0xFTkdUSClcbiAgICAgICAgICAgIGNoYXJDb3VudCA9IHRoaXMuJHRleHRMYXllci5NQVhfTElORV9MRU5HVEggKyAzMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aCAtIDIgKiB0aGlzLiRwYWRkaW5nLCBNYXRoLnJvdW5kKGNoYXJDb3VudCAqIHRoaXMuY2hhcmFjdGVyV2lkdGgpKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlRnJvbnRNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKHRydWUpKTtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9NQVJLRVJfRlJPTlQpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVCYWNrTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKCkpO1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX01BUktFUl9CQUNLKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYWRkR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uIChyb3csIGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5hZGRHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uIChyb3csIGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQnJlYWtwb2ludHMgPSBmdW5jdGlvbiAocm93cykge1xuICAgICAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9HVVRURVIpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyk7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfR1VUVEVSKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQ3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0NVUlNPUik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmhpZGVDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLmhpZGVDdXJzb3IoKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2hvd0N1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuc2hvd0N1cnNvcigpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IGZ1bmN0aW9uIChhbmNob3IsIGxlYWQsIG9mZnNldCkge1xuICAgICAgICB0aGlzLnNjcm9sbEN1cnNvckludG9WaWV3KGFuY2hvciwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zY3JvbGxDdXJzb3JJbnRvVmlldyhsZWFkLCBvZmZzZXQpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxDdXJzb3JJbnRvVmlldyA9IGZ1bmN0aW9uIChjdXJzb3IsIG9mZnNldCwgJHZpZXdNYXJnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGN1cnNvcik7XG4gICAgICAgIHZhciBuZXdMZWZ0ID0gcG9zLmxlZnQ7XG4gICAgICAgIHZhciBuZXdUb3AgPSBwb3MudG9wO1xuICAgICAgICB2YXIgdG9wTWFyZ2luID0gJHZpZXdNYXJnaW4gJiYgJHZpZXdNYXJnaW4udG9wIHx8IDA7XG4gICAgICAgIHZhciBib3R0b21NYXJnaW4gPSAkdmlld01hcmdpbiAmJiAkdmlld01hcmdpbi5ib3R0b20gfHwgMDtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy4kc3RvcEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRUb3AgPSB0aGlzLiRzY3JvbGxBbmltYXRpb24gPyB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgOiB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKGN1cnJlbnRUb3AgKyB0b3BNYXJnaW4gPiBuZXdUb3ApIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgJiYgY3VycmVudFRvcCArIHRvcE1hcmdpbiA+IG5ld1RvcCArIHRoaXMubGluZUhlaWdodClcbiAgICAgICAgICAgICAgICBuZXdUb3AgLT0gb2Zmc2V0ICogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgIGlmIChuZXdUb3AgPT09IDApXG4gICAgICAgICAgICAgICAgbmV3VG9wID0gLXRoaXMuc2Nyb2xsTWFyZ2luLnRvcDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AobmV3VG9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50VG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIGJvdHRvbU1hcmdpbiA8IG5ld1RvcCArIHRoaXMubGluZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCAmJiBjdXJyZW50VG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIGJvdHRvbU1hcmdpbiA8IG5ld1RvcCAtIHRoaXMubGluZUhlaWdodClcbiAgICAgICAgICAgICAgICBuZXdUb3AgKz0gb2Zmc2V0ICogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AobmV3VG9wICsgdGhpcy5saW5lSGVpZ2h0ICsgYm90dG9tTWFyZ2luIC0gdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgdHdvQ2hhcnNXaWR0aCA9IDIgKiB0aGlzLmxheWVyQ29uZmlnLmNoYXJhY3RlcldpZHRoO1xuICAgICAgICBpZiAobmV3TGVmdCAtIHR3b0NoYXJzV2lkdGggPCBjdXJyZW50TGVmdCkge1xuICAgICAgICAgICAgbmV3TGVmdCAtPSB0d29DaGFyc1dpZHRoO1xuICAgICAgICAgICAgaWYgKG5ld0xlZnQgPCB0aGlzLiRwYWRkaW5nICsgdHdvQ2hhcnNXaWR0aCkge1xuICAgICAgICAgICAgICAgIG5ld0xlZnQgPSAtdGhpcy5zY3JvbGxNYXJnaW4ubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KG5ld0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3TGVmdCArPSB0d29DaGFyc1dpZHRoO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWZ0ICsgdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIDwgbmV3TGVmdCArIHRoaXMuY2hhcmFjdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdChNYXRoLnJvdW5kKG5ld0xlZnQgKyB0aGlzLmNoYXJhY3RlcldpZHRoIC0gdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGVmdCA8PSB0aGlzLiRwYWRkaW5nICYmIG5ld0xlZnQgLSBjdXJyZW50TGVmdCA8IHRoaXMuY2hhcmFjdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3BSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcCAvIHRoaXMubGluZUhlaWdodDtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2Nyb2xsQm90dG9tUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcigodGhpcy5zY3JvbGxUb3AgKyB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0KSAvIHRoaXMubGluZUhlaWdodCkgLSAxKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2Nyb2xsVG9Sb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aocm93ICogdGhpcy5saW5lSGVpZ2h0KTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYWxpZ25DdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yLCBhbGlnbm1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJzb3IgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIGN1cnNvciA9IHsgcm93OiBjdXJzb3IsIGNvbHVtbjogMCB9O1xuICAgICAgICB2YXIgcG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICB2YXIgaCA9IHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgLSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwb3MudG9wIC0gaCAqIChhbGlnbm1lbnQgfHwgMCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGNhbGNTdGVwcyA9IGZ1bmN0aW9uIChmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbCA9IHRoaXMuU1RFUFM7XG4gICAgICAgIHZhciBzdGVwcyA9IFtdO1xuICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uICh0LCB4X21pbiwgZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBkeCAqIChNYXRoLnBvdyh0IC0gMSwgMykgKyAxKSArIHhfbWluO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKVxuICAgICAgICAgICAgc3RlcHMucHVzaChmdW5jKGkgLyB0aGlzLlNURVBTLCBmcm9tVmFsdWUsIHRvVmFsdWUgLSBmcm9tVmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHN0ZXBzO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb0xpbmUgPSBmdW5jdGlvbiAobGluZSwgY2VudGVyLCBhbmltYXRlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbih7IHJvdzogbGluZSwgY29sdW1uOiAwIH0pO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcG9zLnRvcDtcbiAgICAgICAgaWYgKGNlbnRlcilcbiAgICAgICAgICAgIG9mZnNldCAtPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGluaXRpYWxTY3JvbGwgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcChvZmZzZXQpO1xuICAgICAgICBpZiAoYW5pbWF0ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVTY3JvbGxpbmcoaW5pdGlhbFNjcm9sbCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlU2Nyb2xsaW5nID0gZnVuY3Rpb24gKGZyb21WYWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRvVmFsdWUgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKCF0aGlzLiRhbmltYXRlZFNjcm9sbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGZyb21WYWx1ZSA9PSB0b1ZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RlcHMgPSB0aGlzLiRzY3JvbGxBbmltYXRpb24uc3RlcHM7XG4gICAgICAgICAgICBpZiAob2xkU3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbVZhbHVlID0gb2xkU3RlcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSA9PSB0b1ZhbHVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBzID0gX3NlbGYuJGNhbGNTdGVwcyhmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICAgICAgICB0aGlzLiRzY3JvbGxBbmltYXRpb24gPSB7IGZyb206IGZyb21WYWx1ZSwgdG86IHRvVmFsdWUsIHN0ZXBzOiBzdGVwcyB9O1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuJHRpbWVyKTtcbiAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aoc3RlcHMuc2hpZnQoKSk7XG4gICAgICAgIF9zZWxmLnNlc3Npb24uJHNjcm9sbFRvcCA9IHRvVmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGVuZEFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIF9zZWxmLiR0aW1lciA9IGNsZWFySW50ZXJ2YWwoX3NlbGYuJHRpbWVyKTtcbiAgICAgICAgICAgIF9zZWxmLiRzY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgX3NlbGYuJHN0b3BBbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3NlbGYuJHN0b3BBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBlbmRBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV9zZWxmLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoX3NlbGYuJHRpbWVyKTtcbiAgICAgICAgICAgIGlmIChzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChzdGVwcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLiRzY3JvbGxUb3AgPSB0b1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi4kc2Nyb2xsVG9wID0gLTE7XG4gICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3AodG9WYWx1ZSk7XG4gICAgICAgICAgICAgICAgdG9WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTApO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb1kgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb1ggPSBmdW5jdGlvbiAoc2Nyb2xsTGVmdCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0ICE9PSBzY3JvbGxMZWZ0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9IX1NDUk9MTCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcCh5KTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbExlZnQoeCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNjcm9sbEJ5ID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIGRlbHRhWSAmJiB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKSArIGRlbHRhWSk7XG4gICAgICAgIGRlbHRhWCAmJiB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdCh0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpICsgZGVsdGFYKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuaXNTY3JvbGxhYmxlQnkgPSBmdW5jdGlvbiAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgaWYgKGRlbHRhWSA8IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpID49IDEgLSB0aGlzLnNjcm9sbE1hcmdpbi50b3ApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlbHRhWSA+IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodFxuICAgICAgICAgICAgLSB0aGlzLmxheWVyQ29uZmlnLm1heEhlaWdodCA8IC0xICsgdGhpcy5zY3JvbGxNYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChkZWx0YVggPCAwICYmIHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxMZWZ0KCkgPj0gMSAtIHRoaXMuc2Nyb2xsTWFyZ2luLmxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlbHRhWCA+IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbExlZnQoKSArIHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aFxuICAgICAgICAgICAgLSB0aGlzLmxheWVyQ29uZmlnLndpZHRoIDwgLTEgKyB0aGlzLnNjcm9sbE1hcmdpbi5yaWdodClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5waXhlbFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgY2FudmFzUG9zO1xuICAgICAgICBpZiAodGhpcy4kaGFzQ3NzVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgY2FudmFzUG9zID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy4kZm9udE1ldHJpY3MudHJhbnNmb3JtQ29vcmRpbmF0ZXMoW3gsIHldKTtcbiAgICAgICAgICAgIHggPSBwWzFdIC0gdGhpcy5ndXR0ZXJXaWR0aCAtIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgICAgICB5ID0gcFswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhc1BvcyA9IHRoaXMuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldFggPSB4ICsgdGhpcy5zY3JvbGxMZWZ0IC0gY2FudmFzUG9zLmxlZnQgLSB0aGlzLiRwYWRkaW5nO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WCAvIHRoaXMuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh5ICsgdGhpcy5zY3JvbGxUb3AgLSBjYW52YXNQb3MudG9wKSAvIHRoaXMubGluZUhlaWdodCk7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLiRibG9ja0N1cnNvciA/IE1hdGguZmxvb3Iob2Zmc2V0KSA6IE1hdGgucm91bmQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHsgcm93OiByb3csIGNvbHVtbjogY29sLCBzaWRlOiBvZmZzZXQgLSBjb2wgPiAwID8gMSA6IC0xLCBvZmZzZXRYOiBvZmZzZXRYIH07XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGNhbnZhc1BvcztcbiAgICAgICAgaWYgKHRoaXMuJGhhc0Nzc1RyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgIGNhbnZhc1BvcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuJGZvbnRNZXRyaWNzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKFt4LCB5XSk7XG4gICAgICAgICAgICB4ID0gcFsxXSAtIHRoaXMuZ3V0dGVyV2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICAgICAgeSA9IHBbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW52YXNQb3MgPSB0aGlzLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXRYID0geCArIHRoaXMuc2Nyb2xsTGVmdCAtIGNhbnZhc1Bvcy5sZWZ0IC0gdGhpcy4kcGFkZGluZztcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFggLyB0aGlzLmNoYXJhY3RlcldpZHRoO1xuICAgICAgICB2YXIgY29sID0gdGhpcy4kYmxvY2tDdXJzb3IgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLnJvdW5kKG9mZnNldCk7XG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh5ICsgdGhpcy5zY3JvbGxUb3AgLSBjYW52YXNQb3MudG9wKSAvIHRoaXMubGluZUhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHJvdywgTWF0aC5tYXgoY29sLCAwKSwgb2Zmc2V0WCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnRleHRUb1NjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgICAgIHZhciB4ID0gdGhpcy4kcGFkZGluZyArICh0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLmlzQmlkaVJvdyhwb3Mucm93LCByb3cpXG4gICAgICAgICAgICA/IHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuZ2V0UG9zTGVmdChwb3MuY29sdW1uKVxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHBvcy5jb2x1bW4gKiB0aGlzLmNoYXJhY3RlcldpZHRoKSk7XG4gICAgICAgIHZhciB5ID0gcG9zLnJvdyAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZ2VYOiBjYW52YXNQb3MubGVmdCArIHggLSB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBwYWdlWTogY2FudmFzUG9zLnRvcCArIHkgLSB0aGlzLnNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS52aXN1YWxpemVGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9mb2N1c1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudmlzdWFsaXplQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9mb2N1c1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2hvd0NvbXBvc2l0aW9uID0gZnVuY3Rpb24gKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuJGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb247XG4gICAgICAgIGlmICghY29tcG9zaXRpb24uY3NzVGV4dCkge1xuICAgICAgICAgICAgY29tcG9zaXRpb24uY3NzVGV4dCA9IHRoaXMudGV4dGFyZWEuc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUgPSB0aGlzLiR1c2VUZXh0YXJlYUZvcklNRTtcbiAgICAgICAgaWYgKHRoaXMuJHVzZVRleHRhcmVhRm9ySU1FKSB7XG4gICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy50ZXh0YXJlYSwgXCJhY2VfY29tcG9zaXRpb25cIik7XG4gICAgICAgICAgICB0aGlzLnRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckxheWVyLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcG9zaXRpb24ubWFya2VySWQgPSB0aGlzLnNlc3Npb24uYWRkTWFya2VyKGNvbXBvc2l0aW9uLm1hcmtlclJhbmdlLCBcImFjZV9jb21wb3NpdGlvbl9tYXJrZXJcIiwgXCJ0ZXh0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldENvbXBvc2l0aW9uVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvcjtcbiAgICAgICAgdGhpcy5hZGRUb2tlbih0ZXh0LCBcImNvbXBvc2l0aW9uX3BsYWNlaG9sZGVyXCIsIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5oaWRlQ29tcG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kY29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLiRjb21wb3NpdGlvbi5tYXJrZXJJZClcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIodGhpcy4kY29tcG9zaXRpb24ubWFya2VySWQpO1xuICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy50ZXh0YXJlYSwgXCJhY2VfY29tcG9zaXRpb25cIik7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9IHRoaXMuJGNvbXBvc2l0aW9uLmNzc1RleHQ7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvcjtcbiAgICAgICAgdGhpcy5yZW1vdmVFeHRyYVRva2VuKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB0aGlzLiRjb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldEdob3N0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5zZXNzaW9uLnNlbGVjdGlvbi5jdXJzb3I7XG4gICAgICAgIHZhciBpbnNlcnRQb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHsgcm93OiBjdXJzb3Iucm93LCBjb2x1bW46IGN1cnNvci5jb2x1bW4gfTtcbiAgICAgICAgdGhpcy5yZW1vdmVHaG9zdFRleHQoKTtcbiAgICAgICAgdmFyIHRleHRDaHVua3MgPSB0aGlzLiRjYWxjdWxhdGVXcmFwcGVkVGV4dENodW5rcyh0ZXh0LCBpbnNlcnRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYWRkVG9rZW4odGV4dENodW5rc1swXS50ZXh0LCBcImdob3N0X3RleHRcIiwgaW5zZXJ0UG9zaXRpb24ucm93LCBpbnNlcnRQb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICB0aGlzLiRnaG9zdFRleHQgPSB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICByb3c6IGluc2VydFBvc2l0aW9uLnJvdyxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluc2VydFBvc2l0aW9uLmNvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgd2lkZ2V0RGl2ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0ZXh0Q2h1bmtzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBoaWRkZW5Ub2tlbnMgPSB0aGlzLmhpZGVUb2tlbnNBZnRlclBvc2l0aW9uKGluc2VydFBvc2l0aW9uLnJvdywgaW5zZXJ0UG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBsYXN0TGluZURpdjtcbiAgICAgICAgICAgIHRleHRDaHVua3Muc2xpY2UoMSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtEaXYgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtTcGFuID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIGNodW5rU3Bhbi5jbGFzc05hbWUgPSBcImFjZV9naG9zdF90ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKGVsLndyYXBwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNodW5rRGl2LmNsYXNzTmFtZSA9IFwiZ2hvc3RfdGV4dF9saW5lX3dyYXBwZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAoZWwudGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHQgPSBcIiBcIjtcbiAgICAgICAgICAgICAgICBjaHVua1NwYW4uYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZVRleHROb2RlKGVsLnRleHQpKTtcbiAgICAgICAgICAgICAgICBjaHVua0Rpdi5hcHBlbmRDaGlsZChjaHVua1NwYW4pO1xuICAgICAgICAgICAgICAgIHdpZGdldERpdi5hcHBlbmRDaGlsZChjaHVua0Rpdik7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVEaXYgPSBjaHVua0RpdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGlkZGVuVG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RleHRUb2tlbih0b2tlbi50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9cIiArIHRva2VuLnR5cGUucmVwbGFjZSgvXFwuL2csIFwiIGFjZV9cIik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb20uY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZURpdi5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kZ2hvc3RUZXh0V2lkZ2V0ID0ge1xuICAgICAgICAgICAgICAgIGVsOiB3aWRnZXREaXYsXG4gICAgICAgICAgICAgICAgcm93OiBpbnNlcnRQb3NpdGlvbi5yb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbnNlcnRQb3NpdGlvbi5jb2x1bW4sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImFjZV9naG9zdF90ZXh0X2NvbnRhaW5lclwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLndpZGdldE1hbmFnZXIuYWRkTGluZVdpZGdldCh0aGlzLiRnaG9zdFRleHRXaWRnZXQpO1xuICAgICAgICAgICAgdmFyIHBpeGVsUG9zaXRpb24gPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGluc2VydFBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBnaG9zdFRleHRIZWlnaHQgPSB0ZXh0Q2h1bmtzLmxlbmd0aCAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgICAgIHZhciBmaXRzWSA9IGdob3N0VGV4dEhlaWdodCA8IChoZWlnaHQgLSBwaXhlbFBvc2l0aW9uLnRvcCk7XG4gICAgICAgICAgICBpZiAoZml0c1kpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGdob3N0VGV4dEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoMCwgKHRleHRDaHVua3MubGVuZ3RoIC0gMSkgKiB0aGlzLmxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1JvdyhpbnNlcnRQb3NpdGlvbi5yb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiRjYWxjdWxhdGVXcmFwcGVkVGV4dENodW5rcyA9IGZ1bmN0aW9uICh0ZXh0LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB0aGlzLiRwYWRkaW5nICogMjtcbiAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5mbG9vcihhdmFpbGFibGVXaWR0aCAvIHRoaXMuY2hhcmFjdGVyV2lkdGgpIC0gMjtcbiAgICAgICAgbGltaXQgPSBsaW1pdCA8PSAwID8gNjAgOiBsaW1pdDsgLy8gdGhpcyBpcyBhIGhhY2sgdG8gcHJldmVudCB0aGUgZWRpdG9yIGZyb20gY3Jhc2hpbmcgd2hlbiB0aGUgd2luZG93IGlzIHRvbyBzbWFsbFxuICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICB2YXIgdGV4dENodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlUb2tlbnMgPSB0aGlzLnNlc3Npb24uJGdldERpc3BsYXlUb2tlbnModGV4dExpbmVzW2ldLCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICAgICAgdmFyIHdyYXBTcGxpdHMgPSB0aGlzLnNlc3Npb24uJGNvbXB1dGVXcmFwU3BsaXRzKGRpc3BsYXlUb2tlbnMsIGxpbWl0LCB0aGlzLnNlc3Npb24uJHRhYlNpemUpO1xuICAgICAgICAgICAgaWYgKHdyYXBTcGxpdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgd3JhcFNwbGl0cy5wdXNoKHRleHRMaW5lc1tpXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd3JhcFNwbGl0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dFNsaWNlID0gdGV4dExpbmVzW2ldLnNsaWNlKHN0YXJ0LCB3cmFwU3BsaXRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dENodW5rcy5wdXNoKHsgdGV4dDogdGV4dFNsaWNlLCB3cmFwcGVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHdyYXBTcGxpdHNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dENodW5rcy5wdXNoKHsgdGV4dDogdGV4dExpbmVzW2ldLCB3cmFwcGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dENodW5rcztcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlR2hvc3RUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGdob3N0VGV4dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy4kZ2hvc3RUZXh0LnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnJlbW92ZUV4dHJhVG9rZW4ocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy4kZ2hvc3RUZXh0V2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ud2lkZ2V0TWFuYWdlci5yZW1vdmVMaW5lV2lkZ2V0KHRoaXMuJGdob3N0VGV4dFdpZGdldCk7XG4gICAgICAgICAgICB0aGlzLiRnaG9zdFRleHRXaWRnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGdob3N0VGV4dCA9IG51bGw7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmFkZFRva2VuID0gZnVuY3Rpb24gKHRleHQsIHR5cGUsIHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBzZXNzaW9uLmJnVG9rZW5pemVyLmxpbmVzW3Jvd10gPSBudWxsO1xuICAgICAgICB2YXIgbmV3VG9rZW4gPSB7IHR5cGU6IHR5cGUsIHZhbHVlOiB0ZXh0IH07XG4gICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICBpZiAoY29sdW1uID09IG51bGwgfHwgIXRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ld1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgIGwgKz0gdG9rZW4udmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPD0gbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHRva2VuLnZhbHVlLmxlbmd0aCAtIChsIC0gY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRva2VuLnZhbHVlLnNsaWNlKDAsIGRpZmYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0b2tlbi52YWx1ZS5zbGljZShkaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxLCB7IHR5cGU6IHRva2VuLnR5cGUsIHZhbHVlOiBiZWZvcmUgfSwgbmV3VG9rZW4sIHsgdHlwZTogdG9rZW4udHlwZSwgdmFsdWU6IGFmdGVyIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVMaW5lcyhyb3csIHJvdyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmhpZGVUb2tlbnNBZnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XG4gICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgdmFyIGhhc1Bhc3NlZEN1cnNvciA9IGZhbHNlO1xuICAgICAgICB2YXIgaGlkZGVuVG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBsICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImdob3N0X3RleHRcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChoYXNQYXNzZWRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5Ub2tlbnMucHVzaCh7IHR5cGU6IHRva2VuLnR5cGUsIHZhbHVlOiB0b2tlbi52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJoaWRkZW5fdG9rZW5cIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBoYXNQYXNzZWRDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlTGluZXMocm93LCByb3cpO1xuICAgICAgICByZXR1cm4gaGlkZGVuVG9rZW5zO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVFeHRyYVRva2VuID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5iZ1Rva2VuaXplci5saW5lc1tyb3ddID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVMaW5lcyhyb3csIHJvdyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lLCBjYikge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiR0aGVtZUlkID0gdGhlbWU7XG4gICAgICAgIF9zZWxmLl9kaXNwYXRjaEV2ZW50KCd0aGVtZUNoYW5nZScsIHsgdGhlbWU6IHRoZW1lIH0pO1xuICAgICAgICBpZiAoIXRoZW1lIHx8IHR5cGVvZiB0aGVtZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IHRoZW1lIHx8IHRoaXMuJG9wdGlvbnMudGhlbWUuaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoW1widGhlbWVcIiwgbW9kdWxlTmFtZV0sIGFmdGVyTG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZnRlckxvYWQodGhlbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyTG9hZChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChfc2VsZi4kdGhlbWVJZCAhPSB0aGVtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIGlmICghbW9kdWxlIHx8ICFtb2R1bGUuY3NzQ2xhc3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgbG9hZCBtb2R1bGUgXCIgKyB0aGVtZSArIFwiIG9yIGl0IGRpZG4ndCBjYWxsIGRlZmluZVwiKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuJGlkKVxuICAgICAgICAgICAgICAgIF9zZWxmLiR0aGVtZUlkID0gbW9kdWxlLiRpZDtcbiAgICAgICAgICAgIGRvbS5pbXBvcnRDc3NTdHJpbmcobW9kdWxlLmNzc1RleHQsIG1vZHVsZS5jc3NDbGFzcywgX3NlbGYuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChfc2VsZi50aGVtZSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3MoX3NlbGYuY29udGFpbmVyLCBfc2VsZi50aGVtZS5jc3NDbGFzcyk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IFwicGFkZGluZ1wiIGluIG1vZHVsZSA/IG1vZHVsZS5wYWRkaW5nXG4gICAgICAgICAgICAgICAgOiBcInBhZGRpbmdcIiBpbiAoX3NlbGYudGhlbWUgfHwge30pID8gNCA6IF9zZWxmLiRwYWRkaW5nO1xuICAgICAgICAgICAgaWYgKF9zZWxmLiRwYWRkaW5nICYmIHBhZGRpbmcgIT0gX3NlbGYuJHBhZGRpbmcpXG4gICAgICAgICAgICAgICAgX3NlbGYuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgICAgIF9zZWxmLiR0aGVtZSA9IG1vZHVsZS5jc3NDbGFzcztcbiAgICAgICAgICAgIF9zZWxmLnRoZW1lID0gbW9kdWxlO1xuICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKF9zZWxmLmNvbnRhaW5lciwgbW9kdWxlLmNzc0NsYXNzKTtcbiAgICAgICAgICAgIGRvbS5zZXRDc3NDbGFzcyhfc2VsZi5jb250YWluZXIsIFwiYWNlX2RhcmtcIiwgbW9kdWxlLmlzRGFyayk7XG4gICAgICAgICAgICBpZiAoX3NlbGYuJHNpemUpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi4kc2l6ZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgX3NlbGYuJHVwZGF0ZVNpemVBc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NlbGYuX2Rpc3BhdGNoRXZlbnQoJ3RoZW1lTG9hZGVkJywgeyB0aGVtZTogbW9kdWxlIH0pO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIGlmICh1c2VyYWdlbnQuaXNTYWZhcmkgJiYgX3NlbGYuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5zY3JvbGxlci5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICBfc2VsZi5zY3JvbGxlci5zdHlsZS5iYWNrZ3JvdW5kID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaGVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRoZW1lSWQ7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCBpbmNsdWRlKSB7XG4gICAgICAgIGRvbS5zZXRDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgc3R5bGUsIGluY2x1ZGUgIT09IGZhbHNlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudW5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIHN0eWxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0Q3Vyc29yU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwiY3Vyc29yXCIsIHN0eWxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0TW91c2VDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwiY3Vyc29yXCIsIGN1cnNvclN0eWxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVG9TaGFkb3dSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb20uaW1wb3J0Q3NzU3RyaW5nKGVkaXRvckNzcywgXCJhY2VfZWRpdG9yLmNzc1wiLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnJlZXplKCk7XG4gICAgICAgIHRoaXMuJGZvbnRNZXRyaWNzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidXNlUmVzaXplT2JzZXJ2ZXJcIiwgZmFsc2UpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlQ3VzdG9tU2Nyb2xsYmFyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRob3JpelNjcm9sbCA9IHRoaXMuJHZTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcm9sbEJhclYuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJILmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxEZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRzY3JvbGxEZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWID0gbmV3IFZTY3JvbGxCYXJDdXN0b20odGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJIID0gbmV3IEhTY3JvbGxCYXJDdXN0b20odGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLnNldEhlaWdodCh0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFySC5zZXRXaWR0aCh0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9zZWxmLiRzY3JvbGxBbmltYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIF9zZWxmLnNlc3Npb24uc2V0U2Nyb2xsVG9wKGUuZGF0YSAtIF9zZWxmLnNjcm9sbE1hcmdpbi50b3ApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckguYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KGUuZGF0YSAtIF9zZWxmLnNjcm9sbE1hcmdpbi5sZWZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yID0gbmV3IERlY29yYXRvcih0aGlzLnNjcm9sbEJhclYsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yLiR1cGRhdGVEZWNvcmF0b3JzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYgPSBuZXcgVlNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckggPSBuZXcgSFNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoZS5kYXRhIC0gX3NlbGYuc2Nyb2xsTWFyZ2luLnRvcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFySC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfc2VsZi4kc2Nyb2xsQW5pbWF0aW9uKVxuICAgICAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbExlZnQoZS5kYXRhIC0gX3NlbGYuc2Nyb2xsTWFyZ2luLmxlZnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGFkZFJlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdpbmRvdy5SZXNpemVPYnNlcnZlciB8fCB0aGlzLiRyZXNpemVPYnNlcnZlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRyZXNpemVUaW1lciA9IGxhbmcuZGVsYXllZENhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICBzZWxmLm9uUmVzaXplKCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICAgICAgdGhpcy4kcmVzaXplT2JzZXJ2ZXIgPSBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGVbMF0uY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgaCA9IGVbMF0uY29udGVudFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlbGYuJHNpemUud2lkdGggLSB3KSA+IDFcbiAgICAgICAgICAgICAgICB8fCBNYXRoLmFicyhzZWxmLiRzaXplLmhlaWdodCAtIGgpID4gMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuJHJlc2l6ZVRpbWVyLmRlbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLiRyZXNpemVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250YWluZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpcnR1YWxSZW5kZXJlcjtcbn0oKSk7XG5WaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLkNIQU5HRV9DVVJTT1IgPSAxO1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfTUFSS0VSID0gMjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX0dVVFRFUiA9IDQ7XG5WaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLkNIQU5HRV9TQ1JPTEwgPSA4O1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfTElORVMgPSAxNjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX1RFWFQgPSAzMjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX1NJWkUgPSA2NDtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX01BUktFUl9CQUNLID0gMTI4O1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfTUFSS0VSX0ZST05UID0gMjU2O1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfRlVMTCA9IDUxMjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX0hfU0NST0xMID0gMTAyNDtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGNoYW5nZXMgPSAwO1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kcGFkZGluZyA9IG51bGw7XG5WaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiRmcm96ZW4gPSBmYWxzZTtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuU1RFUFMgPSA4O1xub29wLmltcGxlbWVudChWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuY29uZmlnLmRlZmluZU9wdGlvbnMoVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCB7XG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy4kcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzaXplVGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzaXplVGltZXIgPSB0aGlzLiRyZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAmJiAhdGhpcy4kcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhZGRSZXNpemVPYnNlcnZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRlZFNjcm9sbDogeyBpbml0aWFsVmFsdWU6IGZhbHNlIH0sXG4gICAgc2hvd0ludmlzaWJsZXM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIuc2V0U2hvd0ludmlzaWJsZXModmFsdWUpKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHNob3dQcmludE1hcmdpbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBwcmludE1hcmdpbkNvbHVtbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiA4MFxuICAgIH0sXG4gICAgcHJpbnRNYXJnaW46IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRoaXMuJHByaW50TWFyZ2luQ29sdW1uID0gdmFsO1xuICAgICAgICAgICAgdGhpcy4kc2hvd1ByaW50TWFyZ2luID0gISF2YWw7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgdGhpcy4kcHJpbnRNYXJnaW5Db2x1bW47XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNob3dHdXR0ZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICAgICAgdGhpcy4kZ3V0dGVyLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICAgICAgdGhpcy5vbkd1dHRlclJlc2l6ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHVzZVN2Z0d1dHRlckljb25zOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci4kdXNlU3ZnR3V0dGVySWNvbnMgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd0ZvbGRlZEFubm90YXRpb25zOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci4kc2hvd0ZvbGRlZEFubm90YXRpb25zID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIGZhZGVGb2xkV2lkZ2V0czoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy4kZ3V0dGVyLCBcImFjZV9mYWRlLWZvbGQtd2lkZ2V0c1wiLCBzaG93KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd0ZvbGRXaWRnZXRzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnNldFNob3dGb2xkV2lkZ2V0cyhzaG93KTtcbiAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfR1VUVEVSKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBkaXNwbGF5SW5kZW50R3VpZGVzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIuc2V0RGlzcGxheUluZGVudEd1aWRlcyhzaG93KSlcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGhpZ2hsaWdodEluZGVudEd1aWRlczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdGV4dExheWVyLnNldEhpZ2hsaWdodEluZGVudEd1aWRlcyhzaG93KSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLiRoaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLiRjbGVhckFjdGl2ZUluZGVudEd1aWRlKHRoaXMuJHRleHRMYXllci4kbGluZXMuY2VsbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGhpZ2hsaWdodEd1dHRlckxpbmU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRIaWdobGlnaHRHdXR0ZXJMaW5lKHNob3VsZEhpZ2hsaWdodCk7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgaFNjcm9sbEJhckFsd2F5c1Zpc2libGU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlIHx8ICF0aGlzLiRob3JpelNjcm9sbClcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSB8fCAhdGhpcy4kdlNjcm9sbClcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIGZvbnRTaXplOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb250U2l6ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IDEyXG4gICAgfSxcbiAgICBmb250RmFtaWx5OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb250U2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXhMaW5lczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnVsbCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtaW5MaW5lczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuJG1pbkxpbmVzIDwgMHgxZmZmZmZmZmZmZmZmKSlcbiAgICAgICAgICAgICAgICB0aGlzLiRtaW5MaW5lcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bGwoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWF4UGl4ZWxIZWlnaHQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAwXG4gICAgfSxcbiAgICBzY3JvbGxQYXN0RW5kOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFsID0gK3ZhbCB8fCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhc3RFbmQgPT0gdmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhc3RFbmQgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogMCxcbiAgICAgICAgaGFuZGxlc1NldDogdHJ1ZVxuICAgIH0sXG4gICAgZml4ZWRXaWR0aEd1dHRlcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLiRmaXhlZFdpZHRoID0gISF2YWw7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGN1c3RvbVNjcm9sbGJhcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1c3RvbVNjcm9sbGJhcih2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB0aGVtZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5zZXRUaGVtZSh2YWwpOyB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJHRoZW1lSWQgfHwgdGhpcy50aGVtZTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBcIi4vdGhlbWUvdGV4dG1hdGVcIixcbiAgICAgICAgaGFuZGxlc1NldDogdHJ1ZVxuICAgIH0sXG4gICAgaGFzQ3NzVHJhbnNmb3Jtczoge30sXG4gICAgdXNlVGV4dGFyZWFGb3JJTUU6IHtcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAhdXNlcmFnZW50LmlzTW9iaWxlICYmICF1c2VyYWdlbnQuaXNJRVxuICAgIH1cbn0pO1xuZXhwb3J0cy5WaXJ0dWFsUmVuZGVyZXIgPSBWaXJ0dWFsUmVuZGVyZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3dvcmtlci93b3JrZXJfY2xpZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9uZXRcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IHJlcXVpcmUoXCIuLi9saWIvb29wXCIpO1xudmFyIG5ldCA9IHJlcXVpcmUoXCIuLi9saWIvbmV0XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxuZnVuY3Rpb24gJHdvcmtlckJsb2Iod29ya2VyVXJsKSB7XG4gICAgdmFyIHNjcmlwdCA9IFwiaW1wb3J0U2NyaXB0cygnXCIgKyBuZXQucXVhbGlmeVVSTCh3b3JrZXJVcmwpICsgXCInKTtcIjtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3NjcmlwdF0sIHtcInR5cGVcIjogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJ9KTtcbiAgICB9IGNhdGNoIChlKSB7IC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyO1xuICAgICAgICB2YXIgYmxvYkJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgYmxvYkJ1aWxkZXIuYXBwZW5kKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiBibG9iQnVpbGRlci5nZXRCbG9iKFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtlcih3b3JrZXJVcmwpIHtcbiAgICBpZiAodHlwZW9mIFdvcmtlciA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4geyBwb3N0TWVzc2FnZTogZnVuY3Rpb24oKSB7fSwgdGVybWluYXRlOiBmdW5jdGlvbigpIHt9IH07XG4gICAgaWYgKGNvbmZpZy5nZXQoXCJsb2FkV29ya2VyRnJvbUJsb2JcIikpIHtcbiAgICAgICAgdmFyIGJsb2IgPSAkd29ya2VyQmxvYih3b3JrZXJVcmwpO1xuICAgICAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICB2YXIgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKGJsb2JVUkwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xufVxuXG52YXIgV29ya2VyQ2xpZW50ID0gZnVuY3Rpb24od29ya2VyKSB7XG4gICAgaWYgKCF3b3JrZXIucG9zdE1lc3NhZ2UpXG4gICAgICAgIHdvcmtlciA9IHRoaXMuJGNyZWF0ZVdvcmtlckZyb21PbGRDb25maWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuJHdvcmtlciA9IHdvcmtlcjtcbiAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IHRoaXMuJHNlbmREZWx0YVF1ZXVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IHRoaXMuY2hhbmdlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG5cbiAgICB0aGlzLiR3b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2U7XG59O1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuICAgIHRoaXMuJGNyZWF0ZVdvcmtlckZyb21PbGRDb25maWcgPSBmdW5jdGlvbih0b3BMZXZlbE5hbWVzcGFjZXMsIG1vZCwgY2xhc3NuYW1lLCB3b3JrZXJVcmwsIGltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgaWYgKHJlcXVpcmUubmFtZVRvVXJsICYmICFyZXF1aXJlLnRvVXJsKVxuICAgICAgICAgICAgcmVxdWlyZS50b1VybCA9IHJlcXVpcmUubmFtZVRvVXJsO1xuXG4gICAgICAgIGlmIChjb25maWcuZ2V0KFwicGFja2FnZWRcIikgfHwgIXJlcXVpcmUudG9VcmwpIHtcbiAgICAgICAgICAgIHdvcmtlclVybCA9IHdvcmtlclVybCB8fCBjb25maWcubW9kdWxlVXJsKG1vZCwgXCJ3b3JrZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplUGF0aCA9IHRoaXMuJG5vcm1hbGl6ZVBhdGg7XG4gICAgICAgICAgICB3b3JrZXJVcmwgPSB3b3JrZXJVcmwgfHwgbm9ybWFsaXplUGF0aChyZXF1aXJlLnRvVXJsKFwiYWNlL3dvcmtlci93b3JrZXIuanNcIiwgbnVsbCwgXCJfXCIpKTtcblxuICAgICAgICAgICAgdmFyIHRsbnMgPSB7fTtcbiAgICAgICAgICAgIHRvcExldmVsTmFtZXNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKG5zKSB7XG4gICAgICAgICAgICAgICAgdGxuc1tuc10gPSBub3JtYWxpemVQYXRoKHJlcXVpcmUudG9VcmwobnMsIG51bGwsIFwiX1wiKS5yZXBsYWNlKC8oXFwuanMpPyhcXD8uKik/JC8sIFwiXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kd29ya2VyID0gY3JlYXRlV29ya2VyKHdvcmtlclVybCk7XG4gICAgICAgIGlmIChpbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoXCJpbXBvcnRTY3JpcHRzXCIsIGltcG9ydFNjcmlwdHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpbml0IDogdHJ1ZSxcbiAgICAgICAgICAgIHRsbnMgOiB0bG5zLFxuICAgICAgICAgICAgbW9kdWxlIDogbW9kLFxuICAgICAgICAgICAgY2xhc3NuYW1lIDogY2xhc3NuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy4kd29ya2VyO1xuICAgIH07XG5cbiAgICB0aGlzLm9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG1zZyA9IGUuZGF0YTtcbiAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKG1zZy5uYW1lLCB7ZGF0YTogbXNnLmRhdGF9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbbXNnLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobXNnLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbbXNnLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyAmJiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBtc2cuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfTtcblxuICAgIHRoaXMuJG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXQucXVhbGlmeVVSTChwYXRoKTtcbiAgICB9O1xuXG4gICAgdGhpcy50ZXJtaW5hdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwidGVybWluYXRlXCIsIHt9KTtcbiAgICAgICAgdGhpcy5kZWx0YVF1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLiR3b3JrZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4kd29ya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuJGRvYylcbiAgICAgICAgICAgIHRoaXMuJGRvYy5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuJGRvYyA9IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGNtZCwgYXJncykge1xuICAgICAgICB0aGlzLiR3b3JrZXIucG9zdE1lc3NhZ2Uoe2NvbW1hbmQ6IGNtZCwgYXJnczogYXJnc30pO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbGwgPSBmdW5jdGlvbihjbWQsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tpZF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGFyZ3MucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kKGNtZCwgYXJncyk7XG4gICAgfTtcblxuICAgIHRoaXMuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5lcnIpXG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmVyciA9IHttZXNzYWdlOiBkYXRhLmRhdGEuZXJyLm1lc3NhZ2UsIHN0YWNrOiBkYXRhLmRhdGEuZXJyLnN0YWNrLCBjb2RlOiBkYXRhLmRhdGEuZXJyLmNvZGV9O1xuICAgICAgICAgICAgICAgIHRoaXMuJHdvcmtlciAmJiB0aGlzLiR3b3JrZXIucG9zdE1lc3NhZ2Uoe2V2ZW50OiBldmVudCwgZGF0YToge2RhdGE6IGRhdGEuZGF0YX19KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChleCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hdHRhY2hUb0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLiRkb2MpXG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgIHRoaXMuJGRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jYWxsKFwic2V0VmFsdWVcIiwgW2RvYy5nZXRWYWx1ZSgpXSk7XG4gICAgICAgIGRvYy5vbihcImNoYW5nZVwiLCB0aGlzLmNoYW5nZUxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWx0YVF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy4kc2VuZERlbHRhUXVldWUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIilcbiAgICAgICAgICAgIHRoaXMuZGVsdGFRdWV1ZS5wdXNoKGRlbHRhLnN0YXJ0LCBkZWx0YS5saW5lcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZGVsdGFRdWV1ZS5wdXNoKGRlbHRhLnN0YXJ0LCBkZWx0YS5lbmQpO1xuICAgIH07XG5cbiAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcSA9IHRoaXMuZGVsdGFRdWV1ZTtcbiAgICAgICAgaWYgKCFxKSByZXR1cm47XG4gICAgICAgIHRoaXMuZGVsdGFRdWV1ZSA9IG51bGw7XG4gICAgICAgIGlmIChxLmxlbmd0aCA+IDUwICYmIHEubGVuZ3RoID4gdGhpcy4kZG9jLmdldExlbmd0aCgpID4+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbChcInNldFZhbHVlXCIsIFt0aGlzLiRkb2MuZ2V0VmFsdWUoKV0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7ZGF0YTogcX0pO1xuICAgIH07XG5cbn0pLmNhbGwoV29ya2VyQ2xpZW50LnByb3RvdHlwZSk7XG5cblxudmFyIFVJV29ya2VyQ2xpZW50ID0gZnVuY3Rpb24odG9wTGV2ZWxOYW1lc3BhY2VzLCBtb2QsIGNsYXNzbmFtZSkge1xuICAgIHZhciBtYWluID0gbnVsbDtcbiAgICB2YXIgZW1pdFN5bmMgPSBmYWxzZTtcbiAgICB2YXIgc2VuZGVyID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIpO1xuXG4gICAgdmFyIG1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICB2YXIgd29ya2VyQ2xpZW50ID0gbmV3IFdvcmtlckNsaWVudCh7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXI6IG1lc3NhZ2VCdWZmZXIsXG4gICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIucHVzaChlKTtcbiAgICAgICAgICAgIGlmICghbWFpbikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVtaXRTeW5jKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocHJvY2Vzc05leHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHdvcmtlckNsaWVudC5zZXRFbWl0U3luYyA9IGZ1bmN0aW9uKHZhbCkgeyBlbWl0U3luYyA9IHZhbDsgfTtcblxuICAgIHZhciBwcm9jZXNzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICBpZiAobXNnLmNvbW1hbmQpXG4gICAgICAgICAgICBtYWluW21zZy5jb21tYW5kXS5hcHBseShtYWluLCBtc2cuYXJncyk7XG4gICAgICAgIGVsc2UgaWYgKG1zZy5ldmVudClcbiAgICAgICAgICAgIHNlbmRlci5fc2lnbmFsKG1zZy5ldmVudCwgbXNnLmRhdGEpO1xuICAgIH07XG5cbiAgICBzZW5kZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgd29ya2VyQ2xpZW50Lm9uTWVzc2FnZSh7ZGF0YTogbXNnfSk7XG4gICAgfTtcbiAgICBzZW5kZXIuY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFja0lkKSB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiY2FsbFwiLCBpZDogY2FsbGJhY2tJZCwgZGF0YTogZGF0YX0pO1xuICAgIH07XG4gICAgc2VuZGVyLmVtaXQgPSBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiZXZlbnRcIiwgbmFtZTogbmFtZSwgZGF0YTogZGF0YX0pO1xuICAgIH07XG5cbiAgICBjb25maWcubG9hZE1vZHVsZShbXCJ3b3JrZXJcIiwgbW9kXSwgZnVuY3Rpb24oTWFpbikge1xuICAgICAgICBtYWluID0gbmV3IE1haW5bY2xhc3NuYW1lXShzZW5kZXIpO1xuICAgICAgICB3aGlsZSAobWVzc2FnZUJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHdvcmtlckNsaWVudDtcbn07XG5cbmV4cG9ydHMuVUlXb3JrZXJDbGllbnQgPSBVSVdvcmtlckNsaWVudDtcbmV4cG9ydHMuV29ya2VyQ2xpZW50ID0gV29ya2VyQ2xpZW50O1xuZXhwb3J0cy5jcmVhdGVXb3JrZXIgPSBjcmVhdGVXb3JrZXI7XG5cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcGxhY2Vob2xkZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvbGliL29vcFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIFBsYWNlSG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlSG9sZGVyKHNlc3Npb24sIGxlbmd0aCwgcG9zLCBvdGhlcnMsIG1haW5DbGFzcywgb3RoZXJzQ2xhc3MpIHtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZG9jID0gc2Vzc2lvbi5nZXREb2N1bWVudCgpO1xuICAgICAgICB0aGlzLm1haW5DbGFzcyA9IG1haW5DbGFzcztcbiAgICAgICAgdGhpcy5vdGhlcnNDbGFzcyA9IG90aGVyc0NsYXNzO1xuICAgICAgICB0aGlzLiRvblVwZGF0ZSA9IHRoaXMub25VcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2Mub24oXCJjaGFuZ2VcIiwgdGhpcy4kb25VcGRhdGUsIHRydWUpO1xuICAgICAgICB0aGlzLiRvdGhlcnMgPSBvdGhlcnM7XG4gICAgICAgIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYub25DdXJzb3JDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiRwb3MgPSBwb3M7XG4gICAgICAgIHZhciB1bmRvU3RhY2sgPSBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuJHVuZG9TdGFjayB8fCBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKClbXCIkdW5kb3N0YWNrXCJdIHx8IHsgbGVuZ3RoOiAtMSB9O1xuICAgICAgICB0aGlzLiR1bmRvU3RhY2tEZXB0aCA9IHVuZG9TdGFjay5sZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgICAgc2Vzc2lvbi5zZWxlY3Rpb24ub24oXCJjaGFuZ2VDdXJzb3JcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgIH1cbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQmVmb3JlID0gc2Vzc2lvbi5zZWxlY3Rpb24udG9KU09OKCk7XG4gICAgICAgIGlmIChzZXNzaW9uLnNlbGVjdGlvbi5pbk11bHRpU2VsZWN0TW9kZSlcbiAgICAgICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBkb2MuY3JlYXRlQW5jaG9yKHRoaXMuJHBvcy5yb3csIHRoaXMuJHBvcy5jb2x1bW4pO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHBvcy4kaW5zZXJ0UmlnaHQgPSB0cnVlO1xuICAgICAgICBwb3MuZGV0YWNoKCk7XG4gICAgICAgIHBvcy5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uLCBwb3Mucm93LCBwb3MuY29sdW1uICsgdGhpcy5sZW5ndGgpLCB0aGlzLm1haW5DbGFzcywgbnVsbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLm90aGVycyA9IFtdO1xuICAgICAgICB0aGlzLiRvdGhlcnMuZm9yRWFjaChmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBkb2MuY3JlYXRlQW5jaG9yKG90aGVyLnJvdywgb3RoZXIuY29sdW1uKTtcbiAgICAgICAgICAgIGFuY2hvci4kaW5zZXJ0UmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgYW5jaG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgX3NlbGYub3RoZXJzLnB1c2goYW5jaG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24uc2V0VW5kb1NlbGVjdChmYWxzZSk7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuc2hvd090aGVyTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3RoZXJzQWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vdGhlcnNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm90aGVycy5mb3JFYWNoKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgICAgIGFuY2hvci5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShhbmNob3Iucm93LCBhbmNob3IuY29sdW1uLCBhbmNob3Iucm93LCBhbmNob3IuY29sdW1uICsgX3NlbGYubGVuZ3RoKSwgX3NlbGYub3RoZXJzQ2xhc3MsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuaGlkZU90aGVyTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm90aGVyc0FjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vdGhlcnNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm90aGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcih0aGlzLm90aGVyc1tpXS5tYXJrZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsYWNlSG9sZGVyLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy4kdXBkYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVBbmNob3JzKGRlbHRhKTtcbiAgICAgICAgdmFyIHJhbmdlID0gZGVsdGE7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgIT09IHJhbmdlLmVuZC5yb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgIT09IHRoaXMucG9zLnJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgbGVuZ3RoRGlmZiA9IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHJhbmdlLmVuZC5jb2x1bW4gLSByYW5nZS5zdGFydC5jb2x1bW4gOiByYW5nZS5zdGFydC5jb2x1bW4gLSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICB2YXIgaW5NYWluUmFuZ2UgPSByYW5nZS5zdGFydC5jb2x1bW4gPj0gdGhpcy5wb3MuY29sdW1uICYmIHJhbmdlLnN0YXJ0LmNvbHVtbiA8PSB0aGlzLnBvcy5jb2x1bW4gKyB0aGlzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBkaXN0YW5jZUZyb21TdGFydCA9IHJhbmdlLnN0YXJ0LmNvbHVtbiAtIHRoaXMucG9zLmNvbHVtbjtcbiAgICAgICAgdGhpcy51cGRhdGVBbmNob3JzKGRlbHRhKTtcbiAgICAgICAgaWYgKGluTWFpblJhbmdlKVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gbGVuZ3RoRGlmZjtcbiAgICAgICAgaWYgKGluTWFpblJhbmdlICYmICF0aGlzLnNlc3Npb24uJGZyb21VbmRvKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm90aGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSB0aGlzLm90aGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHsgcm93OiBvdGhlclBvcy5yb3csIGNvbHVtbjogb3RoZXJQb3MuY29sdW1uICsgZGlzdGFuY2VGcm9tU3RhcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MuaW5zZXJ0TWVyZ2VkTGluZXMobmV3UG9zLCBkZWx0YS5saW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm90aGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSB0aGlzLm90aGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHsgcm93OiBvdGhlclBvcy5yb3csIGNvbHVtbjogb3RoZXJQb3MuY29sdW1uICsgZGlzdGFuY2VGcm9tU3RhcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MucmVtb3ZlKG5ldyBSYW5nZShuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uLCBuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uIC0gbGVuZ3RoRGlmZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR1cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB9O1xuICAgIFBsYWNlSG9sZGVyLnByb3RvdHlwZS51cGRhdGVBbmNob3JzID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRoaXMucG9zLm9uQ2hhbmdlKGRlbHRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMub3RoZXJzLmxlbmd0aDsgaS0tOylcbiAgICAgICAgICAgIHRoaXMub3RoZXJzW2ldLm9uQ2hhbmdlKGRlbHRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUudXBkYXRlTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHVwZGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHVwZGF0ZU1hcmtlciA9IGZ1bmN0aW9uIChwb3MsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIocG9zLm1hcmtlcklkKTtcbiAgICAgICAgICAgIHBvcy5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uLCBwb3Mucm93LCBwb3MuY29sdW1uICsgX3NlbGYubGVuZ3RoKSwgY2xhc3NOYW1lLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZU1hcmtlcih0aGlzLnBvcywgdGhpcy5tYWluQ2xhc3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5vdGhlcnMubGVuZ3RoOyBpLS07KVxuICAgICAgICAgICAgdXBkYXRlTWFya2VyKHRoaXMub3RoZXJzW2ldLCB0aGlzLm90aGVyc0NsYXNzKTtcbiAgICB9O1xuICAgIFBsYWNlSG9sZGVyLnByb3RvdHlwZS5vbkN1cnNvckNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy4kdXBkYXRpbmcgfHwgIXRoaXMuc2Vzc2lvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmIChwb3Mucm93ID09PSB0aGlzLnBvcy5yb3cgJiYgcG9zLmNvbHVtbiA+PSB0aGlzLnBvcy5jb2x1bW4gJiYgcG9zLmNvbHVtbiA8PSB0aGlzLnBvcy5jb2x1bW4gKyB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaG93T3RoZXJNYXJrZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY3Vyc29yRW50ZXJcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlT3RoZXJNYXJrZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY3Vyc29yTGVhdmVcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlTWFya2VyKHRoaXMucG9zICYmIHRoaXMucG9zLm1hcmtlcklkKTtcbiAgICAgICAgdGhpcy5oaWRlT3RoZXJNYXJrZXJzKCk7XG4gICAgICAgIHRoaXMuZG9jLm9mZihcImNoYW5nZVwiLCB0aGlzLiRvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24ub2ZmKFwiY2hhbmdlQ3Vyc29yXCIsIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFVuZG9TZWxlY3QodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kdW5kb1N0YWNrRGVwdGggPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdW5kb01hbmFnZXIgPSB0aGlzLnNlc3Npb24uZ2V0VW5kb01hbmFnZXIoKTtcbiAgICAgICAgdmFyIHVuZG9zUmVxdWlyZWQgPSAodW5kb01hbmFnZXIuJHVuZG9TdGFjayB8fCB1bmRvTWFuYWdlcltcIiR1bmRvc3RhY2tcIl0pLmxlbmd0aCAtIHRoaXMuJHVuZG9TdGFja0RlcHRoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZG9zUmVxdWlyZWQ7IGkrKykge1xuICAgICAgICAgICAgdW5kb01hbmFnZXIudW5kbyh0aGlzLnNlc3Npb24sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkJlZm9yZSlcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZnJvbUpTT04odGhpcy5zZWxlY3Rpb25CZWZvcmUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBsYWNlSG9sZGVyO1xufSgpKTtcbm9vcC5pbXBsZW1lbnQoUGxhY2VIb2xkZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5QbGFjZUhvbGRlciA9IFBsYWNlSG9sZGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7dmFyIGV2ZW50ID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbmZ1bmN0aW9uIGlzU2FtZVBvaW50KHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgPT0gcDIucm93ICYmIHAxLmNvbHVtbiA9PSBwMi5jb2x1bW47XG59XG5mdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgdmFyIGV2ID0gZS5kb21FdmVudDtcbiAgICB2YXIgYWx0ID0gZXYuYWx0S2V5O1xuICAgIHZhciBzaGlmdCA9IGV2LnNoaWZ0S2V5O1xuICAgIHZhciBjdHJsID0gZXYuY3RybEtleTtcbiAgICB2YXIgYWNjZWwgPSBlLmdldEFjY2VsS2V5KCk7XG4gICAgdmFyIGJ1dHRvbiA9IGUuZ2V0QnV0dG9uKCk7XG4gICAgaWYgKGN0cmwgJiYgdXNlcmFnZW50LmlzTWFjKVxuICAgICAgICBidXR0b24gPSBldi5idXR0b247XG4gICAgaWYgKGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlICYmIGJ1dHRvbiA9PSAyKSB7XG4gICAgICAgIGUuZWRpdG9yLnRleHRJbnB1dC5vbkNvbnRleHRNZW51KGUuZG9tRXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3RybCAmJiAhYWx0ICYmICFhY2NlbCkge1xuICAgICAgICBpZiAoYnV0dG9uID09PSAwICYmIGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgZS5lZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChidXR0b24gIT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIGlzTXVsdGlTZWxlY3QgPSBlZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGU7XG4gICAgdmFyIHBvcyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgIHZhciBjdXJzb3IgPSBzZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgdmFyIGluU2VsZWN0aW9uID0gZS5pblNlbGVjdGlvbigpIHx8IChzZWxlY3Rpb24uaXNFbXB0eSgpICYmIGlzU2FtZVBvaW50KHBvcywgY3Vyc29yKSk7XG4gICAgdmFyIG1vdXNlWCA9IGUueCwgbW91c2VZID0gZS55O1xuICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgICAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgfTtcbiAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgIHZhciBzY3JlZW5BbmNob3IgPSBlZGl0b3IucmVuZGVyZXIucGl4ZWxUb1NjcmVlbkNvb3JkaW5hdGVzKG1vdXNlWCwgbW91c2VZKTtcbiAgICB2YXIgc2NyZWVuQ3Vyc29yID0gc2NyZWVuQW5jaG9yO1xuICAgIHZhciBzZWxlY3Rpb25Nb2RlO1xuICAgIGlmIChlZGl0b3IuJG1vdXNlSGFuZGxlci4kZW5hYmxlSnVtcFRvRGVmKSB7XG4gICAgICAgIGlmIChjdHJsICYmIGFsdCB8fCBhY2NlbCAmJiBhbHQpXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gc2hpZnQgPyBcImJsb2NrXCIgOiBcImFkZFwiO1xuICAgICAgICBlbHNlIGlmIChhbHQgJiYgZWRpdG9yLiRibG9ja1NlbGVjdEVuYWJsZWQpXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGFjY2VsICYmICFhbHQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGUgPSBcImFkZFwiO1xuICAgICAgICAgICAgaWYgKCFpc011bHRpU2VsZWN0ICYmIHNoaWZ0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbHQgJiYgZWRpdG9yLiRibG9ja1NlbGVjdEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGUgPSBcImJsb2NrXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbk1vZGUgJiYgdXNlcmFnZW50LmlzTWFjICYmIGV2LmN0cmxLZXkpIHtcbiAgICAgICAgZWRpdG9yLiRtb3VzZUhhbmRsZXIuY2FuY2VsQ29udGV4dE1lbnUoKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbk1vZGUgPT0gXCJhZGRcIikge1xuICAgICAgICBpZiAoIWlzTXVsdGlTZWxlY3QgJiYgaW5TZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47IC8vIGRyYWdnaW5nXG4gICAgICAgIGlmICghaXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgZWRpdG9yLmFkZFNlbGVjdGlvbk1hcmtlcihyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZFJhbmdlID0gc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZUF0UG9pbnQocG9zKTtcbiAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlO1xuICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgIG9sZFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLnJhbmdlc1swXSB8fCByYW5nZTtcbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5vbmNlKFwibW91c2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG1wU2VsID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKG9sZFJhbmdlICYmIHRtcFNlbC5pc0VtcHR5KCkgJiYgaXNTYW1lUG9pbnQob2xkUmFuZ2UuY3Vyc29yLCB0bXBTZWwuY3Vyc29yKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc3Vic3RyYWN0UG9pbnQodG1wU2VsLmN1cnNvcik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnN1YnN0cmFjdFBvaW50KHJhbmdlLmN1cnNvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UodG1wU2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlID09IFwiYmxvY2tcIikge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlO1xuICAgICAgICB2YXIgaW5pdGlhbFJhbmdlO1xuICAgICAgICB2YXIgcmVjdFNlbCA9IFtdO1xuICAgICAgICB2YXIgYmxvY2tTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q3Vyc29yID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcyhtb3VzZVgsIG1vdXNlWSk7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24obmV3Q3Vyc29yLnJvdywgbmV3Q3Vyc29yLmNvbHVtbiwgbmV3Q3Vyc29yLm9mZnNldFgpO1xuICAgICAgICAgICAgaWYgKGlzU2FtZVBvaW50KHNjcmVlbkN1cnNvciwgbmV3Q3Vyc29yKSAmJiBpc1NhbWVQb2ludChjdXJzb3IsIHNlbGVjdGlvbi5sZWFkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzY3JlZW5DdXJzb3IgPSBuZXdDdXJzb3I7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKGN1cnNvcik7XG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzKHJlY3RTZWwpO1xuICAgICAgICAgICAgcmVjdFNlbCA9IHNlbGVjdGlvbi5yZWN0YW5ndWxhclJhbmdlQmxvY2soc2NyZWVuQ3Vyc29yLCBzY3JlZW5BbmNob3IpO1xuICAgICAgICAgICAgaWYgKGVkaXRvci4kbW91c2VIYW5kbGVyLiRjbGlja1NlbGVjdGlvbiAmJiByZWN0U2VsLmxlbmd0aCA9PSAxICYmIHJlY3RTZWxbMF0uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHJlY3RTZWxbMF0gPSBlZGl0b3IuJG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIHJlY3RTZWwuZm9yRWFjaChlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyLCBlZGl0b3IpO1xuICAgICAgICAgICAgZWRpdG9yLnVwZGF0ZVNlbGVjdGlvbk1hcmtlcnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzTXVsdGlTZWxlY3QgJiYgIWFjY2VsKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24udG9TaW5nbGVSYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc011bHRpU2VsZWN0ICYmIGFjY2VsKSB7XG4gICAgICAgICAgICBpbml0aWFsUmFuZ2UgPSBzZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgICAgICBlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyKGluaXRpYWxSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoaWZ0KVxuICAgICAgICAgICAgc2NyZWVuQW5jaG9yID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oc2VsZWN0aW9uLmxlYWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgc2NyZWVuQ3Vyc29yID0geyByb3c6IC0xLCBjb2x1bW46IC0xIH07XG4gICAgICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0KCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMocmVjdFNlbCk7XG4gICAgICAgICAgICBpZiAoIXJlY3RTZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlY3RTZWwgPSBbc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpXTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlU2VsZWN0aW9uTWFya2VyKGluaXRpYWxSYW5nZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UoaW5pdGlhbFJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdFNlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmVjdFNlbFtpXSk7XG4gICAgICAgICAgICBlZGl0b3IuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgZWRpdG9yLiRtb3VzZUhhbmRsZXIuJGNsaWNrU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU2VsZWN0aW9uSW50ZXJ2YWwgPSBibG9ja1NlbGVjdDtcbiAgICAgICAgZXZlbnQuY2FwdHVyZShlZGl0b3IuY29udGFpbmVyLCBvbk1vdXNlU2VsZWN0aW9uLCBvbk1vdXNlU2VsZWN0aW9uRW5kKTtcbiAgICAgICAgdmFyIHRpbWVySWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IG9uU2VsZWN0aW9uSW50ZXJ2YWwoKTsgfSwgMjApO1xuICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMub25Nb3VzZURvd24gPSBvbk1vdXNlRG93bjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvY29tbWFuZHMvbXVsdGlfc2VsZWN0X2NvbW1hbmRzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpey8qKlxuICogY29tbWFuZHMgdG8gZW50ZXIgbXVsdGlzZWxlY3QgbW9kZVxuICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2FjZS1pbnRlcm5hbFwiKS5BY2UuQ29tbWFuZFtdfVxuICovXG5leHBvcnRzLmRlZmF1bHRDb21tYW5kcyA9IFt7XG4gICAgICAgIG5hbWU6IFwiYWRkQ3Vyc29yQWJvdmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkIGN1cnNvciBhYm92ZVwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlTGluZXMoLTEpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1VcFwiLCBtYWM6IFwiQ3RybC1BbHQtVXBcIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYWRkQ3Vyc29yQmVsb3dcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkIGN1cnNvciBiZWxvd1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlTGluZXMoMSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LURvd25cIiwgbWFjOiBcIkN0cmwtQWx0LURvd25cIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYWRkQ3Vyc29yQWJvdmVTa2lwQ3VycmVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBZGQgY3Vyc29yIGFib3ZlIChza2lwIGN1cnJlbnQpXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmVMaW5lcygtMSwgdHJ1ZSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LVNoaWZ0LVVwXCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1VcFwiIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhZGRDdXJzb3JCZWxvd1NraXBDdXJyZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFkZCBjdXJzb3IgYmVsb3cgKHNraXAgY3VycmVudClcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKDEsIHRydWUpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1TaGlmdC1Eb3duXCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1Eb3duXCIgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdE1vcmVCZWZvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IG1vcmUgYmVmb3JlXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmUoLTEpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1MZWZ0XCIsIG1hYzogXCJDdHJsLUFsdC1MZWZ0XCIgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdE1vcmVBZnRlclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbW9yZSBhZnRlclwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlKDEpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1SaWdodFwiLCBtYWM6IFwiQ3RybC1BbHQtUmlnaHRcIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0TmV4dEJlZm9yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbmV4dCBiZWZvcmVcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZSgtMSwgdHJ1ZSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LVNoaWZ0LUxlZnRcIiwgbWFjOiBcIkN0cmwtQWx0LVNoaWZ0LUxlZnRcIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0TmV4dEFmdGVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBuZXh0IGFmdGVyXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmUoMSwgdHJ1ZSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LVNoaWZ0LVJpZ2h0XCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1SaWdodFwiIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ0b2dnbGVTcGxpdFNlbGVjdGlvbkludG9MaW5lc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTcGxpdCBzZWxlY3Rpb24gaW50byBsaW5lc1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLm11bHRpU2VsZWN0LnJhbmdlQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5qb2luU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5zcGxpdEludG9MaW5lcygpO1xuICAgICAgICB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1MXCIsIG1hYzogXCJDdHJsLUFsdC1MXCIgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic3BsaXRTZWxlY3Rpb25JbnRvTGluZXNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3BsaXQgaW50byBsaW5lc1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5tdWx0aVNlbGVjdC5zcGxpdEludG9MaW5lcygpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhbGlnbkN1cnNvcnNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWxpZ24gY3Vyc29yc1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5hbGlnbkN1cnNvcnMoKTsgfSxcbiAgICAgICAgYmluZEtleTogeyB3aW46IFwiQ3RybC1BbHQtQVwiLCBtYWM6IFwiQ3RybC1BbHQtQVwiIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImZpbmRBbGxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmluZCBhbGxcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZmluZEFsbCgpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1LXCIsIG1hYzogXCJDdHJsLUFsdC1HXCIgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfV07XG5leHBvcnRzLm11bHRpU2VsZWN0Q29tbWFuZHMgPSBbe1xuICAgICAgICBuYW1lOiBcInNpbmdsZVNlbGVjdGlvblwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTaW5nbGUgc2VsZWN0aW9uXCIsXG4gICAgICAgIGJpbmRLZXk6IFwiZXNjXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24gKGVkaXRvcikgeyByZXR1cm4gZWRpdG9yICYmIGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZTsgfVxuICAgIH1dO1xudmFyIEhhc2hIYW5kbGVyID0gcmVxdWlyZShcIi4uL2tleWJvYXJkL2hhc2hfaGFuZGxlclwiKS5IYXNoSGFuZGxlcjtcbmV4cG9ydHMua2V5Ym9hcmRIYW5kbGVyID0gbmV3IEhhc2hIYW5kbGVyKGV4cG9ydHMubXVsdGlTZWxlY3RDb21tYW5kcyk7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL211bHRpX3NlbGVjdFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlX2xpc3RcIixcImFjZS9yYW5nZVwiLFwiYWNlL3NlbGVjdGlvblwiLFwiYWNlL21vdXNlL211bHRpX3NlbGVjdF9oYW5kbGVyXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIixcImFjZS9zZWFyY2hcIixcImFjZS9lZGl0X3Nlc3Npb25cIixcImFjZS9lZGl0b3JcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7LyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9hbmNob3JcIikuQW5jaG9yfSBBbmNob3JcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9hY2UtaW50ZXJuYWxcIikuQWNlLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL2FjZS1pbnRlcm5hbFwiKS5BY2UuU2NyZWVuQ29vcmRpbmF0ZXN9IFNjcmVlbkNvb3JkaW5hdGVzXG4gKi9cbnZhciBSYW5nZUxpc3QgPSByZXF1aXJlKFwiLi9yYW5nZV9saXN0XCIpLlJhbmdlTGlzdDtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvblwiKS5TZWxlY3Rpb247XG52YXIgb25Nb3VzZURvd24gPSByZXF1aXJlKFwiLi9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclwiKS5vbk1vdXNlRG93bjtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgY29tbWFuZHMgPSByZXF1aXJlKFwiLi9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIik7XG5leHBvcnRzLmNvbW1hbmRzID0gY29tbWFuZHMuZGVmYXVsdENvbW1hbmRzLmNvbmNhdChjb21tYW5kcy5tdWx0aVNlbGVjdENvbW1hbmRzKTtcbnZhciBTZWFyY2ggPSByZXF1aXJlKFwiLi9zZWFyY2hcIikuU2VhcmNoO1xudmFyIHNlYXJjaCA9IG5ldyBTZWFyY2goKTtcbmZ1bmN0aW9uIGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpIHtcbiAgICBzZWFyY2guJG9wdGlvbnMud3JhcCA9IHRydWU7XG4gICAgc2VhcmNoLiRvcHRpb25zLm5lZWRsZSA9IG5lZWRsZTtcbiAgICBzZWFyY2guJG9wdGlvbnMuYmFja3dhcmRzID0gZGlyID09IC0xO1xuICAgIHJldHVybiBzZWFyY2guZmluZChzZXNzaW9uKTtcbn1cbnZhciBFZGl0U2Vzc2lvbiA9IHJlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvblwiKS5FZGl0U2Vzc2lvbjtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VsZWN0aW9uTWFya2VycztcbiAgICB9O1xufSkuY2FsbChFZGl0U2Vzc2lvbi5wcm90b3R5cGUpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJhbmdlcyA9IG51bGw7XG4gICAgdGhpcy5yYW5nZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuYWRkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsICRibG9ja0NoYW5nZUV2ZW50cykge1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgdGhpcy5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgb2xkUmFuZ2UgPSB0aGlzLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYWRkKG9sZFJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VMaXN0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QucmFuZ2VzLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRibG9ja0NoYW5nZUV2ZW50cyB8fCB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFuZ2VMaXN0LnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYWRkKG9sZFJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQWRkUmFuZ2Uob2xkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UuY3Vyc29yKVxuICAgICAgICAgICAgcmFuZ2UuY3Vyc29yID0gcmFuZ2UuZW5kO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LmFkZChyYW5nZSk7XG4gICAgICAgIHRoaXMuJG9uQWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID4gMSAmJiAhdGhpcy5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwibXVsdGlTZWxlY3RcIik7XG4gICAgICAgICAgICB0aGlzLmluTXVsdGlTZWxlY3RNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kdW5kb1NlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYXR0YWNoKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRibG9ja0NoYW5nZUV2ZW50cyB8fCB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICB9O1xuICAgIHRoaXMudG9TaW5nbGVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByYW5nZSA9IHJhbmdlIHx8IHRoaXMucmFuZ2VzWzBdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xuICAgICAgICByYW5nZSAmJiB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic3RyYWN0UG9pbnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yYW5nZUxpc3Quc3Vic3RyYWN0UG9pbnQocG9zKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZFswXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tZXJnZU92ZXJsYXBwaW5nUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0Lm1lcmdlKCk7XG4gICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XG4gICAgfTtcbiAgICB0aGlzLiRvbkFkZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMucmFuZ2VzLnVuc2hpZnQocmFuZ2UpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJhZGRSYW5nZVwiLCB7IHJhbmdlOiByYW5nZSB9KTtcbiAgICB9O1xuICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAocmVtb3ZlZCkge1xuICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09IDEgJiYgdGhpcy5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgdmFyIGxhc3RSYW5nZSA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5wb3AoKTtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChsYXN0UmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMucmFuZ2VzLmluZGV4T2YocmVtb3ZlZFtpXSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbChcInJlbW92ZVJhbmdlXCIsIHsgcmFuZ2VzOiByZW1vdmVkIH0pO1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09PSAwICYmIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcInNpbmdsZVNlbGVjdFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kdW5kb1NlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJhbmdlTGlzdC5kZXRhY2godGhpcy5zZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmFuZ2UgPSBsYXN0UmFuZ2UgfHwgdGhpcy5yYW5nZXNbMF07XG4gICAgICAgIGlmIChsYXN0UmFuZ2UgJiYgIWxhc3RSYW5nZS5pc0VxdWFsKHRoaXMuZ2V0UmFuZ2UoKSkpXG4gICAgICAgICAgICB0aGlzLmZyb21PcmllbnRlZFJhbmdlKGxhc3RSYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLiRpbml0UmFuZ2VMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmFuZ2VMaXN0ID0gbmV3IFJhbmdlTGlzdCgpO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSAwO1xuICAgIH07XG4gICAgdGhpcy5nZXRBbGxSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlQ291bnQgPyB0aGlzLnJhbmdlTGlzdC5yYW5nZXMuY29uY2F0KCkgOiBbdGhpcy5nZXRSYW5nZSgpXTtcbiAgICB9O1xuICAgIHRoaXMuc3BsaXRJbnRvTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcy5sZW5ndGggPyB0aGlzLnJhbmdlcyA6IFt0aGlzLmdldFJhbmdlKCldO1xuICAgICAgICB2YXIgbmV3UmFuZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICB2YXIgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHJhbmdlLmVuZC5yb3c7XG4gICAgICAgICAgICBpZiAocm93ID09PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChyYW5nZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ldyBSYW5nZShyb3csIHJhbmdlLnN0YXJ0LmNvbHVtbiwgcm93LCB0aGlzLnNlc3Npb24uZ2V0TGluZShyb3cpLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK3JvdyA8IGVuZFJvdylcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2godGhpcy5nZXRMaW5lUmFuZ2Uocm93LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKGVuZFJvdywgMCwgZW5kUm93LCByYW5nZS5lbmQuY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSAwICYmICF0aGlzLmlzQmFja3dhcmRzKCkpXG4gICAgICAgICAgICAgICAgbmV3UmFuZ2VzID0gbmV3UmFuZ2VzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5ld1Jhbmdlcy5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICB0aGlzLmFkZFJhbmdlKG5ld1Jhbmdlc1tpXSk7XG4gICAgfTtcbiAgICB0aGlzLmpvaW5TZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICB2YXIgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhyYW5nZXNbMF0uc3RhcnQsIGxhc3RSYW5nZS5lbmQpO1xuICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgbGFzdFJhbmdlLmN1cnNvciA9PSBsYXN0UmFuZ2Uuc3RhcnQpO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGVCbG9ja1NlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXM7XG4gICAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2VzWzBdLnN0YXJ0LCBsYXN0UmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHRoaXMudG9TaW5nbGVSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgbGFzdFJhbmdlLmN1cnNvciA9PSBsYXN0UmFuZ2Uuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5jdXJzb3IpO1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5hbmNob3IpO1xuICAgICAgICAgICAgdmFyIHJlY3RTZWwgPSB0aGlzLnJlY3Rhbmd1bGFyUmFuZ2VCbG9jayhjdXJzb3IsIGFuY2hvcik7XG4gICAgICAgICAgICByZWN0U2VsLmZvckVhY2godGhpcy5hZGRSYW5nZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVjdGFuZ3VsYXJSYW5nZUJsb2NrID0gZnVuY3Rpb24gKHNjcmVlbkN1cnNvciwgc2NyZWVuQW5jaG9yLCBpbmNsdWRlRW1wdHlMaW5lcykge1xuICAgICAgICB2YXIgcmVjdFNlbCA9IFtdO1xuICAgICAgICB2YXIgeEJhY2t3YXJkcyA9IHNjcmVlbkN1cnNvci5jb2x1bW4gPCBzY3JlZW5BbmNob3IuY29sdW1uO1xuICAgICAgICBpZiAoeEJhY2t3YXJkcykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gc2NyZWVuQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgICAgIHZhciBlbmRDb2x1bW4gPSBzY3JlZW5BbmNob3IuY29sdW1uO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0WCA9IHNjcmVlbkN1cnNvci5vZmZzZXRYO1xuICAgICAgICAgICAgdmFyIGVuZE9mZnNldFggPSBzY3JlZW5BbmNob3Iub2Zmc2V0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IHNjcmVlbkFuY2hvci5jb2x1bW47XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2NyZWVuQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldFggPSBzY3JlZW5BbmNob3Iub2Zmc2V0WDtcbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXRYID0gc2NyZWVuQ3Vyc29yLm9mZnNldFg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHlCYWNrd2FyZHMgPSBzY3JlZW5DdXJzb3Iucm93IDwgc2NyZWVuQW5jaG9yLnJvdztcbiAgICAgICAgaWYgKHlCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IHNjcmVlbkN1cnNvci5yb3c7XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gc2NyZWVuQW5jaG9yLnJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IHNjcmVlbkFuY2hvci5yb3c7XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gc2NyZWVuQ3Vyc29yLnJvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPCAwKVxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICBpZiAoc3RhcnRSb3cgPCAwKVxuICAgICAgICAgICAgc3RhcnRSb3cgPSAwO1xuICAgICAgICBpZiAoc3RhcnRSb3cgPT0gZW5kUm93KVxuICAgICAgICAgICAgaW5jbHVkZUVtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgICB2YXIgZG9jRW5kO1xuICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93IDw9IGVuZFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHModGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihyb3csIHN0YXJ0Q29sdW1uLCBzdGFydE9mZnNldFgpLCB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHJvdywgZW5kQ29sdW1uLCBlbmRPZmZzZXRYKSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY0VuZCAmJiBpc1NhbWVQb2ludChyYW5nZS5lbmQsIGRvY0VuZCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRvY0VuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHhCYWNrd2FyZHMgPyByYW5nZS5zdGFydCA6IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIHJlY3RTZWwucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHlCYWNrd2FyZHMpXG4gICAgICAgICAgICByZWN0U2VsLnJldmVyc2UoKTtcbiAgICAgICAgaWYgKCFpbmNsdWRlRW1wdHlMaW5lcykge1xuICAgICAgICAgICAgdmFyIGVuZCA9IHJlY3RTZWwubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChyZWN0U2VsW2VuZF0uaXNFbXB0eSgpICYmIGVuZCA+IDApXG4gICAgICAgICAgICAgICAgZW5kLS07XG4gICAgICAgICAgICBpZiAoZW5kID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlY3RTZWxbc3RhcnRdLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbmQ7IGkgPj0gc3RhcnQ7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0U2VsW2ldLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgcmVjdFNlbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RTZWw7XG4gICAgfTtcbn0pLmNhbGwoU2VsZWN0aW9uLnByb3RvdHlwZSk7XG52YXIgRWRpdG9yID0gcmVxdWlyZShcIi4vZWRpdG9yXCIpLkVkaXRvcjtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZFNlbGVjdGlvbk1hcmtlciA9IGZ1bmN0aW9uIChvcmllbnRlZFJhbmdlKSB7XG4gICAgICAgIGlmICghb3JpZW50ZWRSYW5nZS5jdXJzb3IpXG4gICAgICAgICAgICBvcmllbnRlZFJhbmdlLmN1cnNvciA9IG9yaWVudGVkUmFuZ2UuZW5kO1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlKCk7XG4gICAgICAgIG9yaWVudGVkUmFuZ2UubWFya2VyID0gdGhpcy5zZXNzaW9uLmFkZE1hcmtlcihvcmllbnRlZFJhbmdlLCBcImFjZV9zZWxlY3Rpb25cIiwgc3R5bGUpO1xuICAgICAgICB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMucHVzaChvcmllbnRlZFJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbk1hcmtlckNvdW50ID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG9yaWVudGVkUmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbk1hcmtlciA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAoIXJhbmdlLm1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXIpO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMuaW5kZXhPZihyYW5nZSk7XG4gICAgICAgIGlmIChpbmRleCAhPSAtMSlcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2VsZWN0aW9uTWFya2VyQ291bnQgPSB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMubGVuZ3RoO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24gKHJhbmdlcykge1xuICAgICAgICB2YXIgbWFya2VyTGlzdCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycztcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UubWFya2VyKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXIpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbWFya2VyTGlzdC5pbmRleE9mKHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSlcbiAgICAgICAgICAgICAgICBtYXJrZXJMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbk1hcmtlckNvdW50ID0gbWFya2VyTGlzdC5sZW5ndGg7XG4gICAgfTtcbiAgICB0aGlzLiRvbkFkZFJhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb25NYXJrZXIoZS5yYW5nZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcbiAgICB9O1xuICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMoZS5yYW5nZXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcbiAgICB0aGlzLiRvbk11bHRpU2VsZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0eWxlKFwiYWNlX211bHRpc2VsZWN0XCIpO1xuICAgICAgICB0aGlzLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKGNvbW1hbmRzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuc2V0RGVmYXVsdEhhbmRsZXIoXCJleGVjXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3RFeGVjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xuICAgIH07XG4gICAgdGhpcy4kb25TaW5nbGVTZWxlY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLm11bHRpU2VsZWN0LmluVmlydHVhbE1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnNldFN0eWxlKFwiYWNlX211bHRpc2VsZWN0XCIpO1xuICAgICAgICB0aGlzLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKGNvbW1hbmRzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucmVtb3ZlRGVmYXVsdEhhbmRsZXIoXCJleGVjXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3RFeGVjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlU2VsZWN0aW9uXCIpO1xuICAgIH07XG4gICAgdGhpcy4kb25NdWx0aVNlbGVjdEV4ZWMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGUuY29tbWFuZDtcbiAgICAgICAgdmFyIGVkaXRvciA9IGUuZWRpdG9yO1xuICAgICAgICBpZiAoIWVkaXRvci5tdWx0aVNlbGVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjb21tYW5kLm11bHRpU2VsZWN0QWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tbWFuZC5leGVjKGVkaXRvciwgZS5hcmdzIHx8IHt9KTtcbiAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5hZGRSYW5nZShlZGl0b3IubXVsdGlTZWxlY3QudG9PcmllbnRlZFJhbmdlKCkpO1xuICAgICAgICAgICAgZWRpdG9yLm11bHRpU2VsZWN0Lm1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21tYW5kLm11bHRpU2VsZWN0QWN0aW9uID09IFwiZm9yRWFjaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlZGl0b3IuZm9yRWFjaFNlbGVjdGlvbihjb21tYW5kLCBlLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24gPT0gXCJmb3JFYWNoTGluZVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlZGl0b3IuZm9yRWFjaFNlbGVjdGlvbihjb21tYW5kLCBlLmFyZ3MsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24gPT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbW1hbmQuZXhlYyhlZGl0b3IsIGUuYXJncyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21tYW5kLm11bHRpU2VsZWN0QWN0aW9uKGVkaXRvciwgZS5hcmdzIHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgdGhpcy5mb3JFYWNoU2VsZWN0aW9uID0gZnVuY3Rpb24gKGNtZCwgYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2VlcE9yZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmtlZXBPcmRlcjtcbiAgICAgICAgdmFyICRieUxpbmVzID0gb3B0aW9ucyA9PSB0cnVlIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy4kYnlMaW5lcztcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIHJhbmdlTGlzdCA9IHNlbGVjdGlvbi5yYW5nZUxpc3Q7XG4gICAgICAgIHZhciByYW5nZXMgPSAoa2VlcE9yZGVyID8gc2VsZWN0aW9uIDogcmFuZ2VMaXN0KS5yYW5nZXM7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBjbWQuZXhlYyA/IGNtZC5leGVjKHRoaXMsIGFyZ3MgfHwge30pIDogY21kKHRoaXMsIGFyZ3MgfHwge30pO1xuICAgICAgICB2YXIgcmVnID0gc2VsZWN0aW9uLl9ldmVudFJlZ2lzdHJ5O1xuICAgICAgICBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnkgPSB7fTtcbiAgICAgICAgdmFyIHRtcFNlbCA9IG5ldyBTZWxlY3Rpb24oc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBpZiAoJGJ5TGluZXMpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgcmFuZ2VzW2ldLnN0YXJ0LnJvdyA9PSByYW5nZXNbaSAtIDFdLmVuZC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcFNlbC5mcm9tT3JpZW50ZWRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICAgICAgdG1wU2VsLmluZGV4ID0gaTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2Vzc2lvbi5zZWxlY3Rpb24gPSB0bXBTZWw7XG4gICAgICAgICAgICB2YXIgY21kUmVzdWx0ID0gY21kLmV4ZWMgPyBjbWQuZXhlYyh0aGlzLCBhcmdzIHx8IHt9KSA6IGNtZCh0aGlzLCBhcmdzIHx8IHt9KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIGNtZFJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNtZFJlc3VsdDtcbiAgICAgICAgICAgIHRtcFNlbC50b09yaWVudGVkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0bXBTZWwuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2Vzc2lvbi5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgICBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnkgPSByZWc7XG4gICAgICAgIHNlbGVjdGlvbi5tZXJnZU92ZXJsYXBwaW5nUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VzWzBdKVxuICAgICAgICAgICAgc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKHNlbGVjdGlvbi5yYW5nZXNbMF0pO1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXMucmVuZGVyZXIuJHNjcm9sbEFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5vbkN1cnNvckNoYW5nZSgpO1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIGlmIChhbmltICYmIGFuaW0uZnJvbSA9PSBhbmltLnRvKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hbmltYXRlU2Nyb2xsaW5nKGFuaW0uZnJvbSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB0aGlzLmV4aXRNdWx0aVNlbGVjdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbk11bHRpU2VsZWN0TW9kZSB8fCB0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3QudG9TaW5nbGVSYW5nZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgIXRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMubXVsdGlTZWxlY3QucmFuZ2VMaXN0LnJhbmdlcztcbiAgICAgICAgICAgIHZhciBidWYgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmLnB1c2godGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBubCA9IHRoaXMuc2Vzc2lvbi5nZXREb2N1bWVudCgpLmdldE5ld0xpbmVDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgIHRleHQgPSBidWYuam9pbihubCk7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gKGJ1Zi5sZW5ndGggLSAxKSAqIG5sLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uIChlLCBhbmNob3IpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgIXRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5tdWx0aVNlbGVjdC5yYW5nZXNbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdC5pc0VtcHR5KCkgJiYgYW5jaG9yID09IHRoaXMubXVsdGlTZWxlY3QuYW5jaG9yKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwb3MgPSBhbmNob3IgPT0gdGhpcy5tdWx0aVNlbGVjdC5hbmNob3JcbiAgICAgICAgICAgICAgICA/IHJhbmdlLmN1cnNvciA9PSByYW5nZS5zdGFydCA/IHJhbmdlLmVuZCA6IHJhbmdlLnN0YXJ0XG4gICAgICAgICAgICAgICAgOiByYW5nZS5jdXJzb3I7XG4gICAgICAgICAgICBpZiAocG9zLnJvdyAhPSBhbmNob3Iucm93XG4gICAgICAgICAgICAgICAgfHwgdGhpcy5zZXNzaW9uLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KHBvcy5yb3csIHBvcy5jb2x1bW4pLmNvbHVtbiAhPSBhbmNob3IuY29sdW1uKVxuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3QudG9TaW5nbGVSYW5nZSh0aGlzLm11bHRpU2VsZWN0LnRvT3JpZW50ZWRSYW5nZSgpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0Lm1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5maW5kQWxsID0gZnVuY3Rpb24gKG5lZWRsZSwgb3B0aW9ucywgYWRkaXRpdmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMubmVlZGxlID0gbmVlZGxlIHx8IG9wdGlvbnMubmVlZGxlO1xuICAgICAgICBpZiAob3B0aW9ucy5uZWVkbGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KClcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2VsZWN0aW9uLmdldFdvcmRSYW5nZSgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgb3B0aW9ucy5uZWVkbGUgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzZWFyY2guc2V0KG9wdGlvbnMpO1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy4kc2VhcmNoLmZpbmRBbGwodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm11bHRpU2VsZWN0O1xuICAgICAgICBpZiAoIWFkZGl0aXZlKVxuICAgICAgICAgICAgc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2VzW2ldLCB0cnVlKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VBdFBvaW50KHJhbmdlLnN0YXJ0KSlcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByYW5nZXMubGVuZ3RoO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RNb3JlTGluZXMgPSBmdW5jdGlvbiAoZGlyLCBza2lwKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSByYW5nZS5jdXJzb3IgPT0gcmFuZ2UuZW5kO1xuICAgICAgICB2YXIgc2NyZWVuTGVhZCA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocmFuZ2UuY3Vyc29yKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLiRkZXNpcmVkQ29sdW1uKVxuICAgICAgICAgICAgc2NyZWVuTGVhZC5jb2x1bW4gPSB0aGlzLnNlbGVjdGlvbi4kZGVzaXJlZENvbHVtbjtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlbkxlYWQucm93ICsgZGlyLCBzY3JlZW5MZWFkLmNvbHVtbik7XG4gICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgc2NyZWVuQW5jaG9yID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihpc0JhY2t3YXJkcyA/IHJhbmdlLmVuZCA6IHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlbkFuY2hvci5yb3cgKyBkaXIsIHNjcmVlbkFuY2hvci5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmFja3dhcmRzKSB7XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGxlYWQsIGFuY2hvcik7XG4gICAgICAgICAgICBuZXdSYW5nZS5jdXJzb3IgPSBuZXdSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdSYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoYW5jaG9yLCBsZWFkKTtcbiAgICAgICAgICAgIG5ld1JhbmdlLmN1cnNvciA9IG5ld1JhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBuZXdSYW5nZS5kZXNpcmVkQ29sdW1uID0gc2NyZWVuTGVhZC5jb2x1bW47XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IHJhbmdlLmN1cnNvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZSk7XG4gICAgICAgIGlmICh0b1JlbW92ZSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnN1YnN0cmFjdFBvaW50KHRvUmVtb3ZlKTtcbiAgICB9O1xuICAgIHRoaXMudHJhbnNwb3NlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWwgPSBzZXNzaW9uLm11bHRpU2VsZWN0O1xuICAgICAgICB2YXIgYWxsID0gc2VsLnJhbmdlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFsbFtpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wXzEgPSBzZXNzaW9uLmdldFdvcmRSYW5nZShyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gdG1wXzEuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRtcF8xLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQucm93ID0gdG1wXzEuZW5kLnJvdztcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gdG1wXzEuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWwubWVyZ2VPdmVybGFwcGluZ1JhbmdlcygpO1xuICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFsbFtpXTtcbiAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQoc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQod29yZHMucG9wKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmRzLnNoaWZ0KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gYWxsLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gYWxsW2ldO1xuICAgICAgICAgICAgdmFyIHRtcCA9IHJhbmdlLmNsb25lKCk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHdvcmRzW2ldKTtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdyA9IHRtcC5zdGFydC5yb3c7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSB0bXAuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHNlbC5mcm9tT3JpZW50ZWRSYW5nZShzZWwucmFuZ2VzWzBdKTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0TW9yZSA9IGZ1bmN0aW9uIChkaXIsIHNraXAsIHN0b3BBdEZpcnN0KSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgc2VsID0gc2Vzc2lvbi5tdWx0aVNlbGVjdDtcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByYW5nZSA9IHNlc3Npb24uZ2V0V29yZFJhbmdlKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IGRpciA9PSAtMSA/IHJhbmdlLnN0YXJ0IDogcmFuZ2UuZW5kO1xuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpZiAoc3RvcEF0Rmlyc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWVkbGUgPSBzZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIHZhciBuZXdSYW5nZSA9IGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpO1xuICAgICAgICBpZiAobmV3UmFuZ2UpIHtcbiAgICAgICAgICAgIG5ld1JhbmdlLmN1cnNvciA9IGRpciA9PSAtMSA/IG5ld1JhbmdlLnN0YXJ0IDogbmV3UmFuZ2UuZW5kO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVuZm9sZChuZXdSYW5nZSk7XG4gICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0LmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcClcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3Quc3Vic3RyYWN0UG9pbnQocmFuZ2UuY3Vyc29yKTtcbiAgICB9O1xuICAgIHRoaXMuYWxpZ25DdXJzb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHNlbCA9IHNlc3Npb24ubXVsdGlTZWxlY3Q7XG4gICAgICAgIHZhciByYW5nZXMgPSBzZWwucmFuZ2VzO1xuICAgICAgICB2YXIgcm93ID0gLTE7XG4gICAgICAgIHZhciBzYW1lUm93UmFuZ2VzID0gcmFuZ2VzLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgaWYgKHIuY3Vyc29yLnJvdyA9PSByb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByb3cgPSByLmN1cnNvci5yb3c7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgc2FtZVJvd1Jhbmdlcy5sZW5ndGggPT0gcmFuZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgZnIgPSByYW5nZS5zdGFydC5yb3csIGxyID0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICAgIHZhciBndWVzc1JhbmdlID0gZnIgPT0gbHI7XG4gICAgICAgICAgICBpZiAoZ3Vlc3NSYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUobHIpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC9bPTpdLy50ZXN0KGxpbmUpICYmICsrbHIgPCBtYXgpO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGZyKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgvWz06XS8udGVzdChsaW5lKSAmJiAtLWZyID4gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZnIgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChsciA+PSBtYXgpXG4gICAgICAgICAgICAgICAgICAgIGxyID0gbWF4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuc2Vzc2lvbi5yZW1vdmVGdWxsTGluZXMoZnIsIGxyKTtcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy4kcmVBbGlnblRleHQobGluZXMsIGd1ZXNzUmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmluc2VydCh7IHJvdzogZnIsIGNvbHVtbjogMCB9LCBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoIWd1ZXNzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzYW1lUm93UmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICBzZWwuc3Vic3RyYWN0UG9pbnQoci5jdXJzb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWF4Q29sID0gMDtcbiAgICAgICAgICAgIHZhciBtaW5TcGFjZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHNwYWNlT2Zmc2V0cyA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHIuY3Vyc29yO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHAucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VPZmZzZXQgPSBsaW5lLnN1YnN0cihwLmNvbHVtbikuc2VhcmNoKC9cXFMvZyk7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzcGFjZU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHAuY29sdW1uID4gbWF4Q29sKVxuICAgICAgICAgICAgICAgICAgICBtYXhDb2wgPSBwLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VPZmZzZXQgPCBtaW5TcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgbWluU3BhY2UgPSBzcGFjZU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSByLmN1cnNvcjtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IG1heENvbCAtIHAuY29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBkID0gc3BhY2VPZmZzZXRzW2ldIC0gbWluU3BhY2U7XG4gICAgICAgICAgICAgICAgaWYgKGwgPiBkKVxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmluc2VydChwLCBsYW5nLnN0cmluZ1JlcGVhdChcIiBcIiwgbCAtIGQpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKG5ldyBSYW5nZShwLnJvdywgcC5jb2x1bW4sIHAucm93LCBwLmNvbHVtbiAtIGwgKyBkKSk7XG4gICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gPSByLmVuZC5jb2x1bW4gPSBtYXhDb2w7XG4gICAgICAgICAgICAgICAgci5zdGFydC5yb3cgPSByLmVuZC5yb3cgPSBwLnJvdztcbiAgICAgICAgICAgICAgICByLmN1cnNvciA9IHIuZW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWwuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJHJlQWxpZ25UZXh0ID0gZnVuY3Rpb24gKGxpbmVzLCBmb3JjZUxlZnQpIHtcbiAgICAgICAgdmFyIGlzTGVmdEFsaWduZWQgPSB0cnVlLCBpc1JpZ2h0QWxpZ25lZCA9IHRydWU7XG4gICAgICAgIHZhciBzdGFydFcsIHRleHRXLCBlbmRXO1xuICAgICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goLyhcXHMqKSguKj8pKFxccyopKFs9Ol0uKikvKTtcbiAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xpbmVdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0VyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRXID0gbVsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGV4dFcgPSBtWzJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlbmRXID0gbVszXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRXICsgdGV4dFcgKyBlbmRXICE9IG1bMV0ubGVuZ3RoICsgbVsyXS5sZW5ndGggKyBtWzNdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpc1JpZ2h0QWxpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0VyAhPSBtWzFdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpc0xlZnRBbGlnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhcnRXID4gbVsxXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgc3RhcnRXID0gbVsxXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGV4dFcgPCBtWzJdLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0ZXh0VyA9IG1bMl0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZFcgPiBtWzNdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBlbmRXID0gbVszXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSkubWFwKGZvcmNlTGVmdCA/IGFsaWduTGVmdCA6XG4gICAgICAgICAgICBpc0xlZnRBbGlnbmVkID8gaXNSaWdodEFsaWduZWQgPyBhbGlnblJpZ2h0IDogYWxpZ25MZWZ0IDogdW5BbGlnbik7XG4gICAgICAgIGZ1bmN0aW9uIHNwYWNlcyhuKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsaWduTGVmdChtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VykgKyBtWzJdXG4gICAgICAgICAgICAgICAgKyBzcGFjZXModGV4dFcgLSBtWzJdLmxlbmd0aCArIGVuZFcpXG4gICAgICAgICAgICAgICAgKyBtWzRdLnJlcGxhY2UoL14oWz06XSlcXHMrLywgXCIkMSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxpZ25SaWdodChtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VyArIHRleHRXIC0gbVsyXS5sZW5ndGgpICsgbVsyXVxuICAgICAgICAgICAgICAgICsgc3BhY2VzKGVuZFcpXG4gICAgICAgICAgICAgICAgKyBtWzRdLnJlcGxhY2UoL14oWz06XSlcXHMrLywgXCIkMSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdW5BbGlnbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VykgKyBtWzJdXG4gICAgICAgICAgICAgICAgKyBzcGFjZXMoZW5kVylcbiAgICAgICAgICAgICAgICArIG1bNF0ucmVwbGFjZSgvXihbPTpdKVxccysvLCBcIiQxIFwiKTtcbiAgICAgICAgfVxuICAgIH07XG59KS5jYWxsKEVkaXRvci5wcm90b3R5cGUpO1xuZnVuY3Rpb24gaXNTYW1lUG9pbnQocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyA9PSBwMi5yb3cgJiYgcDEuY29sdW1uID09IHAyLmNvbHVtbjtcbn1cbmV4cG9ydHMub25TZXNzaW9uQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IGUuc2Vzc2lvbjtcbiAgICBpZiAoc2Vzc2lvbiAmJiAhc2Vzc2lvbi5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzID0gW107XG4gICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLiRpbml0UmFuZ2VMaXN0KCk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QgPSBzZXNzaW9uLnNlbGVjdGlvbjtcbiAgICB9XG4gICAgdGhpcy5tdWx0aVNlbGVjdCA9IHNlc3Npb24gJiYgc2Vzc2lvbi5tdWx0aVNlbGVjdDtcbiAgICB2YXIgb2xkU2Vzc2lvbiA9IGUub2xkU2Vzc2lvbjtcbiAgICBpZiAob2xkU2Vzc2lvbikge1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcImFkZFJhbmdlXCIsIHRoaXMuJG9uQWRkUmFuZ2UpO1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcInJlbW92ZVJhbmdlXCIsIHRoaXMuJG9uUmVtb3ZlUmFuZ2UpO1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcIm11bHRpU2VsZWN0XCIsIHRoaXMuJG9uTXVsdGlTZWxlY3QpO1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcInNpbmdsZVNlbGVjdFwiLCB0aGlzLiRvblNpbmdsZVNlbGVjdCk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3QubGVhZC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3QuYW5jaG9yLm9mZihcImNoYW5nZVwiLCB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcImFkZFJhbmdlXCIsIHRoaXMuJG9uQWRkUmFuZ2UpO1xuICAgICAgICBzZXNzaW9uLm11bHRpU2VsZWN0Lm9uKFwicmVtb3ZlUmFuZ2VcIiwgdGhpcy4kb25SZW1vdmVSYW5nZSk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3Qub24oXCJtdWx0aVNlbGVjdFwiLCB0aGlzLiRvbk11bHRpU2VsZWN0KTtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcInNpbmdsZVNlbGVjdFwiLCB0aGlzLiRvblNpbmdsZVNlbGVjdCk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QubGVhZC5vbihcImNoYW5nZVwiLCB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlKTtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5hbmNob3Iub24oXCJjaGFuZ2VcIiwgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgfVxuICAgIGlmIChzZXNzaW9uICYmIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgIT0gc2Vzc2lvbi5zZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgaWYgKHNlc3Npb24uc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgdGhpcy4kb25NdWx0aVNlbGVjdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRvblNpbmdsZVNlbGVjdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBNdWx0aVNlbGVjdChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGVkaXRvci4kb25BZGRSYW5nZSA9IGVkaXRvci4kb25BZGRSYW5nZS5iaW5kKGVkaXRvcik7XG4gICAgZWRpdG9yLiRvblJlbW92ZVJhbmdlID0gZWRpdG9yLiRvblJlbW92ZVJhbmdlLmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IuJG9uTXVsdGlTZWxlY3QgPSBlZGl0b3IuJG9uTXVsdGlTZWxlY3QuYmluZChlZGl0b3IpO1xuICAgIGVkaXRvci4kb25TaW5nbGVTZWxlY3QgPSBlZGl0b3IuJG9uU2luZ2xlU2VsZWN0LmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IuJG11bHRpc2VsZWN0T25TZXNzaW9uQ2hhbmdlID0gZXhwb3J0cy5vblNlc3Npb25DaGFuZ2UuYmluZChlZGl0b3IpO1xuICAgIGVkaXRvci4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSA9IGVkaXRvci4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZS5iaW5kKGVkaXRvcik7XG4gICAgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZShlZGl0b3IpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlc3Npb25cIiwgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSk7XG4gICAgZWRpdG9yLm9uKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duKTtcbiAgICBlZGl0b3IuY29tbWFuZHMuYWRkQ29tbWFuZHMoY29tbWFuZHMuZGVmYXVsdENvbW1hbmRzKTtcbiAgICBhZGRBbHRDdXJzb3JMaXN0ZW5lcnMoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGFkZEFsdEN1cnNvckxpc3RlbmVycyhlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci50ZXh0SW5wdXQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZWwgPSBlZGl0b3IudGV4dElucHV0LmdldEVsZW1lbnQoKTtcbiAgICB2YXIgYWx0Q3Vyc29yID0gZmFsc2U7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYWx0RG93biA9IGUua2V5Q29kZSA9PSAxOCAmJiAhKGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSk7XG4gICAgICAgIGlmIChlZGl0b3IuJGJsb2NrU2VsZWN0RW5hYmxlZCAmJiBhbHREb3duKSB7XG4gICAgICAgICAgICBpZiAoIWFsdEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zZXRNb3VzZUN1cnNvcihcImNyb3NzaGFpclwiKTtcbiAgICAgICAgICAgICAgICBhbHRDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsdEN1cnNvcikge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwia2V5dXBcIiwgcmVzZXQsIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwiYmx1clwiLCByZXNldCwgZWRpdG9yKTtcbiAgICBmdW5jdGlvbiByZXNldChlKSB7XG4gICAgICAgIGlmIChhbHRDdXJzb3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zZXRNb3VzZUN1cnNvcihcIlwiKTtcbiAgICAgICAgICAgIGFsdEN1cnNvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aVNlbGVjdCA9IE11bHRpU2VsZWN0O1xucmVxdWlyZShcIi4vY29uZmlnXCIpLmRlZmluZU9wdGlvbnMoRWRpdG9yLnByb3RvdHlwZSwgXCJlZGl0b3JcIiwge1xuICAgIGVuYWJsZU11bHRpc2VsZWN0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgTXVsdGlTZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBlbmFibGVCbG9ja1NlbGVjdDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGJsb2NrU2VsZWN0RW5hYmxlZCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICB9XG59KTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS9mb2xkaW5nL2ZvbGRfbW9kZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uLy4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIEZvbGRNb2RlID0gZXhwb3J0cy5Gb2xkTW9kZSA9IGZ1bmN0aW9uICgpIHsgfTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZ2V0Rm9sZFdpZGdldCA9IGZ1bmN0aW9uIChzZXNzaW9uLCBmb2xkU3R5bGUsIHJvdykge1xuICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpO1xuICAgICAgICBpZiAodGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIudGVzdChsaW5lKSlcbiAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgIGlmIChmb2xkU3R5bGUgPT0gXCJtYXJrYmVnaW5lbmRcIlxuICAgICAgICAgICAgJiYgdGhpcy5mb2xkaW5nU3RvcE1hcmtlclxuICAgICAgICAgICAgJiYgdGhpcy5mb2xkaW5nU3RvcE1hcmtlci50ZXN0KGxpbmUpKVxuICAgICAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG4gICAgdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgZm9sZFN0eWxlLCByb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmluZGVudGF0aW9uQmxvY2sgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgcm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHJlID0gL1xcUy87XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBzdGFydExldmVsID0gbGluZS5zZWFyY2gocmUpO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gY29sdW1uIHx8IGxpbmUubGVuZ3RoO1xuICAgICAgICB2YXIgbWF4Um93ID0gc2Vzc2lvbi5nZXRMZW5ndGgoKTtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gcm93O1xuICAgICAgICB2YXIgZW5kUm93ID0gcm93O1xuICAgICAgICB3aGlsZSAoKytyb3cgPCBtYXhSb3cpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHNlc3Npb24uZ2V0TGluZShyb3cpLnNlYXJjaChyZSk7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPD0gc3RhcnRMZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlc3Npb24uZ2V0VG9rZW5BdChyb3csIDApO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRSb3cgPSByb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFJvdyA+IHN0YXJ0Um93KSB7XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2Vzc2lvbi5nZXRMaW5lKGVuZFJvdykubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydFJvdywgc3RhcnRDb2x1bW4sIGVuZFJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuaW5nQnJhY2tldEJsb2NrID0gZnVuY3Rpb24gKHNlc3Npb24sIGJyYWNrZXQsIHJvdywgY29sdW1uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0geyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gKyAxIH07XG4gICAgICAgIHZhciBlbmQgPSBzZXNzaW9uLiRmaW5kQ2xvc2luZ0JyYWNrZXQoYnJhY2tldCwgc3RhcnQsIHR5cGVSZSk7XG4gICAgICAgIGlmICghZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZncgPSBzZXNzaW9uLmZvbGRXaWRnZXRzW2VuZC5yb3ddO1xuICAgICAgICBpZiAoZncgPT0gbnVsbClcbiAgICAgICAgICAgIGZ3ID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0KGVuZC5yb3cpO1xuICAgICAgICBpZiAoZncgPT0gXCJzdGFydFwiICYmIGVuZC5yb3cgPiBzdGFydC5yb3cpIHtcbiAgICAgICAgICAgIGVuZC5yb3ctLTtcbiAgICAgICAgICAgIGVuZC5jb2x1bW4gPSBzZXNzaW9uLmdldExpbmUoZW5kLnJvdykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgdGhpcy5jbG9zaW5nQnJhY2tldEJsb2NrID0gZnVuY3Rpb24gKHNlc3Npb24sIGJyYWNrZXQsIHJvdywgY29sdW1uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIGVuZCA9IHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH07XG4gICAgICAgIHZhciBzdGFydCA9IHNlc3Npb24uJGZpbmRPcGVuaW5nQnJhY2tldChicmFja2V0LCBlbmQpO1xuICAgICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGFydC5jb2x1bW4rKztcbiAgICAgICAgZW5kLmNvbHVtbi0tO1xuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgZW5kKTtcbiAgICB9O1xufSkuY2FsbChGb2xkTW9kZS5wcm90b3R5cGUpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9leHQvZXJyb3JfbWFya2VyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGluZV93aWRnZXRzXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvY29uZmlnXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIExpbmVXaWRnZXRzID0gcmVxdWlyZShcIi4uL2xpbmVfd2lkZ2V0c1wiKS5MaW5lV2lkZ2V0cztcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBubHMgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpLm5scztcbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwgbmVlZGxlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGZpcnN0ID0gMDtcbiAgICB2YXIgbGFzdCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGZpcnN0IDw9IGxhc3QpIHtcbiAgICAgICAgdmFyIG1pZCA9IChmaXJzdCArIGxhc3QpID4+IDE7XG4gICAgICAgIHZhciBjID0gY29tcGFyYXRvcihuZWVkbGUsIGFycmF5W21pZF0pO1xuICAgICAgICBpZiAoYyA+IDApXG4gICAgICAgICAgICBmaXJzdCA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAwKVxuICAgICAgICAgICAgbGFzdCA9IG1pZCAtIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIHJldHVybiAtKGZpcnN0ICsgMSk7XG59XG5mdW5jdGlvbiBmaW5kQW5ub3RhdGlvbnMoc2Vzc2lvbiwgcm93LCBkaXIpIHtcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBzZXNzaW9uLmdldEFubm90YXRpb25zKCkuc29ydChSYW5nZS5jb21wYXJlUG9pbnRzKTtcbiAgICBpZiAoIWFubm90YXRpb25zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBpID0gYmluYXJ5U2VhcmNoKGFubm90YXRpb25zLCB7IHJvdzogcm93LCBjb2x1bW46IC0xIH0sIFJhbmdlLmNvbXBhcmVQb2ludHMpO1xuICAgIGlmIChpIDwgMClcbiAgICAgICAgaSA9IC1pIC0gMTtcbiAgICBpZiAoaSA+PSBhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgICAgIGkgPSBkaXIgPiAwID8gMCA6IGFubm90YXRpb25zLmxlbmd0aCAtIDE7XG4gICAgZWxzZSBpZiAoaSA9PT0gMCAmJiBkaXIgPCAwKVxuICAgICAgICBpID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xuICAgIGlmICghYW5ub3RhdGlvbiB8fCAhZGlyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGFubm90YXRpb24ucm93ID09PSByb3cpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2kgKz0gZGlyXTtcbiAgICAgICAgfSB3aGlsZSAoYW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9uLnJvdyA9PT0gcm93KTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zLnNsaWNlKCk7XG4gICAgfVxuICAgIHZhciBtYXRjaGVkID0gW107XG4gICAgcm93ID0gYW5ub3RhdGlvbi5yb3c7XG4gICAgZG8ge1xuICAgICAgICBtYXRjaGVkW2RpciA8IDAgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiXShhbm5vdGF0aW9uKTtcbiAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2kgKz0gZGlyXTtcbiAgICB9IHdoaWxlIChhbm5vdGF0aW9uICYmIGFubm90YXRpb24ucm93ID09IHJvdyk7XG4gICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoICYmIG1hdGNoZWQ7XG59XG5leHBvcnRzLnNob3dFcnJvck1hcmtlciA9IGZ1bmN0aW9uIChlZGl0b3IsIGRpcikge1xuICAgIHZhciBzZXNzaW9uID0gZWRpdG9yLnNlc3Npb247XG4gICAgaWYgKCFzZXNzaW9uLndpZGdldE1hbmFnZXIpIHtcbiAgICAgICAgc2Vzc2lvbi53aWRnZXRNYW5hZ2VyID0gbmV3IExpbmVXaWRnZXRzKHNlc3Npb24pO1xuICAgICAgICBzZXNzaW9uLndpZGdldE1hbmFnZXIuYXR0YWNoKGVkaXRvcik7XG4gICAgfVxuICAgIHZhciBwb3MgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgcm93ID0gcG9zLnJvdztcbiAgICB2YXIgb2xkV2lkZ2V0ID0gc2Vzc2lvbi53aWRnZXRNYW5hZ2VyLmdldFdpZGdldHNBdFJvdyhyb3cpLmZpbHRlcihmdW5jdGlvbiAodykge1xuICAgICAgICByZXR1cm4gdy50eXBlID09IFwiZXJyb3JNYXJrZXJcIjtcbiAgICB9KVswXTtcbiAgICBpZiAob2xkV2lkZ2V0KSB7XG4gICAgICAgIG9sZFdpZGdldC5kZXN0cm95KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByb3cgLT0gZGlyO1xuICAgIH1cbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBmaW5kQW5ub3RhdGlvbnMoc2Vzc2lvbiwgcm93LCBkaXIpO1xuICAgIHZhciBndXR0ZXJBbm5vO1xuICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zWzBdO1xuICAgICAgICBwb3MuY29sdW1uID0gKGFubm90YXRpb24ucG9zICYmIHR5cGVvZiBhbm5vdGF0aW9uLmNvbHVtbiAhPSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IGFubm90YXRpb24ucG9zLnNjXG4gICAgICAgICAgICA6IGFubm90YXRpb24uY29sdW1uKSB8fCAwO1xuICAgICAgICBwb3Mucm93ID0gYW5ub3RhdGlvbi5yb3c7XG4gICAgICAgIGd1dHRlckFubm8gPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLiRhbm5vdGF0aW9uc1twb3Mucm93XTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2xkV2lkZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGd1dHRlckFubm8gPSB7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogW25scyhcImVycm9yLW1hcmtlci5nb29kLXN0YXRlXCIsIFwiTG9va3MgZ29vZCFcIildLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImFjZV9va1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVkaXRvci5zZXNzaW9uLnVuZm9sZChwb3Mucm93KTtcbiAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHBvcyk7XG4gICAgdmFyIHcgPSB7XG4gICAgICAgIHJvdzogcG9zLnJvdyxcbiAgICAgICAgZml4ZWRXaWR0aDogdHJ1ZSxcbiAgICAgICAgY292ZXJHdXR0ZXI6IHRydWUsXG4gICAgICAgIGVsOiBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgdHlwZTogXCJlcnJvck1hcmtlclwiXG4gICAgfTtcbiAgICB2YXIgZWwgPSB3LmVsLmFwcGVuZENoaWxkKGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB2YXIgYXJyb3cgPSB3LmVsLmFwcGVuZENoaWxkKGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBcImVycm9yX3dpZGdldF9hcnJvdyBcIiArIGd1dHRlckFubm8uY2xhc3NOYW1lO1xuICAgIHZhciBsZWZ0ID0gZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllclxuICAgICAgICAuZ2V0UGl4ZWxQb3NpdGlvbihwb3MpLmxlZnQ7XG4gICAgYXJyb3cuc3R5bGUubGVmdCA9IGxlZnQgKyBlZGl0b3IucmVuZGVyZXIuZ3V0dGVyV2lkdGggLSA1ICsgXCJweFwiO1xuICAgIHcuZWwuY2xhc3NOYW1lID0gXCJlcnJvcl93aWRnZXRfd3JhcHBlclwiO1xuICAgIGVsLmNsYXNzTmFtZSA9IFwiZXJyb3Jfd2lkZ2V0IFwiICsgZ3V0dGVyQW5uby5jbGFzc05hbWU7XG4gICAgZ3V0dGVyQW5uby5kaXNwbGF5VGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChhbm5vVGV4dExpbmUsIGkpIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZVRleHROb2RlKGFubm9UZXh0TGluZSkpO1xuICAgICAgICBpZiAoaSA8IGd1dHRlckFubm8uZGlzcGxheVRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBlbC5hcHBlbmRDaGlsZChkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgdmFyIGtiID0gZnVuY3Rpb24gKF8sIGhhc2hJZCwga2V5U3RyaW5nKSB7XG4gICAgICAgIGlmIChoYXNoSWQgPT09IDAgJiYgKGtleVN0cmluZyA9PT0gXCJlc2NcIiB8fCBrZXlTdHJpbmcgPT09IFwicmV0dXJuXCIpKSB7XG4gICAgICAgICAgICB3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbW1hbmQ6IFwibnVsbFwiIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHcuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVkaXRvci4kbW91c2VIYW5kbGVyLmlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlZGl0b3Iua2V5QmluZGluZy5yZW1vdmVLZXlib2FyZEhhbmRsZXIoa2IpO1xuICAgICAgICBzZXNzaW9uLndpZGdldE1hbmFnZXIucmVtb3ZlTGluZVdpZGdldCh3KTtcbiAgICAgICAgZWRpdG9yLm9mZihcImNoYW5nZVNlbGVjdGlvblwiLCB3LmRlc3Ryb3kpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwiY2hhbmdlU2Vzc2lvblwiLCB3LmRlc3Ryb3kpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwibW91c2V1cFwiLCB3LmRlc3Ryb3kpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwiY2hhbmdlXCIsIHcuZGVzdHJveSk7XG4gICAgfTtcbiAgICBlZGl0b3Iua2V5QmluZGluZy5hZGRLZXlib2FyZEhhbmRsZXIoa2IpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlbGVjdGlvblwiLCB3LmRlc3Ryb3kpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlc3Npb25cIiwgdy5kZXN0cm95KTtcbiAgICBlZGl0b3Iub24oXCJtb3VzZXVwXCIsIHcuZGVzdHJveSk7XG4gICAgZWRpdG9yLm9uKFwiY2hhbmdlXCIsIHcuZGVzdHJveSk7XG4gICAgZWRpdG9yLnNlc3Npb24ud2lkZ2V0TWFuYWdlci5hZGRMaW5lV2lkZ2V0KHcpO1xuICAgIHcuZWwub25tb3VzZWRvd24gPSBlZGl0b3IuZm9jdXMuYmluZChlZGl0b3IpO1xuICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUsIHsgYm90dG9tOiB3LmVsLm9mZnNldEhlaWdodCB9KTtcbn07XG5kb20uaW1wb3J0Q3NzU3RyaW5nKFwiXFxuICAgIC5lcnJvcl93aWRnZXRfd3JhcHBlciB7XFxuICAgICAgICBiYWNrZ3JvdW5kOiBpbmhlcml0O1xcbiAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICBib3JkZXI6bm9uZVxcbiAgICB9XFxuICAgIC5lcnJvcl93aWRnZXQge1xcbiAgICAgICAgYm9yZGVyLXRvcDogc29saWQgMnB4O1xcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogc29saWQgMnB4O1xcbiAgICAgICAgbWFyZ2luOiA1cHggMDtcXG4gICAgICAgIHBhZGRpbmc6IDEwcHggNDBweDtcXG4gICAgICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gICAgfVxcbiAgICAuZXJyb3Jfd2lkZ2V0LmFjZV9lcnJvciwgLmVycm9yX3dpZGdldF9hcnJvdy5hY2VfZXJyb3J7XFxuICAgICAgICBib3JkZXItY29sb3I6ICNmZjVhNWFcXG4gICAgfVxcbiAgICAuZXJyb3Jfd2lkZ2V0LmFjZV93YXJuaW5nLCAuZXJyb3Jfd2lkZ2V0X2Fycm93LmFjZV93YXJuaW5ne1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjRjFEODE3XFxuICAgIH1cXG4gICAgLmVycm9yX3dpZGdldC5hY2VfaW5mbywgLmVycm9yX3dpZGdldF9hcnJvdy5hY2VfaW5mb3tcXG4gICAgICAgIGJvcmRlci1jb2xvcjogIzVhNWE1YVxcbiAgICB9XFxuICAgIC5lcnJvcl93aWRnZXQuYWNlX29rLCAuZXJyb3Jfd2lkZ2V0X2Fycm93LmFjZV9va3tcXG4gICAgICAgIGJvcmRlci1jb2xvcjogIzVhYWE1YVxcbiAgICB9XFxuICAgIC5lcnJvcl93aWRnZXRfYXJyb3cge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgYm9yZGVyOiBzb2xpZCA1cHg7XFxuICAgICAgICBib3JkZXItdG9wLWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxuICAgICAgICBib3JkZXItcmlnaHQtY29sb3I6IHRyYW5zcGFyZW50IWltcG9ydGFudDtcXG4gICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxuICAgICAgICB0b3A6IC01cHg7XFxuICAgIH1cXG5cIiwgXCJlcnJvcl9tYXJrZXIuY3NzXCIsIGZhbHNlKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYWNlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvZWRpdG9yXCIsXCJhY2UvZWRpdF9zZXNzaW9uXCIsXCJhY2UvdW5kb21hbmFnZXJcIixcImFjZS92aXJ0dWFsX3JlbmRlcmVyXCIsXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcIixcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIixcImFjZS9wbGFjZWhvbGRlclwiLFwiYWNlL211bHRpX3NlbGVjdFwiLFwiYWNlL21vZGUvZm9sZGluZy9mb2xkX21vZGVcIixcImFjZS90aGVtZS90ZXh0bWF0ZVwiLFwiYWNlL2V4dC9lcnJvcl9tYXJrZXJcIixcImFjZS9jb25maWdcIixcImFjZS9sb2FkZXJfYnVpbGRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7LyoqXG4gKiBUaGUgbWFpbiBjbGFzcyByZXF1aXJlZCB0byBzZXQgdXAgYW4gQWNlIGluc3RhbmNlIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBuYW1lc3BhY2UgQWNlXG4gKiovXG5cInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoXCIuL2xvYWRlcl9idWlsZFwiKShleHBvcnRzKVxudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBFZGl0b3IgPSByZXF1aXJlKFwiLi9lZGl0b3JcIikuRWRpdG9yO1xudmFyIEVkaXRTZXNzaW9uID0gcmVxdWlyZShcIi4vZWRpdF9zZXNzaW9uXCIpLkVkaXRTZXNzaW9uO1xudmFyIFVuZG9NYW5hZ2VyID0gcmVxdWlyZShcIi4vdW5kb21hbmFnZXJcIikuVW5kb01hbmFnZXI7XG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKFwiLi92aXJ0dWFsX3JlbmRlcmVyXCIpLlZpcnR1YWxSZW5kZXJlcjtcbnJlcXVpcmUoXCIuL3dvcmtlci93b3JrZXJfY2xpZW50XCIpO1xucmVxdWlyZShcIi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIpO1xucmVxdWlyZShcIi4vcGxhY2Vob2xkZXJcIik7XG5yZXF1aXJlKFwiLi9tdWx0aV9zZWxlY3RcIik7XG5yZXF1aXJlKFwiLi9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXCIpO1xucmVxdWlyZShcIi4vdGhlbWUvdGV4dG1hdGVcIik7XG5yZXF1aXJlKFwiLi9leHQvZXJyb3JfbWFya2VyXCIpO1xuZXhwb3J0cy5jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5leHBvcnRzLmVkaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGVsID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIF9pZCA9IGVsO1xuICAgICAgICBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF9pZCk7XG4gICAgICAgIGlmICghZWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhY2UuZWRpdCBjYW4ndCBmaW5kIGRpdiAjXCIgKyBfaWQpO1xuICAgIH1cbiAgICBpZiAoZWwgJiYgZWwuZW52ICYmIGVsLmVudi5lZGl0b3IgaW5zdGFuY2VvZiBFZGl0b3IpXG4gICAgICAgIHJldHVybiBlbC5lbnYuZWRpdG9yO1xuICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgaWYgKGVsICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZWwudGFnTmFtZSkpIHtcbiAgICAgICAgdmFyIG9sZE5vZGUgPSBlbDtcbiAgICAgICAgdmFsdWUgPSBvbGROb2RlLnZhbHVlO1xuICAgICAgICBlbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsLCBvbGROb2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgdmFsdWUgPSBlbC50ZXh0Q29udGVudDtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9XG4gICAgdmFyIGRvYyA9IGV4cG9ydHMuY3JlYXRlRWRpdFNlc3Npb24odmFsdWUpO1xuICAgIHZhciBlZGl0b3IgPSBuZXcgRWRpdG9yKG5ldyBSZW5kZXJlcihlbCksIGRvYywgb3B0aW9ucyk7XG4gICAgdmFyIGVudiA9IHtcbiAgICAgICAgZG9jdW1lbnQ6IGRvYyxcbiAgICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICAgIG9uUmVzaXplOiBlZGl0b3IucmVzaXplLmJpbmQoZWRpdG9yLCBudWxsKVxuICAgIH07XG4gICAgaWYgKG9sZE5vZGUpXG4gICAgICAgIGVudi50ZXh0YXJlYSA9IG9sZE5vZGU7XG4gICAgZWRpdG9yLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVudi5lZGl0b3IuY29udGFpbmVyLmVudiA9IG51bGw7IC8vIHByZXZlbnQgbWVtb3J5IGxlYWsgb24gb2xkIGllXG4gICAgfSk7XG4gICAgZWRpdG9yLmNvbnRhaW5lci5lbnYgPSBlZGl0b3IuZW52ID0gZW52O1xuICAgIHJldHVybiBlZGl0b3I7XG59O1xuZXhwb3J0cy5jcmVhdGVFZGl0U2Vzc2lvbiA9IGZ1bmN0aW9uICh0ZXh0LCBtb2RlKSB7XG4gICAgdmFyIGRvYyA9IG5ldyBFZGl0U2Vzc2lvbih0ZXh0LCBtb2RlKTtcbiAgICBkb2Muc2V0VW5kb01hbmFnZXIobmV3IFVuZG9NYW5hZ2VyKCkpO1xuICAgIHJldHVybiBkb2M7XG59O1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5FZGl0b3IgPSBFZGl0b3I7XG5leHBvcnRzLkVkaXRTZXNzaW9uID0gRWRpdFNlc3Npb247XG5leHBvcnRzLlVuZG9NYW5hZ2VyID0gVW5kb01hbmFnZXI7XG5leHBvcnRzLlZpcnR1YWxSZW5kZXJlciA9IFJlbmRlcmVyO1xuZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy5jb25maWcudmVyc2lvbjtcblxufSk7ICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFjZS5yZXF1aXJlKFtcImFjZS9hY2VcIl0sIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuY29uZmlnLmluaXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmRlZmluZSA9IGFjZS5kZWZpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdsb2JhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnbG9iYWwgJiYgdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKSBnbG9iYWwgPSB3aW5kb3c7IC8vIGNhbiBoYXBwZW4gaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnbG9iYWwgJiYgdHlwZW9mIHNlbGYgIT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsID0gc2VsZjsgLy8gY2FuIGhhcHBlbiBpbiB3ZWJ3b3JrZXJcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsLmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hY2UgPSBhO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hY2Vba2V5XSA9IGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmFjZVtcImRlZmF1bHRcIl0gPSBnbG9iYWwuYWNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5hY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ace-builds/src-noconflict/ace.js\n");

/***/ }),

/***/ "./node_modules/ace-builds/src-noconflict/ext-split.js":
/*!*************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/ext-split.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nace.define(\"ace/split\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/editor\",\"ace/virtual_renderer\",\"ace/edit_session\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Editor = require(\"./editor\").Editor;\nvar Renderer = require(\"./virtual_renderer\").VirtualRenderer;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar Split;\nSplit = function (container, theme, splits) {\n    this.BELOW = 1;\n    this.BESIDE = 0;\n    this.$container = container;\n    this.$theme = theme;\n    this.$splits = 0;\n    this.$editorCSS = \"\";\n    this.$editors = [];\n    this.$orientation = this.BESIDE;\n    this.setSplits(splits || 1);\n    this.$cEditor = this.$editors[0];\n    this.on(\"focus\", function (editor) {\n        this.$cEditor = editor;\n    }.bind(this));\n};\n(function () {\n    oop.implement(this, EventEmitter);\n    this.$createEditor = function () {\n        var el = document.createElement(\"div\");\n        el.className = this.$editorCSS;\n        el.style.cssText = \"position: absolute; top:0px; bottom:0px\";\n        this.$container.appendChild(el);\n        var editor = new Editor(new Renderer(el, this.$theme));\n        editor.on(\"focus\", function () {\n            this._emit(\"focus\", editor);\n        }.bind(this));\n        this.$editors.push(editor);\n        editor.setFontSize(this.$fontSize);\n        return editor;\n    };\n    this.setSplits = function (splits) {\n        var editor;\n        if (splits < 1) {\n            throw \"The number of splits have to be > 0!\";\n        }\n        if (splits == this.$splits) {\n            return;\n        }\n        else if (splits > this.$splits) {\n            while (this.$splits < this.$editors.length && this.$splits < splits) {\n                editor = this.$editors[this.$splits];\n                this.$container.appendChild(editor.container);\n                editor.setFontSize(this.$fontSize);\n                this.$splits++;\n            }\n            while (this.$splits < splits) {\n                this.$createEditor();\n                this.$splits++;\n            }\n        }\n        else {\n            while (this.$splits > splits) {\n                editor = this.$editors[this.$splits - 1];\n                this.$container.removeChild(editor.container);\n                this.$splits--;\n            }\n        }\n        this.resize();\n    };\n    this.getSplits = function () {\n        return this.$splits;\n    };\n    this.getEditor = function (idx) {\n        return this.$editors[idx];\n    };\n    this.getCurrentEditor = function () {\n        return this.$cEditor;\n    };\n    this.focus = function () {\n        this.$cEditor.focus();\n    };\n    this.blur = function () {\n        this.$cEditor.blur();\n    };\n    this.setTheme = function (theme) {\n        this.$editors.forEach(function (editor) {\n            editor.setTheme(theme);\n        });\n    };\n    this.setKeyboardHandler = function (keybinding) {\n        this.$editors.forEach(function (editor) {\n            editor.setKeyboardHandler(keybinding);\n        });\n    };\n    this.forEach = function (callback, scope) {\n        this.$editors.forEach(callback, scope);\n    };\n    this.$fontSize = \"\";\n    this.setFontSize = function (size) {\n        this.$fontSize = size;\n        this.forEach(function (editor) {\n            editor.setFontSize(size);\n        });\n    };\n    this.$cloneSession = function (session) {\n        var s = new EditSession(session.getDocument(), session.getMode());\n        var undoManager = session.getUndoManager();\n        s.setUndoManager(undoManager);\n        s.setTabSize(session.getTabSize());\n        s.setUseSoftTabs(session.getUseSoftTabs());\n        s.setOverwrite(session.getOverwrite());\n        s.setBreakpoints(session.getBreakpoints());\n        s.setUseWrapMode(session.getUseWrapMode());\n        s.setUseWorker(session.getUseWorker());\n        s.setWrapLimitRange(session.$wrapLimitRange.min, session.$wrapLimitRange.max);\n        s.$foldData = session.$cloneFoldData();\n        return s;\n    };\n    this.setSession = function (session, idx) {\n        var editor;\n        if (idx == null) {\n            editor = this.$cEditor;\n        }\n        else {\n            editor = this.$editors[idx];\n        }\n        var isUsed = this.$editors.some(function (editor) {\n            return editor.session === session;\n        });\n        if (isUsed) {\n            session = this.$cloneSession(session);\n        }\n        editor.setSession(session);\n        return session;\n    };\n    this.getOrientation = function () {\n        return this.$orientation;\n    };\n    this.setOrientation = function (orientation) {\n        if (this.$orientation == orientation) {\n            return;\n        }\n        this.$orientation = orientation;\n        this.resize();\n    };\n    this.resize = function () {\n        var width = this.$container.clientWidth;\n        var height = this.$container.clientHeight;\n        var editor;\n        if (this.$orientation == this.BESIDE) {\n            var editorWidth = width / this.$splits;\n            for (var i = 0; i < this.$splits; i++) {\n                editor = this.$editors[i];\n                editor.container.style.width = editorWidth + \"px\";\n                editor.container.style.top = \"0px\";\n                editor.container.style.left = i * editorWidth + \"px\";\n                editor.container.style.height = height + \"px\";\n                editor.resize();\n            }\n        }\n        else {\n            var editorHeight = height / this.$splits;\n            for (var i = 0; i < this.$splits; i++) {\n                editor = this.$editors[i];\n                editor.container.style.width = width + \"px\";\n                editor.container.style.top = i * editorHeight + \"px\";\n                editor.container.style.left = \"0px\";\n                editor.container.style.height = editorHeight + \"px\";\n                editor.resize();\n            }\n        }\n    };\n}).call(Split.prototype);\nexports.Split = Split;\n\n});\n\nace.define(\"ace/ext/split\",[\"require\",\"exports\",\"module\",\"ace/split\"], function(require, exports, module){\"use strict\";\nmodule.exports = require(\"../split\");\n\n});                (function() {\n                    ace.require([\"ace/ext/split\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9leHQtc3BsaXQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2FjZS1idWlsZHMvc3JjLW5vY29uZmxpY3QvZXh0LXNwbGl0LmpzP2ZiZTkiXSwic291cmNlc0NvbnRlbnQiOlsiYWNlLmRlZmluZShcImFjZS9zcGxpdFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvZWRpdG9yXCIsXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiLFwiYWNlL2VkaXRfc2Vzc2lvblwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgRWRpdG9yID0gcmVxdWlyZShcIi4vZWRpdG9yXCIpLkVkaXRvcjtcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoXCIuL3ZpcnR1YWxfcmVuZGVyZXJcIikuVmlydHVhbFJlbmRlcmVyO1xudmFyIEVkaXRTZXNzaW9uID0gcmVxdWlyZShcIi4vZWRpdF9zZXNzaW9uXCIpLkVkaXRTZXNzaW9uO1xudmFyIFNwbGl0O1xuU3BsaXQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCB0aGVtZSwgc3BsaXRzKSB7XG4gICAgdGhpcy5CRUxPVyA9IDE7XG4gICAgdGhpcy5CRVNJREUgPSAwO1xuICAgIHRoaXMuJGNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiR0aGVtZSA9IHRoZW1lO1xuICAgIHRoaXMuJHNwbGl0cyA9IDA7XG4gICAgdGhpcy4kZWRpdG9yQ1NTID0gXCJcIjtcbiAgICB0aGlzLiRlZGl0b3JzID0gW107XG4gICAgdGhpcy4kb3JpZW50YXRpb24gPSB0aGlzLkJFU0lERTtcbiAgICB0aGlzLnNldFNwbGl0cyhzcGxpdHMgfHwgMSk7XG4gICAgdGhpcy4kY0VkaXRvciA9IHRoaXMuJGVkaXRvcnNbMF07XG4gICAgdGhpcy5vbihcImZvY3VzXCIsIGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgdGhpcy4kY0VkaXRvciA9IGVkaXRvcjtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcbihmdW5jdGlvbiAoKSB7XG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuICAgIHRoaXMuJGNyZWF0ZUVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdGhpcy4kZWRpdG9yQ1NTO1xuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDowcHg7IGJvdHRvbTowcHhcIjtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIGVkaXRvciA9IG5ldyBFZGl0b3IobmV3IFJlbmRlcmVyKGVsLCB0aGlzLiR0aGVtZSkpO1xuICAgICAgICBlZGl0b3Iub24oXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiZm9jdXNcIiwgZWRpdG9yKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy4kZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5zZXRGb250U2l6ZSh0aGlzLiRmb250U2l6ZSk7XG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfTtcbiAgICB0aGlzLnNldFNwbGl0cyA9IGZ1bmN0aW9uIChzcGxpdHMpIHtcbiAgICAgICAgdmFyIGVkaXRvcjtcbiAgICAgICAgaWYgKHNwbGl0cyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IFwiVGhlIG51bWJlciBvZiBzcGxpdHMgaGF2ZSB0byBiZSA+IDAhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0cyA9PSB0aGlzLiRzcGxpdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcGxpdHMgPiB0aGlzLiRzcGxpdHMpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiRzcGxpdHMgPCB0aGlzLiRlZGl0b3JzLmxlbmd0aCAmJiB0aGlzLiRzcGxpdHMgPCBzcGxpdHMpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IgPSB0aGlzLiRlZGl0b3JzW3RoaXMuJHNwbGl0c107XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKGVkaXRvci5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRGb250U2l6ZSh0aGlzLiRmb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4kc3BsaXRzIDwgc3BsaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4kc3BsaXRzID4gc3BsaXRzKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yID0gdGhpcy4kZWRpdG9yc1t0aGlzLiRzcGxpdHMgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2hpbGQoZWRpdG9yLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXRzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U3BsaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3BsaXRzO1xuICAgIH07XG4gICAgdGhpcy5nZXRFZGl0b3IgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlZGl0b3JzW2lkeF07XG4gICAgfTtcbiAgICB0aGlzLmdldEN1cnJlbnRFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjRWRpdG9yO1xuICAgIH07XG4gICAgdGhpcy5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kY0VkaXRvci5mb2N1cygpO1xuICAgIH07XG4gICAgdGhpcy5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRjRWRpdG9yLmJsdXIoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VGhlbWUgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgICAgdGhpcy4kZWRpdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbiAoa2V5YmluZGluZykge1xuICAgICAgICB0aGlzLiRlZGl0b3JzLmZvckVhY2goZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnNldEtleWJvYXJkSGFuZGxlcihrZXliaW5kaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuJGVkaXRvcnMuZm9yRWFjaChjYWxsYmFjaywgc2NvcGUpO1xuICAgIH07XG4gICAgdGhpcy4kZm9udFNpemUgPSBcIlwiO1xuICAgIHRoaXMuc2V0Rm9udFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB0aGlzLiRmb250U2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Rm9udFNpemUoc2l6ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy4kY2xvbmVTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgRWRpdFNlc3Npb24oc2Vzc2lvbi5nZXREb2N1bWVudCgpLCBzZXNzaW9uLmdldE1vZGUoKSk7XG4gICAgICAgIHZhciB1bmRvTWFuYWdlciA9IHNlc3Npb24uZ2V0VW5kb01hbmFnZXIoKTtcbiAgICAgICAgcy5zZXRVbmRvTWFuYWdlcih1bmRvTWFuYWdlcik7XG4gICAgICAgIHMuc2V0VGFiU2l6ZShzZXNzaW9uLmdldFRhYlNpemUoKSk7XG4gICAgICAgIHMuc2V0VXNlU29mdFRhYnMoc2Vzc2lvbi5nZXRVc2VTb2Z0VGFicygpKTtcbiAgICAgICAgcy5zZXRPdmVyd3JpdGUoc2Vzc2lvbi5nZXRPdmVyd3JpdGUoKSk7XG4gICAgICAgIHMuc2V0QnJlYWtwb2ludHMoc2Vzc2lvbi5nZXRCcmVha3BvaW50cygpKTtcbiAgICAgICAgcy5zZXRVc2VXcmFwTW9kZShzZXNzaW9uLmdldFVzZVdyYXBNb2RlKCkpO1xuICAgICAgICBzLnNldFVzZVdvcmtlcihzZXNzaW9uLmdldFVzZVdvcmtlcigpKTtcbiAgICAgICAgcy5zZXRXcmFwTGltaXRSYW5nZShzZXNzaW9uLiR3cmFwTGltaXRSYW5nZS5taW4sIHNlc3Npb24uJHdyYXBMaW1pdFJhbmdlLm1heCk7XG4gICAgICAgIHMuJGZvbGREYXRhID0gc2Vzc2lvbi4kY2xvbmVGb2xkRGF0YSgpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHRoaXMuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uLCBpZHgpIHtcbiAgICAgICAgdmFyIGVkaXRvcjtcbiAgICAgICAgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlZGl0b3IgPSB0aGlzLiRjRWRpdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWRpdG9yID0gdGhpcy4kZWRpdG9yc1tpZHhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc1VzZWQgPSB0aGlzLiRlZGl0b3JzLnNvbWUoZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5zZXNzaW9uID09PSBzZXNzaW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzVXNlZCkge1xuICAgICAgICAgICAgc2Vzc2lvbiA9IHRoaXMuJGNsb25lU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfTtcbiAgICB0aGlzLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kb3JpZW50YXRpb247XG4gICAgfTtcbiAgICB0aGlzLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLiRvcmllbnRhdGlvbiA9PSBvcmllbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy4kY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy4kY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGVkaXRvcjtcbiAgICAgICAgaWYgKHRoaXMuJG9yaWVudGF0aW9uID09IHRoaXMuQkVTSURFKSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yV2lkdGggPSB3aWR0aCAvIHRoaXMuJHNwbGl0cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kc3BsaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IgPSB0aGlzLiRlZGl0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIuc3R5bGUud2lkdGggPSBlZGl0b3JXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY29udGFpbmVyLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gaSAqIGVkaXRvcldpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZXNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3JIZWlnaHQgPSBoZWlnaHQgLyB0aGlzLiRzcGxpdHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHNwbGl0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yID0gdGhpcy4kZWRpdG9yc1tpXTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNvbnRhaW5lci5zdHlsZS50b3AgPSBpICogZWRpdG9ySGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBlZGl0b3JIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlc2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pLmNhbGwoU3BsaXQucHJvdG90eXBlKTtcbmV4cG9ydHMuU3BsaXQgPSBTcGxpdDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZXh0L3NwbGl0XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2Uvc3BsaXRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9zcGxpdFwiKTtcblxufSk7ICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNlLnJlcXVpcmUoW1wiYWNlL2V4dC9zcGxpdFwiXSwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ace-builds/src-noconflict/ext-split.js\n");

/***/ }),

/***/ "./node_modules/diff-match-patch/index.js":
/*!************************************************!*\
  !*** ./node_modules/diff-match-patch/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports.diff_match_patch = diff_match_patch;\nmodule.exports.DIFF_DELETE = DIFF_DELETE;\nmodule.exports.DIFF_INSERT = DIFF_INSERT;\nmodule.exports.DIFF_EQUAL = DIFF_EQUAL;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gvaW5kZXguanM/NjQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgZGlmZi1tYXRjaC1wYXRjaCBBdXRob3JzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9kaWZmLW1hdGNoLXBhdGNoXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGV4dHMgdG8gY3JlYXRlIGEgcGF0Y2guXG4gKiBBcHBsaWVzIHRoZSBwYXRjaCBvbnRvIGFub3RoZXIgdGV4dCwgYWxsb3dpbmcgZm9yIGVycm9ycy5cbiAqIEBhdXRob3IgZnJhc2VyQGdvb2dsZS5jb20gKE5laWwgRnJhc2VyKVxuICovXG5cbi8qKlxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIGRpZmZfbWF0Y2hfcGF0Y2ggPSBmdW5jdGlvbigpIHtcblxuICAvLyBEZWZhdWx0cy5cbiAgLy8gUmVkZWZpbmUgdGhlc2UgaW4geW91ciBwcm9ncmFtIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cblxuICAvLyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cbiAgdGhpcy5EaWZmX1RpbWVvdXQgPSAxLjA7XG4gIC8vIENvc3Qgb2YgYW4gZW1wdHkgZWRpdCBvcGVyYXRpb24gaW4gdGVybXMgb2YgZWRpdCBjaGFyYWN0ZXJzLlxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xuICAvLyBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cbiAgdGhpcy5NYXRjaF9UaHJlc2hvbGQgPSAwLjU7XG4gIC8vIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAvLyBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgLy8gMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gIHRoaXMuTWF0Y2hfRGlzdGFuY2UgPSAxMDAwO1xuICAvLyBXaGVuIGRlbGV0aW5nIGEgbGFyZ2UgYmxvY2sgb2YgdGV4dCAob3ZlciB+NjQgY2hhcmFjdGVycyksIGhvdyBjbG9zZSBkb1xuICAvLyB0aGUgY29udGVudHMgaGF2ZSB0byBiZSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgY29udGVudHMuICgwLjAgPSBwZXJmZWN0aW9uLFxuICAvLyAxLjAgPSB2ZXJ5IGxvb3NlKS4gIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXG4gIC8vIGVuZCBwb2ludHMgb2YgYSBkZWxldGUgbmVlZCB0byBtYXRjaC5cbiAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQgPSAwLjU7XG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxuICB0aGlzLlBhdGNoX01hcmdpbiA9IDQ7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgdGhpcy5NYXRjaF9NYXhCaXRzID0gMzI7XG59O1xuXG5cbi8vICBESUZGIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXG4gKi9cbnZhciBESUZGX0RFTEVURSA9IC0xO1xudmFyIERJRkZfSU5TRVJUID0gMTtcbnZhciBESUZGX0VRVUFMID0gMDtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIGRpZmYgdHVwbGUuXG4gKiB+QXR0ZW1wdHMgdG8gbG9vayBsaWtlIGEgdHdvLWVsZW1lbnQgYXJyYXkgKHdoaWNoIGlzIHdoYXQgdGhpcyB1c2VkIHRvIGJlKS5+XG4gKiBDb25zdHJ1Y3RvciByZXR1cm5zIGFuIGFjdHVhbCB0d28tZWxlbWVudCBhcnJheSwgdG8gYWxsb3cgZGVzdHJ1Y3RpbmcgQEphY2t1QlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9KYWNrdUIvZGlmZi1tYXRjaC1wYXRjaC9pc3N1ZXMvMTQgZm9yIGRldGFpbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcCBPcGVyYXRpb24sIG9uZSBvZjogRElGRl9ERUxFVEUsIERJRkZfSU5TRVJULCBESUZGX0VRVUFMLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dCB0byBiZSBkZWxldGVkLCBpbnNlcnRlZCwgb3IgcmV0YWluZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5EaWZmID0gZnVuY3Rpb24ob3AsIHRleHQpIHtcbiAgcmV0dXJuIFtvcCwgdGV4dF07XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcbiAqIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeCBvZmYgdGhlIHRleHRzIGJlZm9yZSBkaWZmaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NoZWNrbGluZXMgT3B0aW9uYWwgc3BlZWR1cCBmbGFnLiBJZiBwcmVzZW50IGFuZCBmYWxzZSxcbiAqICAgICB0aGVuIGRvbid0IHJ1biBhIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RlYWRsaW5lIE9wdGlvbmFsIHRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGVcbiAqICAgICBieS4gIFVzZWQgaW50ZXJuYWxseSBmb3IgcmVjdXJzaXZlIGNhbGxzLiAgVXNlcnMgc2hvdWxkIHNldCBEaWZmVGltZW91dFxuICogICAgIGluc3RlYWQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9tYWluID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBvcHRfY2hlY2tsaW5lcyxcbiAgICBvcHRfZGVhZGxpbmUpIHtcbiAgLy8gU2V0IGEgZGVhZGxpbmUgYnkgd2hpY2ggdGltZSB0aGUgZGlmZiBtdXN0IGJlIGNvbXBsZXRlLlxuICBpZiAodHlwZW9mIG9wdF9kZWFkbGluZSA9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0aGlzLkRpZmZfVGltZW91dCA8PSAwKSB7XG4gICAgICBvcHRfZGVhZGxpbmUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRfZGVhZGxpbmUgPSAobmV3IERhdGUpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcbiAgICB9XG4gIH1cbiAgdmFyIGRlYWRsaW5lID0gb3B0X2RlYWRsaW5lO1xuXG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgaWYgKHRleHQxID09IG51bGwgfHwgdGV4dDIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBpbnB1dC4gKGRpZmZfbWFpbiknKTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cCkuXG4gIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xuICAgIGlmICh0ZXh0MSkge1xuICAgICAgcmV0dXJuIFtuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsIHRleHQxKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XG4gIH1cbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcblxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKS5cbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcblxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBjb21tb25wcmVmaXgpKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeCkpO1xuICB9XG4gIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxuICogaGF2ZSBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXguXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrbGluZXMgU3BlZWR1cCBmbGFnLiAgSWYgZmFsc2UsIHRoZW4gZG9uJ3QgcnVuIGFcbiAqICAgICBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXG4gKiAgICAgSWYgdHJ1ZSwgdGhlbiBydW4gYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZV8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsXG4gICAgZGVhZGxpbmUpIHtcbiAgdmFyIGRpZmZzO1xuXG4gIGlmICghdGV4dDEpIHtcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0lOU0VSVCwgdGV4dDIpXTtcbiAgfVxuXG4gIGlmICghdGV4dDIpIHtcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0RFTEVURSwgdGV4dDEpXTtcbiAgfVxuXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT0gLTEpIHtcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXG4gICAgZGlmZnMgPSBbbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpKSxcbiAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsIHNob3J0dGV4dCksXG4gICAgICAgICAgICAgbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0lOU0VSVCxcbiAgICAgICAgICAgICAgICAgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKSldO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cblxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXG4gICAgLy8gQWZ0ZXIgdGhlIHByZXZpb3VzIHNwZWVkdXAsIHRoZSBjaGFyYWN0ZXIgY2FuJ3QgYmUgYW4gZXF1YWxpdHkuXG4gICAgcmV0dXJuIFtuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCB0ZXh0MSksXG4gICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChobSkge1xuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICB2YXIgZGlmZnNfYiA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2IsIHRleHQyX2IsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW25ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgbWlkX2NvbW1vbildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc19iKTtcbiAgfVxuXG4gIGlmIChjaGVja2xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmX2xpbmVNb2RlXyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0Xyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcbn07XG5cblxuLyoqXG4gKiBEbyBhIHF1aWNrIGxpbmUtbGV2ZWwgZGlmZiBvbiBib3RoIHN0cmluZ3MsIHRoZW4gcmVkaWZmIHRoZSBwYXJ0cyBmb3JcbiAqIGdyZWF0ZXIgYWNjdXJhY3kuXG4gKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZSBieS5cbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lTW9kZV8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gIC8vIFNjYW4gdGhlIHRleHQgb24gYSBsaW5lLWJ5LWxpbmUgYmFzaXMgZmlyc3QuXG4gIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc18odGV4dDEsIHRleHQyKTtcbiAgdGV4dDEgPSBhLmNoYXJzMTtcbiAgdGV4dDIgPSBhLmNoYXJzMjtcbiAgdmFyIGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xuXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UsIGRlYWRsaW5lKTtcblxuICAvLyBDb252ZXJ0IHRoZSBkaWZmIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC5cbiAgdGhpcy5kaWZmX2NoYXJzVG9MaW5lc18oZGlmZnMsIGxpbmVhcnJheSk7XG4gIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcblxuICAvLyBSZWRpZmYgYW55IHJlcGxhY2VtZW50IGJsb2NrcywgdGhpcyB0aW1lIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXG4gIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIGRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCAnJykpO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcbiAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50X2luc2VydCsrO1xuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlID49IDEgJiYgY291bnRfaW5zZXJ0ID49IDEpIHtcbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0O1xuICAgICAgICAgIHZhciBzdWJEaWZmID1cbiAgICAgICAgICAgICAgdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSwgZGVhZGxpbmUpO1xuICAgICAgICAgIGZvciAodmFyIGogPSBzdWJEaWZmLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgc3ViRGlmZltqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgc3ViRGlmZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cblxuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgJ21pZGRsZSBzbmFrZScgb2YgYSBkaWZmLCBzcGxpdCB0aGUgcHJvYmxlbSBpbiB0d29cbiAqIGFuZCByZXR1cm4gdGhlIHJlY3Vyc2l2ZWx5IGNvbnN0cnVjdGVkIGRpZmYuXG4gKiBTZWUgTXllcnMgMTk4NiBwYXBlcjogQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIEl0cyBWYXJpYXRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdF8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gIHZhciB2X29mZnNldCA9IG1heF9kO1xuICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIHZhciBkZWx0YSA9IHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aDtcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuICB2YXIgZnJvbnQgPSAoZGVsdGEgJSAyICE9IDApO1xuICAvLyBPZmZzZXRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGsgbG9vcC5cbiAgLy8gUHJldmVudHMgbWFwcGluZyBvZiBzcGFjZSBiZXlvbmQgdGhlIGdyaWQuXG4gIHZhciBrMXN0YXJ0ID0gMDtcbiAgdmFyIGsxZW5kID0gMDtcbiAgdmFyIGsyc3RhcnQgPSAwO1xuICB2YXIgazJlbmQgPSAwO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcbiAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxuICAgIGlmICgobmV3IERhdGUoKSkuZ2V0VGltZSgpID4gZGVhZGxpbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdhbGsgdGhlIGZyb250IHBhdGggb25lIHN0ZXAuXG4gICAgZm9yICh2YXIgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgazE7XG4gICAgICB2YXIgeDE7XG4gICAgICBpZiAoazEgPT0gLWQgfHwgKGsxICE9IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkxID0geDEgLSBrMTtcbiAgICAgIHdoaWxlICh4MSA8IHRleHQxX2xlbmd0aCAmJiB5MSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh4MSkgPT0gdGV4dDIuY2hhckF0KHkxKSkge1xuICAgICAgICB4MSsrO1xuICAgICAgICB5MSsrO1xuICAgICAgfVxuICAgICAgdjFbazFfb2Zmc2V0XSA9IHgxO1xuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHJpZ2h0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTEgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJfb2Zmc2V0ID49IDAgJiYgazJfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjJbazJfb2Zmc2V0XSAhPSAtMSkge1xuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgIHZhciB4MiA9IHRleHQxX2xlbmd0aCAtIHYyW2syX29mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgZm9yICh2YXIgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XG4gICAgICB2YXIgeDI7XG4gICAgICBpZiAoazIgPT0gLWQgfHwgKGsyICE9IGQgJiYgdjJbazJfb2Zmc2V0IC0gMV0gPCB2MltrMl9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkyID0geDIgLSBrMjtcbiAgICAgIHdoaWxlICh4MiA8IHRleHQxX2xlbmd0aCAmJiB5MiA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MV9sZW5ndGggLSB4MiAtIDEpID09XG4gICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkyIC0gMSkpIHtcbiAgICAgICAgeDIrKztcbiAgICAgICAgeTIrKztcbiAgICAgIH1cbiAgICAgIHYyW2syX29mZnNldF0gPSB4MjtcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBsZWZ0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgdG9wIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxX29mZnNldCA+PSAwICYmIGsxX29mZnNldCA8IHZfbGVuZ3RoICYmIHYxW2sxX29mZnNldF0gIT0gLTEpIHtcbiAgICAgICAgICB2YXIgeDEgPSB2MVtrMV9vZmZzZXRdO1xuICAgICAgICAgIHZhciB5MSA9IHZfb2Zmc2V0ICsgeDEgLSBrMV9vZmZzZXQ7XG4gICAgICAgICAgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAgeDIgPSB0ZXh0MV9sZW5ndGggLSB4MjtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaWZmIHRvb2sgdG9vIGxvbmcgYW5kIGhpdCB0aGUgZGVhZGxpbmUgb3JcbiAgLy8gbnVtYmVyIG9mIGRpZmZzIGVxdWFscyBudW1iZXIgb2YgY2hhcmFjdGVycywgbm8gY29tbW9uYWxpdHkgYXQgYWxsLlxuICByZXR1cm4gW25ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9ERUxFVEUsIHRleHQxKSxcbiAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIHRoZSBsb2NhdGlvbiBvZiB0aGUgJ21pZGRsZSBzbmFrZScsIHNwbGl0IHRoZSBkaWZmIGluIHR3byBwYXJ0c1xuICogYW5kIHJlY3Vyc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdFNwbGl0XyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgeCwgeSxcbiAgICBkZWFkbGluZSkge1xuICB2YXIgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpO1xuICB2YXIgdGV4dDJhID0gdGV4dDIuc3Vic3RyaW5nKDAsIHkpO1xuICB2YXIgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpO1xuICB2YXIgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpO1xuXG4gIC8vIENvbXB1dGUgYm90aCBkaWZmcyBzZXJpYWxseS5cbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDFhLCB0ZXh0MmEsIGZhbHNlLCBkZWFkbGluZSk7XG4gIHZhciBkaWZmc2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MWIsIHRleHQyYiwgZmFsc2UsIGRlYWRsaW5lKTtcblxuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59O1xuXG5cbi8qKlxuICogU3BsaXQgdHdvIHRleHRzIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcbiAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHt7Y2hhcnMxOiBzdHJpbmcsIGNoYXJzMjogc3RyaW5nLCBsaW5lQXJyYXk6ICFBcnJheS48c3RyaW5nPn19XG4gKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZFxuICogICAgIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cbiAqICAgICBUaGUgemVyb3RoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzIGlzIGludGVudGlvbmFsbHkgYmxhbmsuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xpbmVzVG9DaGFyc18gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxpbmVBcnJheSA9IFtdOyAgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xuICB2YXIgbGluZUhhc2ggPSB7fTsgICAvLyBlLmcuIGxpbmVIYXNoWydIZWxsb1xcbiddID09IDRcblxuICAvLyAnXFx4MDAnIGlzIGEgdmFsaWQgY2hhcmFjdGVyLCBidXQgdmFyaW91cyBkZWJ1Z2dlcnMgZG9uJ3QgbGlrZSBpdC5cbiAgLy8gU28gd2UnbGwgaW5zZXJ0IGEganVuayBlbnRyeSB0byBhdm9pZCBnZW5lcmF0aW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG4gIGxpbmVBcnJheVswXSA9ICcnO1xuXG4gIC8qKlxuICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICAgKiBNb2RpZmllcyBsaW5lYXJyYXkgYW5kIGxpbmVoYXNoIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dCkge1xuICAgIHZhciBjaGFycyA9ICcnO1xuICAgIC8vIFdhbGsgdGhlIHRleHQsIHB1bGxpbmcgb3V0IGEgc3Vic3RyaW5nIGZvciBlYWNoIGxpbmUuXG4gICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxuICAgIC8vIE1vZGlmeWluZyB0ZXh0IHdvdWxkIGNyZWF0ZSBtYW55IGxhcmdlIHN0cmluZ3MgdG8gZ2FyYmFnZSBjb2xsZWN0LlxuICAgIHZhciBsaW5lU3RhcnQgPSAwO1xuICAgIHZhciBsaW5lRW5kID0gLTE7XG4gICAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXJpYWJsZSBpcyBmYXN0ZXIgdGhhbiBsb29raW5nIGl0IHVwLlxuICAgIHZhciBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKCdcXG4nLCBsaW5lU3RhcnQpO1xuICAgICAgaWYgKGxpbmVFbmQgPT0gLTEpIHtcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG5cbiAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDpcbiAgICAgICAgICAobGluZUhhc2hbbGluZV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lSGFzaFtsaW5lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZUFycmF5TGVuZ3RoID09IG1heExpbmVzKSB7XG4gICAgICAgICAgLy8gQmFpbCBvdXQgYXQgNjU1MzUgYmVjYXVzZVxuICAgICAgICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzYpID09IFN0cmluZy5mcm9tQ2hhckNvZGUoMClcbiAgICAgICAgICBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0KTtcbiAgICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICB9XG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9XG4gIC8vIEFsbG9jYXRlIDIvM3JkcyBvZiB0aGUgc3BhY2UgZm9yIHRleHQxLCB0aGUgcmVzdCBmb3IgdGV4dDIuXG4gIHZhciBtYXhMaW5lcyA9IDQwMDAwO1xuICB2YXIgY2hhcnMxID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICB2YXIgY2hhcnMyID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDIpO1xuICByZXR1cm4ge2NoYXJzMTogY2hhcnMxLCBjaGFyczI6IGNoYXJzMiwgbGluZUFycmF5OiBsaW5lQXJyYXl9O1xufTtcblxuXG4vKipcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG4gKiB0ZXh0LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lc18gPSBmdW5jdGlvbihkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcnMgPSBkaWZmc1tpXVsxXTtcbiAgICB2YXIgdGV4dCA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRleHRbal0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdChqKV07XG4gICAgfVxuICAgIGRpZmZzW2ldWzFdID0gdGV4dC5qb2luKCcnKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICogICAgIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25QcmVmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25TdWZmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fFxuICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc3VmZml4IG9mIG9uZSBzdHJpbmcgaXMgdGhlIHByZWZpeCBvZiBhbm90aGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0XG4gKiAgICAgc3RyaW5nIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHNlY29uZCBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vbk92ZXJsYXBfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgLy8gRWxpbWluYXRlIHRoZSBudWxsIGNhc2UuXG4gIGlmICh0ZXh0MV9sZW5ndGggPT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIFRydW5jYXRlIHRoZSBsb25nZXIgc3RyaW5nLlxuICBpZiAodGV4dDFfbGVuZ3RoID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0ZXh0MV9sZW5ndGggPCB0ZXh0Ml9sZW5ndGgpIHtcbiAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGgpO1xuICB9XG4gIHZhciB0ZXh0X2xlbmd0aCA9IE1hdGgubWluKHRleHQxX2xlbmd0aCwgdGV4dDJfbGVuZ3RoKTtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIHRoZSB3b3JzdCBjYXNlLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICByZXR1cm4gdGV4dF9sZW5ndGg7XG4gIH1cblxuICAvLyBTdGFydCBieSBsb29raW5nIGZvciBhIHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hcbiAgLy8gYW5kIGluY3JlYXNlIGxlbmd0aCB1bnRpbCBubyBtYXRjaCBpcyBmb3VuZC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMTAvMTEvMDQvXG4gIHZhciBiZXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IDE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpO1xuICAgIHZhciBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG4gICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9XG4gICAgbGVuZ3RoICs9IGZvdW5kO1xuICAgIGlmIChmb3VuZCA9PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0X2xlbmd0aCAtIGxlbmd0aCkgPT1cbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpIHtcbiAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICBsZW5ndGgrKztcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGxvbmdlciB0ZXh0P1xuICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfaGFsZk1hdGNoXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xuICAgIC8vIERvbid0IHJpc2sgcmV0dXJuaW5nIGEgbm9uLW9wdGltYWwgZGlmZiBpZiB3ZSBoYXZlIHVubGltaXRlZCB0aW1lLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ3RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydHRleHQubGVuZ3RoICogMiA8IGxvbmd0ZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxuICB9XG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0LlxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBpKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuICAgIHZhciBzZWVkID0gbG9uZ3RleHQuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgICB2YXIgaiA9IC0xO1xuICAgIHZhciBiZXN0X2NvbW1vbiA9ICcnO1xuICAgIHZhciBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcbiAgICB3aGlsZSAoKGogPSBzaG9ydHRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9IC0xKSB7XG4gICAgICB2YXIgcHJlZml4TGVuZ3RoID0gZG1wLmRpZmZfY29tbW9uUHJlZml4KGxvbmd0ZXh0LnN1YnN0cmluZyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqKSk7XG4gICAgICB2YXIgc3VmZml4TGVuZ3RoID0gZG1wLmRpZmZfY29tbW9uU3VmZml4KGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqKSk7XG4gICAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XG4gICAgICAgIGJlc3RfY29tbW9uID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqIC0gc3VmZml4TGVuZ3RoLCBqKSArXG4gICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGosIGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EgPSBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaiAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2IgPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsXG4gICAgICAgICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2IsIGJlc3RfY29tbW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHNlY29uZCBxdWFydGVyIGlzIHRoZSBzZWVkIGZvciBhIGhhbGYtbWF0Y2guXG4gIHZhciBobTEgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMikpO1xuICB2YXIgaG07XG4gIGlmICghaG0xICYmICFobTIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICghaG0yKSB7XG4gICAgaG0gPSBobTE7XG4gIH0gZWxzZSBpZiAoIWhtMSkge1xuICAgIGhtID0gaG0yO1xuICB9IGVsc2Uge1xuICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICB9XG5cbiAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgcmV0dXJuIFt0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iLCBtaWRfY29tbW9uXTtcbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWMgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gIHZhciBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBwcmlvciB0byB0aGUgZXF1YWxpdHkuXG4gIHZhciBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwO1xuICB2YXIgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgYWZ0ZXIgdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgdmFyIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gRXF1YWxpdHkgZm91bmQuXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gbGVuZ3RoX2luc2VydGlvbnMyO1xuICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSBsZW5ndGhfZGVsZXRpb25zMjtcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICB9IGVsc2UgeyAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBFbGltaW5hdGUgYW4gZXF1YWxpdHkgdGhhdCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBlZGl0cyBvbiBib3RoXG4gICAgICAvLyBzaWRlcyBvZiBpdC5cbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgKGxhc3RFcXVhbGl0eS5sZW5ndGggPD1cbiAgICAgICAgICBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczEsIGxlbmd0aF9kZWxldGlvbnMxKSkgJiZcbiAgICAgICAgICAobGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHkpKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcbiAgICAgICAgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZGlmZi5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuXG4gIC8vIEZpbmQgYW55IG92ZXJsYXBzIGJldHdlZW4gZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zLlxuICAvLyBlLmc6IDxkZWw+YWJjeHh4PC9kZWw+PGlucz54eHhkZWY8L2lucz5cbiAgLy8gICAtPiA8ZGVsPmFiYzwvZGVsPnh4eDxpbnM+ZGVmPC9pbnM+XG4gIC8vIGUuZzogPGRlbD54eHhhYmM8L2RlbD48aW5zPmRlZnh4eDwvaW5zPlxuICAvLyAgIC0+IDxpbnM+ZGVmPC9pbnM+eHh4PGRlbD5hYmM8L2RlbD5cbiAgLy8gT25seSBleHRyYWN0IGFuIG92ZXJsYXAgaWYgaXQgaXMgYXMgYmlnIGFzIHRoZSBlZGl0IGFoZWFkIG9yIGJlaGluZCBpdC5cbiAgcG9pbnRlciA9IDE7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0RFTEVURSAmJlxuICAgICAgICBkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0lOU0VSVCkge1xuICAgICAgdmFyIGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgdmFyIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgdmFyIG92ZXJsYXBfbGVuZ3RoMSA9IHRoaXMuZGlmZl9jb21tb25PdmVybGFwXyhkZWxldGlvbiwgaW5zZXJ0aW9uKTtcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDIgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IG92ZXJsYXBfbGVuZ3RoMikge1xuICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcbiAgICAgICAgICAgIG92ZXJsYXBfbGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgIC8vIE92ZXJsYXAgZm91bmQuICBJbnNlcnQgYW4gZXF1YWxpdHkgYW5kIHRyaW0gdGhlIHN1cnJvdW5kaW5nIGVkaXRzLlxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsXG4gICAgICAgICAgICAgIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgxKSkpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9XG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgxKTtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fFxuICAgICAgICAgICAgb3ZlcmxhcF9sZW5ndGgyID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XG4gICAgICAgICAgLy8gUmV2ZXJzZSBvdmVybGFwIGZvdW5kLlxuICAgICAgICAgIC8vIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgc3dhcCBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBfbGVuZ3RoMikpKTtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPVxuICAgICAgICAgICAgICBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIGluc2VydGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDIpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERJRkZfREVMRVRFO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9XG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDIpO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIC8qKlxuICAgKiBHaXZlbiB0d28gc3RyaW5ncywgY29tcHV0ZSBhIHNjb3JlIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBpbnRlcm5hbFxuICAgKiBib3VuZGFyeSBmYWxscyBvbiBsb2dpY2FsIGJvdW5kYXJpZXMuXG4gICAqIFNjb3JlcyByYW5nZSBmcm9tIDYgKGJlc3QpIHRvIDAgKHdvcnN0KS5cbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgcmV0dXJuIDY7XG4gICAgfVxuXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cbiAgICAvLyBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gZWFjaCBsYW5ndWFnZSdzIGRlZmluaXRpb24gb2YgdGhpbmdzIGxpa2VcbiAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xuICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXG4gICAgdmFyIGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGNoYXIyID0gdHdvLmNoYXJBdCgwKTtcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfKTtcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMiA9IGNoYXIyLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfKTtcbiAgICB2YXIgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmXG4gICAgICAgIGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gud2hpdGVzcGFjZVJlZ2V4Xyk7XG4gICAgdmFyIHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJlxuICAgICAgICBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8pO1xuICAgIHZhciBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiZcbiAgICAgICAgY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8pO1xuICAgIHZhciBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiZcbiAgICAgICAgY2hhcjIubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8pO1xuICAgIHZhciBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJlxuICAgICAgICBvbmUubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVFbmRSZWdleF8pO1xuICAgIHZhciBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJlxuICAgICAgICB0d28ubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVTdGFydFJlZ2V4Xyk7XG5cbiAgICBpZiAoYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyKSB7XG4gICAgICAvLyBGaXZlIHBvaW50cyBmb3IgYmxhbmsgbGluZXMuXG4gICAgICByZXR1cm4gNTtcbiAgICB9IGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xuICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGxpbmUgYnJlYWtzLlxuICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xuICAgICAgLy8gVGhyZWUgcG9pbnRzIGZvciBlbmQgb2Ygc2VudGVuY2VzLlxuICAgICAgcmV0dXJuIDM7XG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMikge1xuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyKSB7XG4gICAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgdmFyIGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB2YXIgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICB2YXIgY29tbW9uT2Zmc2V0ID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgIHZhciBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcbiAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgdmFyIHNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZXF1YWxpdHkxLCBlZGl0KSArXG4gICAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXG4gICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpIHtcbiAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgICAgIGJlc3RFZGl0ID0gZWRpdDtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT0gYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIGltcHJvdmVtZW50LCBzYXZlIGl0IGJhY2sgdG8gdGhlIGRpZmYuXG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0O1xuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5Mikge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG59O1xuXG4vLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cbmRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfID0gL1teYS16QS1aMC05XS87XG5kaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8gPSAvXFxzLztcbmRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfID0gL1tcXHJcXG5dLztcbmRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lRW5kUmVnZXhfID0gL1xcblxccj9cXG4kLztcbmRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lU3RhcnRSZWdleF8gPSAvXlxccj9cXG5cXHI/XFxuLztcblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cEVmZmljaWVuY3kgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gIHZhciBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcHJlX2lucyA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwcmVfZGVsID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwb3N0X2lucyA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHBvc3RfZGVsID0gZmFsc2U7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIEVxdWFsaXR5IGZvdW5kLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxuICAgICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcbiAgICAgICAgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYSBjYW5kaWRhdGUsIGFuZCBjYW4gbmV2ZXIgYmVjb21lIG9uZS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICB9XG4gICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgfSBlbHNlIHsgIC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0RFTEVURSkge1xuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlhZPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XG4gICAgICAgKiA8aW5zPkE8L2RlbD5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgKChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxhc3RFcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVfaW5zICsgcHJlX2RlbCArIHBvc3RfaW5zICsgcG9zdF9kZWwpID09IDMpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHkpKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07ICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQ7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cblxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwTWVyZ2UgPSBmdW5jdGlvbihkaWZmcykge1xuICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICBkaWZmcy5wdXNoKG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgJycpKTtcbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQgPiAxKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCkpKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICBwb2ludGVyIC09IGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydDtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0KTtcbiAgICAgICAgICBpZiAodGV4dF9kZWxldGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcbiAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZSkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dF9pbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcbiAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCB0ZXh0X2luc2VydCkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIC8vIE1lcmdlIHRoaXMgZXF1YWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgIHRleHRfZGVsZXRlID0gJyc7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09ICcnKSB7XG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIH1cblxuICAvLyBTZWNvbmQgcGFzczogbG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXG4gIC8vIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGVsaW1pbmF0ZSBhbiBlcXVhbGl0eS5cbiAgLy8gZS5nOiBBPGlucz5CQTwvaW5zPkMgLT4gPGlucz5BQjwvaW5zPkFDXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHBvaW50ZXIgPSAxO1xuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICtcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpO1xuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT1cbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgbmV4dCBlcXVhbGl0eS5cbiAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPVxuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICAvLyBJZiBzaGlmdHMgd2VyZSBtYWRlLCB0aGUgZGlmZiBuZWVkcyByZW9yZGVyaW5nIGFuZCBhbm90aGVyIHNoaWZ0IHN3ZWVwLlxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogbG9jIGlzIGEgbG9jYXRpb24gaW4gdGV4dDEsIGNvbXB1dGUgYW5kIHJldHVybiB0aGUgZXF1aXZhbGVudCBsb2NhdGlvbiBpblxuICogdGV4dDIuXG4gKiBlLmcuICdUaGUgY2F0JyB2cyAnVGhlIGJpZyBjYXQnLCAxLT4xLCA1LT44XG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvY2F0aW9uIHdpdGhpbiB0ZXh0Mi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl94SW5kZXggPSBmdW5jdGlvbihkaWZmcywgbG9jKSB7XG4gIHZhciBjaGFyczEgPSAwO1xuICB2YXIgY2hhcnMyID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMyID0gMDtcbiAgdmFyIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHsgIC8vIEVxdWFsaXR5IG9yIGRlbGV0aW9uLlxuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkgeyAgLy8gRXF1YWxpdHkgb3IgaW5zZXJ0aW9uLlxuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGNoYXJzMSA+IGxvYykgeyAgLy8gT3ZlcnNob3QgdGhlIGxvY2F0aW9uLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICB9XG4gIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIH1cbiAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlmZiBhcnJheSBpbnRvIGEgcHJldHR5IEhUTUwgcmVwb3J0LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGh0bWwgPSBbXTtcbiAgdmFyIHBhdHRlcm5fYW1wID0gLyYvZztcbiAgdmFyIHBhdHRlcm5fbHQgPSAvPC9nO1xuICB2YXIgcGF0dGVybl9ndCA9IC8+L2c7XG4gIHZhciBwYXR0ZXJuX3BhcmEgPSAvXFxuL2c7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTsgICAgLy8gT3BlcmF0aW9uIChpbnNlcnQsIGRlbGV0ZSwgZXF1YWwpXG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTsgIC8vIFRleHQgb2YgY2hhbmdlLlxuICAgIHZhciB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCAnJmFtcDsnKS5yZXBsYWNlKHBhdHRlcm5fbHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UocGF0dGVybl9ndCwgJyZndDsnKS5yZXBsYWNlKHBhdHRlcm5fcGFyYSwgJyZwYXJhOzxicj4nKTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBodG1sW3hdID0gJzxpbnMgc3R5bGU9XCJiYWNrZ3JvdW5kOiNlNmZmZTY7XCI+JyArIHRleHQgKyAnPC9pbnM+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBodG1sW3hdID0gJzxkZWwgc3R5bGU9XCJiYWNrZ3JvdW5kOiNmZmU2ZTY7XCI+JyArIHRleHQgKyAnPC9kZWw+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGh0bWxbeF0gPSAnPHNwYW4+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNvdXJjZSB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgZGVsZXRpb25zKS5cbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQxID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgaW5zZXJ0aW9ucykuXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcbiAqIHN1YnN0aXR1dGVkIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgY2hhbmdlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9sZXZlbnNodGVpbiA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBsZXZlbnNodGVpbiA9IDA7XG4gIHZhciBpbnNlcnRpb25zID0gMDtcbiAgdmFyIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTtcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdO1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgLy8gQSBkZWxldGlvbiBhbmQgYW4gaW5zZXJ0aW9uIGlzIG9uZSBzdWJzdGl0dXRpb24uXG4gICAgICAgIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gICAgICAgIGluc2VydGlvbnMgPSAwO1xuICAgICAgICBkZWxldGlvbnMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgcmV0dXJuIGxldmVuc2h0ZWluO1xufTtcblxuXG4vKipcbiAqIENydXNoIHRoZSBkaWZmIGludG8gYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSBvcGVyYXRpb25zXG4gKiByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0Mi5cbiAqIEUuZy4gPTNcXHQtMlxcdCtpbmcgIC0+IEtlZXAgMyBjaGFycywgZGVsZXRlIDIgY2hhcnMsIGluc2VydCAnaW5nJy5cbiAqIE9wZXJhdGlvbnMgYXJlIHRhYi1zZXBhcmF0ZWQuICBJbnNlcnRlZCB0ZXh0IGlzIGVzY2FwZWQgdXNpbmcgJXh4IG5vdGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRGVsdGEgdGV4dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90b0RlbHRhID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAoZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHRleHRbeF0gPSAnLScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignXFx0JykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxuICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIFNvdXJjZSBzdHJpbmcgZm9yIHRoZSBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEB0aHJvd3MgeyFFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbih0ZXh0MSwgZGVsdGEpIHtcbiAgdmFyIGRpZmZzID0gW107XG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEN1cnNvciBpbiB0ZXh0MVxuICB2YXIgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcbiAgICAvLyBFYWNoIHRva2VuIGJlZ2lucyB3aXRoIGEgb25lIGNoYXJhY3RlciBwYXJhbWV0ZXIgd2hpY2ggc3BlY2lmaWVzIHRoZVxuICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxuICAgIHZhciBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9JTlNFUlQsIGRlY29kZVVSSShwYXJhbSkpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgdmFyIG4gPSBwYXJzZUludChwYXJhbSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09ICc9Jykge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCB0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9ERUxFVEUsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQmxhbmsgdG9rZW5zIGFyZSBvayAoZnJvbSBhIHRyYWlsaW5nIFxcdCkuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYW4gZXJyb3IuXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbeF0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVsdGEgbGVuZ3RoICgnICsgcG9pbnRlciArXG4gICAgICAgICcpIGRvZXMgbm90IGVxdWFsIHNvdXJjZSB0ZXh0IGxlbmd0aCAoJyArIHRleHQxLmxlbmd0aCArICcpLicpO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLy8gIE1BVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xuICB9XG5cbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xuICBpZiAodGV4dCA9PSBwYXR0ZXJuKSB7XG4gICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaC5cbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xuICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcbiAgICByZXR1cm4gbG9jO1xuICB9IGVsc2Uge1xuICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcF8odGV4dCwgcGF0dGVybiwgbG9jKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXG4gKiBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwXyA9IGZ1bmN0aW9uKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci4nKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0LlxuICB2YXIgcyA9IHRoaXMubWF0Y2hfYWxwaGFiZXRfKHBhdHRlcm4pO1xuXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXG4gICAqIEFjY2Vzc2VzIGxvYyBhbmQgcGF0dGVybiB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTG9jYXRpb24gb2YgbWF0Y2guXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3ZlcmFsbCBzY29yZSBmb3IgbWF0Y2ggKDAuMCA9IGdvb2QsIDEuMCA9IGJhZCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaF9iaXRhcFNjb3JlXyhlLCB4KSB7XG4gICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xuICAgIHZhciBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICBpZiAoIWRtcC5NYXRjaF9EaXN0YW5jZSkge1xuICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG4gICAgfVxuICAgIHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBkbXAuTWF0Y2hfRGlzdGFuY2UpO1xuICB9XG5cbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgdmFyIHNjb3JlX3RocmVzaG9sZCA9IHRoaXMuTWF0Y2hfVGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIHZhciBiZXN0X2xvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgLy8gV2hhdCBhYm91dCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uPyAoc3BlZWR1cClcbiAgICBiZXN0X2xvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpO1xuICAgIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgICAgc2NvcmVfdGhyZXNob2xkID1cbiAgICAgICAgICBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gIGJlc3RfbG9jID0gLTE7XG5cbiAgdmFyIGJpbl9taW4sIGJpbl9taWQ7XG4gIHZhciBiaW5fbWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcbiAgdmFyIGxhc3RfcmQ7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xuICAgIC8vIGVycm9yIGxldmVsLlxuICAgIGJpbl9taW4gPSAwO1xuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xuICAgICAgaWYgKG1hdGNoX2JpdGFwU2NvcmVfKGQsIGxvYyArIGJpbl9taWQpIDw9IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICBiaW5fbWluID0gYmluX21pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgfVxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xuICAgIHZhciBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcblxuICAgIHZhciByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgLy8gVGhlIGFscGhhYmV0IChzKSBpcyBhIHNwYXJzZSBoYXNoLCBzbyB0aGUgZm9sbG93aW5nIGxpbmUgZ2VuZXJhdGVzXG4gICAgICAvLyB3YXJuaW5ncy5cbiAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCkgeyAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcbiAgICAgIH0gZWxzZSB7ICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKCgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2gpIHxcbiAgICAgICAgICAgICAgICAoKChsYXN0X3JkW2ogKyAxXSB8IGxhc3RfcmRbal0pIDw8IDEpIHwgMSkgfFxuICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmVfKGQsIGogLSAxKTtcbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gVG9sZCB5b3Ugc28uXG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgbG9jLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCArIDEsIGxvYykgPiBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYXN0X3JkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RfbG9jO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0IGZvciB0aGUgQml0YXAgYWxnb3JpdGhtLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHRleHQgdG8gZW5jb2RlLlxuICogQHJldHVybiB7IU9iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYWxwaGFiZXRfID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG5cbi8vICBQQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIEluY3JlYXNlIHRoZSBjb250ZXh0IHVudGlsIGl0IGlzIHVuaXF1ZSxcbiAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxuICogQHBhcmFtIHshZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmp9IHBhdGNoIFRoZSBwYXRjaCB0byBncm93LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU291cmNlIHRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0XyA9IGZ1bmN0aW9uKHBhdGNoLCB0ZXh0KSB7XG4gIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXRjaC5zdGFydDIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcigncGF0Y2ggbm90IGluaXRpYWxpemVkJyk7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpO1xuICB2YXIgcGFkZGluZyA9IDA7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IG1hdGNoZXMgb2YgcGF0dGVybiBpbiB0ZXh0LiAgSWYgdHdvIGRpZmZlcmVudFxuICAvLyBtYXRjaGVzIGFyZSBmb3VuZCwgaW5jcmVhc2UgdGhlIHBhdHRlcm4gbGVuZ3RoLlxuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcbiAgICAgICAgIHBhdHRlcm4ubGVuZ3RoIDwgdGhpcy5NYXRjaF9NYXhCaXRzIC0gdGhpcy5QYXRjaF9NYXJnaW4gLVxuICAgICAgICAgdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgLy8gQWRkIG9uZSBjaHVuayBmb3IgZ29vZCBsdWNrLlxuICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuXG4gIC8vIEFkZCB0aGUgcHJlZml4LlxuICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeCkge1xuICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBwcmVmaXgpKTtcbiAgfVxuICAvLyBBZGQgdGhlIHN1ZmZpeC5cbiAgdmFyIHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIGlmIChzdWZmaXgpIHtcbiAgICBwYXRjaC5kaWZmcy5wdXNoKG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgc3VmZml4KSk7XG4gIH1cblxuICAvLyBSb2xsIGJhY2sgdGhlIHN0YXJ0IHBvaW50cy5cbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeC5sZW5ndGg7XG4gIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXgubGVuZ3RoO1xuICAvLyBFeHRlbmQgdGhlIGxlbmd0aHMuXG4gIHBhdGNoLmxlbmd0aDEgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG4gIHBhdGNoLmxlbmd0aDIgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhIGxpc3Qgb2YgcGF0Y2hlcyB0byB0dXJuIHRleHQxIGludG8gdGV4dDIuXG4gKiBVc2UgZGlmZnMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBjb21wdXRlIGl0IG91cnNlbHZlcy5cbiAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXG4gKiBhdmFpbGFibGUgdG8gdGhlIGNhbGxlcjpcbiAqIE1ldGhvZCAxOlxuICogYSA9IHRleHQxLCBiID0gdGV4dDJcbiAqIE1ldGhvZCAyOlxuICogYSA9IGRpZmZzXG4gKiBNZXRob2QgMyAob3B0aW1hbCk6XG4gKiBhID0gdGV4dDEsIGIgPSBkaWZmc1xuICogTWV0aG9kIDQgKGRlcHJlY2F0ZWQsIHVzZSBtZXRob2QgMyk6XG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gYSB0ZXh0MSAobWV0aG9kcyAxLDMsNCkgb3JcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDIpLlxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPj19IG9wdF9iIHRleHQyIChtZXRob2RzIDEsNCkgb3JcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDMpIG9yIHVuZGVmaW5lZCAobWV0aG9kIDIpLlxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPj19IG9wdF9jIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCA0KSBvciB1bmRlZmluZWQgKG1ldGhvZHMgMSwyLDMpLlxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24oYSwgb3B0X2IsIG9wdF9jKSB7XG4gIHZhciB0ZXh0MSwgZGlmZnM7XG4gIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcbiAgICAvLyBDb21wdXRlIGRpZmZzIGZyb20gdGV4dDEgYW5kIHRleHQyLlxuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovKGEpO1xuICAgIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDEsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhvcHRfYiksIHRydWUpO1xuICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdF9iID09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBNZXRob2QgMjogZGlmZnNcbiAgICAvLyBDb21wdXRlIHRleHQxIGZyb20gZGlmZnMuXG4gICAgZGlmZnMgPSAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovKGEpO1xuICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiBvcHRfYiAmJiB0eXBlb2Ygb3B0X2IgPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAzOiB0ZXh0MSwgZGlmZnNcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8ob3B0X2IpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRfYiA9PSAnc3RyaW5nJyAmJlxuICAgICAgb3B0X2MgJiYgdHlwZW9mIG9wdF9jID09ICdvYmplY3QnKSB7XG4gICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcbiAgICAvLyB0ZXh0MiBpcyBub3QgdXNlZC5cbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8ob3B0X2MpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYWxsIGZvcm1hdCB0byBwYXRjaF9tYWtlLicpO1xuICB9XG5cbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTsgIC8vIEdldCByaWQgb2YgdGhlIG51bGwgY2FzZS5cbiAgfVxuICB2YXIgcGF0Y2hlcyA9IFtdO1xuICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcbiAgdmFyIHBhdGNoRGlmZkxlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXG4gIHZhciBjaGFyX2NvdW50MiA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XG4gIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxuICAvLyBjb250ZXh0IGluZm8uXG4gIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGRpZmZfdHlwZSA9IGRpZmZzW3hdWzBdO1xuICAgIHZhciBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcblxuICAgIGlmICghcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZfdHlwZSAhPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gQSBuZXcgcGF0Y2ggc3RhcnRzIGhlcmUuXG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiB0aGlzLlBhdGNoX01hcmdpbiAmJlxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xuICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHRfKHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIFVubGlrZSBVbmlkaWZmLCBvdXIgcGF0Y2ggbGlzdHMgaGF2ZSBhIHJvbGxpbmcgY29udGV4dC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZGlmZi1tYXRjaC1wYXRjaC93aWtpL1VuaWRpZmZcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgLy8ganVzdCBjb21wbGV0ZWQgcGF0Y2guXG4gICAgICAgICAgICBwcmVwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQ7XG4gICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgfVxuXG4gIHJldHVybiBwYXRjaGVzO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHBhdGNoZXMsIHJldHVybiBhbm90aGVyIGFycmF5IHRoYXQgaXMgaWRlbnRpY2FsLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZGVlcENvcHkgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIC8vIE1ha2luZyBkZWVwIGNvcGllcyBpcyBoYXJkIGluIEphdmFTY3JpcHQuXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPVxuICAgICAgICAgIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYocGF0Y2guZGlmZnNbeV1bMF0sIHBhdGNoLmRpZmZzW3ldWzFdKTtcbiAgICB9XG4gICAgcGF0Y2hDb3B5LnN0YXJ0MSA9IHBhdGNoLnN0YXJ0MTtcbiAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xuICAgIHBhdGNoQ29weS5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMTtcbiAgICBwYXRjaENvcHkubGVuZ3RoMiA9IHBhdGNoLmxlbmd0aDI7XG4gICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXNDb3B5O1xufTtcblxuXG4vKipcbiAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgT2xkIHRleHQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZ3whQXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbihwYXRjaGVzLCB0ZXh0KSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIH1cblxuICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cbiAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XG5cbiAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG5cbiAgdGhpcy5wYXRjaF9zcGxpdE1heChwYXRjaGVzKTtcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSBwcmV2aW91cyBwYXRjaC4gIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcbiAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBleHBlY3RlZF9sb2MgPSBwYXRjaGVzW3hdLnN0YXJ0MiArIGRlbHRhO1xuICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICB2YXIgc3RhcnRfbG9jO1xuICAgIHZhciBlbmRfbG9jID0gLTE7XG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgLy8gcGF0Y2hfc3BsaXRNYXggd2lsbCBvbmx5IHByb3ZpZGUgYW4gb3ZlcnNpemVkIHBhdHRlcm4gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgIC8vIGEgbW9uc3RlciBkZWxldGUuXG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfbG9jKTtcbiAgICAgIGlmIChzdGFydF9sb2MgIT0gLTEpIHtcbiAgICAgICAgZW5kX2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LFxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xuICAgICAgICAgIC8vIENhbid0IGZpbmQgdmFsaWQgdHJhaWxpbmcgY29udGV4dC4gIERyb3AgdGhpcyBwYXRjaC5cbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XG4gICAgfVxuICAgIGlmIChzdGFydF9sb2MgPT0gLTEpIHtcbiAgICAgIC8vIE5vIG1hdGNoIGZvdW5kLiAgOihcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBkZWx0YSBmb3IgdGhpcyBmYWlsZWQgcGF0Y2ggZnJvbSBzdWJzZXF1ZW50IHBhdGNoZXMuXG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvdW5kIGEgbWF0Y2guICA6KVxuICAgICAgcmVzdWx0c1t4XSA9IHRydWU7XG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcbiAgICAgIHZhciB0ZXh0MjtcbiAgICAgIGlmIChlbmRfbG9jID09IC0xKSB7XG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIGVuZF9sb2MgKyB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcbiAgICAgICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXG4gICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW1wZXJmZWN0IG1hdGNoLiAgUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxuICAgICAgICAvLyBpbmRpY2VzLlxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cyAmJlxuICAgICAgICAgICAgdGhpcy5kaWZmX2xldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+XG4gICAgICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIFRoZSBlbmQgcG9pbnRzIG1hdGNoLCBidXQgdGhlIGNvbnRlbnQgaXMgdW5hY2NlcHRhYmx5IGJhZC5cbiAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICB2YXIgaW5kZXgxID0gMDtcbiAgICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2hlc1t4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgdmFyIG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kWzBdID09PSBESUZGX0lOU0VSVCkgeyAgLy8gSW5zZXJ0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGluZGV4Mik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufTtcblxuXG4vKipcbiAqIEFkZCBzb21lIHBhZGRpbmcgb24gdGV4dCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgZWRnZXMgY2FuIG1hdGNoIHNvbWV0aGluZy5cbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHBhZGRpbmcgc3RyaW5nIGFkZGVkIHRvIGVhY2ggc2lkZS5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkUGFkZGluZyA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgdmFyIHBhZGRpbmdMZW5ndGggPSB0aGlzLlBhdGNoX01hcmdpbjtcbiAgdmFyIG51bGxQYWRkaW5nID0gJyc7XG4gIGZvciAodmFyIHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykge1xuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIH1cblxuICAvLyBCdW1wIGFsbCB0aGUgcGF0Y2hlcyBmb3J3YXJkLlxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoZXNbeF0uc3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH1cblxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIHN0YXJ0IG9mIGZpcnN0IGRpZmYuXG4gIHZhciBwYXRjaCA9IHBhdGNoZXNbMF07XG4gIHZhciBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbMF1bMF0gIT0gRElGRl9FUVVBTCkge1xuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICBkaWZmcy51bnNoaWZ0KG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgbnVsbFBhZGRpbmcpKTtcbiAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gZW5kIG9mIGxhc3QgZGlmZi5cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBudWxsUGFkZGluZykpO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufTtcblxuXG4vKipcbiAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxuICogbGltaXQgb2YgdGhlIG1hdGNoIGFsZ29yaXRobS5cbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIHZhciBwYXRjaF9zaXplID0gdGhpcy5NYXRjaF9NYXhCaXRzO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoX3NpemUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIHZhciBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDE7XG4gICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcbiAgICB2YXIgcHJlY29udGV4dCA9ICcnO1xuICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcbiAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXG4gICAgICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHByZWNvbnRleHQgIT09ICcnKSB7XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBwcmVjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMSA8IHBhdGNoX3NpemUgLSB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgICAgICB2YXIgZGlmZl90eXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XG4gICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKTtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9ERUxFVEUgJiYgcGF0Y2guZGlmZnMubGVuZ3RoID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1swXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaF9zaXplKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhcmdlIGRlbGV0aW9uLiAgTGV0IGl0IHBhc3MgaW4gb25lIGNodW5rLlxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihkaWZmX3R5cGUsIGRpZmZfdGV4dCkpO1xuICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVsZXRpb24gb3IgZXF1YWxpdHkuICBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cbiAgICAgICAgICBkaWZmX3RleHQgPSBkaWZmX3RleHQuc3Vic3RyaW5nKDAsXG4gICAgICAgICAgICAgIHBhdGNoX3NpemUgLSBwYXRjaC5sZW5ndGgxIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKGRpZmZfdHlwZSwgZGlmZl90ZXh0KSk7XG4gICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxuICAgICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENvbXB1dGUgdGhlIGhlYWQgY29udGV4dCBmb3IgdGhlIG5leHQgcGF0Y2guXG4gICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcbiAgICAgIHByZWNvbnRleHQgPVxuICAgICAgICAgIHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgLy8gQXBwZW5kIHRoZSBlbmQgY29udGV4dCBmb3IgdGhpcyBwYXRjaC5cbiAgICAgIHZhciBwb3N0Y29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MShiaWdwYXRjaC5kaWZmcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBwb3N0Y29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBwb3N0Y29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgIHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFRha2UgYSBsaXN0IG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0bGluZSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2Zyb21UZXh0ID0gZnVuY3Rpb24odGV4dGxpbmUpIHtcbiAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgaWYgKCF0ZXh0bGluZSkge1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xuICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICB2YXIgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xuICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdGNoIHN0cmluZzogJyArIHRleHRbdGV4dFBvaW50ZXJdKTtcbiAgICB9XG4gICAgdmFyIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuXG4gICAgcGF0Y2guc3RhcnQyID0gcGFyc2VJbnQobVszXSwgMTApO1xuICAgIGlmIChtWzRdID09PSAnJykge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xuICAgIH1cbiAgICB0ZXh0UG9pbnRlcisrO1xuXG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduID09ICctJykge1xuICAgICAgICAvLyBEZWxldGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJysnKSB7XG4gICAgICAgIC8vIEluc2VydGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJyAnKSB7XG4gICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgbGluZSkpO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xuICAgICAgICAvLyBTdGFydCBvZiBuZXh0IHBhdGNoLlxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcbiAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV1RGP1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XG4gICAgICB9XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5kaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaiA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovXG4gIHRoaXMuZGlmZnMgPSBbXTtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB0aGlzLnN0YXJ0MSA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgdGhpcy5zdGFydDIgPSBudWxsO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGgxID0gMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMubGVuZ3RoMiA9IDA7XG59O1xuXG5cbi8qKlxuICogRW11bGF0ZSBHTlUgZGlmZidzIGZvcm1hdC5cbiAqIEhlYWRlcjogQEAgLTM4Miw4ICs0ODEsOSBAQFxuICogSW5kaWNlcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmoucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb29yZHMxLCBjb29yZHMyO1xuICBpZiAodGhpcy5sZW5ndGgxID09PSAwKSB7XG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgJywwJztcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT0gMSkge1xuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gIH0gZWxzZSB7XG4gICAgY29vcmRzMSA9ICh0aGlzLnN0YXJ0MSArIDEpICsgJywnICsgdGhpcy5sZW5ndGgxO1xuICB9XG4gIGlmICh0aGlzLmxlbmd0aDIgPT09IDApIHtcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAnLDAnO1xuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMiA9PSAxKSB7XG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZHMyID0gKHRoaXMuc3RhcnQyICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDI7XG4gIH1cbiAgdmFyIHRleHQgPSBbJ0BAIC0nICsgY29vcmRzMSArICcgKycgKyBjb29yZHMyICsgJyBAQFxcbiddO1xuICB2YXIgb3A7XG4gIC8vIEVzY2FwZSB0aGUgYm9keSBvZiB0aGUgcGF0Y2ggd2l0aCAleHggbm90YXRpb24uXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAodGhpcy5kaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgb3AgPSAnKyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgb3AgPSAnLSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBvcCA9ICcgJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRleHRbeCArIDFdID0gb3AgKyBlbmNvZGVVUkkodGhpcy5kaWZmc1t4XVsxXSkgKyAnXFxuJztcbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKCcnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcbn07XG5cblxuLy8gVGhlIGZvbGxvd2luZyBleHBvcnQgY29kZSB3YXMgYWRkZWQgYnkgQEZvcmJlc0xpbmRlc2F5XG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZfbWF0Y2hfcGF0Y2g7XG5tb2R1bGUuZXhwb3J0c1snZGlmZl9tYXRjaF9wYXRjaCddID0gZGlmZl9tYXRjaF9wYXRjaDtcbm1vZHVsZS5leHBvcnRzWydESUZGX0RFTEVURSddID0gRElGRl9ERUxFVEU7XG5tb2R1bGUuZXhwb3J0c1snRElGRl9JTlNFUlQnXSA9IERJRkZfSU5TRVJUO1xubW9kdWxlLmV4cG9ydHNbJ0RJRkZfRVFVQUwnXSA9IERJRkZfRVFVQUw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/diff-match-patch/index.js\n");

/***/ })

}]);